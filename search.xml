<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java中的SPI服务发现机制</title>
      <link href="/p/b3bc049e.html"/>
      <url>/p/b3bc049e.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>SPI 是 Java 提供的一种插件化机制，核心思想是将服务接口和服务实现分离，使得服务调用者和服务提供者解耦。服务提供者只需要按照约定的接口进行实现，并在配置文件中声明，服务调用者就可以在运行时通过 SPI 机制发现并使用这些实现。</p><h2 id="Java-SPI-的工作流程"><a href="#Java-SPI-的工作流程" class="headerlink" title="Java SPI 的工作流程"></a>Java SPI 的工作流程</h2><ol><li><strong>定义接口</strong>：定义一个服务接口。</li><li><strong>实现接口</strong>：编写接口的具体实现类。</li><li><strong>配置文件</strong>：在 <code>META-INF/services/</code> 目录下创建配置文件，并列出实现类。</li><li><strong>加载服务</strong>：使用 <code>ServiceLoader.load()</code> 方法加载接口的所有实现类。<code>ServiceLoader</code> 会扫描 <code>META-INF/services/</code> 目录下的配置文件，并通过反射实例化实现类。</li><li><strong>服务调用</strong>: 遍历 <code>ServiceLoader</code> 加载的实现类，调用其方法。</li></ol><h2 id="Java-SPI-的优点"><a href="#Java-SPI-的优点" class="headerlink" title="Java SPI 的优点"></a>Java SPI 的优点</h2><ol><li><strong>解耦</strong>：接口与实现分离，便于扩展和维护。</li><li><strong>动态加载</strong>：通过配置文件动态加载实现类，无需修改代码。</li><li><strong>标准化</strong>：Java 标准库提供了 SPI 机制，使用简单。</li></ol><h2 id="Java-SPI-的缺点"><a href="#Java-SPI-的缺点" class="headerlink" title="Java SPI 的缺点"></a>Java SPI 的缺点</h2><ol><li><strong>配置文件依赖</strong>：必须严格按照规范配置 <code>META-INF/services/</code> 文件。</li><li><strong>一次性加载</strong>：<code>ServiceLoader</code> 会加载所有实现类，无法按需加载。</li><li><strong>缺乏依赖管理</strong>：无法处理实现类之间的依赖关系。</li><li>多个并发多线程使用 ServiceLoader 类的实例是不安全的。</li></ol><h2 id="Java-SPI-的应用场景"><a href="#Java-SPI-的应用场景" class="headerlink" title="Java SPI 的应用场景"></a>Java SPI 的应用场景</h2><ol><li><strong>数据库驱动加载</strong>：JDBC 使用 SPI 动态加载数据库驱动。</li><li><strong>日志框架适配</strong>：SLF4J 使用 SPI 加载具体的日志实现（如 Logback、Log4j）。</li><li><strong>插件化开发</strong>：在需要动态扩展功能的场景中，SPI 是一种常用的解决方案。</li></ol><h2 id="Java-SPI-示例代码"><a href="#Java-SPI-示例代码" class="headerlink" title="Java SPI 示例代码"></a>Java SPI 示例代码</h2><ol><li><p><strong>服务接口（Service Interface）</strong><br>定义一个接口，表示某种服务或功能。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    String <span class="title function_">getMessage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>服务实现（Service Implementation）</strong><br>提供接口的具体实现类。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Email Message&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SMS Message&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>配置文件（Service Configuration File）</strong><br>在 <code>META-INF/services/</code> 目录下创建一个以服务<strong>接口全限定名命名</strong>的文件（如 <code>com.example.MessageService</code>），并在文件中列出实现类的全限定名。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.example.EmailService</span><br><span class="line">com.example.SmsService</span><br></pre></td></tr></table></figure></li><li><p><strong>服务加载器（ServiceLoader）</strong><br>使用 <code>java.util.ServiceLoader</code> 动态加载服务实现类。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SPIMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ServiceLoader&lt;MessageService&gt; services = ServiceLoader.load(MessageService.class);</span><br><span class="line">        <span class="keyword">for</span> (MessageService service : services) &#123;</span><br><span class="line">            System.out.println(service.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Java-SPI-的工作原理"><a href="#Java-SPI-的工作原理" class="headerlink" title="Java SPI 的工作原理"></a>Java SPI 的工作原理</h2><ol><li><p><strong>首先，</strong>ServiceLoader实现了Iterable接口，所以它有迭代器的属性，这里主要都是实现了迭代器的hasNext和next方法。这里主要都是调用的lookupIterator的相应hasNext和next方法，lookupIterator是懒加载迭代器。</p></li><li><p><strong>其次，</strong>LazyIterator中的hasNext方法，静态变量PREFIX就是”META-INF&#x2F;services&#x2F;”目录，这也就是为什么需要在classpath下的META-INF&#x2F;services&#x2F;目录里创建一个以服务接口命名的文件。</p></li><li><p><strong>最后，</strong>通过反射方法Class.forName()加载类对象，并用newInstance方法将类实例化，并把实例化后的类缓存到providers对象中，(LinkedHashMap&lt;String,S&gt;类型） 然后返回实例对象</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceLoader实现了Iterable接口，可以遍历所有的服务实现者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ServiceLoader</span>&lt;S&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;S&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 查找配置文件的目录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX</span> <span class="operator">=</span> <span class="string">&quot;META-INF/services/&quot;</span>;</span><br><span class="line">    <span class="comment">// 表示要被加载的服务的类或接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line">    <span class="comment">// 这个ClassLoader用来定位，加载，实例化服务提供者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line">    <span class="comment">// 访问控制上下文</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line">    <span class="comment">// 缓存已经被实例化的服务提供者，按照实例化的顺序存储</span></span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="keyword">private</span> LazyIterator lookupIterator; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 服务提供者查找的迭代器</span></span><br><span class="line"><span class="keyword">public</span> Iterator&lt;S&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;S&gt;() &#123;</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders</span><br><span class="line">            = providers.entrySet().iterator();</span><br><span class="line">        <span class="comment">// hasNext方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> lookupIterator.hasNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// next方法</span></span><br><span class="line">        <span class="keyword">public</span> S <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                <span class="keyword">return</span> knownProviders.next().getValue();</span><br><span class="line">            <span class="keyword">return</span> lookupIterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 服务提供者查找的迭代器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">LazyIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;S&gt; &#123;</span><br><span class="line">    <span class="comment">// 服务提供者接口</span></span><br><span class="line">    Class&lt;S&gt; service;</span><br><span class="line">    <span class="comment">// 类加载器</span></span><br><span class="line">    ClassLoader loader;</span><br><span class="line">    <span class="comment">// 保存实现类的url</span></span><br><span class="line">    Enumeration&lt;URL&gt; configs = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 保存实现类的全名</span></span><br><span class="line">    Iterator&lt;String&gt; pending = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 迭代器中下一个实现类的全名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">nextName</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextName != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (configs == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> PREFIX + service.getName();</span><br><span class="line">                <span class="keyword">if</span> (loader == <span class="literal">null</span>)</span><br><span class="line">                    configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    configs = loader.getResources(fullName);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                fail(service, <span class="string">&quot;Error locating configuration files&quot;</span>, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((pending == <span class="literal">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pending = parse(service, configs.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">        nextName = pending.next();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> S <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasNext()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cn</span> <span class="operator">=</span> nextName;</span><br><span class="line">        nextName = <span class="literal">null</span>;</span><br><span class="line">        Class&lt;?&gt; c = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c = Class.forName(cn, <span class="literal">false</span>, loader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">            fail(service,<span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">            fail(service, <span class="string">&quot;Provider &quot;</span> + cn  + <span class="string">&quot; not a subtype&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">S</span> <span class="variable">p</span> <span class="operator">=</span> service.cast(c.newInstance());</span><br><span class="line">            providers.put(cn, p);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">            fail(service, <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; could not be instantiated: &quot;</span> + x, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();          <span class="comment">// This cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dubbo实现的SPI机制"><a href="#Dubbo实现的SPI机制" class="headerlink" title="Dubbo实现的SPI机制"></a>Dubbo实现的SPI机制</h2><p>Dubbo 对 Java 原生的 SPI 机制进行了增强和扩展，提供了更强大、更灵活的服务发现和加载功能。下面将详细介绍如何使用 Dubbo 实现的 SPI 机制，包括定义接口、实现接口、配置 SPI、加载和使用扩展等步骤。</p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>首先，需要在项目中添加 Dubbo 的依赖。如果使用 Maven 项目，可以在 <code>pom.xml</code> 中添加以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="定义服务接口"><a href="#定义服务接口" class="headerlink" title="定义服务接口"></a>定义服务接口</h3><p>使用 <code>@SPI</code> 注解标记服务接口，该注解是 Dubbo SPI 的核心注解，用于标识这是一个可扩展的接口。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.dubbo.common.extension.SPI;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 @SPI 注解标记接口</span></span><br><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现服务接口"><a href="#实现服务接口" class="headerlink" title="实现服务接口"></a>实现服务接口</h3><p>提供多个实现类来实现上述定义的服务接口。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现类 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnglishHelloService</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChineseHelloService</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你好！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置-SPI"><a href="#配置-SPI" class="headerlink" title="配置 SPI"></a>配置 SPI</h3><p>在 <code>META-INF/dubbo</code> 目录下创建一个以服务接口全限定名命名的文件，文件内容为键值对形式，键为扩展点名称，值为实现类的全限定名。例如，对于 <code>HelloService</code> 接口，文件路径为 <code>META-INF/dubbo/com.example.HelloService</code>，文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">english = com.example.EnglishHelloService</span><br><span class="line">chinese = com.example.ChineseHelloService</span><br></pre></td></tr></table></figure><h3 id="加载和使用扩展"><a href="#加载和使用扩展" class="headerlink" title="加载和使用扩展"></a>加载和使用扩展</h3><p>使用 <code>ExtensionLoader</code> 类来加载和使用扩展。<code>ExtensionLoader</code> 是 Dubbo SPI 机制的核心类，负责从配置文件中加载扩展实现。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 ExtensionLoader 实例</span></span><br><span class="line">        ExtensionLoader&lt;HelloService&gt; extensionLoader = ExtensionLoader.getExtensionLoader(HelloService.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据扩展点名称获取具体的实现</span></span><br><span class="line">        <span class="type">HelloService</span> <span class="variable">englishService</span> <span class="operator">=</span> extensionLoader.getExtension(<span class="string">&quot;english&quot;</span>);</span><br><span class="line">        englishService.sayHello();</span><br><span class="line"></span><br><span class="line">        <span class="type">HelloService</span> <span class="variable">chineseService</span> <span class="operator">=</span> extensionLoader.getExtension(<span class="string">&quot;chinese&quot;</span>);</span><br><span class="line">        chineseService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ul><li><strong><code>@SPI</code> 注解</strong>：用于标记服务接口，表示这是一个可扩展的接口。</li><li><strong><code>META-INF/dubbo</code> 目录</strong>：Dubbo 约定在该目录下查找 SPI 配置文件。</li><li><strong>配置文件格式</strong>：使用键值对形式，键为扩展点名称，值为实现类的全限定名。</li><li><strong><code>ExtensionLoader</code> 类</strong>：负责加载和管理扩展实现。通过 <code>getExtensionLoader</code> 方法获取 <code>ExtensionLoader</code> 实例，再通过 <code>getExtension</code> 方法根据扩展点名称获取具体的实现。</li></ul><h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><ul><li><strong>自适应扩展</strong>：Dubbo 支持自适应扩展，通过 <code>@Adaptive</code> 注解可以在运行时根据参数动态选择扩展实现。</li><li><strong>自动包装</strong>：Dubbo 支持自动包装扩展实现，通过实现 <code>Wrapper</code> 类可以对扩展实现进行包装和增强。</li></ul><h2 id="与Spring集成"><a href="#与Spring集成" class="headerlink" title="与Spring集成"></a>与Spring集成</h2><p>创建一个 Spring 配置类，用于将 Dubbo SPI 扩展点注入到 Spring 容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboSPIConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        ExtensionLoader&lt;MyService&gt; extensionLoader = ExtensionLoader.getExtensionLoader(MyService.class);</span><br><span class="line">        <span class="keyword">return</span> extensionLoader.getExtension(<span class="string">&quot;myImpl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPI方式比较"><a href="#SPI方式比较" class="headerlink" title="SPI方式比较"></a>SPI方式比较</h2><table><thead><tr><th>对比维度</th><th>Java 原生 SPI</th><th>Dubbo 的 SPI</th></tr></thead><tbody><tr><td><strong>配置文件位置</strong></td><td><code>META - INF/services</code> 目录下</td><td>默认 <code>META - INF/dubbo</code> 目录，也支持 <code>META - INF/dubbo/internal</code> 和 <code>META - INF/services</code> 目录</td></tr><tr><td><strong>配置文件内容格式</strong></td><td>实现类全限定名，每行一个</td><td>键值对形式，键为扩展点名称，值为实现类全限定名</td></tr><tr><td><strong>加载类</strong></td><td><code>java.util.ServiceLoader</code></td><td><code>org.apache.dubbo.common.extension.ExtensionLoader</code></td></tr><tr><td><strong>加载方式</strong></td><td>一次性加载并实例化配置文件中所有实现类</td><td>按需加载，可根据扩展点名称获取指定实现类</td></tr><tr><td><strong>高级特性</strong></td><td>无自动激活、自适应扩展、扩展点包装等高级特性</td><td>支持自动激活（<code>@Activate</code> 注解）、自适应扩展（<code>@Adaptive</code> 注解）、扩展点包装</td></tr><tr><td><strong>性能和灵活性</strong></td><td>一次性加载可能造成资源浪费，缺乏灵活扩展定制能力</td><td>按需加载，性能较好，借助各种注解和机制可灵活定制，适合复杂分布式系统</td></tr><tr><td><strong>获取实现类方式</strong></td><td>通过迭代器遍历获取所有实现类实例</td><td>通过扩展点名称获取指定实现类实例</td></tr></tbody></table><script>var description="SPI（Service Provider Interface）是JDK内置的一种服务提供发现机制。"</script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot预览PDF文件</title>
      <link href="/p/3ca9bef3.html"/>
      <url>/p/3ca9bef3.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="关键点说明"><a href="#关键点说明" class="headerlink" title="关键点说明"></a><strong>关键点说明</strong></h2><ol><li><p><strong>预览与下载的优先级</strong></p><ul><li><code>Content-Disposition: inline</code> 要求浏览器优先内联显示（预览）。</li><li>若浏览器不支持预览（如某些移动端），会自动触发下载。</li></ul></li><li><p><strong>性能与安全</strong></p><ul><li>流式传输（非一次性加载到内存）支持大文件。</li><li>校验文件存在性避免无效请求。</li></ul></li><li><p><strong>兼容性</strong></p><ul><li>文件名编码处理确保中文等特殊字符正常显示。</li></ul></li></ol><h2 id="SpringBoot预览"><a href="#SpringBoot预览" class="headerlink" title="SpringBoot预览"></a>SpringBoot预览</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PdfController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;pdf.file.path&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String pdfFilePath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/pdfpreview&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showPdf</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(pdfFilePath);</span><br><span class="line">        <span class="comment">// 校验文件是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            response.sendError(HttpServletResponse.SC_NOT_FOUND, <span class="string">&quot;PDF文件不存在&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/pdf&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;inline; filename=\&quot;&quot;</span> + encodeFileName(file.getName()) + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">        response.setContentLength((<span class="type">int</span>) file.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 流式传输文件内容</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)) &#123;</span><br><span class="line">            <span class="type">ServletOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">            IOUtils.copy(input, output);</span><br><span class="line">            output.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, <span class="string">&quot;文件处理失败&quot;</span>);</span><br><span class="line">            <span class="comment">// 记录日志 : log.error(&quot;PDF文件处理失败&quot;, e);</span></span><br><span class="line">            <span class="comment">// e.printStackTrace();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理文件名，防止中文乱码</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">encodeFileName</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="keyword">return</span> URLEncoder.encode(fileName, StandardCharsets.UTF_8.name()).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HTTP-Range-请求"><a href="#HTTP-Range-请求" class="headerlink" title="HTTP Range 请求"></a>HTTP Range 请求</h2><p>HTTP 协议支持 <code>Range</code> 请求头，允许客户端请求文件的某一部分（字节范围），服务器可以响应 <code>206 Partial Content</code> 并返回指定范围的数据。这种方式非常适合大文件的懒加载。</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a><strong>实现步骤</strong></h3><ol><li><p><strong>客户端</strong>：在请求头中添加 <code>Range</code> 字段，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes=0-1023</span><br></pre></td></tr></table></figure><p>表示请求文件的前 1024 字节。</p></li><li><p><strong>服务器</strong>：</p><ul><li>解析 <code>Range</code> 请求头，获取请求的字节范围。</li><li>使用 <code>RandomAccessFile</code> 或 <code>FileChannel</code> 读取文件的指定部分。</li><li>返回 <code>206 Partial Content</code> 状态码，并在响应头中设置 <code>Content-Range</code>。</li></ul></li><li><p><strong>响应头</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Content-Range: bytes 0-1023/123456</span><br><span class="line">Content-Length: 1024</span><br></pre></td></tr></table></figure></li></ol><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/pdfpreview2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showPdf</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(pdfFilePath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">        response.sendError(HttpServletResponse.SC_NOT_FOUND, <span class="string">&quot;PDF文件不存在&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">fileLength</span> <span class="operator">=</span> file.length();</span><br><span class="line">    <span class="type">String</span> <span class="variable">rangeHeader</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Range&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置通用响应头</span></span><br><span class="line">    response.setContentType(<span class="string">&quot;application/pdf&quot;</span>);</span><br><span class="line">    response.setHeader(<span class="string">&quot;Accept-Ranges&quot;</span>, <span class="string">&quot;bytes&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rangeHeader == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 首次访问，只返回文件元数据</span></span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;inline; filename=\&quot;&quot;</span> + encodeFileName(file.getName()) + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">        response.setContentLength(<span class="number">0</span>); <span class="comment">// 不返回文件内容</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 解析 Range 请求头</span></span><br><span class="line">        String[] ranges = rangeHeader.replace(<span class="string">&quot;bytes=&quot;</span>, <span class="string">&quot;&quot;</span>).split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> Long.parseLong(ranges[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> ranges.length &gt; <span class="number">1</span> ? Long.parseLong(ranges[<span class="number">1</span>]) : fileLength - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验范围是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span> || end &gt;= fileLength || start &gt; end) &#123;</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);</span><br><span class="line">            response.setHeader(<span class="string">&quot;Content-Range&quot;</span>, <span class="string">&quot;bytes */&quot;</span> + fileLength);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置响应头</span></span><br><span class="line">        response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Range&quot;</span>, <span class="string">&quot;bytes &quot;</span> + start + <span class="string">&quot;-&quot;</span> + end + <span class="string">&quot;/&quot;</span> + fileLength);</span><br><span class="line">        response.setContentLength((<span class="type">int</span>) (end - start + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 RandomAccessFile 读取指定范围</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">             <span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> response.getOutputStream()) &#123;</span><br><span class="line">            randomAccessFile.seek(start);</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">long</span> <span class="variable">remaining</span> <span class="operator">=</span> end - start + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> bytesRead;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (remaining &gt; <span class="number">0</span> &amp;&amp; (bytesRead = randomAccessFile.read(buffer, <span class="number">0</span>, (<span class="type">int</span>) Math.min(buffer.length, remaining))) != -<span class="number">1</span>) &#123;</span><br><span class="line">                output.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">                remaining -= bytesRead;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前端实现懒加载"><a href="#前端实现懒加载" class="headerlink" title="前端实现懒加载"></a><strong>前端实现懒加载</strong></h3><p>在前端，可以通过以下方式实现 PDF 的懒加载</p><ol><li><p><strong>使用 PDF.js（Mozilla 开源的 PDF 渲染库）</strong>：</p><ul><li><p>PDF.js 支持分块加载和渲染，适合大文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>滚动加载 PDF<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.page-container</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">20px</span> auto;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="number">#ccc</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;pdf-container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 引入 PDF.js --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> url = <span class="string">&#x27;http://127.0.0.1:8080/pdfpreview2&#x27;</span>; <span class="comment">// 你的 PDF 接口地址</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> currentPage = <span class="number">1</span>; <span class="comment">// 当前加载的页数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> pdfInstance = <span class="literal">null</span>; <span class="comment">// 保存 PDF 实例</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> isRendering = <span class="literal">false</span>; <span class="comment">// 防止重复渲染</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 初始化 PDF 加载</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> <span class="title function_">loadPDF</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> loadingTask = pdfjsLib.<span class="title function_">getDocument</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">url</span>: url,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">rangeChunkSize</span>: <span class="number">65536</span>, <span class="comment">// 分块大小（64KB）</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">disableAutoFetch</span>: <span class="literal">true</span>, <span class="comment">// 禁用自动加载整个文件</span></span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                pdfInstance = <span class="keyword">await</span> loadingTask.<span class="property">promise</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">renderPage</span>(currentPage); <span class="comment">// 渲染第一页</span></span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">addScrollListener</span>(); <span class="comment">// 添加滚动监听</span></span></span><br><span class="line"><span class="language-javascript">            &#125; <span class="keyword">catch</span> (error) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;PDF 加载失败:&quot;</span>, error);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 渲染单个页面</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> <span class="title function_">renderPage</span> = <span class="keyword">async</span> (<span class="params">pageNumber</span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (isRendering || pageNumber &gt; pdfInstance.<span class="property">numPages</span>) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">            isRendering = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> page = <span class="keyword">await</span> pdfInstance.<span class="title function_">getPage</span>(pageNumber);</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> viewport = page.<span class="title function_">getViewport</span>(&#123; <span class="attr">scale</span>: <span class="number">1.5</span> &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 创建画布容器</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                container.<span class="property">className</span> = <span class="string">&#x27;page-container&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">                container.<span class="property">style</span>.<span class="property">width</span> = <span class="string">`<span class="subst">$&#123;viewport.width&#125;</span>px`</span>;</span></span><br><span class="line"><span class="language-javascript">                container.<span class="property">style</span>.<span class="property">height</span> = <span class="string">`<span class="subst">$&#123;viewport.height&#125;</span>px`</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;pdf-container&#x27;</span>).<span class="title function_">appendChild</span>(container);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 创建画布</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> canvas = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;canvas&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> context = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                canvas.<span class="property">height</span> = viewport.<span class="property">height</span>;</span></span><br><span class="line"><span class="language-javascript">                canvas.<span class="property">width</span> = viewport.<span class="property">width</span>;</span></span><br><span class="line"><span class="language-javascript">                container.<span class="title function_">appendChild</span>(canvas);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 渲染页面</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">await</span> page.<span class="title function_">render</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">canvasContext</span>: context,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">viewport</span>: viewport,</span></span><br><span class="line"><span class="language-javascript">                &#125;).<span class="property">promise</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`第 <span class="subst">$&#123;pageNumber&#125;</span> 页渲染完成`</span>);</span></span><br><span class="line"><span class="language-javascript">                currentPage++;</span></span><br><span class="line"><span class="language-javascript">                isRendering = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 立即检查是否需要加载下一页</span></span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">checkScroll</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125; <span class="keyword">catch</span> (error) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`第 <span class="subst">$&#123;pageNumber&#125;</span> 页渲染失败:`</span>, error);</span></span><br><span class="line"><span class="language-javascript">                isRendering = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 检查是否滚动到底部</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> <span class="title function_">checkScroll</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> lastPageContainer = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.page-container:last-child&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (!lastPageContainer) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> lastPageBottom = lastPageContainer.<span class="property">offsetTop</span> + lastPageContainer.<span class="property">offsetHeight</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> scrollPosition = <span class="variable language_">window</span>.<span class="property">innerHeight</span> + <span class="variable language_">window</span>.<span class="property">scrollY</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 如果距离底部小于 100px，加载下一页</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (scrollPosition &gt; lastPageBottom - <span class="number">100</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">renderPage</span>(currentPage);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 添加滚动监听</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> <span class="title function_">addScrollListener</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, checkScroll);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 启动 PDF 加载</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">loadPDF</span>();</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p><img src="/p/3ca9bef3/f7e190ad91436db905c910b7559489fc.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://github.com/fulsun/springboot-demo/tree/main/pdf_lazy_loading">springboot-demo&#x2F;pdf_lazy_loading at main · fulsun&#x2F;springboot-demo</a></p><script>var description="这篇文章介绍了如何利用Spring Boot的预览PDF功能和HTTP Range请求实现大文件的大范围懒加载技术。"</script>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Debain12配置</title>
      <link href="/p/9b5fc26a.html"/>
      <url>/p/9b5fc26a.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="右键粘贴"><a href="#右键粘贴" class="headerlink" title="右键粘贴"></a>右键粘贴</h2><p>临时： <code>:set mouse-=a</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.vimrc </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> has(<span class="string">&#x27;mouse&#x27;</span>) </span><br><span class="line"><span class="built_in">set</span> mouse-=a </span><br><span class="line">endif</span><br></pre></td></tr></table></figure><h2 id="改变主机名"><a href="#改变主机名" class="headerlink" title="改变主机名"></a>改变主机名</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> hostnamectl set-hostname linux</span><br></pre></td></tr></table></figure><p> 添加主机名和 IP 地址映射</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/hosts</span><br><span class="line">127.0.0.1 node01</span><br></pre></td></tr></table></figure><h2 id="设置静态ip"><a href="#设置静态ip" class="headerlink" title="设置静态ip"></a>设置静态ip</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网卡名称是ens33</span></span><br><span class="line">ip address</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 00:0c:29:07:18:a0 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    altname enp2s1</span><br><span class="line">    inet 192.168.61.129/24 brd 192.168.61.255 scope global dynamic ens33</span><br><span class="line">       valid_lft 1422sec preferred_lft 1422sec</span><br><span class="line">    inet6 fe80::20c:29ff:fe07:18a0/64 scope <span class="built_in">link</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编辑网卡配置文件:将 allow-htplug ens33 行替换为 auto ens33，并将 dhcp 参数更改为 static。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/network/interfaces</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在最后面添加下面内容 其中</span></span><br><span class="line"><span class="comment"># ens33是上步中查询到的网卡名称</span></span><br><span class="line">auto ens33</span><br><span class="line"><span class="comment">#  static:静态ip dhcp:动态</span></span><br><span class="line">iface ens33 inet static</span><br><span class="line"><span class="comment"># ip地址</span></span><br><span class="line">address 192.168.61.110</span><br><span class="line"><span class="comment"># ip地址的子网掩码</span></span><br><span class="line">netmask 255.255.255.0</span><br><span class="line"><span class="comment"># ip地址的网关</span></span><br><span class="line">gateway 192.168.61.2</span><br></pre></td></tr></table></figure><p>重启网络服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart networking.service</span><br><span class="line"><span class="comment"># 验证 ip 地址</span></span><br><span class="line">ip add show</span><br></pre></td></tr></table></figure><p>设置dns</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/resolv.conf</span><br><span class="line"></span><br><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 8.8.8.4</span><br><span class="line">nameserver 192.168.61.2</span><br></pre></td></tr></table></figure><h2 id="windows映射"><a href="#windows映射" class="headerlink" title="windows映射"></a>windows映射</h2><p>修改 <code>C:\WINDOWS\System32\drivers\etc\hosts</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">192.168.61.110debain</span><br><span class="line">192.168.61.111node01</span><br><span class="line">192.168.61.112node02</span><br><span class="line">192.168.61.113node03</span><br><span class="line">192.168.61.114node04</span><br></pre></td></tr></table></figure><h2 id="安装常用工具"><a href="#安装常用工具" class="headerlink" title="安装常用工具"></a>安装常用工具</h2><p>以下是在 Debian 12 中安装常用工具的命令，按类别整理：</p><ol><li>文本编辑（vim&#x2F;nano）</li><li>网络请求调试（curl&#x2F;wget）</li><li>网络诊断（traceroute&#x2F;dig&#x2F;mtr）</li><li>系统监控（htop&#x2F;lsof）</li><li>远程访问（ssh）</li><li>开发调试（gdb&#x2F;strace）</li><li>压缩解压（zip&#x2F;unzip&#x2F;tar）</li><li>硬件诊断（lspci&#x2F;lsusb）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新软件包列表</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装基础工具</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y vim nano curl wget</span><br><span class="line"></span><br><span class="line"><span class="comment"># 网络诊断工具</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y net-tools iproute2 traceroute dnsutils mtr-tiny</span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统管理工具</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y htop lsof tmux screen git unzip zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发/调试工具</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y build-essential gdb strace ltrace</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安全/远程工具</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y openssh-client openssh-server ufw <span class="built_in">sudo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 硬件信息工具</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y lshw pciutils usbutils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩/归档工具</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y tar gzip bzip2 xz-utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选工具</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y aptitude mlocate man-db</span><br></pre></td></tr></table></figure><p>安装完成后建议执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新 locate 数据库</span></span><br><span class="line"><span class="built_in">sudo</span> updatedb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用 UFW 防火墙（按需）</span></span><br><span class="line"><span class="built_in">sudo</span> ufw <span class="built_in">enable</span></span><br></pre></td></tr></table></figure><h2 id="bashrc别名"><a href="#bashrc别名" class="headerlink" title=".bashrc别名"></a>.bashrc别名</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> <span class="built_in">ls</span>=<span class="string">&#x27;ls --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -alF&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">&#x27;ls -A&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> l=<span class="string">&#x27;ls -CF&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> grep=<span class="string">&#x27;grep --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> fgrep=<span class="string">&#x27;fgrep --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> egrep=<span class="string">&#x27;egrep --color=auto&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><h3 id="SSH免密"><a href="#SSH免密" class="headerlink" title="SSH免密"></a>SSH免密</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在本地客户端生成 SSH 密钥对</span></span><br><span class="line">ssh-keygen -t rsa -b 2048</span><br><span class="line">scp ~/.ssh/* root@192.168.61.110:~/.ssh/</span><br><span class="line">scp ~/.ssh/* root@192.168.61.111:~/.ssh/</span><br><span class="line">scp ~/.ssh/* root@192.168.61.112:~/.ssh/</span><br><span class="line">scp ~/.ssh/* root@192.168.61.113:~/.ssh/</span><br><span class="line">scp ~/.ssh/* root@192.168.61.114:~/.ssh/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 ssh-copy-id 命令</span></span><br><span class="line">ssh-copy-id root@192.168.61.110</span><br><span class="line">ssh-copy-id root@192.168.61.111</span><br><span class="line">ssh-copy-id root@192.168.61.112</span><br><span class="line">ssh-copy-id root@192.168.61.113</span><br><span class="line">ssh-copy-id root@192.168.61.114</span><br><span class="line"></span><br><span class="line">ssh-copy-id sun@192.168.61.110</span><br><span class="line">ssh-copy-id sun@192.168.61.111</span><br><span class="line">ssh-copy-id sun@192.168.61.112</span><br><span class="line">ssh-copy-id sun@192.168.61.113</span><br><span class="line">ssh-copy-id sun@192.168.61.114</span><br><span class="line"><span class="comment"># 测试 SSH 免密登录</span></span><br><span class="line">ssh username@remote_server_ip</span><br></pre></td></tr></table></figure><h3 id="root开启ssh"><a href="#root开启ssh" class="headerlink" title="root开启ssh"></a>root开启ssh</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>PermitRootLogin：确保该项的值为 yes 或 prohibit-password（使用密钥认证登录）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果被注释掉则去掉注释符号 #。</span></span><br><span class="line"><span class="comment"># PermitRootLogin yes</span></span><br><span class="line"><span class="comment"># 如果希望仅使用密钥认证登录 root 用户，可设置为：</span></span><br><span class="line">PermitRootLogin prohibit-password</span><br><span class="line"><span class="comment"># 如果希望允许使用密码登录 root 用户，确保该项的值为 yes；如果仅使用密钥认证，可设置为 no。</span></span><br><span class="line">PasswordAuthentication <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart ssh</span><br></pre></td></tr></table></figure><script>var description="这篇文章介绍了如何在 Debian 12 中安装常用工具，并按功能分类整理了相关命令。"</script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Debain12 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装脚本与换源</title>
      <link href="/p/42bd8820.html"/>
      <url>/p/42bd8820.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="官方脚本"><a href="#官方脚本" class="headerlink" title="官方脚本"></a>官方脚本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker</span><br></pre></td></tr></table></figure><h2 id="官方脚本-阿里云镜像"><a href="#官方脚本-阿里云镜像" class="headerlink" title="官方脚本+阿里云镜像"></a>官方脚本+阿里云镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun </span><br></pre></td></tr></table></figure><h2 id="官方脚本镜像"><a href="#官方脚本镜像" class="headerlink" title="官方脚本镜像"></a>官方脚本镜像</h2><p>适合连接不上get.docker.com时使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://bash.foreverlink.love/dockerinstall.sh | bash -s docker --mirror Aliyun </span><br></pre></td></tr></table></figure><h2 id="清华源全镜像"><a href="#清华源全镜像" class="headerlink" title="清华源全镜像"></a>清华源全镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> DOWNLOAD_URL=<span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/docker-ce&quot;</span> &amp;&amp; curl -fsSL https://raw.githubusercontent.com/docker/docker-install/master/install.sh | sh</span><br></pre></td></tr></table></figure><h2 id="增加权限"><a href="#增加权限" class="headerlink" title="增加权限"></a>增加权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br><span class="line"><span class="built_in">sudo</span> groupadd docker               <span class="comment">#添加用户组</span></span><br><span class="line"><span class="built_in">sudo</span> gpasswd -a username docker    <span class="comment">#将当前用户添加至用户组</span></span><br><span class="line">newgrp docker                      <span class="comment">#更新用户组</span></span><br></pre></td></tr></table></figure><h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><p><a href="https://dockerproxy.xiaoxuan6.us.kg/">Docker 镜像加速站集合 - License server</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;registry-mirrors&quot;: [&quot;https://a.ussh.net&quot;]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload &amp;&amp; <span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="portainer安装"><a href="#portainer安装" class="headerlink" title="portainer安装"></a>portainer安装</h2><p><a href="https://docs.portainer.io/user/home">Home | Portainer Documentation</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果计划使用https</span></span><br><span class="line">docker volume create portainer_data &amp;&amp; docker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接Http </span></span><br><span class="line">docker volume create portainer_data &amp;&amp; docker run -d -p 8000:8000 -p 9000:9000 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce</span><br></pre></td></tr></table></figure><p>访问ip:9000页面后 设置账号 admin&#x2F;adminadminadmin</p><p>如果页面提示以下信息，则按提示信息重启portainer容器即可： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Your Portainer instance timed out for security purposes. To re-enable your Portainer instance, you will need to restart Portainer.</span></span><br><span class="line"></span><br><span class="line">docker restart portainer</span><br></pre></td></tr></table></figure><h2 id="docker远程连接"><a href="#docker远程连接" class="headerlink" title="docker远程连接"></a>docker远程连接</h2><h3 id="开启docker远程连接"><a href="#开启docker远程连接" class="headerlink" title="开启docker远程连接"></a>开启docker远程连接</h3><ol><li><p>检查 Docker 的 systemd 配置文件（<code>/lib/systemd/system/docker.service</code>），确保 <code>ExecStart</code> 中没有 <code>-H</code> 参数。如果有，将其移除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /lib/systemd/system/docker.service</span><br><span class="line"><span class="comment"># ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span></span><br><span class="line"><span class="comment"># 改为如下</span></span><br><span class="line">ExecStart=/usr/bin/dockerd --containerd=/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure></li><li><p>编辑 <code>/etc/docker/daemon.json</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;hosts&quot;</span>: [<span class="string">&quot;unix:///var/run/docker.sock&quot;</span>, <span class="string">&quot;tcp://0.0.0.0:2375&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重新加载 systemd 配置并重启 Docker：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload; <span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure></li></ol><h3 id="IDEA连接"><a href="#IDEA连接" class="headerlink" title="IDEA连接"></a>IDEA连接</h3><ol><li>在<a href="https://download.docker.com/win/static/stable/x86_64/">Index of win&#x2F;static&#x2F;stable&#x2F;x86_64&#x2F;</a>中选择最新的 docker，解压到任意目录</li><li>进入 <code>File &gt; Settings &gt; Build, Execution, Deployment &gt; Docker</code>。选择docker.exe解压的位置，点击确定</li><li>点击 <code>+</code> 添加新连接，选择 <code>TCP socket</code>。</li><li>输入服务器地址和端口（如 <code>tcp://your-server-ip:2375</code>）。</li><li>测试连接，成功后保存。</li></ol><h3 id="使用-TLS-加密连接"><a href="#使用-TLS-加密连接" class="headerlink" title="使用 TLS 加密连接"></a>使用 TLS 加密连接</h3><blockquote><p>通过使用 TLS（传输层安全协议）加密连接，可以防止数据在传输过程中被窃取或篡改，同时也能对客户端和服务器进行身份验证。</p></blockquote><ol><li><h4 id="创建证书目录"><a href="#创建证书目录" class="headerlink" title="创建证书目录"></a><strong>创建证书目录</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/docker-certs</span><br><span class="line"><span class="built_in">cd</span> ~/docker-certs</span><br></pre></td></tr></table></figure></li><li><p>一台机器上生成CA 私钥和CA 证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成 CA 私钥：ca-key.pem</span></span><br><span class="line">openssl genrsa -aes256 -out ca-key.pem 4096</span><br><span class="line"><span class="comment"># 设置一个密码来保护私钥: 123456</span></span><br><span class="line"><span class="comment"># 生成 CA 证书：</span></span><br><span class="line">openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem</span><br><span class="line"><span class="comment"># 输入之前设置的密码。123456</span></span><br><span class="line"><span class="comment"># 填写 CA 的相关信息（如国家、组织等）。</span></span><br><span class="line">Country Name (2 letter code) [AU]:CN</span><br><span class="line">State or Province Name (full name) [Some-State]:SHANGHAI</span><br><span class="line">Locality Name (eg, city) []:SHANGHAI</span><br><span class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:Personal</span><br><span class="line">Organizational Unit Name (eg, section) []:Personal Use</span><br><span class="line">Common Name (e.g. server FQDN or YOUR name) []:</span><br><span class="line">Email Address []:</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>共享 CA</p><p><strong>注意：ca-key.pem 是 CA 的私钥，必须严格保护，不能泄露。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将生成的 ca.pem 和 ca-key.pem 文件安全地分发给其他 4 台机器。</span></span><br><span class="line">scp ~/docker-certs/* sun@192.168.61.111:~/docker-certs</span><br><span class="line">scp ~/docker-certs/* sun@192.168.61.112:~/docker-certs</span><br><span class="line">scp ~/docker-certs/* sun@192.168.61.113:~/docker-certs</span><br><span class="line">scp ~/docker-certs/* sun@192.168.61.114:~/docker-certs</span><br></pre></td></tr></table></figure></li><li><p>生成服务器证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成服务器私钥：</span></span><br><span class="line">openssl genrsa -out server-key.pem 4096</span><br><span class="line"><span class="comment"># 生成证书签名请求（CSR）：将 &lt;服务器IP或域名&gt; 替换为服务器的实际 IP 或域名。</span></span><br><span class="line"><span class="comment"># openssl req -subj &quot;/CN=&lt;服务器IP或域名&gt;&quot; -sha256 -new -key server-key.pem -out server.csr</span></span><br><span class="line"><span class="comment"># 创建扩展配置文件（extfile.cnf）：将 &lt;服务器域名&gt; 和 &lt;服务器IP&gt; 替换为实际值。</span></span><br><span class="line"><span class="comment"># echo subjectAltName = DNS:&lt;服务器域名&gt;,IP:&lt;服务器IP&gt;,IP:127.0.0.1 &gt; extfile.cnf</span></span><br><span class="line"><span class="comment"># echo extendedKeyUsage = serverAuth &gt;&gt; extfile.cnf</span></span><br><span class="line">openssl req -subj <span class="string">&quot;/CN=192.168.61.110&quot;</span> -sha256 -new -key server-key.pem -out server.csr</span><br><span class="line"><span class="built_in">echo</span> subjectAltName = IP:192.168.61.110,IP:127.0.0.1 &gt; extfile.cnf</span><br><span class="line"><span class="built_in">echo</span> extendedKeyUsage = serverAuth &gt;&gt; extfile.cnf</span><br><span class="line"></span><br><span class="line">openssl req -subj <span class="string">&quot;/CN=192.168.61.111&quot;</span> -sha256 -new -key server-key.pem -out server.csr</span><br><span class="line"><span class="built_in">echo</span> subjectAltName = DNS:node01,IP:192.168.61.111,IP:127.0.0.1 &gt; extfile.cnf</span><br><span class="line"><span class="built_in">echo</span> extendedKeyUsage = serverAuth &gt;&gt; extfile.cnf</span><br><span class="line"></span><br><span class="line">openssl req -subj <span class="string">&quot;/CN=192.168.61.112&quot;</span> -sha256 -new -key server-key.pem -out server.csr</span><br><span class="line"><span class="built_in">echo</span> subjectAltName = DNS:node02,IP:192.168.61.112,IP:127.0.0.1 &gt; extfile.cnf</span><br><span class="line"><span class="built_in">echo</span> extendedKeyUsage = serverAuth &gt;&gt; extfile.cnf</span><br><span class="line"></span><br><span class="line">openssl req -subj <span class="string">&quot;/CN=192.168.61.113&quot;</span> -sha256 -new -key server-key.pem -out server.csr</span><br><span class="line"><span class="built_in">echo</span> subjectAltName = DNS:node03,IP:192.168.61.113,IP:127.0.0.1 &gt; extfile.cnf</span><br><span class="line"><span class="built_in">echo</span> extendedKeyUsage = serverAuth &gt;&gt; extfile.cnf</span><br><span class="line"></span><br><span class="line">openssl req -subj <span class="string">&quot;/CN=192.168.61.114&quot;</span> -sha256 -new -key server-key.pem -out server.csr</span><br><span class="line"><span class="built_in">echo</span> subjectAltName = DNS:node04,IP:192.168.61.114,IP:127.0.0.1 &gt; extfile.cnf</span><br><span class="line"><span class="built_in">echo</span> extendedKeyUsage = serverAuth &gt;&gt; extfile.cnf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在每台机器上使用共享的 CA 签名服务器证书：</span></span><br><span class="line">openssl x509 -req -days 365 -sha256 -<span class="keyword">in</span> server.csr -CA ca.pem -CAkey ca-key.pem \</span><br><span class="line">  -CAcreateserial -out server-cert.pem -extfile extfile.cnf</span><br><span class="line"><span class="comment"># 输入ca密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除不必要的文件：</span></span><br><span class="line"><span class="built_in">rm</span> -v server.csr extfile.cnf</span><br></pre></td></tr></table></figure></li><li><p>生成客户端证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成客户端私钥：</span></span><br><span class="line">openssl genrsa -out key.pem 4096</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成证书签名请求（CSR）：</span></span><br><span class="line">openssl req -subj <span class="string">&quot;/CN=client&quot;</span> -new -key key.pem -out client.csr</span><br><span class="line"><span class="comment"># 创建扩展配置文件（extfile-client.cnf）：</span></span><br><span class="line"><span class="built_in">echo</span> extendedKeyUsage = clientAuth &gt; extfile-client.cnf</span><br><span class="line"><span class="comment"># 生成客户端证书：</span></span><br><span class="line">openssl x509 -req -days 365 -sha256 -<span class="keyword">in</span> client.csr -CA ca.pem -CAkey ca-key.pem \</span><br><span class="line">  -CAcreateserial -out cert.pem -extfile extfile-client.cnf</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除不必要的文件：</span></span><br><span class="line"><span class="built_in">rm</span> -v client.csr server.csr extfile.cnf extfile-client.cnf</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>设置文件权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -v 0400 ca-key.pem key.pem server-key.pem</span><br><span class="line"><span class="built_in">chmod</span> -v 0444 ca.pem server-cert.pem cert.pem</span><br></pre></td></tr></table></figure></li></ol><h3 id="配置-Docker-使用-TLS"><a href="#配置-Docker-使用-TLS" class="headerlink" title="配置 Docker 使用 TLS"></a>配置 Docker 使用 TLS</h3><ol><li><p>将生成的证书文件复制到 Docker 的配置目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> ~/docker-certs/&#123;ca.pem,server-cert.pem,server-key.pem&#125; /etc/docker/</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R root:root /etc/docker</span><br></pre></td></tr></table></figure></li><li><p>编辑 Docker 的配置文件 <code>/etc/docker/daemon.json</code>，添加以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;tls&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;tlscacert&quot;</span>: <span class="string">&quot;/etc/docker/ca.pem&quot;</span>,</span><br><span class="line">  <span class="string">&quot;tlscert&quot;</span>: <span class="string">&quot;/etc/docker/server-cert.pem&quot;</span>,</span><br><span class="line">  <span class="string">&quot;tlskey&quot;</span>: <span class="string">&quot;/etc/docker/server-key.pem&quot;</span>,</span><br><span class="line">  <span class="string">&quot;hosts&quot;</span>: [<span class="string">&quot;unix:///var/run/docker.sock&quot;</span>, <span class="string">&quot;tcp://0.0.0.0:2376&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重启 Docker 服务以应用配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload; <span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure></li><li><p>客户端配置,将以下文件从服务器复制到客户端机器：</p><ul><li><p><code>ca.pem</code></p></li><li><p><code>cert.pem</code></p></li><li><p><code>key.pem</code></p></li></ul></li></ol><h3 id="生成证书和密钥脚本"><a href="#生成证书和密钥脚本" class="headerlink" title="生成证书和密钥脚本"></a>生成证书和密钥脚本</h3><p><code>hostname -I</code> 命令返回的是服务器上所有网络接口的 IP 地址，多个网卡必须改为服务器真实域名或IP</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">vim generate_docker_tls.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相关配置信息</span></span><br><span class="line">SERVER=$(hostname -I | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>) <span class="comment">#&quot;your_server_domain_or_ip&quot;  # 重要！必须改为服务器真实域名或IP</span></span><br><span class="line">PASSWORD=<span class="string">&quot;XyZ@123abc!#$&quot;</span></span><br><span class="line">COUNTRY=<span class="string">&quot;CN&quot;</span></span><br><span class="line">STATE=<span class="string">&quot;SHANGHAI&quot;</span></span><br><span class="line">CITY=<span class="string">&quot;SHANGHAI&quot;</span></span><br><span class="line">ORGANIZATION=<span class="string">&quot;Personal&quot;</span></span><br><span class="line">ORGANIZATIONAL_UNIT=<span class="string">&quot;Personal Use&quot;</span></span><br><span class="line">EMAIL=<span class="string">&quot;yourname@example.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 开始生成文件 ###</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;开始生成文件&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建目标目录并进入（自动处理目录不存在的情况）</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /etc/docker &amp;&amp; <span class="built_in">cd</span> /etc/docker || <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 CA 私钥（使用 aes256 加密）</span></span><br><span class="line">openssl genrsa -aes256 -passout pass:<span class="string">&quot;<span class="variable">$PASSWORD</span>&quot;</span> -out ca-key.pem 4096</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 CA 证书</span></span><br><span class="line">openssl req -new -x509 -passin <span class="string">&quot;pass:<span class="variable">$PASSWORD</span>&quot;</span> -days 3650 \</span><br><span class="line">    -key ca-key.pem -sha256 -out ca.pem \</span><br><span class="line">    -subj <span class="string">&quot;/C=<span class="variable">$COUNTRY</span>/ST=<span class="variable">$STATE</span>/L=<span class="variable">$CITY</span>/O=<span class="variable">$ORGANIZATION</span>/OU=<span class="variable">$ORGANIZATIONAL_UNIT</span>/CN=<span class="variable">$SERVER</span>/emailAddress=<span class="variable">$EMAIL</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成服务器私钥</span></span><br><span class="line">openssl genrsa -out server-key.pem 4096</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成服务器证书请求</span></span><br><span class="line">openssl req -subj <span class="string">&quot;/CN=<span class="variable">$SERVER</span>&quot;</span> -sha256 -new -key server-key.pem -out server.csr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建服务器证书扩展配置文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;subjectAltName = IP:<span class="variable">$SERVER</span>,IP:0.0.0.0&quot;</span> &gt; server-extfile.cnf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;extendedKeyUsage = serverAuth&quot;</span> &gt;&gt; server-extfile.cnf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成服务器证书</span></span><br><span class="line">openssl x509 -req -days 3650 -sha256 -<span class="keyword">in</span> server.csr \</span><br><span class="line">    -CA ca.pem -CAkey ca-key.pem -CAcreateserial \</span><br><span class="line">    -passin <span class="string">&quot;pass:<span class="variable">$PASSWORD</span>&quot;</span> \</span><br><span class="line">    -out server-cert.pem -extfile server-extfile.cnf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成客户端私钥</span></span><br><span class="line">openssl genrsa -out key.pem 4096</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成客户端证书请求</span></span><br><span class="line">openssl req -subj <span class="string">&#x27;/CN=client&#x27;</span> -new -key key.pem -out client.csr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建客户端证书扩展配置文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;extendedKeyUsage = clientAuth&quot;</span> &gt; client-extfile.cnf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成客户端证书</span></span><br><span class="line">openssl x509 -req -days 3650 -sha256 -<span class="keyword">in</span> client.csr \</span><br><span class="line">    -CA ca.pem -CAkey ca-key.pem -CAcreateserial \</span><br><span class="line">    -passin <span class="string">&quot;pass:<span class="variable">$PASSWORD</span>&quot;</span> \</span><br><span class="line">    -out cert.pem -extfile client-extfile.cnf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置权限</span></span><br><span class="line"><span class="built_in">chmod</span> 0400 ca-key.pem key.pem server-key.pem</span><br><span class="line"><span class="built_in">chmod</span> 0444 ca.pem server-cert.pem cert.pem</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理临时文件</span></span><br><span class="line"><span class="built_in">rm</span> -f client.csr server.csr server-extfile.cnf client-extfile.cnf</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;生成文件完成&quot;</span></span><br><span class="line"><span class="comment">### 生成结束 ###</span></span><br></pre></td></tr></table></figure><ol><li><p><strong>赋予执行权限</strong>：在终端中执行以下命令，为脚本添加执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x generate_docker_tls.sh</span><br><span class="line"><span class="built_in">sudo</span>  ./generate_docker_tls.sh</span><br></pre></td></tr></table></figure></li><li><p>查看证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ll /etc/docker</span><br><span class="line"></span><br><span class="line">-r-------- 1 root root 3.4K  2月 6日 03:15 ca-key.pem</span><br><span class="line">-r--r--r-- 1 root root 2.2K  2月 6日 03:15 ca.pem</span><br><span class="line">-rw-r--r-- 1 root root   41  2月 6日 03:16 ca.srl</span><br><span class="line">-r--r--r-- 1 root root 2.0K  2月 6日 03:16 cert.pem</span><br><span class="line">-rw-r--r-- 1 root root   51  2月 4日 23:47 daemon.json</span><br><span class="line">-r-------- 1 root root 3.2K  2月 6日 03:16 key.pem</span><br><span class="line">-r--r--r-- 1 root root 2.1K  2月 6日 03:15 server-cert.pe </span><br></pre></td></tr></table></figure><p>这些文件是 Docker TLS 认证机制正常工作所必需的：</p><ul><li>**<code>ca-key.pem</code>**：CA（证书颁发机构）的私钥文件，用于签署服务器和客户端证书。它使用 AES256 加密，权限设置为只有所有者可读写（<code>-r--------</code>），以保证安全性。</li><li>**<code>ca.pem</code>**：CA 的证书文件，客户端和服务器使用它来验证对方证书的有效性。</li><li>**<code>server-cert.pem</code>**：服务器的证书文件，用于向客户端证明服务器的身份。</li><li>**<code>server-key.pem</code>**：服务器的私钥文件，与 <code>server-cert.pem</code> 配对使用，用于加密和解密通信数据。</li><li>**<code>cert.pem</code>**：客户端的证书文件，用于向服务器证明客户端的身份。</li><li>**<code>key.pem</code>**：客户端的私钥文件，与 <code>cert.pem</code> 配对使用，用于加密和解密通信数据。</li></ul></li></ol><script>var description="这篇文章介绍了如何在无法访问 Docker 官网时设置本地镜像源，并详细讲解了配置 TLS 以增强数据传输安全的方法。"</script>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nvm包管理器</title>
      <link href="/p/c3561f90.html"/>
      <url>/p/c3561f90.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Nvm，即 Node Version Manager，是一个用于管理 Node.js 版本的工具。在开发过程中，不同的项目可能需要不同版本的 Node.js 来运行，Nvm 就能够帮助开发者在同一台机器上轻松切换 Node.js 版本。</p><p>它的安装步骤因操作系统而异。在 Linux 和 macOS 系统上，通常可以通过 curl 命令或 wget 命令下载安装脚本进行安装。例如，使用 curl 命令安装的方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 国内下载 ,不用再配置国内源</span></span><br><span class="line">bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/RubyMetric/nvm-cn/raw/main/install.sh)</span>&quot;</span></span><br><span class="line">bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/RubyMetric/nvm-cn/raw/main/uninstall.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>安装完成后，通过特定命令即可使用 Nvm 管理 Node.js 版本。例如，要列出所有可安装的 Node.js 版本，可以使用<code>nvm list available</code>命令；</p><p>安装指定版本（如 16.14.2）则使用nvm install 16.14.2命令；切换到已安装的某个版本（如 14.17.0）使用nvm use 14.17.0命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有可安装版本</span></span><br><span class="line">nvm ls-remote</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装某个版本Node</span></span><br><span class="line">nvm install --lts</span><br><span class="line">nvm install v12.20.1</span><br><span class="line">nvm install v15.5.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换Node版本</span></span><br><span class="line">nvm use system</span><br><span class="line">nvm use 14.15    <span class="comment"># 不用全部打出版本号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新nvm</span></span><br><span class="line">nvm-update</span><br></pre></td></tr></table></figure><p>Nvm 的出现极大地提升了开发者在多版本 Node.js 项目中的开发效率，解决了版本冲突等问题。</p><h2 id="国内源修改"><a href="#国内源修改" class="headerlink" title="国内源修改"></a>国内源修改</h2><p>在国内使用 Nvm 安装 Node.js 版本时，由于网络原因，从官方源下载可能速度较慢，此时可以修改为国内源。通常可以使用淘宝 NPM 镜像源来加速下载。具体操作如下：</p><ol><li><p>打开终端，创建或编辑.bashrc文件（如果是 zsh 用户，则编辑.zshrc文件），可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure></li><li><p>在文件末尾添加如下配置，以使用淘宝 NPM 镜像源来安装 Node.js：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_NODEJS_ORG_MIRROR=https://mirrors.ustc.edu.cn/node/</span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com/</span><br></pre></td></tr></table></figure></li><li><p>阿里云镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvm npm_mirror https://npmmirror.com/mirrors/npm/</span><br><span class="line">nvm node_mirror https://npmmirror.com/mirrors/node/</span><br></pre></td></tr></table></figure></li><li><p>腾讯云镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvm npm_mirror http://mirrors.cloud.tencent.com/npm/</span><br><span class="line">nvm node_mirror http://mirrors.cloud.tencent.com/nodejs-release/</span><br></pre></td></tr></table></figure></li><li><p>保存并退出文件（在 vim 中，按Esc键，输入:wq回车）。</p></li><li><p>使配置生效，执行如下命令：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>通过修改为国内源，能够显著提升 Node.js 版本的下载速度，进一步提高开发效率。Nvm 的出现极大地提升了开发者在多版本 Node.js 项目中的开发效率，解决了版本冲突等问题。</p><h2 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h2><ul><li><p>以使用 NPM 来安装 Yarn。在终端中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn</span><br><span class="line">yarn config <span class="built_in">set</span> registry http://mirrors.cloud.tencent.com/npm/ --global</span><br></pre></td></tr></table></figure></li><li><p>要清理 Yarn 缓存，可以在终端中运行<code>yarn cache clean</code>命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn cache clean</span><br></pre></td></tr></table></figure></li><li><p>Ubuntu</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt remove cmdtest</span><br><span class="line"><span class="built_in">sudo</span> apt remove yarn &amp;&amp; curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | <span class="built_in">sudo</span> apt-key add -</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://dl.yarnpkg.com/debian/ stable main&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/yarn.list</span><br><span class="line"><span class="built_in">sudo</span> apt-get update &amp;&amp; <span class="built_in">sudo</span> apt-get install yarn</span><br><span class="line"></span><br><span class="line">❯ yarn --version</span><br><span class="line">1.22.22</span><br><span class="line">❯ yarn global bin         </span><br><span class="line">/home/sun/.yarn/bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vim ~/.zshrc</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$PATH</span>:`yarn global bin`:<span class="variable">$HOME</span>/.config/yarn/global/node_modules/.bin&quot;</span></span><br></pre></td></tr></table></figure></li></ul><script>var description="这篇文章介绍了Nvm、在国内源中使用Nvm以及如何使用NPM安装YARN的相关内容。Nvm是一个用于管理Node.js版本的工具，在同一台机器上可以轻松切换不同版本，解决了多项目开发版本冲突的问题。文章详细说明了Nvm的安装步骤，包括在Linux和macOS系统中使用curl或wget命令下载安装脚本，以及如何通过特定命令切换、列出版本和安装特定版本。此外，文章还针对国内网络环境中的情况，介绍了如何修改源地址加速下载，并提供了YARN的使用方法，如安装和清理缓存。"</script>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos9常用设置</title>
      <link href="/p/23265f25.html"/>
      <url>/p/23265f25.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="yum包"><a href="#yum包" class="headerlink" title="yum包"></a>yum包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget vim curl tree perl util-linux-user git</span><br></pre></td></tr></table></figure><h2 id="更换国内软件源"><a href="#更换国内软件源" class="headerlink" title="更换国内软件源"></a>更换国内软件源</h2><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/centos-stream/">centos-stream | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p><ul><li><p>对于大部分 CentOS Stream 9 镜像，应该已经包含了 Perl 解释器，如果你的镜像没有包含，你可以使用以下命令简单的安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用 dnf</span><br><span class="line">dnf install perl</span><br><span class="line"></span><br><span class="line"># 使用 yum</span><br><span class="line">yum install perl</span><br></pre></td></tr></table></figure></li><li><p>将这段代码保存为一个文件，例如 <code>update_mirror.pl</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/perl</span></span><br><span class="line"></span><br><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line">use autodie;</span><br><span class="line"></span><br><span class="line">my <span class="variable">$mirrors</span> = <span class="string">&#x27;https://mirrors.tuna.tsinghua.edu.cn/centos-stream&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (@ARGV &lt; 1) &#123;</span><br><span class="line">    die <span class="string">&quot;Usage: <span class="variable">$0</span> &lt;filename1&gt; &lt;filename2&gt; ...\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (my <span class="variable">$filename</span> = <span class="built_in">shift</span> @ARGV) &#123;</span><br><span class="line">    my <span class="variable">$backup_filename</span> = <span class="variable">$filename</span> . <span class="string">&#x27;.bak&#x27;</span>;</span><br><span class="line">    rename <span class="variable">$filename</span>, <span class="variable">$backup_filename</span>;</span><br><span class="line"></span><br><span class="line">    open my <span class="variable">$input</span>, <span class="string">&quot;&lt;&quot;</span>, <span class="variable">$backup_filename</span>;</span><br><span class="line">    open my <span class="variable">$output</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="variable">$filename</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (&lt;<span class="variable">$input</span>&gt;) &#123;</span><br><span class="line">        s/^metalink/# metalink/;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m/^name/) &#123;</span><br><span class="line">            my (undef, <span class="variable">$repo</span>, <span class="variable">$arch</span>) = <span class="built_in">split</span> /-/;</span><br><span class="line">            <span class="variable">$repo</span> =~ s/^\s+|\s+$//g;</span><br><span class="line">            (<span class="variable">$arch</span> = defined <span class="variable">$arch</span> ? lc(<span class="variable">$arch</span>) : <span class="string">&#x27;&#x27;</span>) =~ s/^\s+|\s+$//g;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$repo</span> =~ /^Extras/) &#123;</span><br><span class="line">                <span class="variable">$_</span> .= <span class="string">&quot;baseurl=<span class="variable">$&#123;mirrors&#125;</span>/SIGs/\$releasever-stream/extras&quot;</span> . (<span class="variable">$arch</span> eq <span class="string">&#x27;source&#x27;</span> ? <span class="string">&quot;/<span class="variable">$&#123;arch&#125;</span>/&quot;</span> : <span class="string">&quot;/\$basearch/&quot;</span>) . <span class="string">&quot;extras-common\n&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$_</span> .= <span class="string">&quot;baseurl=<span class="variable">$&#123;mirrors&#125;</span>/\$releasever-stream/<span class="variable">$repo</span>&quot;</span> . (<span class="variable">$arch</span> eq <span class="string">&#x27;source&#x27;</span> ? <span class="string">&quot;/&quot;</span> : <span class="string">&quot;/\$basearch/&quot;</span>) . (<span class="variable">$arch</span> ne <span class="string">&#x27;&#x27;</span> ? <span class="string">&quot;<span class="variable">$&#123;arch&#125;</span>/tree/&quot;</span> : <span class="string">&quot;os&quot;</span>) . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> <span class="variable">$output</span> <span class="variable">$_</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在命令行中使用以下命令来执行它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl ./update_mirror.pl /etc/yum.repos.d/centos*.repo</span><br></pre></td></tr></table></figure><p>注意将 <code>./update_mirror.pl</code> 替换为脚本实际保存的路径。其中的 <code>*</code> 通配符，如果只需要替换一些文件中的源，请自行增删。</p><p>另外，请确保已经安装了 Perl 解释器，并将 <code>perl</code> 命令添加到系统的 <code>PATH</code> 环境变量中。这样才能在命令行中运行 Perl 脚本。</p></li><li><p>最后，更新软件包缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 使用 dnf</span><br><span class="line">dnf clean all &amp;&amp; dnf makecache</span><br><span class="line"></span><br><span class="line"># 使用 yum</span><br><span class="line">yum clean all &amp;&amp; yum makecache</span><br><span class="line"></span><br><span class="line"># yum repolist</span><br></pre></td></tr></table></figure><p>注意，如果需要启用其中一些 repo，需要将其中的 <code>enabled=0</code> 改为 <code>enabled=1</code>。</p></li></ul><h2 id="安装Zsh"><a href="#安装Zsh" class="headerlink" title="安装Zsh"></a>安装Zsh</h2><p>在 CentOS 9 上安装 <code>zsh</code> 可以按照以下步骤进行：</p><ol><li><p>**安装 <code>zsh</code>**：</p><ul><li>打开终端，以 root 用户或具有管理员权限的用户身份登录。</li><li>运行以下命令安装 <code>zsh</code>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install zsh</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>安装 <code>oh-my-zsh</code>（可选但推荐）</strong>：<code>oh-my-zsh</code> 是一个基于 <code>zsh</code> 的扩展工具集，提供了丰富的主题、插件等功能。</p><ul><li><p>安装 <code>git</code>（如果尚未安装），因为 <code>oh-my-zsh</code> 的安装脚本需要从 GitHub 上获取文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure></li><li><p>选择一种方式安装 <code>oh-my-zsh</code>：</p><ul><li><strong>使用官方脚本（可能需要科学上网，若网络状况不佳可考虑使用国内镜像源）</strong>：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure>  或者  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot;</span><br></pre></td></tr></table></figure></li><li><strong>使用国内镜像源（以 Gitee 为例）</strong>：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://gitee.com/shmhlsy/oh-my-zsh-install.sh/raw/master/install.sh)&quot;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>配置 <code>zsh</code>（如果安装了 <code>oh-my-zsh</code>）</strong>：</p><ul><li><p>安装完成 <code>oh-my-zsh</code> 后，它会提示你是否使用 <code>zsh</code> 作为默认的 shell。如果选择是，那么下次登录时将自动使用 <code>zsh</code>。如果当时没有选择，也可以手动更改默认 shell，运行以下命令（将 <code>/usr/bin/zsh</code> 替换为你的 <code>zsh</code> 可执行文件的实际路径，如果不确定路径，可以使用 <code>which zsh</code> 命令查看）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chsh命令通常包含在util-linux-user软件包中 </span></span><br><span class="line">yum install util-linux-user</span><br><span class="line">chsh -s /usr/bin/zsh</span><br></pre></td></tr></table></figure></li><li><p>配置 <code>zsh</code> 的插件和主题（可选）。<code>oh-my-zsh</code> 支持各种插件和主题，你可以根据自己的需求进行安装和配置。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装powerlevel10k  </span></span><br><span class="line">git <span class="built_in">clone</span> --depth 1 https://gitee.com/romkatv/powerlevel10k.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/themes/powerlevel10k</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 打开zsh配置文件  </span></span><br><span class="line">vim ~/.zshrc  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 修改主题配置  </span></span><br><span class="line">ZSH_THEME=<span class="string">&quot;powerlevel10k/powerlevel10k&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>Oh My Zsh提供了许多插件，可以帮助我们提高工作效率。以下是一些常用的插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动完成建议插件</span></span><br><span class="line">git <span class="built_in">clone</span> --depth 1  https://gitee.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法高亮插件</span></span><br><span class="line">git <span class="built_in">clone</span> --depth 1  https://gitee.com/zsh-users/zsh-syntax-highlighting <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting </span><br><span class="line"></span><br><span class="line"><span class="comment"># 历史命令搜索插件</span></span><br><span class="line">git <span class="built_in">clone</span>  --depth 1 https://gitee.com/zsh-users/zsh-history-substring-search <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-history-substring-search  </span><br></pre></td></tr></table></figure></li><li><p>然后在 <code>~/.zshrc</code> 文件中找到 <code>plugins</code> 配置项，将需要启用的插件添加进去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开zsh配置文件  </span></span><br><span class="line">vim ~/.zshrc</span><br><span class="line"></span><br><span class="line">plugins=(git zsh-autosuggestions zsh-syntax-highlighting zsh-history-substring-search)  </span><br></pre></td></tr></table></figure></li><li><p>再次保存并退出编辑器，重新加载配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc  </span><br></pre></td></tr></table></figure></li><li><p>字体设置 ，Terminal中设置默认字体为 <code>Ubuntu Mono derivative Powerline</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/powerline/fonts.git --depth=1</span><br><span class="line"><span class="built_in">cd</span> fonts</span><br><span class="line"><span class="comment"># 以管理员启动powershell 或者单独安装</span></span><br><span class="line">./install.ps1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;font&quot;</span>: </span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;face&quot;</span>: <span class="string">&quot;Ubuntu Mono derivative Powerline&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install -y java-1.8.0-openjdk java-1.8.0-openjdk-devel  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑.bashrc文件  </span></span><br><span class="line"><span class="built_in">sudo</span> vim ~/.zshrc  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 在文件末尾添加以下行  </span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.362.b09-4.el9.x86_64  </span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 保存并关闭文件  </span></span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 使修改生效  </span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc  </span><br></pre></td></tr></table></figure></li></ol><script>var description="这篇文章介绍了在 CentOS 9 上安装 YUM 包的相关操作，包括更换国内软件源以获取 YUM 包的内容。"</script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos9 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3项目实战</title>
      <link href="/p/28806695.html"/>
      <url>/p/28806695.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><ul><li>WSL2+ <a href="https://github.com/mishamosher/CentOS-WSL">mishamosher&#x2F;CentOS-WSL</a></li><li>node </li><li>yarn 1.22.22</li><li>vscode &#x2F; jetbrain IDEA</li></ul><h2 id="组件名和标签名的映射规则"><a href="#组件名和标签名的映射规则" class="headerlink" title="组件名和标签名的映射规则"></a>组件名和标签名的映射规则</h2><p>在 Vue 中，组件名和标签名之间的映射规则是基于 PascalCase（大驼峰命名法）和 kebab-case（短横线命名法）的转换。具体规则如下：</p><ol><li><p><strong>PascalCase 到 kebab-case 的转换</strong>：</p><ul><li>当你在模板中使用组件时，Vue 会自动将组件名从 PascalCase 转换为 kebab-case。例如，如果你有一个组件名为 <code>MyComponent</code>，在模板中你可以使用 <code>&lt;my-component&gt;</code> 来引用它。</li></ul></li><li><p><strong>kebab-case 到 PascalCase 的转换</strong>：</p><ul><li>当你在 JavaScript 中导入组件时，你需要使用组件的文件名（通常是 PascalCase）。例如，如果你有一个组件文件名为 <code>MyComponent.vue</code>，你需要使用 <code>import MyComponent from &#39;./MyComponent.vue&#39;</code> 来导入它。</li></ul></li><li><p><strong>全局注册组件</strong>：</p><ul><li>当你全局注册组件时，你可以使用任何有效的 JavaScript 标识符作为组件名。例如，你可以使用 <code>app.component(&#39;my-component&#39;, MyComponent)</code> 来全局注册 <code>MyComponent</code> 组件。</li></ul></li><li><p><strong>局部注册组件</strong>：</p><ul><li>在局部注册组件时，你需要在组件的 <code>components</code> 选项中使用组件的 PascalCase 名称。例如：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./MyComponent.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="title class_">MyComponent</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 其他组件选项</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>&lt;script setup&gt;</code> 语法</strong>：</p><ul><li>在 <code>&lt;script setup&gt;</code> 中，组件的名称会自动根据文件名来推断。例如，如果你的组件文件名为 <code>MyComponent.vue</code>，那么组件的名称就是 <code>MyComponent</code>。你可以在模板中直接使用 <code>&lt;my-component&gt;</code> 来引用它。</li></ul></li></ol><p>总结一下，Vue 会自动处理组件名和标签名之间的转换，使得你可以在模板中使用 kebab-case 命名的标签来引用 PascalCase 命名的组件。这种命名约定有助于提高代码的可读性，并且避免与 HTML 原生标签冲突。</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">❯ yarn create vite</span><br><span class="line">yarn create v1.22.22</span><br><span class="line">[1/4] Resolving packages...</span><br><span class="line">[2/4] Fetching packages...</span><br><span class="line">[3/4] Linking dependencies...</span><br><span class="line">[4/4] Building fresh packages...</span><br><span class="line">success Installed <span class="string">&quot;create-vite@6.1.1&quot;</span> with binaries:</span><br><span class="line">      - create-vite</span><br><span class="line">      - cva</span><br><span class="line">✔ Project name: … vue3-blog</span><br><span class="line">✔ Select a framework: › Vue</span><br><span class="line">✔ Select a variant: › TypeScript</span><br><span class="line"></span><br><span class="line">Scaffolding project <span class="keyword">in</span> /root/vue3-blog...</span><br><span class="line"></span><br><span class="line">Done. Now run:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cd</span> vue3-blog</span><br><span class="line">  yarn</span><br><span class="line">  yarn dev</span><br><span class="line"></span><br><span class="line">Done <span class="keyword">in</span> 16.15s.</span><br></pre></td></tr></table></figure><p>清理初始化内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:.</span><br><span class="line">├───.vscode</span><br><span class="line">├───public</span><br><span class="line">└───src</span><br><span class="line">    ├───assets</span><br><span class="line">    └───components</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev @types/node</span><br></pre></td></tr></table></figure><h2 id="配置alias"><a href="#配置alias" class="headerlink" title="配置alias"></a>配置alias</h2><p><a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense">vscode 插件： Path Intellisense</a> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;path-intellisense.mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;@&quot;</span>: <span class="string">&quot;<span class="variable">$&#123;workspaceFolder&#125;</span>/src&quot;</span>, // Alias <span class="keyword">for</span> absolute path to directory.</span><br><span class="line">    <span class="string">&quot;@cp&quot;</span>: <span class="string">&quot;<span class="variable">$&#123;workspaceFolder&#125;</span>/src/components&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@views&quot;</span>: <span class="string">&quot;<span class="variable">$&#123;workspaceFolder&#125;</span>/src/views&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>vite.config.ts</code> 里配置了这些 alias </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; resolve &#125; <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;@&#x27;</span>: <span class="title function_">resolve</span>(<span class="string">&#x27;src&#x27;</span>), <span class="comment">// 源码根目录</span></span><br><span class="line">      <span class="string">&#x27;@img&#x27;</span>: <span class="title function_">resolve</span>(<span class="string">&#x27;src/assets/img&#x27;</span>), <span class="comment">// 图片</span></span><br><span class="line">      <span class="string">&#x27;@less&#x27;</span>: <span class="title function_">resolve</span>(<span class="string">&#x27;src/assets/less&#x27;</span>), <span class="comment">// 预处理器</span></span><br><span class="line">      <span class="string">&#x27;@libs&#x27;</span>: <span class="title function_">resolve</span>(<span class="string">&#x27;src/libs&#x27;</span>), <span class="comment">// 本地库</span></span><br><span class="line">      <span class="string">&#x27;@plugins&#x27;</span>: <span class="title function_">resolve</span>(<span class="string">&#x27;src/plugins&#x27;</span>), <span class="comment">// 本地插件</span></span><br><span class="line">      <span class="string">&#x27;@cp&#x27;</span>: <span class="title function_">resolve</span>(<span class="string">&#x27;src/components&#x27;</span>), <span class="comment">// 公共组件</span></span><br><span class="line">      <span class="string">&#x27;@views&#x27;</span>: <span class="title function_">resolve</span>(<span class="string">&#x27;src/views&#x27;</span>), <span class="comment">// 路由组件</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在该项目的 tsconfig.json 文件里就需要相应的加上这些 paths ：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;references&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./tsconfig.app.json&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="comment">// 配置应用程序相关的 TypeScript 编译选项</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./tsconfig.node.json&quot;</span> <span class="punctuation">&#125;</span> <span class="comment">//配置与 Node.js 环境相关的 TypeScript 编译选</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改tsconfig.app.json文件</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;@/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;@img/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/assets/img/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;@less/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/assets/less/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;@libs/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/libs/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;@plugins/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/plugins/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;@cp/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/components/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;@views/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/views/*&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>设置vscode 的ts</p><ul><li><code>command + shift + P</code> ，输入 type，选择<code>select typescript version </code>,选择 <strong><code>use WOrkspace Version</code></strong></li><li>重启vscode，可以发现页面报错消失</li></ul><h2 id="全局样式"><a href="#全局样式" class="headerlink" title="全局样式"></a>全局样式</h2><ul><li><p>安装sass依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D sass</span><br></pre></td></tr></table></figure></li><li><p>新建 <code>src/styles/global.scss</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> src/style.css  </span><br><span class="line"><span class="built_in">mkdir</span> -p $(<span class="built_in">dirname</span> src/styles/global.less) &amp;&amp; <span class="built_in">touch</span> src/styles/global.scss</span><br><span class="line"></span><br><span class="line">*&#123;</span><br><span class="line">  padding: 0;</span><br><span class="line">  margin: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引入全局样式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ code ./src/main.ts</span><br><span class="line"></span><br><span class="line">import <span class="string">&#x27;./styles/global.scss&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="tailwindcss"><a href="#tailwindcss" class="headerlink" title="tailwindcss"></a>tailwindcss</h2><ul><li><p><a href="https://tailwind.nodejs.cn/docs/installation">安装 - Tailwind CSS 中文网</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># npm install -D tailwindcss@latest postcss@latest autoprefixer@latest</span></span><br><span class="line"><span class="comment"># npx tailwindcss-cli@latest init -p</span></span><br><span class="line"></span><br><span class="line">yarn add  -D tailwindcss@3 postcss autoprefixer</span><br><span class="line">npx tailwindcss init -p</span><br></pre></td></tr></table></figure></li><li><p>配置css</p><ul><li>这个配置文件中的 <code>content</code> 部分指定了 Tailwind CSS 应该扫描哪些文件来寻找 Tailwind 类。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// vi tailwind.config.js</span><br><span class="line">/** @<span class="built_in">type</span> &#123;import(<span class="string">&#x27;tailwindcss&#x27;</span>).Config&#125; */</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  content: [<span class="string">&quot;./index.html&quot;</span>, <span class="string">&quot;./src/**/*.&#123;vue,js,ts,jsx,tsx&#125;&quot;</span>],</span><br><span class="line">  theme: &#123;</span><br><span class="line">    extend: &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在 src&#x2F;styles&#x2F;tailwind.css 文件中添加<code>@tailwind</code> 指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// <span class="built_in">touch</span>  src/styles/tailwind.css</span><br><span class="line">@tailwind base;</span><br><span class="line">@tailwind components;</span><br><span class="line">@tailwind utilities;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里可以同全局样式关联</span></span><br><span class="line">/* src/styles/global.scss */</span><br><span class="line">@tailwind base;</span><br><span class="line">@tailwind components;</span><br><span class="line">@tailwind utilities;</span><br><span class="line"></span><br><span class="line">/* 这里可以添加自定义的全局样式 */</span><br><span class="line">body &#123;</span><br><span class="line">  font-family: <span class="string">&#x27;Segoe UI&#x27;</span>, Tahoma, Geneva, Verdana, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>main.ts 中引入tailwind.css</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./styles/global.scss&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./styles/tailwind.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1 class=&quot;text-3xl font-bold underline&quot;&gt;</span><br><span class="line">    Hello world!</span><br><span class="line">  &lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="引入Elemen-plus"><a href="#引入Elemen-plus" class="headerlink" title="引入Elemen-plus"></a>引入Elemen-plus</h2><p><a href="https://cn.element-plus.org/zh-CN/guide/design.html">设计 | Element Plus</a></p><ul><li><p>导入依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add element-plus</span><br><span class="line">按需导入</span><br><span class="line">yarn add -D unplugin-vue-components unplugin-auto-import</span><br></pre></td></tr></table></figure></li><li><p>完整引入引入依赖和样式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// main.ts</span><br><span class="line">import ElementPlus from <span class="string">&#x27;element-plus&#x27;</span></span><br><span class="line">import <span class="string">&#x27;element-plus/dist/index.css&#x27;</span></span><br><span class="line">app.use(ElementPlus)</span><br></pre></td></tr></table></figure></li><li><p><strong>按需导入</strong>： 配置插件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AutoImport</span> <span class="keyword">from</span> <span class="string">&#x27;unplugin-auto-import/vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Components</span> <span class="keyword">from</span> <span class="string">&#x27;unplugin-vue-components/vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ElementPlusResolver</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;unplugin-vue-components/resolvers&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">vue</span>(),</span><br><span class="line">    <span class="title class_">AutoImport</span>(&#123;</span><br><span class="line">      <span class="attr">resolvers</span>: [<span class="title class_">ElementPlusResolver</span>()],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="title class_">Components</span>(&#123;</span><br><span class="line">      <span class="attr">resolvers</span>: [<span class="title class_">ElementPlusResolver</span>()],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在 <code>src/main.js</code>（或 <code>src/main.ts</code>）中引入 ElementPlus 的 CSS 样式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-plus/dist/index.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;el-button&gt;click me&lt;/el-button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="引入Vue-router"><a href="#引入Vue-router" class="headerlink" title="引入Vue-router"></a>引入Vue-router</h2><ul><li><p>添加依赖</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add vue-router</span><br></pre></td></tr></table></figure></li><li><p>项目里引入路由,新建 router文件夹,新建index.ts</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// src/router/index.ts</span><br><span class="line"></span><br><span class="line">import &#123; createRouter, createWebHistory &#125; from <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line">import <span class="built_in">type</span> &#123; RouteRecordRaw &#125; from <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line">const routes: Array&lt;RouteRecordRaw&gt; = [</span><br><span class="line">  // ...</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">const router = createRouter(&#123;</span><br><span class="line">  <span class="built_in">history</span>: createWebHistory(import.meta.env.BASE_URL),</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default router</span><br></pre></td></tr></table></figure></li><li><p>main.ts引入</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>);</span><br><span class="line">app.<span class="title function_">use</span>(router);</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>一级路由写法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecordRaw</span>&gt; = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    <span class="comment">// 异步组件</span></span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@views/home.vue&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; |</span><br><span class="line">    &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="引入pinia"><a href="#引入pinia" class="headerlink" title="引入pinia"></a>引入pinia</h2><ol><li><p>首先，您需要安装pinia。您可以通过npm或yarn来安装它。在终端中运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install pinia</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">yarn add pinia</span><br></pre></td></tr></table></figure></li><li><p>在您的main.ts文件中引入pinia并将其挂载到您的Vue应用程序上</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span> <span class="comment">// 引入pinia</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">createPinia</span>()); <span class="comment">// 使用pinia</span></span><br></pre></td></tr></table></figure></li><li><p>启用数据持久化插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add pinia-plugin-persistedstate</span><br></pre></td></tr></table></figure></li><li><p><code>main.ts</code> 文件中导入并使用这个插件：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> piniaPluginPersistedstate <span class="keyword">from</span> <span class="string">&#x27;pinia-plugin-persistedstate&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>);</span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>()</span><br><span class="line">pinia.<span class="title function_">use</span>(piniaPluginPersistedstate)</span><br><span class="line">app.<span class="title function_">use</span>(pinia); <span class="comment">// 使用pinia</span></span><br></pre></td></tr></table></figure></li><li><p>编写stores</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;user&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">state</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">username</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">            <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">            <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 这是按照插件的文档，在实例上启用了该插件，这个选项是插件特有的</span></span><br><span class="line">    <span class="attr">persist</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 自定义存储</span></span><br><span class="line">    <span class="attr">persist</span>: &#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;my-user-store&#x27;</span>, <span class="comment">// 自定义存储的键名</span></span><br><span class="line">    <span class="attr">storage</span>: <span class="variable language_">sessionStorage</span> <span class="comment">// 使用 sessionStorage 而不是 localStorage</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 每一次变化后也会将其写入 localStorage 进行记忆存储。</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  const &#123; username &#125; = storeToRefs(user);</span><br><span class="line">   username.value = &quot;李四&quot;;</span><br><span class="line"> &#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure></li><li><p>可以在浏览器查看到 localStorage 的存储变化，以 Chrome 浏览器为例，按 F12 ，打开 Application 面板，选择 Local Storage ，可以看到以当前 Store ID <code>user</code> 为 Key 的存储数据。</p><p><img src="/p/28806695/9b7d0cac54c9f8457a0e1ed270e13778.png"></p></li></ol><h2 id="SVG图标"><a href="#SVG图标" class="headerlink" title="SVG图标"></a>SVG图标</h2><p><a href="https://www.viterc.cn/en/vite-plugin-svg-icons.html"><code>vite-plugin-svg-icons</code></a> 是一个 Vite 插件，用于在 Vite 项目中轻松地使用 SVG 图标。它允许你将多个 SVG 文件导入为 Vue 组件，并且可以通过配置来优化 SVG 的加载和使用。</p><ol><li><p>安装 <code>vite-plugin-svg-icons</code> 插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D vite-plugin-svg-icons </span><br></pre></td></tr></table></figure></li><li><p><strong>配置插件</strong>： 在 <code>vite.config.js</code> 文件中配置 <code>vite-plugin-svg-icons</code> 插件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createSvgIconsPlugin &#125; <span class="keyword">from</span> <span class="string">&#x27;vite-plugin-svg-icons&#x27;</span> <span class="comment">// 注意这里的导入方式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">vue</span>(),</span><br><span class="line">    <span class="title function_">createSvgIconsPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 指定需要缓存的图标文件夹</span></span><br><span class="line">      <span class="attr">iconDirs</span>: [<span class="title function_">resolve</span>(process.<span class="title function_">cwd</span>(), <span class="string">&#x27;src/icons/svg&#x27;</span>)],</span><br><span class="line">      <span class="comment">// 指定symbolId格式</span></span><br><span class="line">      <span class="attr">symbolId</span>: <span class="string">&#x27;icon-[dir]-[name]&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>在 src&#x2F;main.ts 中引入注册脚本</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;virtual:svg-icons-register&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>创建 SVG 图标组件</strong>： 在 <code>src/components</code> 目录下创建一个 <code>SvgIcon.vue</code> 文件，用于渲染 SVG 图标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// /src/components/SvgIcon.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;svg class=&quot;svg-icon&quot; aria-hidden=&quot;true&quot;&gt;</span><br><span class="line">    &lt;use :href=&quot;iconName&quot; /&gt;</span><br><span class="line">  &lt;/svg&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; computed &#125; from &#x27;vue&#x27;;</span><br><span class="line">const props = defineProps(&#123;</span><br><span class="line">  prefix:&#123;</span><br><span class="line">    type: String,</span><br><span class="line">    default: &#x27;icon&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  name: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    required: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const iconName = computed(() =&gt; `#$&#123;props.prefix&#125;-$&#123;props.name&#125;`);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.svg-icon &#123;</span><br><span class="line">  /* 设置 SVG 图标在垂直方向上的对齐方式。-0.15em 表示将图标向上移动 0.15em 可以使图标与文本的基线对齐*/</span><br><span class="line">  vertical-align: -0.15em;</span><br><span class="line">  /* 使用当前文本的颜色作为填充颜色 */</span><br><span class="line">  fill: currentColor;</span><br><span class="line">  /* 隐藏超出 SVG 图标边界的内容 */</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>下载SVG图标 <a href="https://www.iconfont.cn/?spm=a313x.home_index.i3.d4d0a486a.58a33a81Y85bKl">iconfont-阿里巴巴矢量图标库</a></p></li><li><p><strong>使用 SVG 图标</strong>： 在需要使用 SVG 图标的组件中，通过 <code>&lt;svg-icon&gt;</code> 标签来引用图标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p class=&quot;w-1/2&quot;&gt;This is home page&lt;/p&gt;</span><br><span class="line">    &lt;svg-icon class=&quot;float w-[2rem] h-[2rem] svg-icon-custom&quot; name=&quot;vue&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import SvgIcon from &quot;@/components/SvgIcon.vue&quot;; // 显式引入 SvgIcon 组件</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">.svg-icon-custom &#123;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>在 Vue 3 中，如果你使用的是 <code>&lt;script setup&gt;</code> 语法，那么组件会自动注册，不需要显式地使用 <code>import</code> 语句来引入组件。这是因为 <code>&lt;script setup&gt;</code> 是 Vue 3.2 中引入的一个新特性，它允许你在 <code>&lt;script&gt;</code> 标签中直接使用 Composition API，并且自动将所有顶级变量和函数暴露给模板。</p><p>在你的代码中，<code>&lt;svg-icon&gt;</code> 组件应该在项目定义的，并且已经被全局注册或者在当前组件的父组件中注册过了。因此，你可以直接在模板中使用 <code>&lt;svg-icon&gt;</code> 组件，而不需要显式地引入它。</p></blockquote><h2 id="自动引入icon"><a href="#自动引入icon" class="headerlink" title="自动引入icon"></a>自动引入icon</h2><p><a href="https://www.npmjs.com/package/unplugin-icons">unplugin-icons - npm</a> 使用约定 <code>~icons/&#123;collection&#125;/&#123;icon&#125;</code> 导入图标名称</p><p>图标：</p><ul><li><p><a href="https://icon-sets.iconify.design/">Iconify - home of open source icons</a></p></li><li><p><a href="https://icon-sets.iconify.design/mdi/">Material Design Icons - 7447 open source icons - Iconify</a></p></li><li><p><a href="https://icones.netlify.app/collection/all">https://icones.netlify.app/collection/all</a></p></li></ul><ol><li><p>下载依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D unplugin-icons  @iconify/json</span><br><span class="line"><span class="comment"># 如果您只想使用几个图标集，而不想下载整个集合，您也可以使用 @iconify-json/[collection-id] 单独安装它们。例如，要安装 Material Design 图标，您可以执行以下操作：</span></span><br><span class="line">npm i -D @iconify-json/mdi</span><br><span class="line"><span class="comment"># @iconify/json （~120MB） 包括 Iconify 中的所有图标集，因此您可以安装一次并根据需要使用其中任何一个（只有您实际使用的图标才会捆绑到生产版本中）。</span></span><br></pre></td></tr></table></figure></li><li><p>配置 Vite </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import <span class="punctuation">&#123;</span> defineConfig <span class="punctuation">&#125;</span> from &#x27;vite&#x27;;</span><br><span class="line">import Icons from &#x27;unplugin-icons/vite&#x27;;</span><br><span class="line">import IconsResolver from &#x27;unplugin-icons/resolver&#x27;;</span><br><span class="line">import Components from &#x27;unplugin-vue-components/vite&#x27;;</span><br><span class="line"></span><br><span class="line">export default defineConfig(<span class="punctuation">&#123;</span></span><br><span class="line">  plugins<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    Components(<span class="punctuation">&#123;</span></span><br><span class="line">      resolvers<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        IconsResolver(<span class="punctuation">&#123;</span></span><br><span class="line">          prefix<span class="punctuation">:</span> &#x27;icon&#x27;<span class="punctuation">,</span> <span class="comment">// 图标前缀，例如 &lt;icon-home /&gt;</span></span><br><span class="line">          enabledCollections<span class="punctuation">:</span> <span class="punctuation">[</span>&#x27;mdi&#x27;<span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 启用的图标集，例如 Material Design Icons</span></span><br><span class="line">        <span class="punctuation">&#125;</span>)<span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span>)<span class="punctuation">,</span></span><br><span class="line">    Icons(<span class="punctuation">&#123;</span></span><br><span class="line">      compiler<span class="punctuation">:</span> &#x27;vue3&#x27;<span class="punctuation">,</span> <span class="comment">// 使用 Vue 3 编译器</span></span><br><span class="line">      autoInstall<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 自动安装图标集</span></span><br><span class="line">    <span class="punctuation">&#125;</span>)<span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>配置完成后，你可以在 Vue 组件中直接使用图标。</p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;icon-mdi-account-reactivate class=&quot; size-2rem&quot; style=&quot;font-size: 2em; color: red&quot; /&gt;</span><br><span class="line">    &lt;icon-mdi-home /&gt;</span><br><span class="line">    &lt;icon-carbon-accessibility/&gt;</span><br><span class="line">    &lt;icon-mdi-account-box style=&quot;font-size: 2em; color: red&quot;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">// 不需要显式引入图标组件</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="环境变量管理"><a href="#环境变量管理" class="headerlink" title="环境变量管理"></a>环境变量管理</h2><ol><li><p>在项目根目录下创建 <code>.env</code> 文件，用于存放公共的环境变量；创建 <code>.env.development</code> 和 <code>.env.production</code> 文件，分别用于存放开发环境和生产环境的特定环境变量。</p></li><li><p><strong>使用环境变量</strong>：在代码中通过 <code>import.meta.env</code> 来访问环境变量。</p></li><li><p><strong>配置打包脚本</strong>：在 <code>package.json</code> 中配置不同环境的打包脚本，以便在不同环境下使用不同的环境变量。</p><ul><li><p>在 <code>package.json</code> 中配置不同环境的打包脚本：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;serve&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue-tsc --noEmit &amp;&amp; vite build&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build:dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue-tsc --noEmit &amp;&amp; vite build --mode development&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build:prod&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue-tsc --noEmit &amp;&amp; vite build --mode production&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>这样，在开发环境下运行 <code>npm run serve</code> 或 <code>npm run build:dev</code> 时，会使用 <code>.env.development</code> 中的环境变量；在生产环境下运行 <code>npm run build:prod</code> 时，会使用 <code>.env.production</code> 中的环境变量。</p></blockquote><h2 id="引入-axios"><a href="#引入-axios" class="headerlink" title="引入 axios"></a>引入 axios</h2><ol><li><p>安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 npm 安装</span></span><br><span class="line">npm install axios</span><br><span class="line"><span class="comment"># 或者使用 yarn 安装</span></span><br><span class="line">yarn add axios</span><br></pre></td></tr></table></figure></li><li><p><code>src</code> 目录下创建一个名为 config 的文件j夹，新建request.ts 内容如下：</p></li></ol>   <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">AxiosRequestConfig</span> ,<span class="title class_">InternalAxiosRequestConfig</span>, <span class="title class_">AxiosResponse</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ElMessage</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;element-plus&#x27;</span>; <span class="comment">// 这里使用 ElementPlus 的消息提示，你可以根据项目替换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Axios 实例</span></span><br><span class="line"><span class="keyword">const</span> service = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">VITE_API_BASE_URL</span>, <span class="comment">// 从环境变量中获取 baseURL</span></span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">5000</span> <span class="comment">// 请求超时时间</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">service.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="function">(<span class="params"><span class="attr">config</span>: <span class="title class_">InternalAxiosRequestConfig</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 在发送请求之前做些什么，例如添加 token</span></span><br><span class="line">        <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (token) &#123;</span><br><span class="line">            config.<span class="property">headers</span>.<span class="property">Authorization</span> = <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 处理请求错误</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;请求错误:&#x27;</span>, error);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">service.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="function">(<span class="params"><span class="attr">response</span>: <span class="title class_">AxiosResponse</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; data &#125; = response;</span><br><span class="line">        <span class="comment">// 根据后端返回的状态码进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (data.<span class="property">code</span> === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> data.<span class="property">data</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 处理业务错误</span></span><br><span class="line">            <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(data.<span class="property">message</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(data.<span class="property">message</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 处理网络错误</span></span><br><span class="line">        <span class="keyword">let</span> message = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">const</span> status = error.<span class="property">response</span>?.<span class="property">status</span>;</span><br><span class="line">        <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">                message = <span class="string">&#x27;未授权，请登录&#x27;</span>;</span><br><span class="line">                <span class="comment">// 跳转到登录页</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">403</span>:</span><br><span class="line">                message = <span class="string">&#x27;拒绝访问&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">                message = <span class="string">&#x27;请求地址出错&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">500</span>:</span><br><span class="line">                message = <span class="string">&#x27;服务器内部错误&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">                message = <span class="string">&#x27;网络连接错误&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(message);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装请求方法</span></span><br><span class="line"><span class="keyword">const</span> request = &#123;</span><br><span class="line">    get&lt;T&gt;(<span class="attr">url</span>: <span class="built_in">string</span>, <span class="attr">config</span>?: <span class="title class_">AxiosRequestConfig</span>): <span class="title class_">Promise</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> service.<span class="title function_">get</span>(url, config);</span><br><span class="line">    &#125;,</span><br><span class="line">    post&lt;T&gt;(<span class="attr">url</span>: <span class="built_in">string</span>, <span class="attr">data</span>?: <span class="built_in">any</span>, <span class="attr">config</span>?: <span class="title class_">AxiosRequestConfig</span>): <span class="title class_">Promise</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> service.<span class="title function_">post</span>(url, data, config);</span><br><span class="line">    &#125;,</span><br><span class="line">    put&lt;T&gt;(<span class="attr">url</span>: <span class="built_in">string</span>, <span class="attr">data</span>?: <span class="built_in">any</span>, <span class="attr">config</span>?: <span class="title class_">AxiosRequestConfig</span>): <span class="title class_">Promise</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> service.<span class="title function_">put</span>(url, data, config);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">delete</span>&lt;T&gt;(<span class="attr">url</span>: <span class="built_in">string</span>, <span class="attr">config</span>?: <span class="title class_">AxiosRequestConfig</span>): <span class="title class_">Promise</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> service.<span class="title function_">delete</span>(url, config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> request;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>使用封装后的 Axios , 在组件中引入封装好的 request 对象，并使用其中的方法发送请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;button @click=&quot;fetchData&quot;&gt;获取数据&lt;/button&gt;</span><br><span class="line">        &lt;p v-if=&quot;data&quot;&gt;&#123;&#123; data &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line">import request from &#x27;./http&#x27;;</span><br><span class="line"></span><br><span class="line">const data = ref(&#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">const fetchData = async () =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        const result = await request.get&lt;&#123; name: string &#125;&gt;(&#x27;/api/data&#x27;);</span><br><span class="line">        data.value = result.name;</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">        console.error(&#x27;请求出错:&#x27;, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><ul><li><p>开发模式下可以使用代理服务器</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title function_">react</span>()],</span><br><span class="line">  <span class="attr">server</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="comment">// 配置代理规则</span></span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://api.example.com&#x27;</span>,</span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">rewrite</span>: <span class="function">(<span class="params">path</span>) =&gt;</span> path.<span class="title function_">replace</span>(<span class="regexp">/^\/api/</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&#x27;/uploads&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://uploads.example.com&#x27;</span>,</span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">rewrite</span>: <span class="function">(<span class="params">path</span>) =&gt;</span> path.<span class="title function_">replace</span>(<span class="regexp">/^\/uploads/</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="优化打包"><a href="#优化打包" class="headerlink" title="优化打包"></a>优化打包</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="comment">// 输出目录，默认为 dist</span></span><br><span class="line">    <span class="attr">outDir</span>: <span class="string">&#x27;dist&#x27;</span>,</span><br><span class="line">    <span class="comment">// 静态资源存放目录，默认为 assets</span></span><br><span class="line">    <span class="attr">assetsDir</span>: <span class="string">&#x27;assets&#x27;</span>,</span><br><span class="line">    <span class="comment">// 小于此阈值的导入或引用资源将内联为 base64 编码，以减少 HTTP 请求。设置为 0 可以完全禁用此项</span></span><br><span class="line">    <span class="attr">assetsInlineLimit</span>: <span class="number">4096</span>,</span><br><span class="line">    <span class="comment">// 启用/禁用 CSS 代码分割。如果禁用，所有 CSS 文件将被合并为一个文件</span></span><br><span class="line">    <span class="attr">cssCodeSplit</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 构建后是否生成 source map 文件</span></span><br><span class="line">    <span class="attr">sourcemap</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 自定义底层的 Rollup 打包配置</span></span><br><span class="line">    <span class="attr">rollupOptions</span>: &#123;</span><br><span class="line">      <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">// 自定义入口 chunk 的文件名</span></span><br><span class="line">        <span class="attr">entryFileNames</span>: <span class="string">`assets/[name].[hash].js`</span>,</span><br><span class="line">        <span class="comment">// 自定义块文件的文件名</span></span><br><span class="line">        <span class="attr">chunkFileNames</span>: <span class="string">`assets/[name].[hash].js`</span>,</span><br><span class="line">        <span class="comment">// 自定义静态资源文件名</span></span><br><span class="line">        <span class="attr">assetFileNames</span>: <span class="string">`assets/[name].[hash].[ext]`</span>,</span><br><span class="line">        <span class="comment">// 手动配置分包策略</span></span><br><span class="line">        <span class="title function_">manualChunks</span>(<span class="params">id</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (id.<span class="title function_">includes</span>(<span class="string">&#x27;node_modules&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;vendor&#x27;</span>; <span class="comment">// 将所有来自 node_modules 的模块打包到一个名为 vendor 的文件中</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 启用/禁用 brotli 压缩大小报告。压缩大型输出文件可能会很慢，因此禁用此功能可能会提高大型项目的构建性能</span></span><br><span class="line">    <span class="attr">brotliSize</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 规定触发警告的 chunk 大小，默认是 500kb</span></span><br><span class="line">    <span class="attr">chunkSizeWarningLimit</span>: <span class="number">500</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><script>var description="通过这篇文章的学习，可以掌握如何高效地配置Vite项目，简化代码管理，并利用插件工具提升开发效率。每一步都需要实际操作以加深理解，并结合个人项目需求进行应用。"</script>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由的使用</title>
      <link href="/p/8448ab29.html"/>
      <url>/p/8448ab29.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="1-页面刷新后变404"><a href="#1-页面刷新后变404" class="headerlink" title="1. 页面刷新后变404"></a>1. <strong>页面刷新后变404</strong></h3><p>  这种现象通常是因为：</p><ul><li><p><strong>服务端未配置支持 History 模式的功能</strong>：在部署到服务器之前，服务端（如Nginx、Express）可能没有启用对历史路径的支持。</p></li><li><p><strong>路由跳转逻辑有误</strong>：某些路由逻辑可能需要依赖于用户的行为（如滑块操作），但页面刷新可能导致这些逻辑失效。</p></li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h4><ol><li><p>确保服务端支持 History 模式的功能：</p><ul><li>如果使用Nginx，可以参考官方文档配置支持History fallback：[Nginx History Fallback Configuration](<a href="https://docs.nginx.org/en/stable">https://docs.nginx.org/en/stable</a> brewed&#x2F;history-fallback.html)</li><li>如果使用Express，可以安装<code>connect-history-api-fallback</code>中间件并激活它：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> connectHistoryFallback = <span class="built_in">require</span>(<span class="string">&#x27;connect-history-api-fallback&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    <span class="title function_">connectHistoryFallback</span>(app);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server running on http://localhost:3000&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>确保所有路径在服务端都已正确配置：</p><ul><li>检查根目录（如<code>public</code>或<code>assets</code>）中是否包含所有必要的支持文件。</li><li>配置<code>publicPath</code>和<code>base</code>，确保与项目根目录一致。</li></ul></li></ol><hr><h3 id="2-部分路由显示为白色"><a href="#2-部分路由显示为白色" class="headerlink" title="2. 部分路由显示为白色"></a>2. <strong>部分路由显示为白色</strong></h3><p>  这种现象通常是因为：</p><ul><li><p><strong>静态资源路径错误</strong>：路由配置的公共路径（如<code>./public</code>）未正确指向项目根目录中的资源。</p></li><li><p><strong>Nginx或Vite配置错误</strong>：服务器端没有正确配置支持二级或以上路由的结构。</p></li></ul><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h4><ol><li><p>如果使用Vite：</p><ul><li>确保项目中存在一个根目录，且在<code>config/vite.js</code>中将<code>publicPath</code>和<code>base</code>设置为根目录（例如<code>./</code>）。</li><li>检查是否有以下配置：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="attr">routes</span>: &#123;</span><br><span class="line">        <span class="attr">router</span>: &#123;</span><br><span class="line">            <span class="attr">publicPath</span>: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">            <span class="attr">base</span>: <span class="string">&#x27;/app&#x27;</span>,</span><br><span class="line">            <span class="attr">history</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 其他路由配置...</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果使用Nginx：</p><ul><li>确保项目根目录下存在以下文件夹：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public/</span><br><span class="line">assets/</span><br></pre></td></tr></table></figure></li><li>配置<code>server.conf</code>中的相关参数：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">root</span> /；</span><br><span class="line">    include ../config/variables.<span class="string">&quot;&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="3-检查根目录是否存在"><a href="#3-检查根目录是否存在" class="headerlink" title="3. 检查根目录是否存在"></a>3. <strong>检查根目录是否存在</strong></h3><p>  如果项目中没有配置根目录，或根目录下缺少必要的支持文件（如<code>index.html</code>、<code>style.css</code>等），可能导致部分路由无法加载。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h4><ul><li><p>创建一个包含所有静态资源的根目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">project_root/</span><br><span class="line">  public/</span><br><span class="line">    index.html</span><br><span class="line">    style.css</span><br><span class="line">    // 其他静态资源...</span><br><span class="line">  assets/</span><br><span class="line">    images/</span><br><span class="line">      header.jpg</span><br><span class="line">    js/</span><br><span class="line">      main.js</span><br><span class="line">        // ...</span><br><span class="line">  // 非静态资源（如JavaScript、CSS）</span><br></pre></td></tr></table></figure></li><li><p>在项目根目录中运行以下命令创建根目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p project_root/public &amp;&amp; \</span><br><span class="line">       <span class="built_in">mkdir</span> -p project_root/assets &amp;&amp; \</span><br><span class="line">       <span class="built_in">mkdir</span> -p project_root/assets/images</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="4-环境变量配置"><a href="#4-环境变量配置" class="headerlink" title="4. 环境变量配置"></a>4. <strong>环境变量配置</strong></h3><p>  如果使用Vite或Vue CLI，确保在开发环境中正确配置了相关环境变量。</p><h4 id="示例（Vite）"><a href="#示例（Vite）" class="headerlink" title="示例（Vite）"></a><strong>示例（Vite）</strong></h4>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// config/vite.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vite = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">router</span>: &#123;</span><br><span class="line">        <span class="attr">publicPath</span>: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">        <span class="attr">base</span>: <span class="string">&#x27;/app&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="5-验证服务端配置"><a href="#5-验证服务端配置" class="headerlink" title="5. 验证服务端配置"></a>5. <strong>验证服务端配置</strong></h3><p>  在部署到服务器之前，确保所有相关参数已正确配置：</p><ul><li>如果使用Nginx，检查<code>nginx.conf</code>中是否有以下设置：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 历史路径支持</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">root</span> /；</span><br><span class="line">    include ../config/variables.<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 允许历史路径请求</span></span><br><span class="line"><span class="string">location /admin-history &#123;</span></span><br><span class="line"><span class="string">    allow historical;</span></span><br><span class="line"><span class="string">    expires 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">location /public &#123;</span></span><br><span class="line"><span class="string">    allow historical;</span></span><br><span class="line"><span class="string">    expires 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li><li>如果使用Express，确保<code>connect-history-fallback</code>中间件已正确激活。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  要解决这些问题：</p><ol><li><p>确保根目录下存在所有静态资源。</p></li><li><p>配置Nginx或Vite的<code>publicPath</code>和<code>base</code>参数为项目根目录。</p></li><li><p>确保服务端支持 History 模式的功能（如有）已正确启用。</p></li></ol><h2 id="如果问题仍然存在，可以提供更多具体信息（如错误日志），以便进一步诊断。date-2025-01-20-00-14-28"><a href="#如果问题仍然存在，可以提供更多具体信息（如错误日志），以便进一步诊断。date-2025-01-20-00-14-28" class="headerlink" title="  如果问题仍然存在，可以提供更多具体信息（如错误日志），以便进一步诊断。date: 2025-01-20 00:14:28"></a>  如果问题仍然存在，可以提供更多具体信息（如错误日志），以便进一步诊断。<br>date: 2025-01-20 00:14:28</h2><!-- more --><p>在传统的 Web 开发过程中，当需要实现多个站内页面时，要写很多个 HTML 页面，然后通过 <code>&lt;a /&gt;</code> 标签来实现互相跳转。</p><p>在如今工程化模式下的前端开发，像 Vue 工程，可以轻松实现只用一个 HTML 文件就完成多个站内页面渲染、跳转的功能，这就是路由。</p><h2 id="路由的目录结构"><a href="#路由的目录结构" class="headerlink" title="路由的目录结构"></a>路由的目录结构</h2><p>Vue 3 引入路由的方式和 Vue 2 一样，路由的管理也是放在 src&#x2F;router 这个目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">│ <span class="comment"># 路由目录</span></span><br><span class="line">├─router</span><br><span class="line">│   <span class="comment"># 路由入口文件</span></span><br><span class="line">├───index.ts</span><br><span class="line">│   <span class="comment"># 路由配置，如果路由很多，可以再拆分模块文件</span></span><br><span class="line">├───routes.ts</span><br><span class="line">│ <span class="comment"># 项目入口文件</span></span><br><span class="line">└─main.ts</span><br></pre></td></tr></table></figure><p>其中 index.ts 是路由的入口文件，如果路由很少，那么可以只维护在这个文件里，但对复杂项目来说，往往需要配置二级、三级路由，把逻辑和配置都放到一个文件的话太臃肿了。</p><p>所以如果项目稍微复杂一些，可以像上面这个结构一样拆出两个文件： index.ts 和 routes.ts ，在 routes.ts 里维护路由树的结构，在 index.ts 导入路由树结构并激活路由，同时可以在该文件里配置路由钩子。</p><p>如果项目更加复杂，例如做一个 Admin 后台，可以按照业务模块，再把 routes 拆分得更细，例如 game.ts &#x2F; member.ts &#x2F; order.ts 等业务模块，再统一导入到 index.ts 文件里。</p><blockquote><p>TIP 需要注意与 Vue 3 配套的路由版本： vue-router 4.x 以上才可以正确适配项目。</p></blockquote><h2 id="在项目里引入路由"><a href="#在项目里引入路由" class="headerlink" title="在项目里引入路由"></a>在项目里引入路由</h2><p>不管是 Vue 2 还是 Vue 3 ，引入路由都是在 src&#x2F;router&#x2F;index.ts 文件里，但是版本升级带来的变化很大，由于本书关于 Vue 3 都是使用 TypeScript ，所以这里只做一个 TypeScript 的变化对比。</p><blockquote><p>TIP 下文可能会出现多次 <code>import.meta.env.BASE_URL</code> 这个变量，它是由 Vite 提供的环境变量，详见 Vite 官网关于 <a href="https://cn.vitejs.dev/guide/env-and-mode.html#env-variables">环境变量</a> 的说明。</p></blockquote><p>使用其他构建工具请自行替换为对应构建工具提供的环境变量，例如使用 @vue&#x2F;cli 创建的项目：因为基于 Webpack ，所以使用的是 <code>process.env.BASE_URL</code> 。</p><h3 id="回顾-Vue-2"><a href="#回顾-Vue-2" class="headerlink" title="回顾 Vue 2"></a>回顾 Vue 2</h3><p>Vue 2 的引入方式如下（其中 <code>RouteConfig</code> 是路由项目的 TS 类型）。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">RouteConfig</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteConfig</span>&gt; = [</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="attr">base</span>: <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">BASE_URL</span>,</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>里面一些选项的功能说明：</p><p><code>routes</code> 是路由树的配置，当项目的路由很多时可以集中到 routes.ts 管理，然后再 <code>import</code> 进来。</p><p><code>mode</code> 决定访问路径模式，可配置为 <code>hash</code> 或者 <code>history</code> ， Hash 模式是 <code>http://abc.com/#/home</code> 这种带 <code>#</code> 号的地址，支持所有浏览器， History 模式是 <code>http://abc.com/home</code> 这样不带 <code>#</code> 号的，不仅美观，而且体验更好，但需要服务端做一些配置支持），也只对主流浏览器提供支持。</p><p><code>base</code> 是 History 模式在进行路由切换时的基础路径，默认是 <code>/</code> 根目录，如果的项目不是部署在根目录下，而是二级目录、三级目录等多级目录，就必须指定这个 base ，否则路由切换会有问题。</p><h3 id="了解-Vue-3"><a href="#了解-Vue-3" class="headerlink" title="了解 Vue 3"></a>了解 Vue 3</h3><p>Vue 3 的引入方式如下（其中 <code>RouteRecordRaw</code> 是路由项目的 TS 类型）。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">RouteRecordRaw</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecordRaw</span>&gt; = [</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">BASE_URL</span>),</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>在 Vue 3 （也就是 vue-router 4.x） 里，路由简化了一些配置项，其中 <code>routes</code> 和 Vue 2 一样，是路由树的配置。</p><p>但是 <code>history</code> 和 Vue 2 有所不同，在 Vue 3 ，使用 <code>history</code> 来代替 Vue 2 的 <code>mode</code> ，但功能是一样的，也用于决定访问路径模式是 Hash 模式 还是 History 模式，同时合并了 Vue 2 （也就是 vue-router 3.x） 的 <code>base</code> 选项作为模式函数的入参。</p><p>和在使用 Vue 2 的时候一样， Vue 3 也可以配置一些额外的路由选项，比如：指定 <code>router-link</code> 为当前激活的路由所匹配的 <code>className</code> :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">BASE_URL</span>),</span><br><span class="line">  <span class="attr">linkActiveClass</span>: <span class="string">&#x27;cur&#x27;</span>,</span><br><span class="line">  <span class="attr">linkExactActiveClass</span>: <span class="string">&#x27;cur&#x27;</span>,</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>更多的配置项可以参考 Vue Router 官网的 <a href="https://router.vuejs.org/zh/api/">API 参考</a> 一章。</p><h2 id="路由树的配置"><a href="#路由树的配置" class="headerlink" title="路由树的配置"></a>路由树的配置</h2><p>在 引入路由部分有说到，当项目的路由很多的时候，文件会变得非常长，难以维护，这个时候可以集中到 routes.ts 或者更多的模块化文件管理，然后再 <code>import</code> 到 index.ts 里。</p><p>暂且把 routes.ts 这个文件称为 “路由树” ，因为它像一棵大树一样，不仅可以以一级路由为树干去生长，还可以添加二级、三级等多级路由来开枝散叶，下面来看看 routes.ts 应该怎么写。</p><h3 id="基础格式"><a href="#基础格式" class="headerlink" title="基础格式"></a>基础格式</h3><p>在 TypeScript 里，路由文件的基础格式由三个部分组成：类型声明、数组结构、模块导出。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/router/routes.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 TypeScript 时需要导入路由项目的类型声明</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">RouteRecordRaw</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用路由项目类型声明一个路由数组</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecordRaw</span>&gt; = [</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将路由数组导出给其他模块使用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> routes</span><br></pre></td></tr></table></figure><p>之后就可以在 index.ts 里导入使用了。</p><p>那么里面的路由数组又是怎么写呢？这里就涉及到了 一级路由和 多级路由 的编写。</p><h3 id="公共基础路径"><a href="#公共基础路径" class="headerlink" title="公共基础路径"></a>公共基础路径</h3><p>在配置路由之前，需要先了解 “公共基础路径” 的概念，在讲解使用 Vite 等工具创建项目时，都提到了一个项目配置的管理，以 Vite 项目的配置文件 <code>vite.config.ts</code> 为例，里面有一个选项base ，其实就是用来控制路由的公共基础路径，那么它有什么用呢？</p><p><code>base</code> 的默认值是 <code>/</code>，也就是说，如果不配置它，那么所有的资源文件都是从域名根目录读取，如果项目部署在域名根目录那当然好，但是如果不是呢？那么就必须来配置它了。</p><p>配置很简单，只要把项目要上线的最终地址，去掉域名，剩下的那部分就是 <code>base</code> 的值。假设项目是部署在 <code>https://example.com/vue3/</code> ，那么 <code>base</code> 就可以设置为 <code>/vue3/</code>。</p><blockquote><p>TIP 如果路由只有一级，那么 <code>base</code> 也可以设置为相对路径 <code>./</code>，这样可以把项目部署到任意地方。</p><p>如果路由不止一级，那么请准确地指定 <code>base</code>，并且确保是以 <code>/</code> 开头并以 <code>/</code> 结尾，例如 <code>/foo/</code> 。</p></blockquote><h3 id="一级路由"><a href="#一级路由" class="headerlink" title="一级路由"></a>一级路由</h3><p>一级路由，顾名思义，就是在项目地址后面只有一级 Path ，比如 <code>https://example.com/home</code> ，这里的 <code>home</code> 就是一级路由。</p><p>来看一下最基本的路由配置应该包含哪些字段：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecordRaw</span>&gt; = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@views/home.vue&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>其中 <code>path</code> 是路由的访问路径，像上面说的，如果的域名是 <code>https://example.com</code>， 配置为 <code>/home</code>，那么访问路径就是 <code>https://example.com/home</code></p><blockquote><p>TIP一级路由的 path 都必须是以 <code>/</code> 开头，比如： <code>/home</code>、<code>/setting</code>；</p></blockquote><ul><li><p>如果的项目首页不想带上 <code>home</code> 之类的尾巴，只想要通过 <code>https://example.com/</code> 这样的域名直达 ，其实也是配置一级路由，把路由的 <code>path</code> 指定为 <code>/</code> 即可。</p></li><li><p><code>name</code> 是路由的名称，非必填，但是一般都会配置上去，这样可以很方便地用 <code>name</code> 来代替 <code>path</code> 实现路由的跳转，例如有时候开发环境和生产环境的路径不一致，或者说路径变更，通过 <code>name</code> 无需调整，但如果通过 <code>path</code>，可能就要修改很多文件里面的链接跳转目标了。</p></li><li><p><code>component</code> 是路由的模板文件，指向一个 vue 组件，用于指定路由在浏览器端的视图渲染，这里有两种方式来指定使用哪个组件：</p></li></ul><h4 id="同步组件"><a href="#同步组件" class="headerlink" title="同步组件"></a>同步组件</h4><p>字段 <code>component</code> 接收一个变量，变量的值就是对应的模板组件。</p><p>在打包的时候，组件的所有代码都会被打包到一个文件里，对于大项目来说，这种方式的首屏加载是个灾难，要面对文件过大导致等待时间变长的问题。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;@views/home.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecordRaw</span>&gt; = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Home</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>所以现在都推荐使用第二种方式，可以实现 <strong>路由懒加载</strong> 。</p><h4 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h4><p>字段 <code>component</code> 接收一个函数，在 return 的时候返回模板组件，同时组件里的代码在打包的时候都会生成独立的文件，并在访问到对应路由的时候按需引入。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecordRaw</span>&gt; = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@views/home.vue&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>关于这部分的更多说明，可以查看路由懒加载]。</p><h3 id="多级路由"><a href="#多级路由" class="headerlink" title="多级路由"></a>多级路由</h3><p>在 Vue 路由生态里，支持配置二级、三级、四级等多级路由，理论上没有上限，实际业务中用到的级数通常是三级到四级。</p><p>比如做一个美食类网站，打算在 “中餐” 大分类下配置一个 “饺子” 栏目，那么地址就是：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://example.com/chinese-food/dumplings</span><br></pre></td></tr></table></figure><p>这种情况下，中餐 <code>chinese-food</code> 就是一级路由，饺子 <code>dumplings</code> 就是二级路由。</p><p>如果想再细化一下，“饺子” 下面再增加一个 “韭菜” 、“白菜” 等不同馅料的子分类：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://example.com/chinese-food/dumplings/chives</span><br></pre></td></tr></table></figure><p>这里的韭菜 <code>chives</code> 就是饺子 <code>dumplings</code> 的子路由，也就是三级路由。</p><p>在了解了子路由的概念后，来看一下具体如何配置以及注意事项。</p><p>父子路由的关系，都是严格按照 JSON 的层级关系，子路由的信息配置到父级的 <code>children</code> 数组里面，孙路由也是按照一样的格式，配置到子路由的 <code>children</code> 里。</p><p>这是一个简单的子路由示范：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecordRaw</span>&gt; = [</span><br><span class="line">  <span class="comment">// 注意：这里是一级路由</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/lv1&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;lv1&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@views/lv1.vue&#x27;</span>),</span><br><span class="line">    <span class="comment">// 注意：这里是二级路由，在 `path` 的前面没有 `/`</span></span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;lv2&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;lv2&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@views/lv2.vue&#x27;</span>),</span><br><span class="line">        <span class="comment">// 注意：这里是三级路由，在 `path` 的前面没有 `/`</span></span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;lv3&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;lv3&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@views/lv3.vue&#x27;</span>),</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>上面这个配置，最终三级路由的访问地址如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://example.com/lv1/lv2/lv3</span><br></pre></td></tr></table></figure><p>可以看到在注释里提示了二级、三级路由的 <code>path</code> 字段前面没有 <code>/</code> ，这样路径前面才会有其父级路由的 <code>path</code> 以体现其层级关系，否则会从根目录开始。</p><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p>在上面提过，路由在配置 <code>同步组件</code>的时候，构建出来的文件都集中在一起，大的项目的文件会变得非常大，影响页面加载。</p><p>所以 Vue 在 Webpack 的代码分割功能的基础上，推出了<code>异步组件</code>，可以把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样按需载入，很方便地实现路由组件的懒加载。</p><p>在这一段配置里面：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecordRaw</span>&gt; = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@views/home.vue&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>起到懒加载配置作用的就是 <code>component</code> 接收的值 <code>() =&gt; import(&#39;@views/home.vue&#39;)</code> ，其中 <code>@views/home.vue</code> 就是路由的组件。</p><p>在命令行运行 <code>npm run build</code> 打包构建后，会看到控制台输出的打包结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">❯ npm run build</span><br><span class="line"></span><br><span class="line">&gt; hello-vue3@0.0.0 build</span><br><span class="line">&gt; vue-tsc --noEmit &amp;&amp; vite build</span><br><span class="line"></span><br><span class="line">vite v2.9.15 building <span class="keyword">for</span> production...</span><br><span class="line">✓ 42 modules transformed.</span><br><span class="line">dist/index.html                       0.42 KiB</span><br><span class="line">dist/assets/home.03ad1823.js          0.65 KiB / gzip: 0.42 KiB</span><br><span class="line">dist/assets/HelloWorld.1322d484.js    1.88 KiB / gzip: 0.96 KiB</span><br><span class="line">dist/assets/about.c2af6d65.js         0.64 KiB / gzip: 0.41 KiB</span><br><span class="line">dist/assets/login.e9d1d9f9.js         0.65 KiB / gzip: 0.42 KiB</span><br><span class="line">dist/assets/index.60726771.css        0.47 KiB / gzip: 0.29 KiB</span><br><span class="line">dist/assets/login.bef803dc.css        0.12 KiB / gzip: 0.10 KiB</span><br><span class="line">dist/assets/HelloWorld.b2638077.css   0.38 KiB / gzip: 0.19 KiB</span><br><span class="line">dist/assets/home.ea56cd55.css         0.12 KiB / gzip: 0.10 KiB</span><br><span class="line">dist/assets/about.a0917080.css        0.12 KiB / gzip: 0.10 KiB</span><br><span class="line">dist/assets/index.19d6fb3b.js         79.94 KiB / gzip: 31.71 KiB</span><br></pre></td></tr></table></figure><p>可以看到路由文件都按照 views 目录下的路由组件和 components 目录下的组件命名，输出了对应的 JS 文件和 CSS 文件，项目部署后， Vue 只会根据当前路由加载需要的文件，其他文件只做预加载，对于大型项目的访问体验非常友好。</p><p>而如果不使用路由懒加载，打包出来的文件是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">❯ npm run build</span><br><span class="line"></span><br><span class="line">&gt; hello-vue3@0.0.0 build</span><br><span class="line">&gt; vue-tsc --noEmit &amp;&amp; vite build</span><br><span class="line"></span><br><span class="line">vite v2.9.15 building <span class="keyword">for</span> production...</span><br><span class="line">✓ 41 modules transformed.</span><br><span class="line">dist/index.html                  0.42 KiB</span><br><span class="line">dist/assets/index.67b1ee4f.css   1.22 KiB / gzip: 0.49 KiB</span><br><span class="line">dist/assets/index.f758ee53.js    78.85 KiB / gzip: 31.05 KiB</span><br></pre></td></tr></table></figure><p>可以看到所有的组件都被打包成了一个很大的 JS 文件和 CSS 文件，没有进行代码分割，对大型项目来说，这种方式打包出来的文件可能会有好几兆，首屏加载的速度可想而知。</p><h2 id="路由的渲染"><a href="#路由的渲染" class="headerlink" title="路由的渲染"></a>路由的渲染</h2><p>所有路由组件，要在访问后进行渲染，都必须在父级组件里带有 <code>&lt;router-view /&gt;</code> 标签。</p><p><code>&lt;router-view /&gt;</code> 在哪里，路由组件的代码就渲染在哪个节点上，一级路由的父级组件，就是 src&#x2F;App.vue 这个根组件。</p><p>其中最基础的配置就是 <code>&lt;template /&gt;</code> 里面直接就是写一个 <code>&lt;router-view /&gt;</code> ，整个页面就是路由组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;router-view /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>如果站点带有全局公共组件，比如有全站统一的页头、页脚，只有中间区域才是路由，那么可以这样配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 全局页头 --&gt;</span><br><span class="line">  &lt;Header /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 路由 --&gt;</span><br><span class="line">  &lt;router-view /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 全局页脚 --&gt;</span><br><span class="line">  &lt;Footer /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>如果有一部分路由带公共组件，一部分没有，比如大部分页面都需要有侧边栏，但登录页、注册页不需要，就可以这么处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 登录 --&gt;</span><br><span class="line">  &lt;Login v-if=&quot;route.name === &#x27;login&#x27;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 注册 --&gt;</span><br><span class="line">  &lt;Register v-else-if=&quot;route.name === &#x27;register&#x27;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 带有侧边栏的其他路由 --&gt;</span><br><span class="line">  &lt;div v-else&gt;</span><br><span class="line">    &lt;!-- 固定在左侧的侧边栏 --&gt;</span><br><span class="line">    &lt;Sidebar /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 路由 --&gt;</span><br><span class="line">    &lt;router-view /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>也可以通过路由元信息来管理这些规则。</p><h2 id="使用-route-获取路由信息"><a href="#使用-route-获取路由信息" class="headerlink" title="使用 route 获取路由信息"></a>使用 route 获取路由信息</h2><p>和 Vue 2 可以直接在组件里使用 <code>this.$route</code> 来获取当前路由信息不同，在 Vue 3 的组件里，Vue 实例既没有了 <code>this</code>，也没有了 <code>$route</code>。</p><p>要牢记一个事情就是，Vue 3 用啥都要导入，所以获取当前路由信息的正确用法是先导入路由 API ：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRoute &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br></pre></td></tr></table></figure><p>再在 <code>setup</code> 里定义一个变量来获取当前路由：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br></pre></td></tr></table></figure><p>接下来就可以通过定义好的变量 <code>route</code> 去获取当前路由信息了。</p><p>当然，如果要在 <code>&lt;template /&gt;</code> 里使用路由，记得把 <code>route</code> 在 <code>setup</code> 里 return 出去。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取路由名称</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(route.<span class="property">name</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取路由参数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(route.<span class="property">params</span>.<span class="property">id</span>)</span><br></pre></td></tr></table></figure><p>Vue 3 的 <code>route</code> 和 Vue 2 的用法基本一致，日常使用应该很快能上手。</p><blockquote><p>WARNING </p><p>但是 Vue 3 的新路由也有一些小变化，有一些属性被移除了，比如之前获取父级路由信息常用的 <code>parent</code> 属性，现在已经没有了，可以在 Vue Router 官网的 <a href="https://router.vuejs.org/zh/guide/migration/">从 Vue2 迁移</a> 一章查看所有破坏性变化。</p></blockquote><p>类似被移除的 <code>parent</code> ，如果要获取父级路由信息（比如在做面包屑功能的时候），可以改成下面这样，手动指定倒数第二个为父级信息：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取路由记录</span></span><br><span class="line"><span class="keyword">const</span> matched = route.<span class="property">matched</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取该记录的路由个数</span></span><br><span class="line"><span class="keyword">const</span> max = matched.<span class="property">length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取倒数第二个路由（也就是当前路由的父级路由）</span></span><br><span class="line"><span class="keyword">const</span> parentRoute = matched[max - <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>如果有配置父级路由，那么 <code>parentRoute</code> 就是父级路由信息，否则会返回 <code>undefined</code> 。</p><h2 id="使用-router-操作路由"><a href="#使用-router-操作路由" class="headerlink" title="使用 router 操作路由"></a>使用 router 操作路由</h2><p>和 <code>route</code> 一样，在 Vue 3 也不能再使用 <code>this.$router</code> ，也必须通过导入路由 API 来使用：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br></pre></td></tr></table></figure><p>和 <code>useRoute</code> 一样， <code>useRouter</code> 也是一个函数，需要在 <code>setup</code> 里定义一个变量来获取路由信息。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span><br></pre></td></tr></table></figure><p>接下来就可以通过定义好的变量 <code>router</code> 去操作路由了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳转首页</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回上一页</span></span><br><span class="line">router.<span class="title function_">back</span>()</span><br></pre></td></tr></table></figure><h2 id="使用-router-link-标签跳转"><a href="#使用-router-link-标签跳转" class="headerlink" title="使用 router-link 标签跳转"></a>使用 router-link 标签跳转</h2><p><code>router-link</code> 是一个全局组件，可直接在 <code>&lt;template /&gt;</code> 里直接使用，无需导入，基础的用法在 Vue 2 和 Vue 3 里是一样。</p><p>默认会被转换为一个 <code>a</code> 标签，对比写死的 <code>&lt;a href=&quot;...&quot;&gt;</code> ，使用 <code>router-link</code> 会更加灵活。</p><h3 id="基础跳转"><a href="#基础跳转" class="headerlink" title="基础跳转"></a>基础跳转</h3><p>最基础的用法就是把它当成一个 <code>target=&quot;_self&quot;</code> 的 <code>a</code> 标签使用，但无需重新刷新页面，因为是路由跳转，它的体验和使用 <code>router</code> 去进行路由导航的效果完全一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;router-link to=&quot;/home&quot;&gt;首页&lt;/router-link&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>等价于 <code>router</code> 的 <code>push</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以写个 <code>&lt;div /&gt;</code> 标签绑定 Click 事件达到 <code>router-link</code> 的效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div</span><br><span class="line">    class=&quot;link&quot;</span><br><span class="line">    @click=&quot;</span><br><span class="line">      router.push(&#123;</span><br><span class="line">        name: &#x27;home&#x27;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;span&gt;首页&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>了解这种使用对比，对学习下文其他跳转方式会有帮助。</p><h3 id="带参数的跳转"><a href="#带参数的跳转" class="headerlink" title="带参数的跳转"></a>带参数的跳转</h3><p>使用 <code>router</code> 的时候，可以轻松地带上参数去那些有 ID 的内容页、用户资料页、栏目列表页等等。</p><p>比如要访问一篇文章 <code>https://example.com/article/123</code> ，用 <code>push</code> 的写法是：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;article&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">123</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>同理，从基础跳转的写法，很容易就能猜到在 <code>router-link</code> 里应该怎么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;router-link</span><br><span class="line">    class=&quot;link&quot;</span><br><span class="line">    :to=&quot;&#123;</span><br><span class="line">      name: &#x27;article&#x27;,</span><br><span class="line">      params: &#123;</span><br><span class="line">        id: 123,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    这是文章的标题</span><br><span class="line">  &lt;/router-link&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="不生成-a-标签"><a href="#不生成-a-标签" class="headerlink" title="不生成 a 标签"></a>不生成 a 标签</h3><p><code>router-link</code> 默认被转换为一个 <code>a</code> 标签，但根据业务场景，也可以把它指定为生成其他标签，比如 <code>span</code> 、 <code>div</code> 、 <code>li</code> 等等，这些标签因为不具备 <code>href</code> 属性，所以在跳转时都是通过 Click 事件去执行。</p><p>在 Vue 2 ，指定为其他标签只需要一个 <code>tag</code> 属性即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;router-link tag=&quot;span&quot; to=&quot;/home&quot;&gt;首页&lt;/router-link&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>但在 Vue 3 ，<code>tag</code> 属性已被移除，需要通过 <code>custom</code> 和 <code>v-slot</code> 的配合将其渲染为其他标签。</p><p>比如要渲染为一个带有路由导航功能的其他标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;router-link to=&quot;/home&quot; custom v-slot=&quot;&#123; navigate &#125;&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;link&quot; @click=&quot;navigate&quot;&gt; 首页 &lt;/span&gt;</span><br><span class="line">  &lt;/router-link&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>渲染后就是一个普通的 <code>&lt;span /&gt;</code> 标签，当该标签被点击的时候，会通过路由的导航跳转到指定的路由页：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 渲染后的标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;link&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于这两个属性的参数说明如下：</p><ol><li><code>custom</code> ，一个布尔值，用于控制是否需要渲染为 <code>a</code> 标签，当不包含 <code>custom</code> 或者把 <code>custom</code> 设置为 <code>false</code> 时，则依然使用 <code>a</code> 标签渲染。</li><li><code>v-slot</code> 是一个对象，用来决定标签的行为，它包含了：</li></ol><table><thead><tr><th align="left">字段</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">href</td><td align="left">解析后的 URL，将会作为一个 <code>a</code> 元素的 <code>href</code> 属性</td></tr><tr><td align="left">route</td><td align="left">解析后的规范化的地址</td></tr><tr><td align="left">navigate</td><td align="left">触发导航的函数，会在必要时自动阻止事件，和 <code>router-link</code> 同理</td></tr><tr><td align="left">isActive</td><td align="left">如果需要应用激活的 <code>class</code> 则为 <code>true</code>，允许应用一个任意的 <code>class</code></td></tr><tr><td align="left">isExactActive</td><td align="left">如果需要应用精确激活的 <code>class</code> 则为 <code>true</code>，允许应用一个任意的 <code>class</code></td></tr></tbody></table><p>一般来说，<code>v-slot</code> 必备的只有 <code>navigate</code> ，用来绑定元素的点击事件，否则点击元素后不会有任何反应，其他的可以根据实际需求来添加。</p><blockquote><p>TIP 要渲染为非 <code>a</code> 标签，切记两个点：</p><ol><li><code>router-link</code> 必须带上 <code>custom</code> 和 <code>v-slot</code> 属性</li><li>最终要渲染的标签，写在 <code>router-link</code> 里，包括对应的 <code>className</code> 和点击事件</li></ol></blockquote><h2 id="在独立-TS-JS-文件里使用路由"><a href="#在独立-TS-JS-文件里使用路由" class="headerlink" title="在独立 TS&#x2F;JS 文件里使用路由"></a>在独立 TS&#x2F;JS 文件里使用路由</h2><p>除了可以在 <code>.vue</code> 文件里使用路由之外，也可以在单独的 <code>.ts</code>、<code>.js</code> 里使用。</p><p>比如要做一个带有用户系统的站点，登录的相关代码除了在 <code>login.vue</code> 里运用外，在注册页面 <code>register.vue</code>，用户注册成功还要帮用户执行一次自动登录。</p><p>登录完成还要记录用户的登录信息、 Token 、过期时间等等，有不少数据要做处理，以及需要帮助用户自动切去登录前的页面等行为，这是两个不同的组件，如果写两次几乎一样的代码，会大大提高维护成本。</p><p>这种情况下就可以通过抽离核心代码，封装成一个 <code>login.ts</code> 文件，在这个独立的 <code>ts</code> 文件里去操作路由。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入路由</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行路由跳转</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="路由元信息配置"><a href="#路由元信息配置" class="headerlink" title="路由元信息配置"></a>路由元信息配置</h2><p>有时候项目需要一些个性化配置，比如：</p><ol><li>给予每个路由独立的标题；</li><li>管理后台的路由，部分页面需要限制一些访问权限；</li><li>通过路由来自动生成侧边栏、面包屑；</li><li>部分路由的生命周期需要做缓存（ Keep Alive ）;</li><li>其他更多业务场景…</li></ol><p>无需维护很多套配置，在定义路由树的时候可以配置 <code>meta</code> 字段，比如下面就是包含了多种元信息的一个登录路由：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecordRaw</span>&gt; = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;login&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@views/login.vue&#x27;</span>),</span><br><span class="line">    <span class="attr">meta</span>: &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;登录&#x27;</span>,</span><br><span class="line">      <span class="attr">isDisableBreadcrumbLink</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">isShowBreadcrumb</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">addToSidebar</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">sidebarIcon</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">sidebarIconAlt</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">isNoLogin</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这个是笔者曾经在做后台项目时用过的一些配置，主要的功能是：</p><table><thead><tr><th align="left">字段</th><th align="left">类型</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">title</td><td align="left">string</td><td align="left">用于在渲染的时候配置浏览器标题；</td></tr><tr><td align="left">isDisableBreadcrumbLink</td><td align="left">boolean</td><td align="left">是否禁用面包屑链接（对一些没有内容的路由可以屏蔽访问）；</td></tr><tr><td align="left">isShowBreadcrumb</td><td align="left">boolean</td><td align="left">是否显示面包屑（此处的登录页不需要面包屑）；</td></tr><tr><td align="left">addToSidebar</td><td align="left">boolean</td><td align="left">是否加入侧边栏（此处的登录页不需要加入侧边栏）；</td></tr><tr><td align="left">sidebarIcon</td><td align="left">string</td><td align="left">配置侧边栏的图标 className（默认）；</td></tr><tr><td align="left">sidebarIconAlt</td><td align="left">string</td><td align="left">配置侧边栏的图标 className（展开状态）；</td></tr><tr><td align="left">isNoLogin</td><td align="left">boolean</td><td align="left">是否免登录（后台默认强制登录，设置为 <code>true</code> 则可以免登录访问，此处的登录页不需要校验）；</td></tr></tbody></table><p>类似的，如果有其他需求，比如要增加对不同用户组的权限控制（比如有管理员、普通用户分组，部分页面只有管理员允许访问），都可以通过配置 Meta 里的字段，再配合 <strong>路由拦截</strong> 一起使用。</p><h2 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h2><p>对一些已下线的页面，直接访问原来的地址会导致 404 ，为了避免这种情况出现，通常会配置重定向将其指向一个新的页面，或者跳转回首页。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>路由重定向是使用一个 <code>redirect</code> 字段进行配置到对应的路由里面去实现跳转：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecordRaw</span>&gt; = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@views/home.vue&#x27;</span>),</span><br><span class="line">    <span class="attr">meta</span>: &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 访问这个路由会被重定向到首页</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/error&#x27;</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>通常来说，配置了 <code>redirect</code> 的路由，只需要指定 2 个字段即可，1 个是 <code>path</code> 该路由本身的路径，1 个是 <code>redirect</code> 目标路由的路径，其他字段可以忽略。</p><p><code>redirect</code> 字段可以接收三种类型的值：</p><table><thead><tr><th align="left">类型</th><th align="left">填写的值</th></tr></thead><tbody><tr><td align="left">string</td><td align="left">另外一个路由的 <code>path</code></td></tr><tr><td align="left">route</td><td align="left">另外一个路由（类似 <code>router.push</code>）</td></tr><tr><td align="left">function</td><td align="left">可以判断不同情况的重定向目标，最终 <code>return</code> 一个 <code>path</code> 或者 <code>route</code></td></tr></tbody></table><h3 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h3><p>路由重定向可以避免用户访问到一些无效路由页面：</p><ol><li>比如项目上线了一段时间后，有个路由需要改名，或者调整路径层级，可以把旧路由重定向到新的，避免原来的用户从收藏夹等地方进来后找不到</li><li>一些容易打错的地址，比如通常个人资料页都是用 <code>/profile</code>，但是业务网站是使用 <code>/account</code>，那也可以把 <code>/profile</code> 重定向到 <code>/account</code> 去</li><li>对于一些有会员体系的站点，可以根据用户权限进行重定向，分别指向他们具备访问权限的页面</li><li>官网首页在 PC 端、移动端、游戏内嵌横屏版分别有 3 套页面，但希望能通过主域名来识别不同设备，帮助用户自动切换访问</li></ol><p>了解了业务场景，接下来就能比较清晰地了解应该如何配置重定向了。</p><h3 id="配置为-path"><a href="#配置为-path" class="headerlink" title="配置为 path"></a>配置为 path</h3><p>最常用的场景，恐怕就是首页的指向了，比如首页地址是 <code>https://example.com/home</code>，但是想让主域名 <code>https://example.com/</code> 也能跳转到 <code>/home</code>，可以这么配置：</p><p>这是最简单的配置方式，把目标路由的 <code>path</code> 配置进来就可以了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecordRaw</span>&gt; = [</span><br><span class="line">  <span class="comment">// 重定向到 `/home`</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 真正的首页</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@views/home.vue&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>但缺点也显而易见，只能针对那些不带参数的路由。</p><h3 id="配置为-route"><a href="#配置为-route" class="headerlink" title="配置为 route"></a>配置为 route</h3><p>如果想要重定向后的路由地址带上一些参数，可以配置为 <code>route</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecordRaw</span>&gt; = [</span><br><span class="line">  <span class="comment">// 重定向到 `/home` ，并带上一个 `query` 参数</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">redirect</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">      <span class="attr">query</span>: &#123;</span><br><span class="line">        <span class="attr">from</span>: <span class="string">&#x27;redirect&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 真正的首页</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@views/home.vue&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>最终访问的地址就是 <code>https://example.com/home?from=redirect</code>， 像这样带有来路参数的，就可以在 “百度统计” 或者 “ CNZZ 统计” 之类的统计站点查看来路的流量。</p><h3 id="配置为-function"><a href="#配置为-function" class="headerlink" title="配置为 function"></a>配置为 function</h3><p>结合业务场景来解释是最直观的，比如的网站有 3 个用户组，一个是管理员，一个是普通用户，还有一个是游客（未登录），他们的网站首页是不一样的：</p><table><thead><tr><th align="center">用户组</th><th align="left">访问首页时</th></tr></thead><tbody><tr><td align="center">管理员</td><td align="left">具备各种数据可视化图表、最新的网站数据、一些最新的用户消息等等</td></tr><tr><td align="center">普通用户</td><td align="left">只有一些常用模块的入口链接</td></tr><tr><td align="center">未登录用户</td><td align="left">直接跳转到登录页面</td></tr></tbody></table><p>产品需要在访问网站主域名的时候，识别用户身份跳转不同的首页，那么就可以这样配置路由重定向：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecordRaw</span>&gt; = [</span><br><span class="line">  <span class="comment">// 访问主域名时，根据用户的登录信息，重定向到不同的页面</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// `loginInfo` 是当前用户的登录信息</span></span><br><span class="line">      <span class="comment">// 可以从 `localStorage` 或者 `Pinia` 读取</span></span><br><span class="line">      <span class="keyword">const</span> &#123; groupId &#125; = loginInfo</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据组别 ID 进行跳转</span></span><br><span class="line">      <span class="keyword">switch</span> (groupId) &#123;</span><br><span class="line">        <span class="comment">// 管理员跳去仪表盘</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;/dashboard&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 普通用户跳去首页</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;/home&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他都认为未登录，跳去登录页</span></span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;/login&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="路由别名配置"><a href="#路由别名配置" class="headerlink" title="路由别名配置"></a>路由别名配置</h2><p>根据的业务需求，也可以为路由指定一个别名，与上面的 路由重定向功能相似，但又有不同：</p><p>配置了路由重定向，当用户访问 <code>/a</code> 时，URL 将会被替换成 <code>/b</code>，然后匹配的实际路由是 <code>/b</code> 。</p><p>配置了路由别名，<code>/a</code> 的别名是 <code>/b</code>，当用户访问 <code>/b</code> 时，URL 会保持为 <code>/b</code>，但是路由匹配则为 <code>/a</code>，就像用户访问 <code>/a</code> 一样。</p><p><strong>配置方法</strong></p><p>添加一个 <code>alias</code> 字段即可轻松实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecordRaw</span>&gt; = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">alias</span>: <span class="string">&#x27;/index&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@views/home.vue&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如上的配置，即可实现可以通过 <code>/home</code> 访问首页，也可以通过 <code>/index</code> 访问首页。</p><h2 id="404-路由页面配置"><a href="#404-路由页面配置" class="headerlink" title="404 路由页面配置"></a>404 路由页面配置</h2><p>可以配置一个 404 路由来代替站内的 404 页面。</p><p><strong>配置方法</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecordRaw</span>&gt; = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/:pathMatch(.*)*&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;404&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@views/404.vue&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样配置之后，只要访问到不存在的路由，就会显示为这个 404 模板。</p><blockquote><p>WARNING 新版的路由不再支持直接配置通配符 <code>*</code> ，而是必须使用带有自定义正则表达式的参数进行定义，详见官网 <a href="https://router.vuejs.org/zh/guide/migration/#%E5%88%A0%E9%99%A4%E4%BA%86-%EF%BC%88%E6%98%9F%E6%A0%87%E6%88%96%E9%80%9A%E9%85%8D%E7%AC%A6%EF%BC%89%E8%B7%AF%E7%94%B1">删除了 *（星标或通配符）路由</a> 的说明。</p></blockquote><h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><p>和 Vue 2 时使用的路由一样， Vue 3 也支持导航守卫，并且用法基本上是一样的。</p><p>导航守卫这个词对初次接触的开发者来说应该会有点云里雾里，其实就是几个专属的钩子函数，先来看一下使用场景，大致理解一下基本概念和作用。</p><h3 id="钩子的应用场景"><a href="#钩子的应用场景" class="headerlink" title="钩子的应用场景"></a>钩子的应用场景</h3><p>对于导航守卫还不熟悉的开发者，可以从一些实际使用场景来加强印象，比如：</p><ol><li>前面说的，在渲染的时候配置浏览器标题，由于 Vue 项目只有一个 HTML 文件，所以默认只有一个标题，但想在访问 <code>/home</code> 的时候标题显示为 “首页”，访问 <code>/about</code> 的时候标题显示为 “关于” 。</li><li>部分页面需要管理员才能访问，普通用户不允许进入到该路由页面。</li><li>Vue 单页面项目，传统的 CNZZ &#x2F; 百度统计等网站统计代码只会在页面加载的时候统计一次，但需要每次切换路由都上报一次 PV 数据。</li></ol><p>这样的场景还有很多，导航守卫支持全局使用，也可以在 <code>.vue</code> 文件里单独使用，接下来看看具体的用法。</p><h3 id="路由里的全局钩子"><a href="#路由里的全局钩子" class="headerlink" title="路由里的全局钩子"></a>路由里的全局钩子</h3><p>顾名思义，是在创建 <code>router</code> 的时候进行全局的配置，也就是说，只要配置了钩子，那么所有的路由在被访问到的时候，都会触发这些钩子函数。</p><table><thead><tr><th align="left">可用钩子</th><th align="left">含义</th><th align="left">触发时机</th></tr></thead><tbody><tr><td align="left">beforeEach</td><td align="left">全局前置守卫</td><td align="left">在路由跳转前触发</td></tr><tr><td align="left">beforeResolve</td><td align="left">全局解析守卫</td><td align="left">在导航被确认前，同时在组件内守卫和异步路由组件被解析后</td></tr><tr><td align="left">afterEach</td><td align="left">全局后置守卫</td><td align="left">在路由跳转完成后触发</td></tr></tbody></table><p>全局配置非常简单，在 src&#x2F;router&#x2F;index.ts 里，在创建路由之后、在导出去之前使用：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里调用导航守卫的钩子函数</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出去</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><h4 id="beforeEach"><a href="#beforeEach" class="headerlink" title="beforeEach"></a>beforeEach</h4><p>全局前置守卫，这是导航守卫里面运用的最多的一个钩子函数，通常将其称为 “路由拦截”。</p><p>拦截这个词，顾名思义，就是在 XXX 目的达到之前，把它拦下来，所以路由的目的就是渲染指定的组件，路由拦截就是在组件被渲染之前，做一些拦截操作。</p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">to</td><td align="left">即将要进入的路由对象</td></tr><tr><td align="left">from</td><td align="left">当前导航正要离开的路由</td></tr></tbody></table><blockquote><p>TIP</p><p>和 Vue 2 不同，Vue 2 的 <code>beforeEach</code> 是默认三个参数，第三个参数是 <code>next</code>，用来操作路由接下来的跳转。</p><p>但在新版本路由里，已经通过 RFC 将其删除，虽然目前还是作为可选参数使用，但以后不确定是否会移除，不建议继续使用，<a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0037-router-return-guards.md#motivation">点击查看原因</a>。</p></blockquote><p>新版本路由可以通过 <code>return</code> 来代替 <code>next</code>。</p><p><strong>用法</strong></p><p>比如在进入路由之前，根据 Meta 路由元信息的配置，设定路由的网页标题：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; title &#125; = to.<span class="property">meta</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = title || <span class="string">&#x27;默认标题&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>或者判断是否需要登录：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; isNoLogin &#125; = to.<span class="property">meta</span></span><br><span class="line">  <span class="keyword">if</span> (!isNoLogin) <span class="keyword">return</span> <span class="string">&#x27;/login&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>或者针对一些需要 ID 参数，但参数丢失的路由做拦截，比如：很多网站的文章详情页都是类似 <code>https://example.com/article/123</code> 这样格式的地址，是需要带有文章 ID 作为 URL 的一部分，如果只访问 <code>https://example.com/article</code> 则需要拦截掉。</p><p>这里是关于 <code>article</code> 路由的配置，是有要求 Params 要带上 ID 参数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecordRaw</span>&gt; = [</span><br><span class="line">  <span class="comment">// 这是一个配置了 `params` ，访问的时候必须带 `id` 的路由</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/article/:id&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;article&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@views/article.vue&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>当路由的 <code>params</code> 丢失的时候，路由记录 <code>matched</code> 是一个空数组，针对这样的情况，就可以配置一个拦截，丢失参数时返回首页：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">name</span> === <span class="string">&#x27;article&#x27;</span> &amp;&amp; to.<span class="property">matched</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;/&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="beforeResolve"><a href="#beforeResolve" class="headerlink" title="beforeResolve"></a>beforeResolve</h4><p>全局解析守卫，它会在每次导航时触发，但是在所有组件内守卫和异步路由组件被解析之后，将在确认导航之前被调用。</p><p>这个钩子用得比较少，因为它和 <code>beforeEach</code> 非常相似，相信大部分开发者都会用 <code>beforeEach</code> 来代替它。</p><p>那么它有什么用？</p><p>它通常会用在一些申请权限的环节，比如一些 H5 页面需要申请系统相机权限、一些微信活动需要申请微信的登录信息授权，获得权限之后才允许获取接口数据和给用户更多的操作，使用 <code>beforeEach</code> 时机太早，使用 <code>afterEach</code> 又有点晚，那么这个钩子的时机就刚刚好。</p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">to</td><td align="left">即将要进入的路由对象</td></tr><tr><td align="left">from</td><td align="left">当前导航正要离开的路由</td></tr></tbody></table><p><strong>用法</strong></p><p>用以前 Vue Router 官网的申请照相机权限的例子来举例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://router.vuejs.org/zh/guide/advanced/navigation-guards.html</span></span><br><span class="line"></span><br><span class="line">router.<span class="title function_">beforeResolve</span>(<span class="title function_">async</span> (to) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 如果路由配置了必须调用相机权限</span></span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">meta</span>.<span class="property">requiresCamera</span>) &#123;</span><br><span class="line">    <span class="comment">// 正常流程，咨询是否允许使用照相机</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">askForCameraPermission</span>()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="comment">// 容错</span></span><br><span class="line">      <span class="keyword">if</span> (error <span class="keyword">instanceof</span> <span class="title class_">NotAllowedError</span>) &#123;</span><br><span class="line">        <span class="comment">// ... 处理错误，然后取消导航</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果出现意外，则取消导航并抛出错误</span></span><br><span class="line">        <span class="keyword">throw</span> error</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="afterEach"><a href="#afterEach" class="headerlink" title="afterEach"></a>afterEach</h4><p>全局后置守卫，这也是导航守卫里面用得比较多的一个钩子函数。</p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">to</td><td align="left">即将要进入的路由对象</td></tr><tr><td align="left">from</td><td align="left">当前导航正要离开的路由</td></tr></tbody></table><p><strong>用法</strong></p><p>在刚刚的钩子的应用场景里面有个例子，就是每次切换路由都上报一次 PV 数据，类似这种每个路由都要执行一次，但又不必在渲染前操作的，都可以放到后置钩子里去执行。</p><p>笔者之前写过两个数据统计的插件：<a href="https://www.npmjs.com/package/vue-cnzz-analytics">Vue 版 CNZZ 统计</a>、<a href="https://www.npmjs.com/package/vue-baidu-analytics">Vue 版百度统计</a>，就是用了这个后置钩子来实现自动上报数据。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 上报流量的操作</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="在组件内使用全局钩子"><a href="#在组件内使用全局钩子" class="headerlink" title="在组件内使用全局钩子"></a>在组件内使用全局钩子</h3><p>上面所讲的都是全局钩子，虽然一般都是在路由文件里使用，但如果有需要，也可以在 <code>.vue</code> 文件里操作。</p><blockquote><p>TIP</p><p>和路由的渲染不同，渲染时父级路由组件必须带有 <code>&lt;router-view /&gt;</code> 标签才能渲染，但是使用全局钩子不受此限制。</p><p>建议只在一些入口文件里使用，比如 <code>App.vue</code> ，或者是一些全局的 <code>Header.vue</code>、<code>Footer.vue</code> 里使用，方便后续维护。</p></blockquote><p>在 <code>setup</code> 里，定义一个 <code>router</code> 变量获取路由之后，就可以操作了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 定义路由</span></span><br><span class="line">    <span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用全局钩子</span></span><br><span class="line">    router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="路由里的独享钩子"><a href="#路由里的独享钩子" class="headerlink" title="路由里的独享钩子"></a>路由里的独享钩子</h3><p>介绍完全局钩子，如果只是有个别路由要做处理，可以使用路由独享的守卫，用来针对个别路由定制一些特殊功能，可以减少在全局钩子里面写一堆判断。</p><table><thead><tr><th align="left">可用钩子</th><th align="left">含义</th><th align="left">触发时机</th></tr></thead><tbody><tr><td align="left">beforeEnter</td><td align="left">路由独享前置守卫</td><td align="left">在路由跳转前触发</td></tr></tbody></table><p>注：路由独享的钩子，必须配置在 <code>routes</code> 的 JSON 树里面，挂在对应的路由下面（与 <code>path</code>、 <code>name</code>、<code>meta</code> 这些字段同级）。</p><h4 id="beforeEnte"><a href="#beforeEnte" class="headerlink" title="beforeEnte"></a>beforeEnte</h4><p>它和全局钩子 <code>beforeEach</code> 的作用相同，都是在进入路由之前触发，触发时机比 <code>beforeResolve</code> 要早。</p><p>顺序：<code>beforeEach</code>（全局） &gt; <code>beforeEnter</code>（独享） &gt; <code>beforeResolve</code>（全局）。</p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">to</td><td align="left">即将要进入的路由对象</td></tr><tr><td align="left">from</td><td align="left">当前导航正要离开的路由</td></tr></tbody></table><blockquote><p>TIP 和 <code>beforeEach</code> 一样，也取消了 <code>next</code>，可以用 <code>return</code> 来代替。</p></blockquote><p><strong>用法</strong></p><p>比如：整个站点都默认以 “栏目标题” + “全站关键标题” 的格式作为网页的 Title ，例如 “项目经验 - 程沛权” ，但在首页的时候，想做一些不一样的定制。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecordRaw</span>&gt; = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@views/home.vue&#x27;</span>),</span><br><span class="line">    <span class="comment">// 在这里添加单独的路由守卫</span></span><br><span class="line">    <span class="attr">beforeEnter</span>: <span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;程沛权 - 养了三只猫&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>就可以通过 <code>beforeEnter</code> 来实现一些个别路由的单独定制。</p><blockquote><p>TIP 需要注意的是，只有从不同的路由切换进来，才会触发该钩子。</p></blockquote><p>针对同一个路由，切换不同的 <code>params</code> 、 <code>query</code> 或者 <code>hash</code> ，都不会重复触发该钩子。</p><p>比如从 <code>https://example.com/article/123</code> 切换到 <code>https://example.com/article/234</code> 是不会触发的。</p><p>其他的用法和 <code>beforeEach</code> 可以说是一样的。</p><h3 id="组件内单独使用"><a href="#组件内单独使用" class="headerlink" title="组件内单独使用"></a>组件内单独使用</h3><p>组件里除了可以使用全局钩子外，还可以使用组件专属的路由钩子。</p><table><thead><tr><th align="left">可用钩子</th><th align="left">含义</th><th align="left">触发时机</th></tr></thead><tbody><tr><td align="left">onBeforeRouteUpdate</td><td align="left">组件内的更新守卫</td><td align="left">在当前路由改变，但是该组件被复用时调用</td></tr><tr><td align="left">onBeforeRouteLeave</td><td align="left">组件内的离开守卫</td><td align="left">导航离开该组件的对应路由时调用</td></tr></tbody></table><blockquote><p>TIP</p><p>1、组件内钩子的入参，也都取消了 <code>next</code>，可以用 <code>return</code> 来代替。</p><p>2、和其他 Composition API 一样，需要先 <code>import</code> 再操作。</p></blockquote><p>和旧版路由不同，新版的 Composition API 移除了 <code>beforeRouteEnter</code> 这个钩子。</p><h4 id="onBeforeRouteUpdate"><a href="#onBeforeRouteUpdate" class="headerlink" title="onBeforeRouteUpdate"></a>onBeforeRouteUpdate</h4><p>可以在当前路由改变但该组件被复用时，重新调用里面的一些函数，用来更新模板数据的渲染。</p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">to</td><td align="left">即将要进入的路由对象</td></tr><tr><td align="left">from</td><td align="left">当前导航正要离开的路由</td></tr></tbody></table><p><strong>用法</strong></p><p>比如一个内容网站，通常在文章详情页底部会有相关阅读推荐，这个时候就会有一个操作场景：从文章 A 跳转到文章 B。</p><p>比如从 <code>https://example.com/article/111</code> 切去 <code>https://example.com/article/222</code> ，这种情况就属于 “路由改变，但是组件被复用” 的情况了。</p><p>这种情况下，原本放在 <code>onMounted</code> 里执行数据请求的函数就不会被调用，可以借助该钩子来实现渲染新的文章内容。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useRoute, onBeforeRouteUpdate &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 其他代码略...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询文章详情</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">queryArticleDetail</span>(<span class="params"><span class="attr">id</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">      <span class="comment">// 请求接口数据</span></span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">`/article/<span class="subst">$&#123;id&#125;</span>`</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组件挂载完成后执行文章内容的请求</span></span><br><span class="line">    <span class="comment">// 注意这里是获取 `route` 的 `params`</span></span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> id = <span class="title class_">Number</span>(route.<span class="property">params</span>.<span class="property">id</span>) || <span class="number">0</span></span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">queryArticleDetail</span>(id)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组件被复用时重新请求新的文章内容</span></span><br><span class="line">    <span class="title function_">onBeforeRouteUpdate</span>(<span class="title function_">async</span> (to, <span class="keyword">from</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// ID 不变时减少重复请求</span></span><br><span class="line">      <span class="keyword">if</span> (to.<span class="property">params</span>.<span class="property">id</span> === <span class="keyword">from</span>.<span class="property">params</span>.<span class="property">id</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 注意这里是获取 `to` 的 `params`</span></span><br><span class="line">      <span class="keyword">const</span> id = <span class="title class_">Number</span>(to.<span class="property">params</span>.<span class="property">id</span>) || <span class="number">0</span></span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">queryArticleDetail</span>(id)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="onBeforeRouteLeave"><a href="#onBeforeRouteLeave" class="headerlink" title="onBeforeRouteLeave"></a>onBeforeRouteLeave</h4><p>可以在离开当前路由之前，实现一些离开前的判断拦截。</p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">to</td><td align="left">即将要进入的路由对象</td></tr><tr><td align="left">from</td><td align="left">当前导航正要离开的路由</td></tr></tbody></table><p><strong>用法</strong></p><p>这个离开守卫通常用来禁止用户在还未保存修改前突然离开，可以通过 <code>return false</code> 来取消用户离开当前路由。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; onBeforeRouteLeave &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 调用离开守卫</span></span><br><span class="line">    <span class="title function_">onBeforeRouteLeave</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 弹出一个确认框</span></span><br><span class="line">      <span class="keyword">const</span> confirmText = <span class="string">&#x27;确认要离开吗？您的更改尚未保存！&#x27;</span></span><br><span class="line">      <span class="keyword">const</span> isConfirmLeave = <span class="variable language_">window</span>.<span class="title function_">confirm</span>(confirmText)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当用户点取消时，不离开路由</span></span><br><span class="line">      <span class="keyword">if</span> (!isConfirmLeave) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="路由侦听"><a href="#路由侦听" class="headerlink" title="路由侦听"></a>路由侦听</h2><p>路由的侦听，可以延续以往的 <code>watch</code> 大法，也可以用全新的 <code>watchEffect</code>。</p><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>在 Vue 2 的时候，侦听路由变化用得最多的就是 <code>watch</code> 了， Vue 3 的 <code>watch</code> API 使用更简单。</p><h4 id="侦听整个路由"><a href="#侦听整个路由" class="headerlink" title="侦听整个路由"></a>侦听整个路由</h4><p>可以跟以前一样，直接侦听整个路由的变化：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useRoute &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 侦听整个路由</span></span><br><span class="line">    <span class="title function_">watch</span>(route, <span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 处理一些事情</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第一个参数传入整个路由；第二个参数是个 Callback ，可以获取 <code>to</code> 和 <code>from</code> 来判断路由变化情况。</p><h4 id="侦听路由的某个数据"><a href="#侦听路由的某个数据" class="headerlink" title="侦听路由的某个数据"></a>侦听路由的某个数据</h4><p>如果只想侦听路由的某个数据变化，比如侦听一个 Query ，或者一个 Param ，可以采用这种方式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useRoute &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 侦听路由参数的变化</span></span><br><span class="line">    <span class="title function_">watch</span>(</span><br><span class="line">      <span class="function">() =&gt;</span> route.<span class="property">query</span>.<span class="property">id</span>,</span><br><span class="line">      <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;侦听到 ID 变化&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第一个参数传入一个 getter 函数， <code>return</code> 要侦听的值；第二个参数是个 Callback ，可以针对参数变化进行一些操作。</p><h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><p>这是 Vue 3 新出的一个侦听函数，可以简化 <code>watch</code> 的行为。</p><p>比如定义了一个函数，通过路由的参数来获取文章 ID ，然后请求文章内容：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, watchEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useRoute &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从接口查询文章详情</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">queryArticleDetail</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> id = <span class="title class_">Number</span>(route.<span class="property">params</span>.<span class="property">id</span>) || <span class="number">0</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;文章 ID 是：&#x27;</span>, id)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">`/article/<span class="subst">$&#123;id&#125;</span>`</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接侦听包含路由参数的那个函数</span></span><br><span class="line">    <span class="title function_">watchEffect</span>(queryArticleDetail)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对比 <code>watch</code> 的使用， <code>watchEffect</code> 在操作上更加简单，把包含要被侦听数据的函数，当成它的入参传进去即可。</p><h2 id="部署问题与服务端配置"><a href="#部署问题与服务端配置" class="headerlink" title="部署问题与服务端配置"></a>部署问题与服务端配置</h2><p>通常使用路由的 Hash 模式，部署后有问题的情况很少，但是如果使用 History 模式，可能会遇到这样那样的问题。</p><h3 id="常见部署问题"><a href="#常见部署问题" class="headerlink" title="常见部署问题"></a>常见部署问题</h3><p>这里整理一些常见部署问题的原因分析和解决方案，可作参考。</p><h4 id="页面刷新就-404"><a href="#页面刷新就-404" class="headerlink" title="页面刷新就 404"></a>页面刷新就 404</h4><p>页面部署到服务端之后，访问首页正常；通过导航上面的链接进行路由跳转，也正常；但是刷新页面就变成 404 了。</p><h5 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h5><p>一般这种情况是路由开启了 History 模式，但是服务端没有配置功能支持。</p><h5 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h5><p>请根据<strong>服务端配置</strong>部分的说明，与的运维同事沟通，让他帮忙修改服务端的配置。</p><h4 id="部分路由白屏"><a href="#部分路由白屏" class="headerlink" title="部分路由白屏"></a>部分路由白屏</h4><p>如果在项目配置文件里，把里面的 <a href="https://cli.vuejs.org/zh/config/#publicpath">publicPath</a> （使用 Vue CLI ） 或者 <a href="https://cn.vitejs.dev/config/#base">base</a> （使用 Vite ） 配置成相对路径 <code>./</code> ，但是路由配置了二级或以上，那么就会出现这个问题。</p><h5 id="问题原因-1"><a href="#问题原因-1" class="headerlink" title="问题原因"></a>问题原因</h5><p>原因是打包后的 JS 、 CSS 等静态资源都是存放在项目根目录下，一级路由的 <code>./</code> 就是根目录，所以访问正常；而二级路由的 <code>./</code> 则不是根目录了，是从当前目录载入的 ，这就导致无法正确载入 JS 文件，从而导致了白屏。</p><p>假设项目域名是 <code>https://example.com</code> ，那么：</p><ul><li><p>一级路由是 <code>https://example.com/home</code></p></li><li><p>二级路由是 <code>https://example.com/foo/bar</code></p></li><li><p>假设打包后的 JS 文件等静态资产存放于 <code>https://example.com/assets/</code> 文件夹下</p><ul><li>访问一级路由时， <code>./</code> 访问到的 JS 文件是 <code>https://example.com/assets/home.js</code> ，所以一级路由可以正常访问到。</li></ul></li><li><p>访问二级路由时， <code>./</code> 访问到的 JS 文件是 <code>https://example.com/foo/assets/bar.js</code> ，但实际上文件是存放在 <code>https://example.com/assets/bar.js</code> ，访问到的 URL 资源不存在，所以白屏了。</p></li></ul><h5 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h5><p>如果的项目开启了 History 模式，并且配置有二级或者二级以上的路由时，不要使用 <code>./</code> 这样的相对路径。</p><p>正确的方式应该是修改 <a href="https://cli.vuejs.org/zh/config/#publicpath">publicPath</a> （使用 Vue CLI ） 或者 <a href="https://cn.vitejs.dev/config/#base">base</a> （使用 Vite ），如果是部署在域名根目录则写 <code>/</code> ，如果是子目录，则按照子目录的格式，将其以 <code>/</code> 开头，以 <code>/</code> 结尾的形式配置（ e.g. <code>/hello-world/</code> ）</p><h3 id="服务端配置方案"><a href="#服务端配置方案" class="headerlink" title="服务端配置方案"></a>服务端配置方案</h3><p>如果使用的是 HTML5 的 History 模式，那么服务端也需要配置对应的支持，否则会出现路由跳转正常，但页面一刷新就 404 的情况。</p><blockquote><p>TIP</p><p>服务端配置后，就不再进入 404 了，需要在项目里手动配置 404 路由页面的路由。</p></blockquote><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>现在大部分公司的服务程序都在使用 Nginx ，可以将以下代码发给运维工程师参考，调整 Nginx 的配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">  <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h4><p>如果是前端工程师使用 Node.js 作服务端，并且使用了 Express 服务端框架，那么操作将变得更简单：</p><ol><li>仅需要安装一个中间件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install connect-history-api-fallback</span><br></pre></td></tr></table></figure><ol><li>在服务启动入口文件里导入该中间件并激活</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> history = <span class="built_in">require</span>(<span class="string">&#x27;connect-history-api-fallback&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Express 实例</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line">app</span><br><span class="line">  <span class="comment">// 启用 History 中间件</span></span><br><span class="line">  .<span class="title function_">use</span>(<span class="title function_">history</span>())</span><br><span class="line">  <span class="comment">// 这里是读取打包后的页面文件目录</span></span><br><span class="line">  .<span class="title function_">use</span>(<span class="string">&#x27;/&#x27;</span>, express.<span class="title function_">static</span>(<span class="title function_">resolve</span>(<span class="string">&#x27;../dist&#x27;</span>)))</span><br></pre></td></tr></table></figure><p>更多用法可以看： <a href="https://github.com/bripkens/connect-history-api-fallback">connect-history-api-fallback</a> 的文档。</p><h4 id="更多方案"><a href="#更多方案" class="headerlink" title="更多方案"></a>更多方案</h4><p>其他的诸如 Apache 、 IIS 、或者原生 Node 等等配置方案， Vue 官方都提供了对应的演示代码，点击查看更多配置方案： <a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B">服务器配置示例</a> 。</p><script>var description="在传统Web前端框架（如Vue、Vite等）中使用路由时，如果遇到页面刷新变为404或部分路由显示为白色的问题，通常是由于以下原因："</script>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3入门</title>
      <link href="/p/e930893f.html"/>
      <url>/p/e930893f.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="全新的-Vue-版本"><a href="#全新的-Vue-版本" class="headerlink" title="全新的 Vue 版本"></a>全新的 Vue 版本</h2><p>在 2022 年 2 月 7 日， Vue 3 代替了 Vue 2 成为 Vue 的默认版本，也就是运行 <code>npm i vue</code> 默认会安装 Vue 3 了，无需再和以前一样，需要指定 <code>vue@next</code> 才可以安装到 Vue 3 。包括 <code>vue-router</code> 、 <code>vuex</code> 、<code>vue-loader</code> 和 <code>@vue/test-utils</code> 等相关的生态，同样不需要指定 next 版本了，都配合 Vue 3 指定了新的 latest 默认版本。</p><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p>只罗列 Vue 3.0 相关的官网，有中文版的优先都放中文版。</p><table><thead><tr><th align="center">名称</th><th align="center">官网文档</th></tr></thead><tbody><tr><td align="center">Vue 3</td><td align="center"><a href="https://cn.vuejs.org/">点击访问</a></td></tr><tr><td align="center">Vue Composition API</td><td align="center"><a href="https://cn.vuejs.org/guide/extras/composition-api-faq.html">点击访问</a></td></tr><tr><td align="center">Vue Router</td><td align="center"><a href="https://router.vuejs.org/zh/">点击访问</a></td></tr><tr><td align="center">Vuex</td><td align="center"><a href="https://vuex.vuejs.org/zh/">点击访问</a></td></tr><tr><td align="center">Pinia</td><td align="center"><a href="https://pinia.vuejs.org/">点击访问</a></td></tr><tr><td align="center">Vue CLI</td><td align="center"><a href="https://cli.vuejs.org/zh/">点击访问</a></td></tr><tr><td align="center">Vite</td><td align="center"><a href="https://cn.vitejs.dev/">点击访问</a></td></tr></tbody></table><h3 id="使用-Vue-2"><a href="#使用-Vue-2" class="headerlink" title="使用 Vue 2"></a>使用 Vue 2</h3><p>如果还需要使用 Vue 2 ，则在安装的时候需要手动指定 Tag 为 <code>legacy</code> 或者 <code>v2-latest</code> 才能安装到 Vue 2 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 2.6.x 的最新版本</span></span><br><span class="line">npm i vue@legacy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 2.7.x 的最新版本</span></span><br><span class="line">npm i vue@v2-latest</span><br></pre></td></tr></table></figure><p>注意到 Vue 2 配对了两个不同的 Tag ，分别对应 2.7 系列和 2.6 系列。</p><ul><li><p>Vue 2.7 系列是在 Vue 2 的基础上，对标 Vue 3 的功能支持所作的升级，主要是面向想使用 Vue 3 的新特性、但顾虑于产品对旧浏览器的支持而无法贸然升级的开发者。</p></li><li><p>Vue 2.7 与 Vue 2.6 之前的旧版本在使用上略有不同，具体可以查看 Vue 2 的 <a href="https://github.com/vuejs/vue/blob/main/CHANGELOG.md">更新记录</a> 了解具体的差异化。</p></li></ul><h2 id="使用-Vite-创建项目"><a href="#使用-Vite-创建项目" class="headerlink" title="使用 Vite 创建项目"></a>使用 Vite 创建项目</h2><p>Vite 是由 Vue 作者尤雨溪先生带领团队开发的一个构建工具，它利用浏览器原生支持 ES 模块的特点，极大提升了开发体验，自 2021 年 1 月份发布 2.0 版本以来，发展非常快,整体情况非常稳定，前景非常乐观。</p><h3 id="Create-Vite"><a href="#Create-Vite" class="headerlink" title="Create Vite"></a>Create Vite</h3><p><a href="https://github.com/vitejs/vite/tree/main/packages/create-vite">create-vite</a> 是 Vite 官方推荐的一个脚手架工具，可以创建基于 Vite 的不同技术栈基础模板。</p><p>运行以下命令创建模板项目，再按照命令行的提示操作（选择 <code>vue</code> 技术栈进入），即可创建一个基于 Vite 的基础空项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vite</span><br></pre></td></tr></table></figure><p>不过这个方式创建的项目非常基础，如果需要用到 Router 、 Vuex 、 ESLint 等程序，都需要再单独安装和配置，所以推荐使用 <strong>Create Preset</strong> 。</p><h3 id="Create-Vue"><a href="#Create-Vue" class="headerlink" title="Create Vue"></a>Create Vue</h3><p><a href="https://github.com/vuejs/create-vue">create-vue</a> 是 Vue 官方推出的一个新脚手架，用以代替基于 Webpack 的 Vue CLI ，它可以创建基于 Vite 的 Vue 基础模板。</p><p>运行以下命令创建模板项目，然后根据命令行的提示操作即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init vue@3</span><br></pre></td></tr></table></figure><h3 id="Create-Preset"><a href="#Create-Preset" class="headerlink" title="Create Preset"></a>Create Preset</h3><p><a href="https://github.com/awesome-starter/create-preset">create-preset</a> 是 Awesome Starter 的 CLI 脚手架，提供快速创建预设项目的能力，可以创建一些有趣实用的项目启动模板，也可以用来管理的常用项目配置。</p><ul><li><p><strong>简单使用</strong>: 可以通过包管理器直接创建配置，然后按照命令行的提示操作，即可创建开箱即用的模板项目。</p><ul><li>在这里选择 <code>vue</code> 技术栈进入，选择 <a href="https://github.com/awesome-starter/vue3-ts-vite-starter">vue3-ts-vite</a> 创建一个基于 Vite + Vue 3 + TypeScript 的项目启动模板。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create preset</span><br></pre></td></tr></table></figure></li><li><p><strong>全局安装</strong></p><ul><li><p>也可以像使用 <code>@vue/cli</code> 一样，全局安装到本地，通过 <code>preset init</code> 命令来创建项目。<strong>推荐全局安装它，用起来更方便</strong>，请先全局安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-preset</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以通过下面这个命令来检查安装是否成功，如果成功，将会得到一个版本号：</span></span><br><span class="line">preset -v</span><br><span class="line">0.13.1</span><br></pre></td></tr></table></figure></li><li><p>然后可以通过 <code>--template</code> 选项直接指定一个模板创建项目，在这里使用 <code>vue3-ts-vite</code> 模板创建一个名为 <code>hello-vue3</code> 的项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preset init hello-vue3 --template vue3-ts-vite</span><br></pre></td></tr></table></figure></li></ul></li><li><p>常用的项目模板也可以绑定为本地配置，点击 <a href="https://preset.js.org/zh/">Create Preset 官方文档</a> 查看完整使用教程。</p></li></ul><h3 id="管理项目配置"><a href="#管理项目配置" class="headerlink" title="管理项目配置"></a>管理项目配置</h3><p>不论使用上方哪种方式创建项目，在项目的根目录下都会有一个名为 <code>vite.config.js</code> 或 <code>vite.config.ts</code> 的项目配置文件（其扩展名由项目使用 JavaScript 还是 TypeScript 决定）。</p><p>里面会有一些预设好的配置，可以在 <a href="https://cn.vitejs.dev/config/">Vite 官网的配置文档</a> 查阅更多的可配置选项。</p><h2 id="使用-vue-cli-创建项目"><a href="#使用-vue-cli-创建项目" class="headerlink" title="使用 @vue&#x2F;cli 创建项目"></a>使用 @vue&#x2F;cli 创建项目</h2><p>如果不习惯 Vite ，依然可以使用 Vue CLI 作为开发脚手架,Vue CLI 使用的构建工具是基于 Webpack 。</p><h3 id="更新-CLI-脚手架"><a href="#更新-CLI-脚手架" class="headerlink" title="更新 CLI 脚手架"></a>更新 CLI 脚手架</h3><p>请先全局安装，把脚手架更新到最新版本（最低版本要求在 <code>4.5.6</code> 以上才能支持 Vue 3 项目的创建）。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure><h3 id="使用-CLI-创建-3-x-项目"><a href="#使用-CLI-创建-3-x-项目" class="headerlink" title="使用 CLI 创建 3.x 项目"></a>使用 CLI 创建 3.x 项目</h3><p>Vue CLI 全局安装后，可以在命令行输入 <code>vue</code> 进行操作，创建项目使用的是 <code>create</code> 命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create hello-vue3</span><br></pre></td></tr></table></figure><p>由于要使用 TypeScript ，所以需要选择最后一个选项来进行自定义搭配，通过键盘的上下箭头进行切换选择：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue CLI v5.0.4</span><br><span class="line">? Please pick a preset:</span><br><span class="line">  Default ([Vue 3] babel, eslint)</span><br><span class="line">  Default ([Vue 2] babel, eslint)</span><br><span class="line">&gt; Manually <span class="keyword">select</span> features</span><br></pre></td></tr></table></figure><p>多选菜单可以按空格选中需要的依赖，总共选择了下面这些选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue CLI v5.0.4</span><br><span class="line">? Please pick a preset: Manually <span class="keyword">select</span> features</span><br><span class="line">? Check the features needed <span class="keyword">for</span> your project: (Press &lt;space&gt; to <span class="keyword">select</span>,</span><br><span class="line">&lt;a&gt; to toggle all, &lt;i&gt; to invert selection, and &lt;enter&gt; to proceed)</span><br><span class="line"> (*) Babel</span><br><span class="line"> (*) TypeScript</span><br><span class="line"> ( ) Progressive Web App (PWA) Support</span><br><span class="line"> (*) Router</span><br><span class="line"> (*) Vuex</span><br><span class="line"> (*) CSS Pre-processors</span><br><span class="line">&gt;(*) Linter / Formatter</span><br><span class="line"> ( ) Unit Testing</span><br><span class="line"> ( ) E2E Testing</span><br></pre></td></tr></table></figure><p>选择 Vue 版本，要用 Vue 3 所以需要选择 3.x ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">? Choose a version of Vue.js that you want to start the project with</span><br><span class="line">  (Use arrow keys)</span><br><span class="line">&gt; 3.x</span><br><span class="line">  2.x</span><br></pre></td></tr></table></figure><p>是否选择 Class 语法的模板，在 Vue 2 版本为了更好的支持 TypeScript ，通常需要使用 Class 语法，由于 Vue 3 有了对 TypeScript 支持度更高的 Composition API ，因此选择 <code>n</code> ，也就是 “否” ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? Use class-style component syntax? (y/N) n</span><br></pre></td></tr></table></figure><p>Babel 可以把新版本的 JavaScript 语句转换为兼容性更好的低版本 Polyfill 写法，所以选 <code>y</code> 确认使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? Use Babel alongside TypeScript</span><br><span class="line">  (required <span class="keyword">for</span> modern mode, auto-detected polyfills, transpiling JSX)?</span><br><span class="line">  (Y/n) y</span><br></pre></td></tr></table></figure><p>接下来是选择路由模式，选 <code>y</code> 启用 History 模式，选 <code>n</code> 使用 Hash 模式，可根据项目情况选择。建议先选 <code>y</code> 确认。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? Use <span class="built_in">history</span> mode <span class="keyword">for</span> router?</span><br><span class="line">  (Requires proper server setup <span class="keyword">for</span> index fallback <span class="keyword">in</span> production)</span><br><span class="line">  (Y/n) y</span><br></pre></td></tr></table></figure><p>选择一个 CSS 预处理器，可以根据自己的喜好选择，不过鉴于目前开源社区组件常用的都是 <a href="https://github.com/less/less.js">Less</a> ，所以也建议选择 Less 作为入门的预处理器工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported</span><br><span class="line"> by default):</span><br><span class="line">  Sass/SCSS (with dart-sass)</span><br><span class="line">&gt; Less</span><br><span class="line">  Stylus</span><br></pre></td></tr></table></figure><p>Lint 规则，用来代码检查，写 TypeScript 离不开 Lint ，可以根据自己喜好选择，也可以先选择默认，这里先默认第一个：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? Pick a linter / formatter config: (Use arrow keys)</span><br><span class="line">&gt; ESLint with error prevention only</span><br><span class="line">  ESLint + Airbnb config</span><br><span class="line">  ESLint + Standard config</span><br><span class="line">  ESLint + Prettier</span><br></pre></td></tr></table></figure><p>Lint 的校验时机，一个是在保存时校验，一个是在提交 commit 的时候才校验，这里也选默认：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">? Pick additional lint features: (Press &lt;space&gt; to <span class="keyword">select</span>,</span><br><span class="line"> &lt;a&gt; to toggle all, &lt;i&gt; to invert selection, and &lt;enter&gt; to proceed)</span><br><span class="line">&gt;(*) Lint on save</span><br><span class="line"> ( ) Lint and fix on commit</span><br></pre></td></tr></table></figure><p>项目配置文件，笔者更习惯保存为独立文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">? Where <span class="keyword">do</span> you prefer placing config <span class="keyword">for</span> Babel, ESLint, etc.?</span><br><span class="line">  (Use arrow keys)</span><br><span class="line">&gt; In dedicated config files</span><br><span class="line">  In package.json</span><br></pre></td></tr></table></figure><p>是否保存为未来的项目配置，存起来方便以后快速创建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? Save this as a preset <span class="keyword">for</span> future projects? Yes</span><br><span class="line">? Save preset as: vue-3-ts-config</span><br></pre></td></tr></table></figure><p>至此，项目创建完成！可以通过 <code>npm run serve</code> 开启热更进行开发调试，通过 <code>npm run build</code> 构建打包上线。</p><h3 id="管理项目配置-1"><a href="#管理项目配置-1" class="headerlink" title="管理项目配置"></a>管理项目配置</h3><p>Vue CLI 的配置文件是 <code>vue.config.js</code> ，可以参考官网的说明文档调整各个选项配置：<a href="https://cli.vuejs.org/zh/config/">配置参考 - Vue CLI</a> 。</p><h2 id="Hello-Vue3"><a href="#Hello-Vue3" class="headerlink" title="Hello Vue3"></a>Hello Vue3</h2><p>如果想早点开始 Vue 3 的世界，可以通过以下命令直接创建一个启动项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 `vue3-ts-vite` 模板创建一个名为 `hello-vue3` 的项目</span></span><br><span class="line">preset init hello-vue3 --template vue3-ts-vite</span><br><span class="line"></span><br><span class="line">npm install </span><br></pre></td></tr></table></figure><p>至此，通过脚手架已经搭好了一个可直接运行的基础项目，已经可以正常的 <code>npm run dev</code> 和 <code>npm run build</code> 了，项目配置和编辑器也都弄好了，是不是可以开始写代码了呢？</p><p>请不要着急，还需要了解一点东西，就是如何初始化一个 Vue 3 项目。</p><p>因为在实际开发过程中，还会用到各种 npm 包，像很多 UI 框架、功能插件的引入都是需要在 Vue 初始化阶段处理。</p><p>甚至有时候还要脱离脚手架，采用 CDN 引入的方式来开发，所以开始写组件之前，还需要了解一下在 Vue 3 项目中，初始化阶段对比 Vue 2 的一些变化。</p><h3 id="回顾-Vue-2-vue-2"><a href="#回顾-Vue-2-vue-2" class="headerlink" title="回顾 Vue 2-vue-2"></a>回顾 Vue 2-vue-2</h3><p>Vue 2 在导入各种依赖之后，通过 <code>new Vue()</code> 执行 Vue 的初始化，相关的 Vue 生态和插件，有的是使用 <code>Vue.use()</code> 来进行初始化，有的是作为 <code>new Vue()</code> 的入参：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> pluginA <span class="keyword">from</span> <span class="string">&#x27;pluginA&#x27;</span></span><br><span class="line"><span class="keyword">import</span> pluginB <span class="keyword">from</span> <span class="string">&#x27;pluginB&#x27;</span></span><br><span class="line"><span class="keyword">import</span> pluginC <span class="keyword">from</span> <span class="string">&#x27;pluginC&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用了 `use` 方法激活</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(pluginA)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(pluginB)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(pluginC)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为 `new Vue()` 的入参激活</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">render</span>: <span class="function">(<span class="params">h</span>) =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><p>项目的初始化都是在入口文件集中处理，Vue 3 的目录结构对比 Vue 2 没有变化，入口文件依然还是 main.ts 这个文件。但是 Vue 3 在初始化的时候，做了不少的调整，代码写法和 Vue 2 完全不同。因为统一了相关生态的启用方式，不再像 Vue 2 时期那样多方式共存，显得比较杂乱。</p><p>在 Vue 3 ，使用 <code>createApp</code> 执行 Vue 的初始化，另外不管是 Vue 生态里的东西，还是外部插件、 UI 框架，统一都是由 <code>use()</code> 进行激活，非常统一和简洁：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> pluginA <span class="keyword">from</span> <span class="string">&#x27;pluginA&#x27;</span></span><br><span class="line"><span class="keyword">import</span> pluginB <span class="keyword">from</span> <span class="string">&#x27;pluginB&#x27;</span></span><br><span class="line"><span class="keyword">import</span> pluginC <span class="keyword">from</span> <span class="string">&#x27;pluginC&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">  .<span class="title function_">use</span>(store)</span><br><span class="line">  .<span class="title function_">use</span>(router)</span><br><span class="line">  .<span class="title function_">use</span>(pluginA)</span><br><span class="line">  .<span class="title function_">use</span>(pluginB)</span><br><span class="line">  .<span class="title function_">use</span>(pluginC)</span><br><span class="line">  .<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="全新的-setup-函数"><a href="#全新的-setup-函数" class="headerlink" title="全新的 setup 函数"></a>全新的 setup 函数</h2><p>在开始编写 Vue 组件之前，需要了解两个全新的前置知识点：</p><ul><li>全新的 <code>setup</code> 函数，关系到组件的生命周期和渲染等问题</li><li>写 TypeScript 组件离不开的 <code>defineComponent</code> API</li></ul><h3 id="setup-的含义"><a href="#setup-的含义" class="headerlink" title="setup 的含义"></a>setup 的含义</h3><p>Vue 3 的 Composition API 系列里，推出了一个全新的 <code>setup</code> 函数，它是一个组件选项，在创建组件之前执行，一旦 props 被解析，便作为组合式 API 的入口点。</p><blockquote><p>说的通俗一点，就是在使用 Vue 3 生命周期的情况下，整个组件相关的业务代码，都可以放在 <code>setup</code> 里执行。因为在 <code>setup</code> 之后，其他的生命周期才会被启用。</p></blockquote><p>基本语法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个基于 TypeScript 的 Vue 组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">    <span class="comment">// 在这里声明数据，或者编写函数并在这里执行它</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 需要给 `&lt;template /&gt;` 用的数据或函数，在这里 `return` 出去</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以发现在这段代码里还导入了一个 <code>defineComponent</code> API ，也是 Vue 3 带来的新功能，下文的 defineComponent 的作用将介绍其用法。</p><p><strong>在使用 <code>setup</code> 的情况下，请牢记一点：不能再用 <code>this</code> 来获取 Vue 实例，也就是无法和 Vue 2 一样，通过 <code>this.foo</code> 、 <code>this.bar()</code> 这样来获取实例上的数据，或者执行实例上的方法。</strong></p><h3 id="setup-的参数使用"><a href="#setup-的参数使用" class="headerlink" title="setup 的参数使用"></a>setup 的参数使用</h3><p><code>setup</code> 函数包含了两个入参：</p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">含义</th><th align="left">是否必传</th></tr></thead><tbody><tr><td align="left">props</td><td align="left">object</td><td align="left">由父组件传递下来的数据</td><td align="left">否</td></tr><tr><td align="left">context</td><td align="left">object</td><td align="left">组件的执行上下文</td><td align="left">否</td></tr></tbody></table><ul><li><strong>第一个参数 <code>props</code> ：</strong><ul><li>它是响应式的，当父组件传入新的数据时，它将被更新。</li></ul></li></ul><blockquote><p>请不要解构它，这样会让数据失去响应性，一旦父组件发生数据变化，解构后的变量将无法同步更新为最新的值。</p><p>可以使用 Vue 3 全新的响应式 API <code>toRef / toRefs</code>进行响应式数据转换，下文将会介绍全新的响应式 API 的用法。</p></blockquote><ul><li><p><strong>第二个参数 <code>context</code> ：</strong></p><ul><li><p><code>context</code> 只是一个普通的对象，它暴露三个组件的 Property ：</p><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">attrs</td><td align="left">非响应式对象</td><td align="left">未在 Props 里定义的属性都将变成 Attrs</td></tr><tr><td align="left">slots</td><td align="left">非响应式对象</td><td align="left">组件插槽，用于接收父组件传递进来的模板内容</td></tr><tr><td align="left">emit</td><td align="left">方法</td><td align="left">触发父组件绑定下来的事件</td></tr></tbody></table></li></ul></li><li><p>因为 <code>context</code> 只是一个普通对象，所以可以直接使用 ES6 解构。</p><ul><li>平时使用可以通过直接传入 <code>&#123; emit &#125;</code> ，即可用 <code>emit(&#39;xxx&#39;)</code> 来代替使用 <code>context.emit(&#39;xxx&#39;)</code>，另外两个功能也是如此。</li><li>但是 <code>attrs</code> 和 <code>slots</code> 请保持 <code>attrs.xxx</code>、<code>slots.xxx</code> 的方式来使用其数据，不要进行解构，虽然这两个属性不是响应式对象，但对应的数据会随组件本身的更新而更新。</li></ul></li></ul><h3 id="defineComponent-的作用"><a href="#defineComponent-的作用" class="headerlink" title="defineComponent 的作用"></a>defineComponent 的作用</h3><p><code>defineComponent</code> 是 Vue 3 推出的一个全新 API ，可用于对 TypeScript 代码的类型推导，帮助开发者简化掉很多编码过程中的类型声明。</p><p>比如，原本需要这样才可以使用 <code>setup</code> 函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Slots</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 `props` 和 `return` 的数据类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">unknown</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 `context` 的类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SetupContext</span> &#123;</span><br><span class="line">  <span class="attr">attrs</span>: <span class="title class_">Data</span></span><br><span class="line">  <span class="attr">slots</span>: <span class="title class_">Slots</span></span><br><span class="line">  <span class="attr">emit</span>: <span class="function">(<span class="params"><span class="attr">event</span>: <span class="built_in">string</span>, ...<span class="attr">args</span>: <span class="built_in">unknown</span>[]</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用的时候入参要加上声明， `return` 也要加上声明</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="attr">props</span>: <span class="title class_">Data</span>, <span class="attr">context</span>: <span class="title class_">SetupContext</span>): <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个组件都这样进行类型声明，会非常繁琐，如果使用了 <code>defineComponent</code> ，就可以省略这些类型声明：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 `defineComponent` 包裹组件的内部逻辑</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>代码量瞬间大幅度减少，只要是 Vue 本身的 API ， <code>defineComponent</code> 都可以自动推导其类型，这样开发者在编写组件的过程中，只需要维护自己定义的数据类型就可以了，可专注于业务。</p><h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>在了解了 Vue 3 组件的两个前置知识点后，不着急写组件，还需要先了解组件的生命周期，这个知识点非常重要，只有理解并记住组件的生命周期，才能够灵活地把控好每一处代码的执行，使程序的运行结果可以达到预期。</p><h3 id="升级变化"><a href="#升级变化" class="headerlink" title="升级变化"></a>升级变化</h3><p>从 Vue 2 升级到 Vue 3 ，在保留对 Vue 2 的生命周期支持的同时，Vue 3 也带来了一定的调整。</p><p>Vue 2 的生命周期写法名称是 Options API （选项式 API ）， Vue 3 新的生命周期写法名称是 Composition API （组合式 API ）。</p><p>Vue 3 组件默认支持 Options API ，而 Vue 2 可以通过 <a href="https://www.npmjs.com/package/@vue/composition-api">@vue&#x2F;composition-api</a> 插件获得 Composition API 的功能支持（其中 Vue 2.7 版本内置了该插件， 2.6 及以下的版本需要单独安装）。</p><p>为了减少理解成本，笔者将从读者的使用习惯上，使用 “ Vue 2 的生命周期” 代指 Options API 写法，用 “ Vue 3 的生命周期” 代指 Composition API 写法。</p><p>关于 Vue 生命周期的变化，可以从下表直观地了解：</p><table><thead><tr><th align="center">Vue 2 生命周期</th><th align="center">Vue 3 生命周期</th><th align="center">执行时间说明</th></tr></thead><tbody><tr><td align="center">beforeCreate</td><td align="center">setup</td><td align="center">组件创建前执行</td></tr><tr><td align="center">created</td><td align="center">setup</td><td align="center">组件创建后执行</td></tr><tr><td align="center">beforeMount</td><td align="center">onBeforeMount</td><td align="center">组件挂载到节点上之前执行</td></tr><tr><td align="center">mounted</td><td align="center">onMounted</td><td align="center">组件挂载完成后执行</td></tr><tr><td align="center">beforeUpdate</td><td align="center">onBeforeUpdate</td><td align="center">组件更新之前执行</td></tr><tr><td align="center">updated</td><td align="center">onUpdated</td><td align="center">组件更新完成之后执行</td></tr><tr><td align="center">beforeDestroy</td><td align="center">onBeforeUnmount</td><td align="center">组件卸载之前执行</td></tr><tr><td align="center">destroyed</td><td align="center">onUnmounted</td><td align="center">组件卸载完成后执行</td></tr><tr><td align="center">errorCaptured</td><td align="center">onErrorCaptured</td><td align="center">当捕获一个来自子孙组件的异常时激活钩子函数</td></tr></tbody></table><p>可以看到 Vue 2 生命周期里的 <code>beforeCreate</code> 和 <code>created</code> ，在 Vue 3 里已被 <code>setup</code> 替代。</p><p>熟悉 Vue 2 的开发者应该都知道 Vue 有一个全局组件 <code>&lt;KeepAlive /&gt;</code> ，用于在多个组件间动态切换时缓存被移除的组件实例，当组件被包含在 <code>&lt;KeepAlive /&gt;</code> 组件里时，会多出两个生命周期钩子函数：</p><table><thead><tr><th align="center">Vue 2 生命周期</th><th align="center">Vue 3 生命周期</th><th align="center">执行时间说明</th></tr></thead><tbody><tr><td align="center">activated</td><td align="center">onActivated</td><td align="center">被激活时执行</td></tr><tr><td align="center">deactivated</td><td align="center">onDeactivated</td><td align="center">切换组件后，原组件消失前执行</td></tr></tbody></table><blockquote><p>虽然 Vue 3 依然支持 Vue 2 的生命周期，但是不建议混搭使用，前期可以继续使用 Vue 2 的生命周期作为过渡阶段慢慢适应，但还是建议尽快熟悉并完全使用 Vue 3 的生命周期编写组件。</p></blockquote><h3 id="使用-3-x-的生命周期"><a href="#使用-3-x-的生命周期" class="headerlink" title="使用 3.x 的生命周期"></a>使用 3.x 的生命周期</h3><p>在 Vue 3 的 Composition API 写法里，<strong>每个生命周期函数都要先导入才可以使用</strong>，并且所有生命周期函数统一放在 <code>setup</code> 里运行。</p><p>如果需要达到 Vue 2 的 <code>beforeCreate</code> 和 <code>created</code> 生命周期的执行时机，直接在 <code>setup</code> 里执行函数即可。</p><p>以下是几个生命周期的执行顺序对比：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, onBeforeMount, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onBeforeMount</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最终将按照生命周期的顺序输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">// 4</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure><h2 id="组件的基本写法"><a href="#组件的基本写法" class="headerlink" title="组件的基本写法"></a>组件的基本写法</h2><p>如果想在 Vue 2 里使用 TypeScript 编写组件，需要通过 Options API 的 <a href="https://v2.cn.vuejs.org/v2/api/#Vue-extend">Vue.extend</a> 语法，或者是另外一种风格 <a href="https://class-component.vuejs.org/">Class Component</a> 的语法声明组件，其中为了更好地进行类型推导， Class Component 语法更受开发者欢迎。</p><p>但是 Class Component 语法和默认的组件语法相差较大，带来了一定的学习成本，对于平时编写 JavaScript 代码很少使用 Class 的开发者，适应时间应该也会比较长。</p><p>因此 Vue 3 在保留对 Class Component 支持的同时，推出了全新的 Function-based Component ，更贴合 JavaScript 的函数式编程风格，这也是接下来要讲解并贯穿全文使用的 Composition API 新写法。</p><p>Composition API 虽然也是一个步伐迈得比较大的改动，但其组件结构并没有特别大的变化，区别比较大的地方在于组件生命周期和响应式 API 的使用，只要掌握了这些核心功能，上手 Vue 3 非常容易！</p><h3 id="回顾-Vue-2"><a href="#回顾-Vue-2" class="headerlink" title="回顾 Vue 2"></a>回顾 Vue 2</h3><p>在 Vue 2 ，常用以下三种写法声明 TypeScript 组件：可在 Vue 2 官网的 <a href="https://v2.cn.vuejs.org/v2/guide/typescript.html">TypeScript 支持</a> 一章了解更多配置说明。</p><table><thead><tr><th align="center">适用版本</th><th align="center">基本写法</th><th align="center">视图写法</th></tr></thead><tbody><tr><td align="center">Vue 2</td><td align="center">Vue.extend</td><td align="center">Template</td></tr><tr><td align="center">Vue 2</td><td align="center">Class Component</td><td align="center">Template</td></tr><tr><td align="center">Vue 2</td><td align="center">Class Component</td><td align="center">TSX</td></tr></tbody></table><blockquote><p>使用 <a href="https://v2.cn.vuejs.org/v2/api/#Vue-extend">Vue.extend</a> API 声明组件：</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一段摘选自 Vue 2 官网的代码演示</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐使用 Vue.extend 声明组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Component</span> = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(&#123;</span><br><span class="line">  <span class="comment">// 类型推断已启用</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐这种方式声明</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Component</span> = &#123;</span><br><span class="line">  <span class="comment">// 这里不会有类型推断，</span></span><br><span class="line">  <span class="comment">// 因为 TypeScript 不能确认这是 Vue 组件的选项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为了更好地获得 TypeScript 类型推导支持， 使用 <a href="https://class-component.vuejs.org/">Class Component</a> 的写法，这是 Vue 官方推出的一个装饰器插件（需要单独安装）：</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一段摘选自 Vue 2 官网的代码演示</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Component</span> <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @Component 修饰符注明了此类为一个 Vue 组件</span></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="comment">// 所有的组件选项都可以放在这里</span></span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;button @click=&quot;onClick&quot;&gt;Click!&lt;/button&gt;&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Class 声明一个组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  <span class="comment">// 初始数据可以直接声明为实例的 property</span></span><br><span class="line">  <span class="attr">message</span>: <span class="built_in">string</span> = <span class="string">&#x27;Hello!&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件方法也可以直接声明为实例的方法</span></span><br><span class="line">  <span class="title function_">onClick</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">message</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="了解-Vue-3"><a href="#了解-Vue-3" class="headerlink" title="了解 Vue 3"></a>了解 Vue 3</h3><p>Vue 3 从设计初期就考虑了 TypeScript 的支持，其中 <code>defineComponent</code> 这个 API 就是为了解决 Vue 2 对 TypeScript 类型推导不完善等问题而推出的。</p><p>在 Vue 3 ，至少有以下六种写法可以声明 TypeScript 组件：</p><table><thead><tr><th align="center">适用版本</th><th align="center">基本写法</th><th align="center">视图写法</th><th align="center">生命周期版本</th><th align="center">官方是否推荐</th></tr></thead><tbody><tr><td align="center">Vue 3</td><td align="center">Class Component</td><td align="center">Template</td><td align="center">Vue 2</td><td align="center">×</td></tr><tr><td align="center">Vue 3</td><td align="center">defineComponent</td><td align="center">Template</td><td align="center">Vue 2</td><td align="center">×</td></tr><tr><td align="center">Vue 3</td><td align="center">defineComponent</td><td align="center">Template</td><td align="center">Vue 3</td><td align="center">√</td></tr><tr><td align="center">Vue 3</td><td align="center">Class Component</td><td align="center">TSX</td><td align="center">Vue 2</td><td align="center">×</td></tr><tr><td align="center">Vue 3</td><td align="center">defineComponent</td><td align="center">TSX</td><td align="center">Vue 2</td><td align="center">×</td></tr><tr><td align="center">Vue 3</td><td align="center">defineComponent</td><td align="center">TSX</td><td align="center">Vue 3</td><td align="center">√</td></tr></tbody></table><blockquote><p>其中 <code>defineComponent + Composition API + Template</code> 的组合是 Vue 官方最为推荐的组件声明方式，接下来的内容都会以这种写法作为示范案例，也推荐开发者在学习的过程中，使用该组合进行入门。</p></blockquote><h3 id="编写Hello-World-组件"><a href="#编写Hello-World-组件" class="headerlink" title="编写Hello World 组件"></a>编写Hello World 组件</h3><p>使用 Composition API 编写一个最简单的 Hello World 组件：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- <span class="title class_">Template</span> 代码和 <span class="title class_">Vue</span> <span class="number">2</span> 一样 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;msg&quot;</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="title class_">Script</span> 代码需要使用 <span class="title class_">Vue</span> <span class="number">3</span> 的新写法--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// Vue 3 的 API 需要导入才能使用</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 使用 `defineComponent` 包裹组件代码</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 即可获得完善的 TypeScript 类型推导支持</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 在 `setup` 方法里声明变量</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> msg = <span class="string">&#x27;Hello World!&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 将需要在 `&lt;template /&gt;` 里使用的变量 `return` 出去</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      msg,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="variable constant_">CSS</span> 代码和 <span class="title class_">Vue</span> <span class="number">2</span> 一样 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.msg</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>可以看到 Vue 3 的组件也是 <code>&lt;template /&gt;</code> + <code>&lt;script /&gt;</code> + <code>&lt;style /&gt;</code> 的三段式组合，上手非常简单。</p><p>其中 Template 沿用了 Vue 2 时期类似 HTML 风格的模板写法， Style 则是使用原生 CSS 语法或者 Less 等 CSS 预处理器编写。</p><p>但需要注意的是，在 Vue 3 的 Composition API 写法里，数据或函数如果需要在 <code>&lt;template /&gt;</code> 中使用，就必须在 <code>setup</code> 里将其 <code>return</code> 出去，而仅在 <code>&lt;script /&gt;</code> 里被调用的函数或变量，不需要渲染到模板则无需 <code>return</code> 。</p><h2 id="响应式数据的变化"><a href="#响应式数据的变化" class="headerlink" title="响应式数据的变化"></a>响应式数据的变化</h2><p>响应式数据是 MVVM 数据驱动编程的特色， Vue 的设计也是受 MVVM 模型的启发，相信大部分开发者选择 MVVM 框架都是因为数据驱动编程比传统的事件驱动编程要来得方便，而选择 Vue ，则是方便中的方便。作为最重要的一个亮点， Vue 3 的响应式数据在设计上和 Vue 2 有着很大的不同。</p><h3 id="回顾-Vue-2-1"><a href="#回顾-Vue-2-1" class="headerlink" title="回顾 Vue 2"></a>回顾 Vue 2</h3><p>Vue 2 是使用了 <code>Object.defineProperty</code> API 的 <code>getter/setter</code> 来实现数据的响应性，这个方法的具体用法可以参考 MDN 的文档： <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty - MDN</a> 。</p><p>下面使用 <code>Object.defineProperty</code> 实现一个简单的双向绑定 demo ，亲自敲代码试一下可以有更多的理解：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>DefineProperty Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 输入框和按钮 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;vm.text = &#x27;Hello World&#x27;&quot;</span>&gt;</span>设置为 Hello World<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 输入框和按钮 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 文本展示 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;output&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 文本展示 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 声明一个响应式数据</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> vm = &#123;&#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(vm, <span class="string">&#x27;text&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">set</span>(<span class="params">value</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#input&#x27;</span>).<span class="property">value</span> = value</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#output&#x27;</span>).<span class="property">innerText</span> = value</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 处理输入行为</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#input&#x27;</span>).<span class="property">oninput</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        vm.<span class="property">text</span> = e.<span class="property">target</span>.<span class="property">value</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个小 demo 实现了这两个功能：</p><ol><li>输入框的输入行为只修改 <code>vm.text</code> 的数据，但会同时更新 output 标签的文本内容</li><li>点击按钮修改 <code>vm.text</code> 的数据，也会触发输入框和 output 文本的更新</li></ol><p>当然 Vue 做了非常多的工作，而非只是简单的调用了 <code>Object.defineProperty</code> ，可以在官网 <a href="https://v2.cn.vuejs.org/v2/guide/reactivity.html">深入 Vue 2 的响应式原理</a> 一章了解更多 Vue 2 的响应式原理。</p><h3 id="了解-Vue-3-1"><a href="#了解-Vue-3-1" class="headerlink" title="了解 Vue 3"></a>了解 Vue 3</h3><p>Vue 3 是使用了 <code>Proxy</code> API 的 <code>getter/setter</code> 来实现数据的响应性，这个方法的具体用法可以参考 MDN 的文档： <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy - MDN</a> 。</p><p>同样的，也来实现一个简单的双向绑定 demo ，这次使用 <code>Proxy</code> 来实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Proxy Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 输入框和按钮 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;vm.text = &#x27;Hello World&#x27;&quot;</span>&gt;</span>设置为 Hello World<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 输入框和按钮 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 文本展示 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;output&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 文本展示 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 声明一个响应式数据</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span></span><br><span class="line"><span class="language-javascript">        &#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">set</span>(<span class="params">obj, key, value</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#input&#x27;</span>).<span class="property">value</span> = value</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#output&#x27;</span>).<span class="property">innerText</span> = value</span></span><br><span class="line"><span class="language-javascript">          &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      )</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 处理输入行为</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#input&#x27;</span>).<span class="property">oninput</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        vm.<span class="property">text</span> = e.<span class="property">target</span>.<span class="property">value</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个 demo 实现的功能和使用 <code>Object.defineProperty</code> 的 demo 是完全一样的，也都是基于 <code>setter</code> 的行为完成数据更新的实现，那么为什么 Vue 3 要舍弃 <code>Object.defineProperty</code> ，换成 <code>Proxy</code> 呢？</p><p>主要原因在于 <code>Object.defineProperty</code> 有以下的不足：</p><ol><li>无法侦听数组下标的变化，对例如 <code>arr[i] = newValue</code> 这样的操作无法实时响应</li><li>无法侦听数组长度的变化，例如通过 <code>arr.length = 10</code> 去修改数组长度，无法响应</li><li>只能侦听对象的属性，对于整个对象则需要遍历，针对多级对象更是要通过嵌套来深度侦听</li><li>使用 <code>Object.assign()</code> 等方法给对象添加新属性时，也不会触发更新</li><li>更多细节上的问题 …</li></ol><p>这也是为什么 Vue 2 要提供一个 <a href="https://v2.cn.vuejs.org/v2/api/#Vue-set">Vue.set API</a> 的原因，可以在官网 <a href="https://v2.cn.vuejs.org/v2/guide/reactivity.html#%E6%A3%80%E6%B5%8B%E5%8F%98%E5%8C%96%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">Vue 2 中检测变化的注意事项</a> 一章了解更多说明。</p><p>而这些问题在 <code>Proxy</code> 都可以得到解决，可以在官网 <a href="https://cn.vuejs.org/guide/extras/reactivity-in-depth.html">深入 Vue 3 的响应式原理</a> 一章了解更多这部分的内容。</p><h3 id="用法上的变化"><a href="#用法上的变化" class="headerlink" title="用法上的变化"></a>用法上的变化</h3><p>相对于 Vue 2 在 <code>data</code> 里声明后即可通过 <code>this.xxx</code> 调用响应式数据，在 Vue 3 的生命周期里没有了 Vue 实例的 <code>this</code> 指向，需要导入 <code>ref</code> 、<code>reactive</code> 等响应式 API 才能声明并使用响应式数据。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里导入的 `ref` 是一个响应式 API</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 通过响应式 API 创建的变量具备了响应性</span></span><br><span class="line">    <span class="keyword">const</span> msg = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="响应式-API-之-ref"><a href="#响应式-API-之-ref" class="headerlink" title="响应式 API 之 ref"></a>响应式 API 之 ref</h2><h3 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h3><p><code>ref</code> 是最常用的一个响应式 API，它可以用来<strong>定义所有类型的数据，包括 Node 节点和组件</strong>。</p><p>没错，在 Vue 2 常用的以 <code>this.$refs.xxx</code> 取代 <code>document.querySelector(&#39;.xxx&#39;)</code> 来获取 Node 节点的方式，也是使用了这个 API 。</p><h4 id="API-本身的类型"><a href="#API-本身的类型" class="headerlink" title="API 本身的类型"></a>API 本身的类型</h4><p>先看 API 本身， <code>ref</code> API 是一个函数，通过接受一个泛型入参，返回一个响应式对象，所有的值都通过 <code>.value</code> 属性获取，这是 API 本身的 TS 类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `ref` API 的 TS 类型</span></span><br><span class="line"><span class="keyword">function</span> ref&lt;T&gt;(<span class="attr">value</span>: T): <span class="title class_">Ref</span>&lt;<span class="title class_">UnwrapRef</span>&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `ref` API 的返回值的 TS 类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Ref</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此在声明变量时，是使用尖括号 <code>&lt;&gt;</code> 包裹其 TS 类型，紧跟在 <code>ref</code> API 之后：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式指定 `msg.value` 是 `string` 类型</span></span><br><span class="line"><span class="keyword">const</span> msg = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br></pre></td></tr></table></figure><p>再回看该 API 本身的类型，其中使用了 <code>T</code> 泛型，这表示在传入函数的入参时，可以不需要手动指定其 TS 类型， TypeScript 会根据这个 API 所返回的响应式对象的 <code>.value</code> 属性的类型，确定当前变量的类型。</p><p>因此也可以<strong>省略显式的类型指定，像下面这样声明变量，其类型交给 TypeScript 去自动推导</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeScript 会推导 `msg.value` 是 `string` 类型</span></span><br><span class="line"><span class="keyword">const</span> msg = <span class="title function_">ref</span>(<span class="string">&#x27;Hello World&#x27;</span>)</span><br></pre></td></tr></table></figure><p>对于声明时会赋予初始值，并且在使用过程中不会改变其类型的变量，是可以省略类型的显式指定的。</p><p>而如果有显式的指定的类型，那么在一些特殊情况下，初始化时可以不必赋值，这样 TypeScript 会自动添加 <code>undefined</code> 类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> msg = ref&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(msg.<span class="property">value</span>) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">msg.<span class="property">value</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(msg.<span class="property">value</span>) <span class="comment">// Hello World!</span></span><br></pre></td></tr></table></figure><p>因为入参留空时，虽然指定了 <code>string</code> 类型，但实际上此时的值是 <code>undefined</code> ，所以实际上这个时候的 <code>msg.value</code> 是一个 <code>string | undefined</code> 的联合类型。</p><p>对于声明时不知道是什么值，在某种条件下才进行初始化的情况，就可以省略其初始值，但是切记在调用该变量的时候对 <code>.value</code> 值进行有效性判断。</p><p>而如果既不显式指定类型，也不赋予初始值，那么会被默认为 <code>any</code> 类型，除非真的无法确认类型，否则不建议这么做。</p><h4 id="API-返回值的类型"><a href="#API-返回值的类型" class="headerlink" title="API 返回值的类型"></a>API 返回值的类型</h4><p>细心的开发者还会留意到 <code>ref</code> API 类型里面还标注了一个返回值的 TS 类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Ref</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它是代表整个 Ref 变量的完整类型：</p><ul><li>上文声明 Ref 变量时，提到的 <code>string</code> 类型都是指 <code>msg.value</code> 这个 <code>.value</code> 属性的类型</li><li>而 <code>msg</code> 这个响应式变量，其本身是 <code>Ref&lt;string&gt;</code> 类型</li></ul><p>如果在开发过程中需要在函数里返回一个 Ref 变量，那么其 TypeScript 类型就可以这样写（请留意 <code>Calculator</code> 里的 <code>num</code> 变量的类型）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 `ref` API 函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 导入 `ref` API 的返回值类型</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">Ref</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 `useCalculator` 函数的返回值类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">  <span class="comment">// 这里包含了一个 Ref 变量</span></span><br><span class="line">  <span class="attr">num</span>: <span class="title class_">Ref</span>&lt;<span class="built_in">number</span>&gt;</span><br><span class="line">  <span class="attr">add</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个 “使用计算器” 的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useCalculator</span>(<span class="params"></span>): <span class="title class_">Calculator</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> num = ref&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">    num.<span class="property">value</span>++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    num,</span><br><span class="line">    add,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在执行使用计算器函数时，可以获取到一个 Ref 变量和其他方法</span></span><br><span class="line"><span class="keyword">const</span> &#123; num, add &#125; = <span class="title function_">useCalculator</span>()</span><br><span class="line"><span class="title function_">add</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="property">value</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面这个简单的例子演示了如何手动指定 Ref 变量的类型，对于逻辑复用时的函数代码抽离、插件开发等场景非常有用！当然大部分情况下可以交给 TypeScript 自动推导，但掌握其用法，在必要的时候就派得上用场了！</p><h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><p>在了解了如何对 Ref 变量进行类型声明之后，面对不同的数据类型，相信都得心应手了！但不同类型的值之间还是有少许差异和注意事项，例如上文提及该 API 可以用来定义所有类型的数据，包括 Node 节点和组件，具体可以参考下文的示例。</p><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>对字符串、布尔值等基本类型的定义方式，比较简单：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">const</span> msg = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数值</span></span><br><span class="line"><span class="keyword">const</span> count = ref&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔值</span></span><br><span class="line"><span class="keyword">const</span> isVip = ref&lt;<span class="built_in">boolean</span>&gt;(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>对于对象、数组等引用类型也适用，比如要定义一个对象：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先声明对象的格式</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在定义对象时指定该类型</span></span><br><span class="line"><span class="keyword">const</span> userInfo = ref&lt;<span class="title class_">Member</span>&gt;(&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>定义一个普通数组：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值数组</span></span><br><span class="line"><span class="keyword">const</span> uids = ref&lt;<span class="built_in">number</span>[]&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串数组</span></span><br><span class="line"><span class="keyword">const</span> names = ref&lt;<span class="built_in">string</span>[]&gt;([<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Petter&#x27;</span>, <span class="string">&#x27;Andy&#x27;</span>])</span><br></pre></td></tr></table></figure><p>定义一个对象数组：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明对象的格式</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个对象数组</span></span><br><span class="line"><span class="keyword">const</span> memberList = ref&lt;<span class="title class_">Member</span>[]&gt;([</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Petter&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h3 id="DOM-元素与子组件"><a href="#DOM-元素与子组件" class="headerlink" title="DOM 元素与子组件"></a>DOM 元素与子组件</h3><p>除了可以定义数据，<code>ref</code> 也有熟悉的用途，就是用来挂载节点，也可以挂在子组件上，对应在 Vue 2 时常用的 <code>this.$refs.xxx</code> ，起到获取 DOM 元素信息的作用。</p><p>模板部分依然是熟悉的用法，在要引用的 DOM 上添加一个 <code>ref</code> 属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 给 DOM 元素添加 `ref` 属性 --&gt;</span><br><span class="line">  &lt;p ref=&quot;msg&quot;&gt;请留意该节点，有一个 ref 属性&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 子组件也用同样的方式添加 --&gt;</span><br><span class="line">  &lt;Child ref=&quot;child&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>在 <code>&lt;script /&gt;</code> 部分有三个最基本的注意事项：</p><ol><li>在 <code>&lt;template /&gt;</code> 代码里添加的 <code>ref</code> 属性的值，对应 <code>&lt;script /&gt;</code> 里使用 <code>ref</code> API 声明的变量的名称；</li><li>请保证视图渲染完毕后再执行 DOM 或组件的相关操作（需要放到生命周期的 <code>onMounted</code> 或者 <code>nextTick</code> 函数里，这一点在 Vue 2 也是一样）；</li><li>该 Ref 变量必须 <code>return</code> 出去才可以给到 <code>&lt;template /&gt;</code> 使用，这一点是 Vue 3 生命周期的硬性要求，子组件的数据和方法如果要给父组件操作，也要 <code>return</code> 出来才可以。</li></ol><p>配合上面的 <code>&lt;template /&gt;</code> ，来看看 <code>&lt;script /&gt;</code> 部分的具体例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, onMounted, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;@cp/Child.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="title class_">Child</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 定义挂载节点，声明的类型详见下方附表</span></span><br><span class="line">    <span class="keyword">const</span> msg = ref&lt;<span class="title class_">HTMLElement</span>&gt;()</span><br><span class="line">    <span class="keyword">const</span> child = ref&lt;<span class="title class_">InstanceType</span>&lt;<span class="keyword">typeof</span> <span class="title class_">Child</span>&gt;&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请保证视图渲染完毕后再执行节点操作 e.g. `onMounted` / `nextTick`</span></span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 比如获取 DOM 的文本</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(msg.<span class="property">value</span>.<span class="property">innerText</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 或者操作子组件里的数据</span></span><br><span class="line">      child.<span class="property">value</span>.<span class="property">isShowDialog</span> = <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须 `return` 出去才可以给到 `&lt;template /&gt;` 使用</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg,</span><br><span class="line">      child,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>关于 DOM 和子组件的 TS 类型声明，可参考以下规则：</p><table><thead><tr><th align="left">节点类型</th><th align="left">声明类型</th><th align="left">参考文档</th></tr></thead><tbody><tr><td align="left">DOM 元素</td><td align="left">使用 HTML 元素接口</td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model#html_%E5%85%83%E7%B4%A0%E6%8E%A5%E5%8F%A3">HTML 元素接口</a></td></tr><tr><td align="left">子组件</td><td align="left">使用 <code>InstanceType</code> 配合 <code>typeof</code> 获取子组件的类型</td><td align="left"><a href="https://zhuanlan.zhihu.com/p/311150643">typeof 操作符</a></td></tr></tbody></table><blockquote><p>单纯使用 <code>typeof Child</code> 虽然可以获得 Child.vue 组件的 Props 和方法等提示，但目前在 VSCode 的类型推导还不够智能，缺乏更有效的代码补全支持。</p><p>上文使用的 <code>InstanceType&lt;T&gt;</code> 是 TypeScript 提供的一个工具类型，可以获取构造函数类型的实例类型，因此将组件的类型声明为 <code>InstanceType&lt;typeof Child&gt;</code> ，不仅可以得到更完善的类型提示，在编程过程中还可以让编辑器提供更完善的代码补全功能。</p></blockquote><h3 id="变量的读取与赋值"><a href="#变量的读取与赋值" class="headerlink" title="变量的读取与赋值"></a>变量的读取与赋值</h3><p>前面在介绍 API 类型的时候已经了解，通过 <code>ref</code> 声明的变量会全部变成对象，不管定义的是什么类型的值，都会转化为一个 Ref 对象，其中 Ref 对象具有指向内部值的单个 Property <code>.value</code>。</p><p>也就是说，任何 Ref 对象的值都必须通过 <code>xxx.value</code> 才可以正确获取。</p><p>请牢记上面这句话，初用 Vue 3 的开发者很多 BUG 都是由这个问题引起的（包括笔者刚开始使用 Vue 3 的那段时间，嘿嘿）。</p><h4 id="读取变量"><a href="#读取变量" class="headerlink" title="读取变量"></a>读取变量</h4><p>平时对于普通变量的值，读取的时候都是直接调用其变量名即可：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取一个字符串</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">msg</span>: <span class="built_in">string</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取一个数组</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">uids</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uids[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>而 Ref 对象的值的读取，切记！必须通过 <code>.value</code> ！</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取一个字符串</span></span><br><span class="line"><span class="keyword">const</span> msg = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(msg.<span class="property">value</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取一个数组</span></span><br><span class="line"><span class="keyword">const</span> uids = ref&lt;<span class="built_in">number</span>[]&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uids.<span class="property">value</span>[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h4 id="为变量赋值"><a href="#为变量赋值" class="headerlink" title="为变量赋值"></a>为变量赋值</h4><p>普通变量需要使用 <code>let</code> 声明才可以修改其值，由于 Ref 对象是个引用类型，所以可以使用 <code>const</code> 声明，直接通过 <code>.value</code> 修改。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个字符串变量</span></span><br><span class="line"><span class="keyword">const</span> msg = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;Hi!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待 1s 后修改它的值</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  msg.<span class="property">value</span> = <span class="string">&#x27;Hello!&#x27;</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>因此日常业务中，像在对接服务端 API 的接口数据时，可以自由地使用 <code>forEach</code>、<code>map</code>、<code>filter</code> 等方法操作 Ref 数组，或者直接重置它，而不必担心数据失去响应性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = ref&lt;<span class="built_in">string</span>[]&gt;([])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取接口的数据</span></span><br><span class="line">data.<span class="property">value</span> = api.<span class="property">data</span>.<span class="title function_">map</span>(<span class="function">(<span class="params"><span class="attr">item</span>: <span class="built_in">any</span></span>) =&gt;</span> item.<span class="property">text</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置数组</span></span><br><span class="line">data.<span class="property">value</span> = []</span><br></pre></td></tr></table></figure><p>为什么突然要说这个呢？因为涉及到下一部分的知识，关于 <code>reactive</code> API 在使用上的注意事项。</p><h2 id="响应式-API-之-reactive"><a href="#响应式-API-之-reactive" class="headerlink" title="响应式 API 之 reactive"></a>响应式 API 之 reactive</h2><p><code>reactive</code> 是继 <code>ref</code> 之后最常用的一个响应式 API 了，相对于 <code>ref</code> ，它的局限性在于只适合对象、数组。</p><p>使用 <code>reactive</code> 的好处就是写法跟平时的对象、数组几乎一模一样，但它也带来了一些特殊注意点，请留意赋值部分的特殊说明。</p><h3 id="类型声明与定义"><a href="#类型声明与定义" class="headerlink" title="类型声明与定义"></a>类型声明与定义</h3><p><code>reactive</code> 变量的声明方式没有 <code>ref</code> 的变化那么大，基本上和普通变量一样，它的 TS 类型如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> reactive&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(<span class="attr">target</span>: T): <span class="title class_">UnwrapNestedRefs</span>&lt;T&gt;</span><br></pre></td></tr></table></figure><p>可以看到其用法还是比较简单的，下面是一个 Reactive 对象的声明方式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明对象的类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">userInfo</span>: <span class="title class_">Member</span> = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>下面是 Reactive 数组的声明方式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">uids</span>: <span class="built_in">number</span>[] = <span class="title function_">reactive</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>还可以声明一个 Reactive 对象数组：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象数组也是先声明其中的对象类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再定义一个为对象数组</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">userList</span>: <span class="title class_">Member</span>[] = <span class="title function_">reactive</span>([</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Petter&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Andy&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h3 id="变量的读取与赋值-1"><a href="#变量的读取与赋值-1" class="headerlink" title="变量的读取与赋值"></a>变量的读取与赋值</h3><p>虽然 <code>reactive</code> API 在使用上没有像 <code>ref</code> API 一样有 <code>.value</code> 的心智负担，但也有一些注意事项要留意。</p><h4 id="处理对象"><a href="#处理对象" class="headerlink" title="处理对象"></a>处理对象</h4><p>Reactive 对象在读取或者修改字段的值时，与普通对象是一样的，这部分没有太多问题。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明对象的类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">userInfo</span>: <span class="title class_">Member</span> = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取用户名</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInfo.<span class="property">name</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改用户名</span></span><br><span class="line">userInfo.<span class="property">name</span> = <span class="string">&#x27;Petter&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="处理数组"><a href="#处理数组" class="headerlink" title="处理数组"></a>处理数组</h4><p>但是 Reactive 数组和普通数组会有一些区别。</p><p>普通数组在 “重置” 或者 “修改值” 时都可以直接操作：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个普通数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">uids</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从另外一个对象数组里提取数据过来</span></span><br><span class="line">uids = api.<span class="property">data</span>.<span class="title function_">map</span>(<span class="function">(<span class="params"><span class="attr">item</span>: <span class="built_in">any</span></span>) =&gt;</span> item.<span class="property">id</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并另外一个数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">newUids</span>: <span class="built_in">number</span>[] = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">uids = [...uids, ...newUids]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置数组</span></span><br><span class="line">uids = []</span><br></pre></td></tr></table></figure><p>但在 Vue 3 ，如果使用 <code>reactive</code> 定义数组，则不能这么处理，必须只使用那些不会改变引用地址的操作。比如要从服务端 API 接口获取翻页数据时，通常要先重置数组，再异步添加数据，如果使用常规的重置，会导致这个变量失去响应性：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">uids</span>: <span class="built_in">number</span>[] = <span class="title function_">reactive</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不推荐使用这种方式，会丢失响应性</span></span><br><span class="line"><span class="comment"> * 异步添加数据后，模板不会响应更新</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">uids = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步获取数据后，模板依然是空数组</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  uids.<span class="title function_">push</span>(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>要让数据依然保持响应性，则必须在关键操作时，不破坏响应性 API ，以下是推荐的操作方式，通过重置数组的 <code>length</code> 长度来实现数据的重置：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">uids</span>: <span class="built_in">number</span>[] = <span class="title function_">reactive</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 推荐使用这种方式，不会破坏响应性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">uids.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步获取数据后，模板可以正确的展示</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  uids.<span class="title function_">push</span>(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h3 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h3><p>不要对 Reactive 数据进行 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">ES6 的解构</a> 操作，因为解构后得到的变量会失去响应性。</p><p>比如这些情况，在 2s 后都得不到新的 name 信息：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 定义一个带有响应性的对象</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">userInfo</span>: <span class="title class_">Member</span> = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;Petter&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 2s 后更新 `userInfo`</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      userInfo.<span class="property">name</span> = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个变量在 2s 后不会同步更新</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">newUserInfo</span>: <span class="title class_">Member</span> = &#123; ...userInfo &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个变量在 2s 后不会再同步更新</span></span><br><span class="line">    <span class="keyword">const</span> &#123; name &#125; = userInfo</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这样 `return` 出去给模板用，在 2s 后也不会同步更新</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...userInfo,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="响应式-API-之-toRef-与-toRefs"><a href="#响应式-API-之-toRef-与-toRefs" class="headerlink" title="响应式 API 之 toRef 与 toRefs"></a>响应式 API 之 toRef 与 toRefs</h2><p>相信各位开发者看到这里时，应该已经对 <code>ref</code> 和 <code>reactive</code> API 都有所了解了，为了方便开发者使用， Vue 3 还推出了两个与之相关的 API ： <code>toRef</code> 和 <code>toRefs</code> ，都是用于 <code>reactive</code> 向 <code>ref</code> 转换。</p><h3 id="各自的作用"><a href="#各自的作用" class="headerlink" title="各自的作用"></a>各自的作用</h3><p>这两个 API 在拼写上非常接近，顾名思义，一个是只转换一个字段，一个是转换所有字段，转换后将得到新的变量，并且新变量和原来的变量可以保持同步更新。</p><table><thead><tr><th align="left">API</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">toRef</td><td align="left">创建一个新的 Ref 变量，转换 Reactive 对象的某个字段为 Ref 变量</td></tr><tr><td align="left">toRefs</td><td align="left">创建一个新的对象，它的每个字段都是 Reactive 对象各个字段的 Ref 变量</td></tr></tbody></table><p>光看概念可能不容易理解，来看下面的例子，先声明一个 <code>reactive</code> 变量：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">userInfo</span>: <span class="title class_">Member</span> = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Petter&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后分别看看这两个 API 应该怎么使用。</p><h3 id="使用-toRef"><a href="#使用-toRef" class="headerlink" title="使用 toRef"></a>使用 toRef</h3><p>先看这个转换单个字段的 <code>toRef</code> API ，了解了它的用法之后，再去看 <code>toRefs</code> 就很容易理解了。</p><h4 id="API-类型和基本用法"><a href="#API-类型和基本用法" class="headerlink" title="API 类型和基本用法"></a>API 类型和基本用法</h4><p><code>toRef</code> API 的 TS 类型如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `toRef` API 的 TS 类型</span></span><br><span class="line"><span class="keyword">function</span> toRef&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>, K <span class="keyword">extends</span> keyof T&gt;(</span><br><span class="line">  <span class="attr">object</span>: T,</span><br><span class="line">  <span class="attr">key</span>: K,</span><br><span class="line">  <span class="attr">defaultValue</span>?: T[K]</span><br><span class="line">): <span class="title class_">ToRef</span>&lt;T[K]&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `toRef` API 的返回值的 TS 类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ToRef</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="title class_">Ref</span> ? T : <span class="title class_">Ref</span>&lt;T&gt;</span><br></pre></td></tr></table></figure><p>通过接收两个必传的参数（第一个是 <code>reactive</code> 对象, 第二个是要转换的 <code>key</code> ），返回一个 Ref 变量，在适当的时候也可以传递第三个参数，为该变量设置默认值。</p><p>以上文声明好的 <code>userInfo</code> 为例，如果想转换 <code>name</code> 这个字段为 Ref 变量，只需要这样操作：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="title function_">toRef</span>(userInfo, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">value</span>) <span class="comment">// Petter</span></span><br></pre></td></tr></table></figure><p>等号左侧的 <code>name</code> 变量此时是一个 Ref 变量，这里因为 TypeScript 可以对其自动推导，因此声明时可以省略 TS 类型的显式指定，实际上该变量的类型是 <code>Ref&lt;string&gt;</code> 。</p><p>所以之后在读取和赋值时，就需要使用 <code>name.value</code> 来操作，在重新赋值时会同时更新 <code>name</code> 和 <code>userInfo.name</code> 的值：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改前先查看初始值</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="title function_">toRef</span>(userInfo, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">value</span>) <span class="comment">// Petter</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInfo.<span class="property">name</span>) <span class="comment">// Petter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 Ref 变量的值，两者同步更新</span></span><br><span class="line">name.<span class="property">value</span> = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">value</span>) <span class="comment">// Tom</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInfo.<span class="property">name</span>) <span class="comment">// Tom</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 Reactive 对象上该属性的值，两者也是同步更新</span></span><br><span class="line">userInfo.<span class="property">name</span> = <span class="string">&#x27;Jerry&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">value</span>) <span class="comment">// Jerry</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInfo.<span class="property">name</span>) <span class="comment">// Jerry</span></span><br></pre></td></tr></table></figure><p>这个 API 也可以接收一个 Reactive 数组，此时第二个参数应该传入数组的下标：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这一次声明的是数组</span></span><br><span class="line"><span class="keyword">const</span> words = <span class="title function_">reactive</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过下标 `0` 转换第一个 item</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">toRef</span>(words, <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">value</span>) <span class="comment">// a</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(words[<span class="number">0</span>]) <span class="comment">// a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过下标 `2` 转换第三个 item</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="title function_">toRef</span>(words, <span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">value</span>) <span class="comment">// c</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(words[<span class="number">2</span>]) <span class="comment">// c</span></span><br></pre></td></tr></table></figure><h4 id="设置默认值"><a href="#设置默认值" class="headerlink" title="设置默认值"></a>设置默认值</h4><p>如果 Reactive 对象上有一个属性本身没有初始值，也可以传递第三个参数进行设置（默认值仅对 Ref 变量有效）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="comment">// 类型上新增一个属性，因为是可选的，因此默认值会是 `undefined`</span></span><br><span class="line">  <span class="attr">age</span>?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明变量时省略 `age` 属性</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">userInfo</span>: <span class="title class_">Member</span> = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Petter&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时为了避免程序运行错误，可以指定一个初始值</span></span><br><span class="line"><span class="comment">// 但初始值仅对 Ref 变量有效，不会影响 Reactive 字段的值</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="title function_">toRef</span>(userInfo, <span class="string">&#x27;age&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age.<span class="property">value</span>)  <span class="comment">// 18</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInfo.<span class="property">age</span>) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 除非重新赋值，才会使两者同时更新</span></span><br><span class="line">age.<span class="property">value</span> = <span class="number">25</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age.<span class="property">value</span>)  <span class="comment">// 25</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInfo.<span class="property">age</span>) <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><p>数组也是同理，对于可能不存在的下标，可以传入默认值避免项目的逻辑代码出现问题：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> words = <span class="title function_">reactive</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当下标对应的值不存在时，也是返回 `undefined`</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="title function_">toRef</span>(words, <span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d.<span class="property">value</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(words[<span class="number">3</span>]) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置了默认值之后，就会对 Ref 变量使用默认值， Reactive 数组此时不影响</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="title function_">toRef</span>(words, <span class="number">4</span>, <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">value</span>) <span class="comment">// e</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(words[<span class="number">4</span>]) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h4 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h4><p>这个 API 还有一个特殊用法，但不建议在 TypeScript 里使用。</p><p>在 <code>toRef</code> 的过程中，如果使用了原对象上面不存在的 <code>key</code> ，那么定义出来的 Ref 变量的 <code>.value</code> 值将会是 <code>undefined</code> 。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 众所周知， Petter 是没有女朋友的</span></span><br><span class="line"><span class="keyword">const</span> girlfriend = <span class="title function_">toRef</span>(userInfo, <span class="string">&#x27;girlfriend&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(girlfriend.<span class="property">value</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInfo.<span class="property">girlfriend</span>) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时 Reactive 对象上只有两个 Key</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(userInfo)) <span class="comment">// [&#x27;id&#x27;, &#x27;name&#x27;]</span></span><br></pre></td></tr></table></figure><p>如果对这个不存在的 <code>key</code> 的 Ref 变量进行赋值，那么原来的 Reactive 对象也会同步增加这个 <code>key</code>，其值也会同步更新。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值后，不仅 Ref 变量得到了 `Marry` ， Reactive 对象也得到了 `Marry`</span></span><br><span class="line">girlfriend.<span class="property">value</span> = <span class="string">&#x27;Marry&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(girlfriend.<span class="property">value</span>) <span class="comment">// &#x27;Marry&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInfo.<span class="property">girlfriend</span>) <span class="comment">// &#x27;Marry&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时 Reactive 对象上有了三个 Key</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(userInfo)) <span class="comment">// [&#x27;id&#x27;, &#x27;name&#x27;, &#x27;girlfriend&#x27;]</span></span><br></pre></td></tr></table></figure><p>为什么强调不要在 TypeScript 里使用呢？因为在编译时，无法通过 TypeScript 的类型检查：</p><p>如果不得不使用这种情况，可以考虑使用 any 类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将该类型直接指定为 `any`</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Member</span> = <span class="built_in">any</span></span><br><span class="line"><span class="comment">// 当然一般都是 `const userInfo: any`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者保持接口类型的情况下，允许任意键值</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 `Record` 也是同理</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Member</span> = <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="使用-toRefs"><a href="#使用-toRefs" class="headerlink" title="使用 toRefs"></a>使用 toRefs</h3><p>在了解了 <code>toRef</code> API 之后，来看看 <code>toRefs</code> 的用法。</p><h4 id="API-类型和基本用法-1"><a href="#API-类型和基本用法-1" class="headerlink" title="API 类型和基本用法"></a>API 类型和基本用法</h4><p>先看看它的 TS 类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> toRefs&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(</span><br><span class="line">  <span class="attr">object</span>: T</span><br><span class="line">): &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: <span class="title class_">ToRef</span>&lt;T[K]&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ToRef</span> = T <span class="keyword">extends</span> <span class="title class_">Ref</span> ? T : <span class="title class_">Ref</span>&lt;T&gt;</span><br></pre></td></tr></table></figure><p>与 <code>toRef</code> 不同， <code>toRefs</code> 只接收了一个参数，是一个 <code>reactive</code> 变量。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个 Reactive 变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">userInfo</span>: <span class="title class_">Member</span> = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Petter&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传给 `toRefs` 作为入参</span></span><br><span class="line"><span class="keyword">const</span> userInfoRefs = <span class="title function_">toRefs</span>(userInfo)</span><br></pre></td></tr></table></figure><p>此时这个新的 <code>userInfoRefs</code> 变量，它的 TS 类型就不再是 <code>Member</code> 了，而应该是：<code>ToRefs&lt;Member&gt;</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 `toRefs` API 的类型</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">ToRefs</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文代码省略...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将原来的类型传给 API 的类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">userInfoRefs</span>: <span class="title class_">ToRefs</span>&lt;<span class="title class_">Member</span>&gt; = <span class="title function_">toRefs</span>(userInfo)</span><br></pre></td></tr></table></figure><p>也可以重新编写一个新的类型来指定它，因为每个字段都是与原来关联的 Ref 变量，所以也可以这样声明：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 `ref` API 的类型</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">Ref</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文代码省略...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新声明的类型每个字段都是一个 Ref 变量的类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MemberRefs</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="title class_">Ref</span>&lt;<span class="built_in">number</span>&gt;</span><br><span class="line">  <span class="attr">name</span>: <span class="title class_">Ref</span>&lt;<span class="built_in">string</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用新的类型进行声明</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">userInfoRefs</span>: <span class="title class_">MemberRefs</span> = <span class="title function_">toRefs</span>(userInfo)</span><br></pre></td></tr></table></figure><p>当然实际上日常使用时并不需要手动指定其类型， TypeScript 会自动推导，可以节约非常多的开发工作量。</p><p>和 <code>toRef</code> API 一样，这个 API 也是可以对数组进行转换：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> words = <span class="title function_">reactive</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="keyword">const</span> wordsRefs = <span class="title function_">toRefs</span>(words)</span><br></pre></td></tr></table></figure><p>此时新数组的类型是 <code>Ref&lt;string&gt;[]</code> ，不再是原来的 <code>string[]</code> 类型。</p><h4 id="解构与赋值"><a href="#解构与赋值" class="headerlink" title="解构与赋值"></a>解构与赋值</h4><p>转换后的 Reactive 对象或数组支持 ES6 的解构，并且不会失去响应性，因为解构后的每一个变量都具备响应性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了提高开发效率，可以直接将 Ref 变量直接解构出来使用</span></span><br><span class="line"><span class="keyword">const</span> &#123; name &#125; = <span class="title function_">toRefs</span>(userInfo)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">value</span>) <span class="comment">// Petter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时对解构出来的变量重新赋值，原来的变量也可以同步更新</span></span><br><span class="line">name.<span class="property">value</span> = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">value</span>) <span class="comment">// Tom</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInfo.<span class="property">name</span>) <span class="comment">// Tom</span></span><br></pre></td></tr></table></figure><p>这一点和直接解构 Reactive 变量有非常大的不同，直接解构 Reactive 变量，得到的是一个普通的变量，不再具备响应性。</p><p>这个功能在使用 Hooks 函数非常好用（在 Vue 3 里也叫可组合函数， Composable Functions ），还是以一个计算器函数为例，这一次将其修改为内部有一个 Reactive 的数据状态中心，在函数返回时解构为多个 Ref 变量：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 `useCalculator` 数据状态类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CalculatorState</span> &#123;</span><br><span class="line">  <span class="comment">// 这是要用来计算操作的数据</span></span><br><span class="line">  <span class="attr">num</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="comment">// 这是每次计算时要增加的幅度</span></span><br><span class="line">  <span class="attr">step</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个 “使用计算器” 的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useCalculator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 通过数据状态中心的形式，集中管理内部变量</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">state</span>: <span class="title class_">CalculatorState</span> = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">num</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">step</span>: <span class="number">10</span>,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 功能函数也是通过数据中心变量去调用</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">    state.<span class="property">num</span> += state.<span class="property">step</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...<span class="title function_">toRefs</span>(state),</span><br><span class="line">    add,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在调用 <code>useCalculator</code> 函数时，可以通过解构直接获取到 Ref 变量，不需要再进行额外的转换工作。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解构出来的 `num` 和 `step` 都是 Ref 变量</span></span><br><span class="line"><span class="keyword">const</span> &#123; num, step, add &#125; = <span class="title function_">useCalculator</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="property">value</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(step.<span class="property">value</span>) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用计算器的方法，数据也是会得到响应式更新</span></span><br><span class="line"><span class="title function_">add</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="property">value</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h3 id="为什么要进行转换"><a href="#为什么要进行转换" class="headerlink" title="为什么要进行转换"></a>为什么要进行转换</h3><p>关于为什么要出这么两个 API ，官方文档没有特别说明，不过经过笔者在业务中的一些实际使用感受，以及在写上一节 <code>reactive</code> 的 特别注意，可能知道一些使用理由。</p><p>关于 <code>ref</code> 和 <code>reactive</code> 这两个 API 的好处就不重复了，但是在使用的过程中，各自都有不方便的地方：</p><p><code>ref</code> API 虽然在 <code>&lt;template /&gt;</code> 里使用起来方便，但是在 <code>&lt;script /&gt;</code> 里进行读取 &#x2F; 赋值的时候，要一直记得加上 <code>.value</code> ，否则 BUG 就来了。</p><p><code>reactive</code> API 虽然在使用的时候，因为知道它本身是一个对象，所以不会忘记通过 <code>foo.bar</code> 这样的格式去操作，但是在 <code>&lt;template /&gt;</code> 渲染的时候，又因此不得不每次都使用 <code>foo.bar</code> 的格式去渲染。</p><p>那么有没有办法，既可以在编写 <code>&lt;script /&gt;</code> 的时候不容易出错，在写 <code>&lt;template /&gt;</code> 的时候又比较简单呢？</p><p>于是， <code>toRef</code> 和 <code>toRefs</code> 因此诞生。</p><h3 id="什么场景下比较适合使用它们"><a href="#什么场景下比较适合使用它们" class="headerlink" title="什么场景下比较适合使用它们"></a>什么场景下比较适合使用它们</h3><p>从便利性和可维护性来说，最好只在功能单一、代码量少的组件里使用，比如一个表单组件，通常表单的数据都放在一个对象里。</p><p>当然也可以把所有的数据都定义到一个 <code>data</code> 里，再去 <code>data</code> 里面取值，但是没有必要为了转换而转换，否则不如使用 Options API 风格。</p><h3 id="在业务中的具体运用"><a href="#在业务中的具体运用" class="headerlink" title="在业务中的具体运用"></a>在业务中的具体运用</h3><p>继续使用上文一直在使用的 <code>userInfo</code> 来当案例，以一个用户信息表的小 demo 做个演示。</p><p>在 <code>&lt;script /&gt;</code> 部分：</p><ol><li><p>先用 <code>reactive</code> 定义一个源数据，所有的数据更新，都是修改这个对象对应的值，按照对象的写法维护数据</p></li><li><p>再通过 <code>toRefs</code> 定义一个给 <code>&lt;template /&gt;</code> 使用的对象，这样可以得到一个每个字段都是 Ref 变量的新对象</p></li><li><p>在 <code>return</code> 的时候，对步骤 2 里的 <code>toRefs</code> 对象进行解构，这样导出去就是各个字段对应的 Ref 变量，而不是一整个对象</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, reactive, toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">gender</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 定义一个 reactive 对象</span></span><br><span class="line">    <span class="keyword">const</span> userInfo = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;Petter&#x27;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">      <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个新的对象，它本身不具备响应性，但是它的字段全部是 Ref 变量</span></span><br><span class="line">    <span class="keyword">const</span> userInfoRefs = <span class="title function_">toRefs</span>(userInfo)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 2s 后更新 `userInfo`</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      userInfo.<span class="property">id</span> = <span class="number">2</span></span><br><span class="line">      userInfo.<span class="property">name</span> = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">      userInfo.<span class="property">age</span> = <span class="number">20</span></span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里解构 `toRefs` 对象才能继续保持响应性</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...userInfoRefs,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>在 <code>&lt;template /&gt;</code> 部分：由于 <code>return</code> 出来的都是 Ref 变量，所以在模板里可以直接使用 <code>userInfo</code> 各个字段的 <code>key</code> ，不再需要写很长的 <code>userInfo.name</code> 了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;user-info&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;key&quot;</span>&gt;</span>ID:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;value&quot;</span>&gt;</span>&#123;&#123; id &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;key&quot;</span>&gt;</span>name:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;value&quot;</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;key&quot;</span>&gt;</span>age:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;value&quot;</span>&gt;</span>&#123;&#123; age &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;key&quot;</span>&gt;</span>gender:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;value&quot;</span>&gt;</span>&#123;&#123; gender &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h3><p>请注意是否有相同命名的变量存在，比如上面在 <code>return</code> 给 <code>&lt;template /&gt;</code> 使用时，在解构 <code>userInfoRefs</code> 的时候已经包含了一个 <code>name</code> 字段，此时如果还有一个单独的变量也叫 <code>name</code> ，就会出现渲染上的数据显示问题。</p><p>此时它们在 <code>&lt;template /&gt;</code> 里哪个会生效，取决于谁排在后面，因为 <code>return</code> 出去的其实是一个对象，在对象里，如果存在相同的 <code>key</code> ，则后面的会覆盖前面的。</p><p>下面这种情况，会以单独的 <code>name</code> 为渲染数据：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  ...userInfoRefs,</span><br><span class="line">  name,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而下面这种情况，则是以 <code>userInfoRefs</code> 里的 <code>name</code> 为渲染数据：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  name,</span><br><span class="line">  ...userInfoRefs,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以当决定使用 <code>toRef</code> 和 <code>toRefs</code> API 的时候，请注意这个特殊情况！</p><h2 id="函数的声明和使用"><a href="#函数的声明和使用" class="headerlink" title="函数的声明和使用"></a>函数的声明和使用</h2><p>在了解了响应式数据如何使用之后，接下来就要开始了解函数了。</p><p>在 Vue 2 ，函数通常是作为当前组件实例上的方法在 <code>methods</code> 里声明，然后再在 <code>mounted</code> 等生命周期里调用，或者是在模板里通过 Click 等行为触发，由于组件内部经常需要使用 <code>this</code> 获取组件实例，因此不能使用箭头函数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">num</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mounted</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">add</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 不可以使用 `add: () =&gt; this.num++`</span></span><br><span class="line">    <span class="attr">add</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">num</span>++</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Vue 3 则灵活了很多，可以使用普通函数、 Class 类、箭头函数、匿名函数等等进行声明，可以将其写在 <code>setup</code> 里直接使用，也可以抽离在独立的 <code>.js</code> &#x2F; <code>.ts</code> 文件里再导入使用。</p><p>需要在组件创建时自动执行的函数，其执行时机需要遵循 Vue 3 的生命周期，需要在模板里通过 <code>@click</code>、<code>@change</code> 等行为触发，和变量一样，需要把函数名在 <code>setup</code> 里进行 <code>return</code> 出去。</p><p>下面是一个简单的例子，方便开发者更直观地了解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 在这里点击执行 `return` 出来的方法 --&gt;</span><br><span class="line">  &lt;button @click=&quot;updateMsg&quot;&gt;修改MSG&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, onMounted, ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const msg = ref&lt;string&gt;(&#x27;Hello World!&#x27;)</span><br><span class="line"></span><br><span class="line">    // 这个要暴露给模板使用，必须 `return` 才可以使用</span><br><span class="line">    function updateMsg() &#123;</span><br><span class="line">      msg.value = &#x27;Hi World!&#x27;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 这个要在页面载入时执行，无需 `return` 出去</span><br><span class="line">    const init = () =&gt; &#123;</span><br><span class="line">      console.log(&#x27;init&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onMounted(() =&gt; &#123;</span><br><span class="line">      init()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      msg,</span><br><span class="line">      updateMsg,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="数据的侦听"><a href="#数据的侦听" class="headerlink" title="数据的侦听"></a>数据的侦听</h2><p>侦听数据变化也是组件里的一项重要工作，比如侦听路由变化、侦听参数变化等等。</p><p>Vue 3 在保留原来的 <code>watch</code> 功能之外，还新增了一个 <code>watchEffect</code> 帮助更简单地进行侦听。</p><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>在 Vue 3 ，新版的 <code>watch</code> 和 Vue 2 的旧版写法对比，在使用方式上变化非常大！</p><h4 id="回顾-Vue-2-2"><a href="#回顾-Vue-2-2" class="headerlink" title="回顾 Vue 2"></a>回顾 Vue 2</h4><p>在 Vue 2 是这样用的，和 <code>data</code> 、 <code>methods</code> 都在同级配置：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 注意这里，放在 `data` 、 `methods` 同个级别</span></span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且类型繁多，选项式 API 的类型如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123; [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="title class_">Function</span> | <span class="title class_">Object</span> | <span class="title class_">Array</span>&#125;</span><br></pre></td></tr></table></figure><p>联合类型过多，意味着用法复杂，下面是个很好的例子，虽然出自 <a href="https://cn.vuejs.org/api/options-state.html#watch">官网</a> 的用法介绍，但过于繁多的用法也反映出来对初学者不太友好，初次接触可能会觉得一头雾水：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">c</span>: &#123;</span><br><span class="line">        <span class="attr">d</span>: <span class="number">4</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">e</span>: <span class="number">5</span>,</span><br><span class="line">      <span class="attr">f</span>: <span class="number">6</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="comment">// 侦听顶级 Property</span></span><br><span class="line">    <span class="title function_">a</span>(<span class="params">val, oldVal</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`new: <span class="subst">$&#123;val&#125;</span>, old: <span class="subst">$&#123;oldVal&#125;</span>`</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 字符串方法名</span></span><br><span class="line">    <span class="attr">b</span>: <span class="string">&#x27;someMethod&#x27;</span>,</span><br><span class="line">    <span class="comment">// 该回调会在任何被侦听的对象的 Property 改变时被调用，不论其被嵌套多深</span></span><br><span class="line">    <span class="attr">c</span>: &#123;</span><br><span class="line">      <span class="title function_">handler</span>(<span class="params">val, oldVal</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;c changed&#x27;</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 侦听单个嵌套 Property</span></span><br><span class="line">    <span class="string">&#x27;c.d&#x27;</span>: <span class="keyword">function</span> (<span class="params">val, oldVal</span>) &#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 该回调将会在侦听开始之后被立即调用</span></span><br><span class="line">    <span class="attr">e</span>: &#123;</span><br><span class="line">      <span class="title function_">handler</span>(<span class="params">val, oldVal</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;e changed&#x27;</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 可以传入回调数组，它们会被逐一调用</span></span><br><span class="line">    <span class="attr">f</span>: [</span><br><span class="line">      <span class="string">&#x27;handle1&#x27;</span>,</span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">handle2</span>(<span class="params">val, oldVal</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;handle2 triggered&#x27;</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">handler</span>: <span class="keyword">function</span> <span class="title function_">handle3</span>(<span class="params">val, oldVal</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;handle3 triggered&#x27;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">someMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b changed&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">handle1</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;handle 1 triggered&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>另外需要注意的是，不能使用箭头函数来定义 Watcher 函数 (例如 <code>searchQuery: newValue =&gt; this.updateAutocomplete(newValue)</code> )。</p><p>因为箭头函数绑定了父级作用域的上下文，所以 <code>this</code> 将不会按照期望指向组件实例， <code>this.updateAutocomplete</code> 将是 <code>undefined</code> 。</p></blockquote><p>Vue 2 也可以通过 <code>this.$watch()</code> 这个 API 的用法来实现对某个数据的侦听，它接受三个参数： <code>source</code> 、 <code>callback</code> 和 <code>options</code> 。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 生命周期钩子</span></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.$watch(<span class="string">&#x27;a&#x27;</span>, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="了解-Vue-3-2"><a href="#了解-Vue-3-2" class="headerlink" title="了解 Vue 3"></a>了解 Vue 3</h4><p>在 Vue 3 的组合式 API 写法， <code>watch</code> 是一个可以接受 3 个参数的函数（保留了 Vue 2 的 <code>this.$watch</code> 这种用法），在使用层面上简单了很多。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个用法走天下</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  source, <span class="comment">// 必传，要侦听的数据源</span></span><br><span class="line">  callback <span class="comment">// 必传，侦听到变化后要执行的回调函数</span></span><br><span class="line">  <span class="comment">// options // 可选，一些侦听选项</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>下面的内容都基于 Vue 3 的组合式 API 用法展开讲解。</p><h4 id="API-的-TS-类型"><a href="#API-的-TS-类型" class="headerlink" title="API 的 TS 类型"></a>API 的 TS 类型</h4><p>在了解用法之前，先对它的 TS 类型声明做一个简单的了解， watch 作为组合式 API ，根据使用方式有两种类型声明：</p><ol><li><p>基础用法的 TS 类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watch 部分的 TS 类型</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">function</span> watch&lt;T, <span class="title class_">Immediate</span> <span class="keyword">extends</span> <span class="title class_">Readonly</span>&lt;<span class="built_in">boolean</span>&gt; = <span class="literal">false</span>&gt;(</span><br><span class="line">  <span class="attr">source</span>: <span class="title class_">WatchSource</span>&lt;T&gt;,</span><br><span class="line">  <span class="attr">cb</span>: <span class="title class_">WatchCallback</span>&lt;T, <span class="title class_">Immediate</span> <span class="keyword">extends</span> <span class="literal">true</span> ? T | <span class="literal">undefined</span> : T&gt;,</span><br><span class="line">  <span class="attr">options</span>?: <span class="title class_">WatchOptions</span>&lt;<span class="title class_">Immediate</span>&gt;</span><br><span class="line">): <span class="title class_">WatchStopHandle</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></li><li><p>批量侦听的 TS 类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watch 部分的 TS 类型</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">function</span> watch&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="title class_">MultiWatchSources</span>,</span><br><span class="line">  <span class="title class_">Immediate</span> <span class="keyword">extends</span> <span class="title class_">Readonly</span>&lt;<span class="built_in">boolean</span>&gt; = <span class="literal">false</span></span><br><span class="line">&gt;(</span><br><span class="line">  <span class="attr">sources</span>: [...T],</span><br><span class="line">  <span class="attr">cb</span>: <span class="title class_">WatchCallback</span>&lt;<span class="title class_">MapSources</span>&lt;T, <span class="literal">false</span>&gt;, <span class="title class_">MapSources</span>&lt;T, <span class="title class_">Immediate</span>&gt;&gt;,</span><br><span class="line">  <span class="attr">options</span>?: <span class="title class_">WatchOptions</span>&lt;<span class="title class_">Immediate</span>&gt;</span><br><span class="line">): <span class="title class_">WatchStopHandle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MultiWatchSources 是一个数组</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">MultiWatchSources</span> = (<span class="title class_">WatchSource</span>&lt;<span class="built_in">unknown</span>&gt; | <span class="built_in">object</span>)[]</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><p>但是不管是基础用法还是批量侦听，可以看到这个 API 都是接受三个入参, 并返回一个可以用来停止侦听的函数</p><table><thead><tr><th align="center">参数</th><th align="center">是否可选</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center">source</td><td align="center">必传</td><td align="left">数据源</td></tr><tr><td align="center">callback</td><td align="center">必传</td><td align="left">侦听到变化后要执行的回调函数</td></tr><tr><td align="center">options</td><td align="center">可选</td><td align="left">一些侦听选项</td></tr></tbody></table></li></ul><h4 id="要侦听的数据源"><a href="#要侦听的数据源" class="headerlink" title="要侦听的数据源"></a>要侦听的数据源</h4><p>在上面API 的 TS 类型已经对 <code>watch</code> API 的组成有一定的了解了，这里先对数据源的类型和使用限制做下说明。如果不提前了解，在使用的过程中可能会遇到 “侦听了但没有反应” 的情况出现。</p><p><code>watch</code> API 的第 1 个参数 <code>source</code> 是要侦听的数据源，它的 TS 类型如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watch 第 1 个入参的 TS 类型</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">WatchSource</span>&lt;T = <span class="built_in">any</span>&gt; = <span class="title class_">Ref</span>&lt;T&gt; | <span class="title class_">ComputedRef</span>&lt;T&gt; | (<span class="function">() =&gt;</span> T)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>可以看到能够用于侦听的数据，是通过响应式 API定义的变量（ <code>Ref&lt;T&gt;</code> ），或者是一个 计算数据（ <code>ComputedRef&lt;T&gt;</code> ），或者是一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get">getter 函数</a> （ <code>() =&gt; T</code> ）。</p><p>所以要想定义的 watch 能够做出预期的行为，数据源必须具备响应性或者是一个 getter ，如果只是通过 <code>let</code> 定义一个普通变量，然后去改变这个变量的值，这样是无法侦听的。</p><blockquote><p>如果要侦听响应式对象里面的某个值（这种情况下对象本身是响应式，但它的 property 不是），需要写成 getter 函数，简单的说就是需要写成有返回值的函数，这个函数 return 要侦听的数据， e.g. <code>() =&gt; foo.bar</code>。</p></blockquote><h4 id="侦听后的回调函数"><a href="#侦听后的回调函数" class="headerlink" title="侦听后的回调函数"></a>侦听后的回调函数</h4><p>在上面 API 的 TS 类型 介绍了 watch API 的组成，和数据源一样，先了解一下回调函数的定义。</p><p>watch API 的第 2 个参数 <code>callback</code> 是侦听到数据变化时要做出的行为，它的 TS 类型如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watch 第 2 个入参的 TS 类型</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">WatchCallback</span>&lt;V = <span class="built_in">any</span>, <span class="variable constant_">OV</span> = <span class="built_in">any</span>&gt; = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">value</span>: V,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">oldValue</span>: OV,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">onCleanup</span>: <span class="title class_">OnCleanup</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="built_in">any</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>乍一看它有三个参数，但实际上这些参数不是自己定义的，而是 watch API 传递的，所以不管用或者不用，它们都在那里：</p><table><thead><tr><th align="left">参数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">value</td><td align="left">变化后的新值，类型和数据源保持一致</td></tr><tr><td align="left">oldValue</td><td align="left">变化前的旧值，类型和数据源保持一致</td></tr><tr><td align="left">onCleanup</td><td align="left">注册一个清理函数</td></tr></tbody></table><p>注意：第一个参数是新值，第二个才是原来的旧值！</p><p>如同其他 JS 函数，在使用 watch 的回调函数时，可以对这三个参数任意命名，比如把 <code>value</code> 命名为觉得更容易理解的 <code>newValue</code> 。</p><p>另外，默认情况下，<code>watch</code> 是惰性的，也就是只有当被侦听的数据源发生变化时才执行回调。</p><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><p>来到这里，对 2 个必传的参数都有一定的了解了，先看看基础的用法，也就是日常最常编写的方案，只需要先关注前 2 个必传的参数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要忘了导入要用的 API</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent, reactive, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 定义一个响应式数据</span></span><br><span class="line">    <span class="keyword">const</span> userInfo = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;Petter&#x27;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2s后改变数据</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      userInfo.<span class="property">name</span> = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以直接侦听这个响应式对象</span></span><br><span class="line"><span class="comment">     * callback 的参数如果不用可以不写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">watch</span>(userInfo, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;侦听整个 userInfo &#x27;</span>, userInfo.<span class="property">name</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 也可以侦听对象里面的某个值</span></span><br><span class="line"><span class="comment">     * 此时数据源需要写成 getter 函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">watch</span>(</span><br><span class="line">      <span class="comment">// 数据源，getter 形式</span></span><br><span class="line">      <span class="function">() =&gt;</span> userInfo.<span class="property">name</span>,</span><br><span class="line">      <span class="comment">// 回调函数 callback</span></span><br><span class="line">      <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;只侦听 name 的变化 &#x27;</span>, userInfo.<span class="property">name</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;打印变化前后的值&#x27;</span>, &#123; oldValue, newValue &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果有多个数据源要侦听，并且侦听到变化后要执行的行为一样，那么可以使用 批量侦听 。特殊的情况下，可以搭配 侦听的选项 做一些特殊的用法，详见下面部分的内容。</p><h4 id="批量侦听"><a href="#批量侦听" class="headerlink" title="批量侦听"></a>批量侦听</h4><p>如果有多个数据源要侦听，并且侦听到变化后要执行的行为一样，第一反应可能是这样来写：</p><ol><li>抽离相同的处理行为为公共函数</li><li>然后定义多个侦听操作，传入这个公共函数</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> message = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> index = ref&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2s后改变数据</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 来到这里才会触发 watch 的回调</span></span><br><span class="line">      message.<span class="property">value</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">      index.<span class="property">value</span>++</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽离相同的处理行为为公共函数</span></span><br><span class="line">    <span class="keyword">const</span> handleWatch = (</span><br><span class="line">      <span class="attr">newValue</span>: <span class="built_in">string</span> | <span class="built_in">number</span>,</span><br><span class="line">      <span class="attr">oldValue</span>: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">    ): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(&#123; newValue, oldValue &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后定义多个侦听操作，传入这个公共函数</span></span><br><span class="line">    <span class="title function_">watch</span>(message, handleWatch)</span><br><span class="line">    <span class="title function_">watch</span>(index, handleWatch)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样写其实没什么问题，不过除了抽离公共代码的写法之外， watch API 还提供了一个批量侦听的用法，<strong>和基础用法的区别在于，数据源和回调参数都变成了数组的形式</strong>。</p><ul><li><p>数据源：以数组的形式传入，里面每一项都是一个响应式数据。</p></li><li><p>回调数：原来的 <code>value</code> 和 <code>newValue</code> 也都变成了数组，每个数组里面的顺序和数据源数组排序一致。</p></li></ul><p>可以看下面的这个例子更为直观：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 定义多个数据源</span></span><br><span class="line">    <span class="keyword">const</span> message = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> index = ref&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2s后改变数据</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      message.<span class="property">value</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">      index.<span class="property">value</span>++</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">watch</span>(</span><br><span class="line">      <span class="comment">// 数据源改成了数组</span></span><br><span class="line">      [message, index],</span><br><span class="line">      <span class="comment">// 回调的入参也变成了数组，每个数组里面的顺序和数据源数组排序一致</span></span><br><span class="line">      <span class="function">(<span class="params">[newMessage, newIndex], [oldMessage, oldIndex]</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;message 的变化&#x27;</span>, &#123; newMessage, oldMessage &#125;)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;index 的变化&#x27;</span>, &#123; newIndex, oldIndex &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="watch侦听的选项"><a href="#watch侦听的选项" class="headerlink" title="watch侦听的选项"></a>watch侦听的选项</h3><p>在 API 的 TS 类型 里提到， watch API 还接受第 3 个参数 options ，可选的一些侦听选项。</p><p>它的 TS 类型如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watch 第 3 个入参的 TS 类型</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">interface</span> <span class="title class_">WatchOptions</span>&lt;<span class="title class_">Immediate</span> = <span class="built_in">boolean</span>&gt;</span><br><span class="line">  <span class="keyword">extends</span> <span class="title class_">WatchOptionsBase</span> &#123;</span><br><span class="line">  <span class="attr">immediate</span>?: <span class="title class_">Immediate</span></span><br><span class="line">  <span class="attr">deep</span>?: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承的 base 类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">interface</span> <span class="title class_">WatchOptionsBase</span> <span class="keyword">extends</span> <span class="title class_">DebuggerOptions</span> &#123;</span><br><span class="line">  <span class="attr">flush</span>?: <span class="string">&#x27;pre&#x27;</span> | <span class="string">&#x27;post&#x27;</span> | <span class="string">&#x27;sync&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承的 debugger 选项类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">interface</span> <span class="title class_">DebuggerOptions</span> &#123;</span><br><span class="line">  <span class="attr">onTrack</span>?: <span class="function">(<span class="params"><span class="attr">event</span>: <span class="title class_">DebuggerEvent</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  <span class="attr">onTrigger</span>?: <span class="function">(<span class="params"><span class="attr">event</span>: <span class="title class_">DebuggerEvent</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><code>options</code> 是一个对象的形式传入，有以下几个选项：</p><table><thead><tr><th align="center">选项</th><th align="center">类型</th><th align="center">默认值</th><th align="center">可选值</th><th align="left">作用</th></tr></thead><tbody><tr><td align="center">deep</td><td align="center">boolean</td><td align="center">false</td><td align="center">true | false</td><td align="left">是否进行深度侦听</td></tr><tr><td align="center">immediate</td><td align="center">boolean</td><td align="center">false</td><td align="center">true | false</td><td align="left">是否立即执行侦听回调</td></tr><tr><td align="center">flush</td><td align="center">string</td><td align="center">‘pre’</td><td align="center">‘pre’ | ‘post’ | ‘sync’</td><td align="left">控制侦听回调的调用时机</td></tr><tr><td align="center">onTrack</td><td align="center">(e) &#x3D;&gt; void</td><td align="center"></td><td align="center"></td><td align="left">在数据源被追踪时调用</td></tr><tr><td align="center">onTrigger</td><td align="center">(e) &#x3D;&gt; void</td><td align="center"></td><td align="center"></td><td align="left">在侦听回调被触发时调用</td></tr></tbody></table><p>其中 <code>onTrack</code> 和 <code>onTrigger</code> 的 <code>e</code> 是 debugger 事件，建议在回调内放置一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/debugger">debugger 语句</a> 以调试依赖，这两个选项仅在开发模式下生效。</p><p>deep 默认是 <code>false</code> ，但是在侦听 reactive 对象或数组时，会默认为 <code>true</code> 。</p><h4 id="侦听选项之-deep"><a href="#侦听选项之-deep" class="headerlink" title="侦听选项之 deep"></a>侦听选项之 deep</h4><p><code>deep</code> 选项接受一个布尔值，可以设置为 <code>true</code> 开启深度侦听，或者是 <code>false</code> 关闭深度侦听，默认情况下这个选项是 <code>false</code> 关闭深度侦听的，但也存在特例。</p><p>设置为 <code>false</code> 的情况下，如果直接侦听一个响应式的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%AF%B9%E8%B1%A1">引用类型</a> 数据（e.g. <code>Object</code> 、 <code>Array</code> … ），虽然它的属性的值有变化，但对其本身来说是不变的，所以不会触发 watch 的 callback 。</p><p>下面是一个关闭了深度侦听的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 定义一个响应式数据，注意用的是 ref 来定义</span></span><br><span class="line">    <span class="keyword">const</span> nums = ref&lt;<span class="built_in">number</span>[]&gt;([])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2s后给这个数组添加项目</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      nums.<span class="property">value</span>.<span class="title function_">push</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 可以打印一下，确保数据确实变化了</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;修改后&#x27;</span>, nums.<span class="property">value</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但是这个 watch 不会按预期执行</span></span><br><span class="line">    <span class="title function_">watch</span>(</span><br><span class="line">      nums,</span><br><span class="line">      <span class="comment">// 这里的 callback 不会被触发</span></span><br><span class="line">      <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发侦听&#x27;</span>, nums.<span class="property">value</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 因为关闭了 deep</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">deep</span>: <span class="literal">false</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>类似这种情况，需要把 <code>deep</code> 设置为 <code>true</code> 才可以触发侦听。</p><p>可以看到上面的例子特地用了ref API，这是因为通过 reactive API义的对象无法将 <code>deep</code> 成功设置为 <code>false</code> （这一点在目前的官网文档未找到说明，最终是在 <a href="https://github.com/vuejs/core/blob/main/packages/runtime-core/src/apiWatch.ts#L212">watch API 的源码</a> 上找到了答案）。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isReactive</span>(source)) &#123;</span><br><span class="line">  getter = <span class="function">() =&gt;</span> source</span><br><span class="line">  deep = <span class="literal">true</span> <span class="comment">// 被强制开启了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这个情况就是上面所说的 “特例” ，可以通过 <code>isReactive</code> API 来判断是否需要手动开启深度侦听。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 isReactive API</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent, isReactive, reactive, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 侦听这个数据时，会默认开启深度侦听</span></span><br><span class="line">    <span class="keyword">const</span> foo = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;Petter&#x27;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(foo)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 侦听这个数据时，不会默认开启深度侦听</span></span><br><span class="line">    <span class="keyword">const</span> bar = <span class="title function_">ref</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;Petter&#x27;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(bar)) <span class="comment">// false</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="侦听选项之-immediate"><a href="#侦听选项之-immediate" class="headerlink" title="侦听选项之 immediate"></a>侦听选项之 immediate</h4><p> watch 默认是惰性的，也就是只有当被侦听的数据源发生变化时才执行回调。</p><p>这句话是什么意思呢？来看一下这段代码，为了减少deep选项的干扰，换一个类型，换成 <code>string</code> 数据来演示，请留意注释：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 这个时候不会触发 watch 的回调</span></span><br><span class="line">    <span class="keyword">const</span> message = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2s后改变数据</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 来到这里才会触发 watch 的回调</span></span><br><span class="line">      message.<span class="property">value</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">watch</span>(message, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发侦听&#x27;</span>, message.<span class="property">value</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到，数据在初始化的时候并不会触发侦听回调，如果有需要的话，通过 <code>immediate</code> 选项来让它直接触发。</p><p><code>immediate</code> 选项接受一个布尔值，默认是 <code>false</code> ，<strong>可以设置为 <code>true</code> 让回调立即执行</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 这一次在这里可以会触发 watch 的回调了</span></span><br><span class="line">    <span class="keyword">const</span> message = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2s后改变数据</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 这一次，这里是第二次触发 watch 的回调，不再是第一次</span></span><br><span class="line">      message.<span class="property">value</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">watch</span>(</span><br><span class="line">      message,</span><br><span class="line">      <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发侦听&#x27;</span>, message.<span class="property">value</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 设置 immediate 选项</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意，在带有 immediate 选项时，不能在第一次回调时取消该数据源的侦听。</p><h4 id="侦听选项之-flush"><a href="#侦听选项之-flush" class="headerlink" title="侦听选项之 flush"></a>侦听选项之 flush</h4><p><code>flush</code> 选项是用来控制[侦听回调的调用时机，接受指定的字符串，可选值如下，默认是 <code>&#39;pre&#39;</code> 。</p><table><thead><tr><th align="center">可选值</th><th align="left">回调的调用时机</th><th align="left">使用场景</th></tr></thead><tbody><tr><td align="center">‘pre’</td><td align="left">将在渲染前被调用</td><td align="left">允许回调在模板运行前更新了其他值</td></tr><tr><td align="center">‘sync’</td><td align="left">在渲染时被同步调用</td><td align="left">目前来说没什么好处，可以了解但不建议用…</td></tr><tr><td align="center">‘post’</td><td align="left">被推迟到渲染之后调用</td><td align="left">如果要通过 ref 操作 DOM 元素与子组件 ，需要使用这个值来启用该选项，以达到预期的执行效果</td></tr></tbody></table><p>对于 <code>&#39;pre&#39;</code> 和 <code>&#39;post&#39;</code> ，回调使用队列进行缓冲。回调只被添加到队列中一次。</p><p>即使观察值变化了多次，值的中间变化将被跳过，不会传递给回调，这样做不仅可以提高性能，还有助于保证数据的一致性。</p><p>更多关于 flush 的信息，请参阅 <a href="https://cn.vuejs.org/guide/essentials/watchers.html#callback-flush-timing">回调的触发时机</a> 。</p><h4 id="停止侦听"><a href="#停止侦听" class="headerlink" title="停止侦听"></a>停止侦听</h4><p>如果在 setup或者script-setup里使用 watch 的话， 组件被卸载的时候也会一起被停止，一般情况下不太需要关心如何停止侦听。</p><p>不过有时候可能想要手动取消， Vue 3 也提供了方法。</p><blockquote><p>随着组件被卸载一起停止的前提是，侦听器必须是 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Introducing#%E5%90%8C%E6%AD%A5javascript">同步语句</a> 创建的，这种情况下侦听器会绑定在当前组件上。</p><p>如果放在 <code>setTimeout</code> 等 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Introducing#%E5%BC%82%E6%AD%A5javascript">异步函数</a> 里面创建，则不会绑定到当前组件，因此组件卸载的时候不会一起停止该侦听器，这种时候就需要手动停止侦听。</p></blockquote><p>当在定义一个 watch 行为的时候，它会返回一个用来停止侦听的函数。这个函数的 TS 类型如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">WatchStopHandle</span> = <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br></pre></td></tr></table></figure><p>用法很简单，做一下简单了解即可：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个取消观察的变量，它是一个函数</span></span><br><span class="line"><span class="keyword">const</span> unwatch = <span class="title function_">watch</span>(message, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在合适的时期调用它，可以取消这个侦听</span></span><br><span class="line"><span class="title function_">unwatch</span>()</span><br></pre></td></tr></table></figure><p>但是也有一点需要注意的是，如果启用了immediate 选项，不能在第一次触发侦听回调时执行它。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：这是一段错误的代码，运行会报错</span></span><br><span class="line"><span class="keyword">const</span> unwatch = <span class="title function_">watch</span>(</span><br><span class="line">  message,</span><br><span class="line">  <span class="comment">// 侦听的回调</span></span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 在这里调用会有问题 ❌</span></span><br><span class="line">    <span class="title function_">unwatch</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 启用 immediate 选项</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>会收获一段报错，告诉 <code>unwatch</code> 这个变量在初始化前无法被访问：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught ReferenceError: Cannot access <span class="string">&#x27;unwatch&#x27;</span> before initialization</span><br></pre></td></tr></table></figure><p>目前有两种方案可以让实现这个操作：</p><p>方案一：使用 <code>var</code> 并判断变量类型，利用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var#%E6%8F%8F%E8%BF%B0">var 的变量提升</a> 来实现目的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里改成 var ，不要用 const 或 let</span></span><br><span class="line"><span class="keyword">var</span> unwatch = <span class="title function_">watch</span>(</span><br><span class="line">  message,</span><br><span class="line">  <span class="comment">// 侦听回调</span></span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里加一个判断，是函数才执行它</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> unwatch === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">unwatch</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 侦听选项</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>不过 <code>var</code> 已经属于过时的语句了，建议用方案二的 <code>let</code> 。</p><p>方案二：使用 <code>let</code> 并判断变量类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果不想用 any ，可以导入 TS 类型</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">WatchStopHandle</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里改成 let ，但是要另起一行，先定义，再赋值</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">unwatch</span>: <span class="title class_">WatchStopHandle</span></span><br><span class="line">unwatch = <span class="title function_">watch</span>(</span><br><span class="line">  message,</span><br><span class="line">  <span class="comment">// 侦听回调</span></span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里加一个判断，是函数才执行它</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> unwatch === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">unwatch</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 侦听选项</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="侦听效果清理"><a href="#侦听效果清理" class="headerlink" title="侦听效果清理"></a>侦听效果清理</h4><p>在 侦听后的回调函数部分提及到一个参数 <code>onCleanup</code> ，它可以帮注册一个清理函数。</p><p>有时 watch 的回调会执行异步操作，当 watch 到数据变更的时候，需要取消这些操作，这个函数的作用就用于此，会在以下情况调用这个清理函数：</p><ul><li>watcher 即将重新运行的时候</li><li>watcher 被停止（组件被卸载或者被手动停止侦听）</li></ul><p>TS 类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">OnCleanup</span> = <span class="function">(<span class="params"><span class="attr">cleanupFn</span>: () =&gt; <span class="built_in">void</span></span>) =&gt;</span> <span class="built_in">void</span></span><br></pre></td></tr></table></figure><p>用法方面比较简单，传入一个回调函数运行即可，不过需要注意的是，需要在停止侦听之前注册好清理行为，否则不会生效。</p><p>在停止侦听里的最后一个 immediate 例子的基础上继续添加代码，请注意注册的时机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let unwatch: WatchStopHandle</span><br><span class="line">unwatch = watch(</span><br><span class="line">  message,</span><br><span class="line">  (newValue, oldValue, onCleanup) =&gt; &#123;</span><br><span class="line">    // 需要在停止侦听之前注册好清理行为</span><br><span class="line">    onCleanup(() =&gt; &#123;</span><br><span class="line">      console.log(&#x27;侦听清理ing&#x27;)</span><br><span class="line">      // 根据实际的业务情况定义一些清理操作 ...</span><br><span class="line">    &#125;)</span><br><span class="line">    // 然后再停止侦听</span><br><span class="line">    if (typeof unwatch === &#x27;function&#x27;) &#123;</span><br><span class="line">      unwatch()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    immediate: true,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><p>如果一个函数里包含了多个需要侦听的数据，一个一个数据去侦听太麻烦了，在 Vue 3 ，可以直接使用 watchEffect API 来简化的操作。</p><h4 id="API-的-TS-类型-1"><a href="#API-的-TS-类型-1" class="headerlink" title="API 的 TS 类型"></a>API 的 TS 类型</h4><p>这个 API 的类型如下，使用的时候需要传入一个副作用函数（相当于 watch 的 侦听后的回调函数），也可以根据的实际情况传入一些可选的侦听选项 。</p><p>和 watch API 一样，它也会返回一个用于停止侦听 的函数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watchEffect 部分的 TS 类型</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">WatchEffect</span> = <span class="function">(<span class="params"><span class="attr">onCleanup</span>: <span class="title class_">OnCleanup</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">watchEffect</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">effect</span>: <span class="title class_">WatchEffect</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">options</span>?: <span class="title class_">WatchOptionsBase</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">WatchStopHandle</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>副作用函数也会传入一个清理回调作为参数，和 watch 的 侦听效果清理一样的用法。可以理解为它是一个简化版的 watch ，具体简化在哪里呢？请看下面的用法示例。</p><h4 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h4><p>它立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref, watchEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 单独定义两个数据，后面用来分开改变数值</span></span><br><span class="line">    <span class="keyword">const</span> name = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;Petter&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> age = ref&lt;<span class="built_in">number</span>&gt;(<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个调用这两个数据的函数</span></span><br><span class="line">    <span class="keyword">const</span> getUserInfo = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: name.<span class="property">value</span>,</span><br><span class="line">        <span class="attr">age</span>: age.<span class="property">value</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2s后改变第一个数据</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      name.<span class="property">value</span> = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4s后改变第二个数据</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      age.<span class="property">value</span> = <span class="number">20</span></span><br><span class="line">    &#125;, <span class="number">4000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接侦听调用函数，在每个数据产生变化的时候，它都会自动执行</span></span><br><span class="line">    <span class="title function_">watchEffect</span>(getUserInfo)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="和-watch-的区别"><a href="#和-watch-的区别" class="headerlink" title="和 watch 的区别"></a>和 watch 的区别</h4><p>虽然理论上 <code>watchEffect</code> 是 <code>watch</code> 的一个简化操作，可以用来代替 批量侦听 ，但它们也有一定的区别：</p><ol><li><code>watch</code> 可以访问侦听状态变化前后的值，而 <code>watchEffect</code> 没有。</li><li><code>watch</code> 是在属性改变的时候才执行，而 <code>watchEffect</code> 则默认会执行一次，然后在属性改变的时候也会执行。</li></ol><p>第二点的意思，看下面这段代码可以有更直观的理解：</p><p>使用 watch ：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> foo = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      foo.<span class="property">value</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">value</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 watch 需要先手动执行一次</span></span><br><span class="line">    <span class="title function_">bar</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后当 foo 有变动时，才会通过 watch 来执行 bar()</span></span><br><span class="line">    <span class="title function_">watch</span>(foo, bar)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用 watchEffect ：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> foo = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      foo.<span class="property">value</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">value</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以通过 watchEffect 实现 bar() + watch(foo, bar) 的效果</span></span><br><span class="line">    <span class="title function_">watchEffect</span>(bar)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="可用的侦听选项"><a href="#可用的侦听选项" class="headerlink" title="可用的侦听选项"></a>可用的侦听选项</h4><p>虽然用法和 watch 类似，但也简化了一些选项，它的侦听选项 TS 类型如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只支持 base 类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">interface</span> <span class="title class_">WatchOptionsBase</span> <span class="keyword">extends</span> <span class="title class_">DebuggerOptions</span> &#123;</span><br><span class="line">  <span class="attr">flush</span>?: <span class="string">&#x27;pre&#x27;</span> | <span class="string">&#x27;post&#x27;</span> | <span class="string">&#x27;sync&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承的 debugger 选项类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">interface</span> <span class="title class_">DebuggerOptions</span> &#123;</span><br><span class="line">  <span class="attr">onTrack</span>?: <span class="function">(<span class="params"><span class="attr">event</span>: <span class="title class_">DebuggerEvent</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  <span class="attr">onTrigger</span>?: <span class="function">(<span class="params"><span class="attr">event</span>: <span class="title class_">DebuggerEvent</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>对比 watch API ，它不支持deep和 immediate，请记住这一点，其他的用法是一样的。</p><h3 id="watchPostEffect"><a href="#watchPostEffect" class="headerlink" title="watchPostEffect"></a>watchPostEffect</h3><p>watchEffec API 使用 <code>flush: &#39;post&#39;</code> 选项时的别名</p><blockquote><p>TIP Vue v3.2.0 及以上版本才支持该 API 。</p></blockquote><h3 id="watchSyncEffe"><a href="#watchSyncEffe" class="headerlink" title="watchSyncEffe"></a>watchSyncEffe</h3><p>watchEffect API 使用 <code>flush: &#39;sync&#39;</code> 选项时的别名。</p><blockquote><p>TIP  Vue v3.2.0 及以上版本才支持该 API 。</p></blockquote><h2 id="数据的计算"><a href="#数据的计算" class="headerlink" title="数据的计算"></a>数据的计算</h2><p>和 Vue 2.0 一样，数据的计算也是使用 <code>computed</code> API ，它可以通过现有的响应式数据，去通过计算得到新的响应式变量，用过 Vue 2.0 的开发者应该不会太陌生，但是在 Vue 3.0 ，在使用方式上也是变化非常大！</p><blockquote><p>TIP 这里的响应式数据，可以简单理解为通过 ref API 、 <a href="https://vue3.chengpeiquan.com/component.html#%E5%93%8D%E5%BA%94%E5%BC%8F-api-%E4%B9%8B-reactive-new">reactive</a> API 定义出来的数据，当然 Vuex 、Vue Router 等 Vue 数据也都具备响应式，可以在 <a href="https://vue3.chengpeiquan.com/component.html#%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E5%8C%96-new">响应式数据的变化</a> 了解。</p></blockquote><h3 id="用法变化"><a href="#用法变化" class="headerlink" title="用法变化"></a>用法变化</h3><p>先从一个简单的用例来看看在 Vue 新旧版本的用法区别：</p><p>假设定义了两个分开的数据 <code>firstName</code> 名字和 <code>lastName</code> 姓氏，但是在 template 展示时，需要展示完整的姓名，那么就可以通过 <code>computed</code> 来计算一个新的数据：</p><h4 id="回顾-Vue-2-3"><a href="#回顾-Vue-2-3" class="headerlink" title="回顾 Vue 2"></a>回顾 Vue 2</h4><p>在 Vue 2.0 ，<code>computed</code> 和 <code>data</code> 在同级配置，并且不可以和 <code>data</code> 里的数据同名重复定义：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Vue 2 的写法：</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">firstName</span>: <span class="string">&#x27;Bill&#x27;</span>,</span><br><span class="line">      <span class="attr">lastName</span>: <span class="string">&#x27;Gates&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 注意这里定义的变量，都要通过函数的形式来返回它的值</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">// 普通函数可以直接通过熟悉的 this 来拿到 data 里的数据</span></span><br><span class="line">    <span class="title function_">fullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.lastName&#125;</span>`</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 箭头函数则需要通过参数来拿到实例上的数据</span></span><br><span class="line">    <span class="attr">fullName2</span>: <span class="function">(<span class="params">vm</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;vm.firstName&#125;</span> <span class="subst">$&#123;vm.lastName&#125;</span>`</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在需要用到全名的地方，只需要通过 <code>this.fullName</code> 就可以得到 <code>Bill Gates</code> 。</p><h4 id="了解-Vue-3-3"><a href="#了解-Vue-3-3" class="headerlink" title="了解 Vue 3"></a>了解 Vue 3</h4><p>在 Vue 3.0 ，跟其他 API 的用法一样，需要先导入 <code>computed</code> 才能使用：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Vue 3 的写法：</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 定义基本的数据</span></span><br><span class="line">    <span class="keyword">const</span> firstName = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;Bill&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> lastName = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;Gates&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义需要计算拼接结果的数据</span></span><br><span class="line">    <span class="keyword">const</span> fullName = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> <span class="string">`<span class="subst">$&#123;firstName.value&#125;</span> <span class="subst">$&#123;lastName.value&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2s 后改变某个数据的值</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      firstName.<span class="property">value</span> = <span class="string">&#x27;Petter&#x27;</span></span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// template 那边在 2s 后也会显示为 Petter Gates</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      fullName,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以把这个用法简单的理解为，传入一个回调函数，并 <code>return</code> 一个值，对，它需要有明确的返回值。</p><blockquote><p>需要注意的是：</p><ol><li>定义出来的 <code>computed</code> 变量，和 Ref 变量的用法一样，也是需要通过 <code>.value</code> 才能拿到它的值</li><li>但是区别在于，默认情况下 <code>computed</code> 的 <code>value</code> 是只读的</li></ol></blockquote><h3 id="类型声明-1"><a href="#类型声明-1" class="headerlink" title="类型声明"></a>类型声明</h3><p>之前说过，在defineComponent里，会自动帮推导 Vue API 的类型，所以一般情况下，是不需要显式的去定义 <code>computed</code> 出来的变量类型的。</p><p>在确实需要手动指定的情况下，也可以导入它的类型然后定义：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">ComputedRef</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里添加了类型声明</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">fullName</span>: <span class="title class_">ComputedRef</span>&lt;<span class="built_in">string</span>&gt; = <span class="title function_">computed</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="string">`<span class="subst">$&#123;firstName.value&#125;</span> <span class="subst">$&#123;lastName.value&#125;</span>`</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>要返回一个字符串，就写 <code>ComputedRef&lt;string&gt;</code> ；返回布尔值，就写 <code>ComputedRef&lt;boolean&gt;</code> ；返回一些复杂对象信息，可以先定义好的类型，再诸如 <code>ComputedRef&lt;UserInfo&gt;</code> 去写。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是 ComputedRef 的类型声明：</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">interface</span> <span class="title class_">ComputedRef</span>&lt;T = <span class="built_in">any</span>&gt; <span class="keyword">extends</span> <span class="title class_">WritableComputedRef</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">value</span>: T</span><br><span class="line">  [<span class="title class_">ComoutedRefSymbol</span>]: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优势对比和注意事项"><a href="#优势对比和注意事项" class="headerlink" title="优势对比和注意事项"></a>优势对比和注意事项</h3><p>在继续往下看之前，先来了解一下这个 API 的一些优势和注意事项（如果在 Vue 2 已经有接触过的话，可以跳过这一段，因为优势和需要注意的东西比较一致）。</p><h4 id="优势对比"><a href="#优势对比" class="headerlink" title="优势对比"></a>优势对比</h4><p>看到这里，相信刚接触的开发者可能会有疑问，既然 <code>computed</code> 也是通过一个函数来返回值，那么和普通的 <code>function</code> 有什么区别，或者说优势？</p><ol><li>性能优势<ul><li>这一点在 <a href="https://cn.vuejs.org/guide/essentials/computed.html#computed-caching-vs-methods">官网文档</a> 其实是有提到的：数据的计算是基于它们的响应依赖关系缓存的，<strong>只在相关响应式依赖发生改变时它们才会重新求值。</strong></li><li>也就是说，只要原始数据没有发生改变，多次访问 <code>computed</code> ，都是会立即返回之前的计算结果，而不是再次执行函数；而普通的 <code>function</code> 调用多少次就执行多少次，每调用一次就计算一次。</li><li>至于为何要如此设计，官网文档也给出了原因：为什么需要缓存？假设有一个性能开销比较大的计算数据 list，它需要遍历一个巨大的数组并做大量的计算。然后可能有其他的计算数据依赖于 list。如果没有缓存，将不可避免地多次执行 list 的 getter！如果不希望有缓存，请用function 来替代。</li></ul></li><li>书写统一<ul><li>假定 foo1 是 Ref 变量， foo2 是 <code>computed</code> 变量， foo3 是普通函数返回值</li><li>看到这里的开发者应该都已经清楚 Vue 3 的 Ref 变量是通过 <code>foo1.value</code> 来拿到值的，而 <code>computed</code> 也是通过 <code>foo2.value</code> ，并且在 template 里都可以省略 <code>.value</code> ，在读取方面，他们是有一致的风格和简洁性。</li><li>而 foo3 不管是在 script 还是 template ，都需要通过 <code>foo3()</code> 才能拿到结果，相对来说会有那么一丢丢别扭。</li></ul></li></ol><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>有优势当然也就有一定的 “劣势” ，当然这也是 Vue 框架的有意为之，所以在使用上也需要注意一些问题：</p><ol><li><p><strong>只会更新响应式数据的计算</strong></p><ul><li><p>假设要获取当前的时间信息，因为不是响应式数据，所以这种情况下就需要用普通的函数去获取返回值，才能拿到最新的时间。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nowTime = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nowTime.<span class="property">value</span>)</span><br><span class="line"><span class="comment">// 输出 Sun Nov 14 2021 21:07:00 GMT+0800 (GMT+08:00)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2s 后依然是跟上面一样的结果</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(nowTime.<span class="property">value</span>)</span><br><span class="line">  <span class="comment">// 还是输出 Sun Nov 14 2021 21:07:00 GMT+0800 (GMT+08:00)</span></span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>数据是只读的</strong></p><ul><li><p>通过 computed 定义的数据，它是只读的，这一点在类型声明已经有所了解。</p></li><li><p>如果直接赋值，不仅无法变更数据，而且会收获一个报错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">TS2540</span>: <span class="title class_">Cannot</span> assign to <span class="string">&#x27;value&#x27;</span> because it is a read-only property.</span><br></pre></td></tr></table></figure></li><li><p>虽然无法直接赋值，但是在必要的情况下，依然可以通过 <code>computed</code> 的 <code>setter</code> 来更新数据。</p></li></ul></li></ol><h3 id="setter-的使用"><a href="#setter-的使用" class="headerlink" title="setter 的使用"></a>setter 的使用</h3><p>通过 computed 定义的变量默认都是只读的形式（只有一个 getter ），但是在必要的情况下，也可以使用其 setter 属性来更新数据。</p><h4 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h4><p>当需要用到 setter 的时候， <code>computed</code> 就不再是一个传入 callback 的形式了，而是传入一个带有 2 个方法的对象。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里computed接收的入参已经不再是函数</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="title function_">computed</span>(&#123;</span><br><span class="line">  <span class="comment">// 这里需要明确的返回一个值</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 这里接收一个参数，代表修改 foo 时，赋值下来的新值</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里的 <code>get</code> 就是 <code>computed</code> 的 getter ，跟原来传入 callback 的形式一样，用于 <code>foo.value</code> 的读取，所以这里必须有明确的返回值。</p><p>这里的 <code>set</code> 就是 <code>computed</code> 的 setter ，它会接收一个参数，代表新的值，当通过 <code>foo.value = xxx</code> 赋值的时候，赋入的这个值，就会通过这个入参传递进来，可以根据的业务需要，把这个值赋给相关的数据源。</p><blockquote><p>TIP 请注意，必须使用 <code>get</code> 和 <code>set</code> 这 2 个方法名，也只接受这 2 个方法。</p></blockquote><h4 id="使用示范"><a href="#使用示范" class="headerlink" title="使用示范"></a>使用示范</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 还是这2个数据源</span></span><br><span class="line"><span class="keyword">const</span> firstName = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;Bill&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> lastName = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;Gates&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里配合setter的需要，改成了另外一种写法</span></span><br><span class="line"><span class="keyword">const</span> fullName = <span class="title function_">computed</span>(&#123;</span><br><span class="line">  <span class="comment">// getter还是返回一个拼接起来的全名</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstName.value&#125;</span> <span class="subst">$&#123;lastName.value&#125;</span>`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// setter这里改成只更新firstName，注意参数也定义TS类型</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params"><span class="attr">newFirstName</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    firstName.<span class="property">value</span> = newFirstName</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fullName.<span class="property">value</span>) <span class="comment">// 输出 Bill Gates</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2s后更新一下数据</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 对fullName的赋值，其实更新的是firstName</span></span><br><span class="line">  fullName.<span class="property">value</span> = <span class="string">&#x27;Petter&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此时firstName已经得到了更新</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(firstName.<span class="property">value</span>) <span class="comment">// 会输出 Petter</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当然，由于firstName变化了，所以fullName的getter也会得到更新</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(fullName.<span class="property">value</span>) <span class="comment">// 会输出 Petter Gates</span></span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>计算 API 的作用，官网文档只举了一个非常简单的例子，那么在实际项目中，什么情况下用它会让更方便呢？</p><p>简单举几个比较常见的例子吧，加深一下对 <code>computed</code> 的理解。</p><h4 id="数据的拼接和计算"><a href="#数据的拼接和计算" class="headerlink" title="数据的拼接和计算"></a>数据的拼接和计算</h4><p>如上面的案例，与其每个用到的地方都要用到 <code>firstName + &#39; &#39; + lastName</code> 这样的多变量拼接，不如用一个 <code>fullName</code> 来的简单。</p><p>当然，不止是字符串拼接，数据的求和等操作更是合适，比如说做一个购物车，购物车里有商品列表，同时还要显示购物车内的商品总金额，这种情况就非常适合用计算数据。</p><h4 id="复用组件的动态数据"><a href="#复用组件的动态数据" class="headerlink" title="复用组件的动态数据"></a>复用组件的动态数据</h4><p>在一个项目里，很多时候组件会涉及到复用，比如说：“首页的文章列表 vs 列表页的文章列表 vs 作者详情页的文章列表” ，特别常见于新闻网站等内容资讯站点，这种情况下，往往并不需要每次都重新写 UI 、数据渲染等代码，仅仅是接口 URL 的区别。</p><p>这种情况就可以通过路由名称来动态获取要调用哪个列表接口：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个根据路由名称来获取接口URL的计算数据</span></span><br><span class="line"><span class="keyword">const</span> apiUrl = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (route.<span class="property">name</span>) &#123;</span><br><span class="line">    <span class="comment">// 首页</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;home&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;/api/list1&#x27;</span></span><br><span class="line">    <span class="comment">// 列表页</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;list&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;/api/list2&#x27;</span></span><br><span class="line">    <span class="comment">// 作者页</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;author&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;/api/list3&#x27;</span></span><br><span class="line">    <span class="comment">// 默认是随机列表</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;/api/random&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求列表</span></span><br><span class="line"><span class="keyword">const</span> getArticleList = <span class="title function_">async</span> (): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  articleList.<span class="property">value</span> = <span class="keyword">await</span> <span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: apiUrl.<span class="property">value</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这种情况也可以在父组件通过 <code>props</code> 传递接口 URL 。</p><h4 id="获取多级对象的值"><a href="#获取多级对象的值" class="headerlink" title="获取多级对象的值"></a>获取多级对象的值</h4><p>经常遇到这样的情况：要在 template 显示一些多级对象的字段，而某些字段不一定有，需要做一些判断。虽然有 <code>v-if</code> ，但是嵌套层级一多，模板代码会难以维护。</p><p>如果把这些工作量转移给计算数据，结合 <code>try / catch</code> ，就无需在 template 里处理很多判断了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子比较极端，但在 Vuex 这种大型数据树上，也不是完全不可能存在</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 正常情况下返回需要的数据</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> store.<span class="property">state</span>.<span class="property">foo3</span>.<span class="property">foo2</span>.<span class="property">foo1</span>.<span class="property">foo</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 处理失败则返回一个默认值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样在 template 里要拿到 foo 的值，完全不需要关心中间一级又一级的字段是否存在，只需要区分是不是默认值。</p><h4 id="不同类型的数据转换"><a href="#不同类型的数据转换" class="headerlink" title="不同类型的数据转换"></a>不同类型的数据转换</h4><p>有时候会遇到一些需求，类似于：让用户在输入框里按一定的格式填写文本，比如用英文逗号 <code>,</code> 隔开每个词，然后保存时用数组的格式提交给接口。</p><p>这个时候 <code>computed</code> 的 setter 就发挥妙用了，只需要一个简单的 <code>computed</code> ，就可以代替 <code>input</code> 的 <code>change</code> 事件或者 <code>watch</code> 侦听，可以减少很多业务代码的编写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    type=&quot;text&quot;</span><br><span class="line">    v-model=&quot;tagsStr&quot;</span><br><span class="line">    placeholder=&quot;请输入标签，多个标签用英文逗号隔开&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, computed, ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    // 这个是最终要用到的数组</span><br><span class="line">    const tags = ref&lt;string[]&gt;([])</span><br><span class="line"></span><br><span class="line">    // 因为input必须绑定一个字符串</span><br><span class="line">    const tagsStr = computed(&#123;</span><br><span class="line">      // 所以通过getter来转成字符串</span><br><span class="line">      get() &#123;</span><br><span class="line">        return tags.value.join(&#x27;,&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">      // 然后在用户输入的时候，切割字符串转换回数组</span><br><span class="line">      set(newValue: string) &#123;</span><br><span class="line">        tags.value = newValue.split(&#x27;,&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      tagsStr,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>所以在实际业务开发中，开发者可以多考虑一下是否可以使用 <code>computed</code> 代替 <code>watch</code> ，避免过多的数组侦听带来项目性能的下降。</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令是 Vue 模板语法里的特殊标记，在使用上和 HTML 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/data-*">data-*</a> 属性十分相似，统一以 <code>v-</code> 开头（ e.g. <code>v-html</code> ）。</p><p>它以简单的方式实现了常用的 JavaScript 表达式功能，当表达式的值改变的时候，响应式地作用到 DOM 上。</p><h3 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a>内置指令</h3><p>Vue 提供了一些内置指令可以直接使用，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 渲染一段文本 --&gt;</span><br><span class="line">  &lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 渲染一段 HTML --&gt;</span><br><span class="line">  &lt;div v-html=&quot;html&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 循环创建一个列表 --&gt;</span><br><span class="line">  &lt;ul v-if=&quot;items.length&quot;&gt;</span><br><span class="line">    &lt;li v-for=&quot;(item, index) in items&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">      &lt;span&gt;&#123;&#123; item &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 一些事件（ `@` 等价于 `v-on` ） --&gt;</span><br><span class="line">  &lt;button @click=&quot;hello&quot;&gt;Hello&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const msg = ref&lt;string&gt;(&#x27;Hello World!&#x27;)</span><br><span class="line">    const html = ref&lt;string&gt;(&#x27;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;)</span><br><span class="line">    const items = ref&lt;string[]&gt;([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;])</span><br><span class="line"></span><br><span class="line">    function hello() &#123;</span><br><span class="line">      console.log(msg.value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      msg,</span><br><span class="line">      html,</span><br><span class="line">      items,</span><br><span class="line">      hello,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>内置指令在使用上都非常的简单，可以在官方文档的 <a href="https://cn.vuejs.org/api/built-in-directives.html">内置指令</a> 一章查询完整的指令列表和用法，在模板上使用时，请了解 <a href="https://cn.vuejs.org/guide/essentials/template-syntax.html#directives">指令的模板语法</a> 。</p><blockquote><p>TIP：有两个指令可以使用别名：</p><ul><li><code>v-on</code> 的别名是 <code>@</code> ，使用 <code>@click</code> 等价于 <code>v-on:click</code></li><li><code>v-bind</code> 的别名是 <code>:</code> ，使用 <code>:src</code> 等价于 <code>v-bind:src</code></li></ul></blockquote><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>如果 Vue 的内置指令不能满足业务需求，还可以开发自定义指令。</p><h4 id="相关的-TS-类型"><a href="#相关的-TS-类型" class="headerlink" title="相关的 TS 类型"></a>相关的 TS 类型</h4><p>在开始编写代码之前，先了解一下自定义指令相关的 TypeScript 类型。</p><p>自定义指令有两种实现形式，一种是作为一个对象，其中的写法比较接近于 Vue 组件，除了 <a href="https://cn.vuejs.org/guide/scaling-up/ssr.html#custom-directives">getSSRProps</a> 和 deep 选项外，其他的每一个属性都是一个 钩子函数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象式写法的 TS 类型</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">interface</span> <span class="title class_">ObjectDirective</span>&lt;T = <span class="built_in">any</span>, V = <span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  <span class="attr">created</span>?: <span class="title class_">DirectiveHook</span>&lt;T, <span class="literal">null</span>, V&gt;</span><br><span class="line">  <span class="attr">beforeMount</span>?: <span class="title class_">DirectiveHook</span>&lt;T, <span class="literal">null</span>, V&gt;</span><br><span class="line">  <span class="attr">mounted</span>?: <span class="title class_">DirectiveHook</span>&lt;T, <span class="literal">null</span>, V&gt;</span><br><span class="line">  <span class="attr">beforeUpdate</span>?: <span class="title class_">DirectiveHook</span>&lt;T, <span class="title class_">VNode</span>&lt;<span class="built_in">any</span>, T&gt;, V&gt;</span><br><span class="line">  <span class="attr">updated</span>?: <span class="title class_">DirectiveHook</span>&lt;T, <span class="title class_">VNode</span>&lt;<span class="built_in">any</span>, T&gt;, V&gt;</span><br><span class="line">  <span class="attr">beforeUnmount</span>?: <span class="title class_">DirectiveHook</span>&lt;T, <span class="literal">null</span>, V&gt;</span><br><span class="line">  <span class="attr">unmounted</span>?: <span class="title class_">DirectiveHook</span>&lt;T, <span class="literal">null</span>, V&gt;</span><br><span class="line">  <span class="attr">getSSRProps</span>?: <span class="title class_">SSRDirectiveHook</span></span><br><span class="line">  <span class="attr">deep</span>?: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>另外一种是函数式写法，只需要定义成一个函数，但这种写法只在 <code>mounted</code> 和 <code>updated</code> 这两个钩子生效，并且触发一样的行为。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数式写法的 TS 类型</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">FunctionDirective</span>&lt;T = <span class="built_in">any</span>, V = <span class="built_in">any</span>&gt; = <span class="title class_">DirectiveHook</span>&lt;</span><br><span class="line">  T,</span><br><span class="line">  <span class="built_in">any</span>,</span><br><span class="line">  V</span><br><span class="line">&gt;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这是每个钩子函数对应的类型，它有 4 个入参：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 钩子函数的 TS 类型</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">DirectiveHook</span>&lt;</span><br><span class="line">  T = <span class="built_in">any</span>,</span><br><span class="line">  <span class="title class_">Prev</span> = <span class="title class_">VNode</span>&lt;<span class="built_in">any</span>, T&gt; | <span class="literal">null</span>,</span><br><span class="line">  V = <span class="built_in">any</span></span><br><span class="line">&gt; = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">el</span>: T,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">binding</span>: <span class="title class_">DirectiveBinding</span>&lt;V&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">vnode</span>: <span class="title class_">VNode</span>&lt;<span class="built_in">any</span>, T&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">prevVNode</span>: <span class="title class_">Prev</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>钩子函数第二个参数的类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 钩子函数第二个参数的 TS 类型</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">interface</span> <span class="title class_">DirectiveBinding</span>&lt;V = <span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  <span class="attr">instance</span>: <span class="title class_">ComponentPublicInstance</span> | <span class="literal">null</span></span><br><span class="line">  <span class="attr">value</span>: V</span><br><span class="line">  <span class="attr">oldValue</span>: V | <span class="literal">null</span></span><br><span class="line">  <span class="attr">arg</span>?: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">modifiers</span>: <span class="title class_">DirectiveModifiers</span></span><br><span class="line">  <span class="attr">dir</span>: <span class="title class_">ObjectDirective</span>&lt;<span class="built_in">any</span>, V&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>可以看到自定义指令最核心的就是 “钩子函数” 了，接下来来了解这部分的知识点。</p><h4 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h4><p>和 组件的生命周期 类似，自定义指令里的逻辑代码也有一些特殊的调用时机，在这里称之为钩子函数：</p><table><thead><tr><th align="center">钩子函数</th><th align="left">调用时机</th></tr></thead><tbody><tr><td align="center">created</td><td align="left">在绑定元素的 attribute 或事件侦听器被应用之前调用</td></tr><tr><td align="center">beforeMount</td><td align="left">当指令第一次绑定到元素并且在挂载父组件之前调用</td></tr><tr><td align="center">mounted</td><td align="left">在绑定元素的父组件被挂载后调用</td></tr><tr><td align="center">beforeUpdate</td><td align="left">在更新包含组件的 VNode 之前调用</td></tr><tr><td align="center">updated</td><td align="left">在包含组件的 VNode 及其子组件的 VNode 更新后调用</td></tr><tr><td align="center">beforeUnmount</td><td align="left">在卸载绑定元素的父组件之前调用</td></tr><tr><td align="center">unmounted</td><td align="left">当指令与元素解除绑定且父组件已卸载时，只调用一次</td></tr></tbody></table><blockquote><p>因为自定义指令的默认写法是一个对象，所以在代码风格上遵循 Options API 的生命周期命名，而非 Vue 3 的 Composition API 风格。</p></blockquote><p>钩子函数在用法上就是这样子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myDirective = &#123;</span><br><span class="line">  <span class="title function_">created</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 其他钩子...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在相关的 TS 类型]已了解，每个钩子函数都有 4 个入参：</p><table><thead><tr><th align="center">参数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="center">el</td><td align="left">指令绑定的 DOM 元素，可以直接操作它</td></tr><tr><td align="center">binding</td><td align="left">一个对象数据，见下方的单独说明</td></tr><tr><td align="center">vnode</td><td align="left">el 对应在 Vue 里的虚拟节点信息</td></tr><tr><td align="center">prevVNode</td><td align="left">Update 时的上一个虚拟节点信息，仅在 <code>beforeUpdate</code> 和 <code>updated</code> 可用</td></tr></tbody></table><p>其中用的最多是 <code>el</code> 和 <code>binding</code> 。</p><ul><li><code>el</code> 的值就是通过 <code>document.querySelector</code> 拿到的那个 DOM 元素。</li><li><code>binding</code> 是一个对象，里面包含了以下属性：</li></ul><table><thead><tr><th align="center">属性</th><th align="left">作用</th></tr></thead><tbody><tr><td align="center">value</td><td align="left">传递给指令的值，例如 <code>v-foo=&quot;bar&quot;</code> 里的 <code>bar</code> ，支持任意有效的 JS 表达式</td></tr><tr><td align="center">oldValue</td><td align="left">指令的上一个值，仅对 <code>beforeUpdate</code> 和 <code>updated</code> 可用</td></tr><tr><td align="center">arg</td><td align="left">传给指令的参数，例如 <code>v-foo:bar</code> 里的 <code>bar</code></td></tr><tr><td align="center">modifiers</td><td align="left">传给指令的修饰符，例如 <code>v-foo.bar</code> 里的 <code>bar</code></td></tr><tr><td align="center">instance</td><td align="left">使用指令的组件实例</td></tr><tr><td align="center">dir</td><td align="left">指令定义的对象（就是上面的 <code>const myDirective = &#123; /* ... */ &#125;</code> 这个对象）</td></tr></tbody></table><p>在了解了指令的写法和参数作用之后，来看看如何注册一个自定义指令。</p><h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><p>自定义指令可以在单个组件内定义并使用，通过和 setup 函数]同级别的 <code>directives</code> 选项进行定义，可以参考下面的例子和注释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 这个使用默认值 `unset` --&gt;</span><br><span class="line">  &lt;div v-highlight&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 这个使用传进去的黄色 --&gt;</span><br><span class="line">  &lt;div v-highlight=&quot;`yellow`&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  // 自定义指令在这里编写，和 `setup` 同级别</span><br><span class="line">  directives: &#123;</span><br><span class="line">    // `directives` 下的每个字段名就是指令名称</span><br><span class="line">    highlight: &#123;</span><br><span class="line">      // 钩子函数</span><br><span class="line">      mounted(el, binding) &#123;</span><br><span class="line">        el.style.backgroundColor =</span><br><span class="line">          typeof binding.value === &#x27;string&#x27; ? binding.value : &#x27;unset&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const msg = ref&lt;string&gt;(&#x27;Hello World!&#x27;)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      msg,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>上面是对象式的写法，也可以写成函数式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="attr">directives</span>: &#123;</span><br><span class="line">    <span class="title function_">highlight</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">      el.<span class="property">style</span>.<span class="property">backgroundColor</span> =</span><br><span class="line">        <span class="keyword">typeof</span> binding.<span class="property">value</span> === <span class="string">&#x27;string&#x27;</span> ? binding.<span class="property">value</span> : <span class="string">&#x27;unset&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>TIP 局部注册的自定义指令，默认在子组件内生效，子组件内无需重新注册即可使用父组件的自定义指令。</p></blockquote><h4 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h4><p>自定义指令也可以注册成全局，这样就无需在每个组件里定义了，只要在入口文件 <code>main.ts</code> 里启用它，任意组件里都可以使用自定义指令。</p><h4 id="deep-选项"><a href="#deep-选项" class="headerlink" title="deep 选项"></a>deep 选项</h4><p>除了钩子函数，在相关的 TS 类型里还可以看到有一个 deep 选项，它是一个布尔值，作用是：</p><p>如果自定义指令用于一个有嵌套属性的对象，并且需要在嵌套属性更新的时候触发 <code>beforeUpdate</code> 和 <code>updated</code> 钩子，那么需要将这个选项设置为 <code>true</code> 才能够生效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div v-foo=&quot;foo&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, reactive &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  directives: &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">      beforeUpdate(el, binding) &#123;</span><br><span class="line">        console.log(&#x27;beforeUpdate&#x27;, binding)</span><br><span class="line">      &#125;,</span><br><span class="line">      updated(el, binding) &#123;</span><br><span class="line">        console.log(&#x27;updated&#x27;, binding)</span><br><span class="line">      &#125;,</span><br><span class="line">      mounted(el, binding) &#123;</span><br><span class="line">        console.log(&#x27;mounted&#x27;, binding)</span><br><span class="line">      &#125;,</span><br><span class="line">      // 需要设置为 `true` ，如果是 `false` 则不会触发</span><br><span class="line">      deep: true,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    // 定义一个有嵌套属性的对象</span><br><span class="line">    const foo = reactive(&#123;</span><br><span class="line">      bar: &#123;</span><br><span class="line">        baz: 1,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    // 2s 后修改其中一个值，会触发 `beforeUpdate` 和 `updated`</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      foo.bar.baz = 2</span><br><span class="line">      console.log(foo)</span><br><span class="line">    &#125;, 2000)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      foo,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><p>Vue 在使用子组件的时候，子组件在 template 里类似一个 HTML 标签，可以在这个子组件标签里传入任意模板代码以及 HTML 代码，这个功能就叫做 “插槽” 。</p><h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><p>默认情况下，子组件使用 <code>&lt;slot /&gt;</code> 标签即可渲染父组件传下来的插槽内容，例如：</p><p>在父组件这边：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Child&gt;</span><br><span class="line">    &lt;!-- 注意这里，子组件标签里面传入了 HTML 代码 --&gt;</span><br><span class="line">    &lt;p&gt;这是插槽内容&lt;/p&gt;</span><br><span class="line">  &lt;/Child&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent &#125; from &#x27;vue&#x27;</span><br><span class="line">import Child from &#x27;@cp/Child.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在子组件这边：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;slot /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>默认插槽非常简单，一个 <code>&lt;slot /&gt;</code> 就可以了。</p><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>有时候可能需要指定多个插槽，例如一个子组件里有 “标题” 、 “作者”、 “内容” 等预留区域可以显示对应的内容，这时候就需要用到具名插槽来指定不同的插槽位。</p><p>子组件通过 <code>name</code> 属性来指定插槽名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 显示标题的插槽内容 --&gt;</span><br><span class="line">  &lt;div class=&quot;title&quot;&gt;</span><br><span class="line">    &lt;slot name=&quot;title&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 显示作者的插槽内容 --&gt;</span><br><span class="line">  &lt;div class=&quot;author&quot;&gt;</span><br><span class="line">    &lt;slot name=&quot;author&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 其他插槽内容放到这里 --&gt;</span><br><span class="line">  &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">    &lt;slot /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>父组件通过 <code>template</code> 标签绑定 <code>v-slot:name</code> 格式的属性，来指定传入哪个插槽里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Child&gt;</span><br><span class="line">    &lt;!-- 传给标题插槽 --&gt;</span><br><span class="line">    &lt;template v-slot:title&gt;</span><br><span class="line">      &lt;h1&gt;这是标题&lt;/h1&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 传给作者插槽 --&gt;</span><br><span class="line">    &lt;template v-slot:author&gt;</span><br><span class="line">      &lt;h1&gt;这是作者信息&lt;/h1&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 传给默认插槽 --&gt;</span><br><span class="line">    &lt;p&gt;这是插槽内容&lt;/p&gt;</span><br><span class="line">  &lt;/Child&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><code>v-slot:name</code> 有一个别名 <code>#name</code> 语法，上面父组件的代码也相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Child&gt;</span><br><span class="line">    &lt;!-- 传给标题插槽 --&gt;</span><br><span class="line">    &lt;template #title&gt;</span><br><span class="line">      &lt;h1&gt;这是标题&lt;/h1&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 传给作者插槽 --&gt;</span><br><span class="line">    &lt;template #author&gt;</span><br><span class="line">      &lt;h1&gt;这是作者信息&lt;/h1&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 传给默认插槽 --&gt;</span><br><span class="line">    &lt;p&gt;这是插槽内容&lt;/p&gt;</span><br><span class="line">  &lt;/Child&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><blockquote><p>TIP  在使用具名插槽的时候，子组件如果不指定默认插槽，那么在具名插槽之外的内容将不会被渲染。</p></blockquote><h3 id="默认内容"><a href="#默认内容" class="headerlink" title="默认内容"></a>默认内容</h3><p>可以给 <code>slot</code> 标签添加内容，例如 <code>&lt;slot&gt;默认内容&lt;/slot&gt;</code> ，当父组件没有传入插槽内容时，会使用默认内容来显示，默认插槽和具名插槽均支持该功能。</p><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>有一条规则需要记住：</p><ul><li>父组件里的所有内容都是在父级作用域中编译的</li><li>子组件里的所有内容都是在子作用域中编译的</li></ul><h2 id="CSS-样式与预处理器"><a href="#CSS-样式与预处理器" class="headerlink" title="CSS 样式与预处理器"></a>CSS 样式与预处理器</h2><p>Vue 组件的 CSS 样式部分，Vue 3 保留着和 Vue 2 完全一样的写法。</p><h3 id="编写组件样式表"><a href="#编写组件样式表" class="headerlink" title="编写组件样式表"></a>编写组件样式表</h3><p>最基础的写法，就是在 <code>.vue</code> 文件里添加一个 <code>&lt;style /&gt;</code> 标签，即可在里面写 CSS 代码了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- HTML 代码 --&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">  // TypeScript 代码</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">/* CSS 代码 */</span><br><span class="line">.msg &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.msg p &#123;</span><br><span class="line">  color: #333;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="动态绑定-CSS"><a href="#动态绑定-CSS" class="headerlink" title="动态绑定 CSS"></a>动态绑定 CSS</h3><p>动态绑定 CSS ，在 Vue 2 就已经存在了，在此之前常用的是 <code>:class</code> 和 <code>:style</code> ，现在在 Vue 3 ，还可以通过 <code>v-bind</code> 来动态修改了。</p><h4 id="使用-class-动态修改样式名"><a href="#使用-class-动态修改样式名" class="headerlink" title="使用 :class 动态修改样式名"></a>使用 :class 动态修改样式名</h4><p>它是绑定在 DOM 元素上面的一个属性，跟 <code>class=&quot;class-name&quot;</code> 这样的属性同级别，它非常灵活！</p><blockquote><p>TIP 使用 <code>:class</code> 是用来动态修改样式名，也就意味着必须提前把样式名对应的样式表先写好！</p></blockquote><p>假设已经提前定义好了这几个变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const activeClass = &#x27;active-class&#x27;</span><br><span class="line">    const activeClass1 = &#x27;active-class1&#x27;</span><br><span class="line">    const activeClass2 = &#x27;active-class2&#x27;</span><br><span class="line">    const isActive = true</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      activeClass,</span><br><span class="line">      activeClass1,</span><br><span class="line">      activeClass2,</span><br><span class="line">      isActive,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>如果只想绑定一个单独的动态样式，可以传入一个字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p :class=&quot;activeClass&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>如果有多个动态样式，也可以传入一个数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p :class=&quot;[activeClass1, activeClass2]&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>还可以对动态样式做一些判断，这个时候传入一个对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p :class=&quot;&#123; &#x27;active-class&#x27;: isActive &#125;&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>多个判断的情况下，记得也用数组套起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p :class=&quot;[&#123; activeClass1: isActive &#125;, &#123; activeClass2: !isActive &#125;]&quot;&gt;</span><br><span class="line">    Hello World!</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>那么什么情况下会用到 <code>:class</code> 呢？</p><p>最常见的场景，应该就是导航、选项卡了，比如要给一个当前选中的选项卡做一个突出高亮的状态，那么就可以使用 <code>:class</code> 来动态绑定一个样式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul class=&quot;list&quot;&gt;</span><br><span class="line">    &lt;li</span><br><span class="line">      class=&quot;item&quot;</span><br><span class="line">      :class=&quot;&#123; cur: index === curIndex &#125;&quot;</span><br><span class="line">      v-for=&quot;(item, index) in 5&quot;</span><br><span class="line">      :key=&quot;index&quot;</span><br><span class="line">      @click=&quot;curIndex = index&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;&#123; item &#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const curIndex = ref&lt;number&gt;(0)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      curIndex,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.cur &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>这样就简单实现了一个点击切换选项卡高亮的功能。</p><h4 id="使用-style-动态修改内联样式"><a href="#使用-style-动态修改内联样式" class="headerlink" title="使用 :style 动态修改内联样式"></a>使用 :style 动态修改内联样式</h4><p>如果觉得使用 <code>:class</code> 需要提前先写样式，再去绑定样式名有点繁琐，有时候只想简简单单的修改几个样式，那么可以通过 <code>:style</code> 来处理。</p><p>默认的情况下，都是传入一个对象去绑定：</p><ul><li><code>key</code> 是符合 CSS 属性名的 “小驼峰式” 写法，或者套上引号的短横线分隔写法（原写法），例如在 CSS 里，定义字号是 <code>font-size</code> ，那么需要写成 <code>fontSize</code> 或者 <code>&#39;font-size&#39;</code> 作为它的键。</li><li><code>value</code> 是 CSS 属性对应的 “合法值”，比如要修改字号大小，可以传入 <code>13px</code> 、<code>0.4rem</code> 这种带合法单位字符串值，但不可以是 <code>13</code> 这样的缺少单位的值，无效的 CSS 值会被过滤不渲染。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p</span><br><span class="line">    :style=&quot;&#123;</span><br><span class="line">      fontSize: &#x27;13px&#x27;,</span><br><span class="line">      &#x27;line-height&#x27;: 2,</span><br><span class="line">      color: &#x27;#ff0000&#x27;,</span><br><span class="line">      textAlign: &#x27;center&#x27;,</span><br><span class="line">    &#125;&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    Hello World!</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>如果有些特殊场景需要绑定多套 <code>style</code>，需要在 <code>script</code> 先定义好各自的样式变量（也是符合上面说到的那几个要求的对象），然后通过数组来传入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p :style=&quot;[style1, style2]&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const style1 = &#123;</span><br><span class="line">      fontSize: &#x27;13px&#x27;,</span><br><span class="line">      &#x27;line-height&#x27;: 2,</span><br><span class="line">    &#125;</span><br><span class="line">    const style2 = &#123;</span><br><span class="line">      color: &#x27;#ff0000&#x27;,</span><br><span class="line">      textAlign: &#x27;center&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      style1,</span><br><span class="line">      style2,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="使用-v-bind-动态修改-style"><a href="#使用-v-bind-动态修改-style" class="headerlink" title="使用 v-bind 动态修改 style"></a>使用 v-bind 动态修改 style</h4><p>当然，以上两种形式都是关于 <code>&lt;script /&gt;</code> 和 <code>&lt;template /&gt;</code> 部分的操作，如果觉得会给模板带来一定的维护成本的话，不妨考虑这个新方案，将变量绑定到 <code>&lt;style /&gt;</code> 部分去。</p><blockquote><p>TIP 请注意这是一个在 <code>3.2.0</code> 版本之后才被归入正式队列的新功能！如果需要使用它，请确保的 <code>vue</code> 的版本号在 <code>3.2.0</code> 以上，最好是保持最新版本。</p></blockquote><p>先来看看基本的用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p class=&quot;msg&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const fontColor = ref&lt;string&gt;(&#x27;#ff0000&#x27;)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      fontColor,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.msg &#123;</span><br><span class="line">  color: v-bind(fontColor);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>如上面的代码，将渲染出一句红色文本的 <code>Hello World!</code></p><p>这其实是利用了现代浏览器支持的 CSS 变量来实现的一个功能（所以如果打算用它的话，需要提前注意一下兼容性噢，点击查看：<a href="https://caniuse.com/css-variables">CSS Variables 兼容情况</a> ）。</p><p>它渲染到 DOM 上，其实也是通过绑定 <code>style</code> 来实现，可以看到渲染出来的样式是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;msg&quot;</span> <span class="attr">data-v-7eb2bc79</span>=<span class="string">&quot;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--7eb2bc79-fontColor:#ff0000;&quot;</span>&gt;</span></span><br><span class="line">  Hello World!</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的 CSS 变成了：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.msg</span><span class="selector-attr">[data-v-7eb2bc79]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--<span class="number">7</span>eb2bc79-fontColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理论上 <code>v-bind</code> 函数可以在 Vue 内部支持任意的 JavaScript 表达式，但由于可能包含在 CSS 标识符中无效的字符，因此官方是建议在大多数情况下，用引号括起来，如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="built_in">v-bind</span>(<span class="string">&#x27;theme.font.size&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 CSS 变量的特性，因此对 CSS 响应式属性的更改不会触发模板的重新渲染（这也是和 <code>:class</code> 与 <code>:style</code> 的最大不同）。</p><blockquote><p>TIP 不管有没有开启 style-scoped ，使用 <code>v-bind</code> 渲染出来的 CSS 变量，都会带上 <code>scoped</code> 的随机 hash 前缀，避免样式污染（永远不会意外泄漏到子组件中），所以请放心使用！</p></blockquote><p>如果对 CSS 变量的使用还不是很了解的话，可以先阅读一下相关的基础知识点。</p><p>相关阅读：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties">使用 CSS 自定义属性（变量） - MDN</a></p><h3 id="样式表的组件作用域"><a href="#样式表的组件作用域" class="headerlink" title="样式表的组件作用域"></a>样式表的组件作用域</h3><p>CSS 不像 JS ，是没有作用域的概念的，一旦写了某个样式，直接就是全局污染。所以 <a href="https://www.bemcss.com/">BEM 命名法</a> 等规范才应运而生。</p><p>但在 Vue 组件里，有两种方案可以避免出现这种污染问题：一个是 Vue 2 就有的 <code>&lt;style scoped&gt;</code> ，一个是 Vue 3 新推出的 <code>&lt;style module&gt;</code> 。</p><h4 id="Style-Scoped"><a href="#Style-Scoped" class="headerlink" title="Style Scoped"></a>Style Scoped</h4><p>Vue 组件在设计的时候，就想到了一个很优秀的解决方案，通过 <code>scoped</code> 来支持创建一个 CSS 作用域，使这部分代码只运行在这个组件渲染出来的虚拟 DOM 上。</p><p>使用方式很简单，只需要在 <code>&lt;style /&gt;</code> 上添加 <code>scoped</code> 属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注意这里多了一个 `scoped` --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.msg &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.msg p &#123;</span><br><span class="line">  color: #333;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>编译后，虚拟 DOM 都会带有一个 <code>data-v-xxxxx</code> 这样的属性，其中 <code>xxxxx</code> 是一个随机生成的 Hash ，同一个组件的 Hash 是相同并且唯一的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;msg&quot;</span> <span class="attr">data-v-7eb2bc79</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">data-v-7eb2bc79</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而 CSS 则也会带上与 HTML 相同的属性，从而达到样式作用域的目的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.msg</span><span class="selector-attr">[data-v-7eb2bc79]</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.msg</span> <span class="selector-tag">p</span><span class="selector-attr">[data-v-7eb2bc79]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>scoped</code> 可以有效的避免全局样式污染，可以在不同的组件里面都使用相同的 className，而不必担心会相互覆盖，不必再定义很长很长的样式名来防止冲突了。</p><blockquote><p>TIP 添加 <code>scoped</code> 生成的样式，只作用于当前组件中的元素，并且权重高于全局 CSS ，可以覆盖全局样式</p></blockquote><h4 id="Style-Module"><a href="#Style-Module" class="headerlink" title="Style Module"></a>Style Module</h4><p>这是在 Vue 3 才推出的一个新方案，和 <code>&lt;style scoped&gt;</code> 不同，scoped 是通过给 DOM 元素添加自定义属性的方式来避免冲突，而 <code>&lt;style module&gt;</code> 则更为激进，将会编译成 <a href="https://github.com/css-modules/css-modules">CSS Modules</a> 。</p><p>对于 CSS Modules 的处理方式，也可以通过一个小例子来更直观的了解它：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 案例来自阮一峰老师的博文《CSS Modules 用法教程》 */</span></span><br><span class="line"><span class="comment">/* https://www.ruanyifeng.com/blog/2016/06/css_modules.html */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 编译前 */</span></span><br><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 编译后 */</span></span><br><span class="line">._3zyde4l1yATCOkgn-DBWEL &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，是通过比较 “暴力” 的方式，把编写的 “好看的” 样式名，直接改写成一个随机 Hash 样式名，来避免样式互相污染。</p><p>所以回到 Vue 这边，看看 <code>&lt;style module&gt;</code> 是怎么操作的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p :class=&quot;$style.msg&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style module&gt;</span><br><span class="line">.msg &#123;</span><br><span class="line">  color: #ff0000;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>于是，将渲染出一句红色文本的 <code>Hello World!</code> 。</p><blockquote><p>TIP</p><ol><li>使用这个方案，需要了解如何 <a href="https://vue3.chengpeiquan.com/component.html#%E4%BD%BF%E7%94%A8-class-%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%A0%B7%E5%BC%8F%E5%90%8D">使用 :class 动态修改样式名</a></li><li>如果单纯只使用 <code>&lt;style module&gt;</code> ，那么在绑定样式的时候，是默认使用 <code>$style</code> 对象来操作的</li><li>必须显示的指定绑定到某个样式，比如 <code>$style.msg</code> ，才能生效</li><li>如果单纯的绑定 <code>$style</code> ，并不能得到 “把全部样式名直接绑定” 的期望结果</li><li>如果指定的 className 是短横杆命名，比如 <code>.user-name</code> ，那么需要通过 <code>$style[&#39;user-name&#39;]</code> 去绑定</li></ol></blockquote><p>也可以给 <code>module</code> 进行命名，然后就可以通过命名的 “变量名” 来操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p :class=&quot;classes.msg&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style module=&quot;classes&quot;&gt;</span><br><span class="line">.msg &#123;</span><br><span class="line">  color: #ff0000;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><blockquote><p>TIP 需要注意的一点是，一旦开启 <code>&lt;style module&gt;</code> ，那么在 <code>&lt;style module&gt;</code> 里所编写的样式都必须手动绑定才能生效，没有被绑定的样式虽然也会被编译，但不会主动生效到 DOM 上。</p></blockquote><p>原因是编译出来的样式名已经变化，而原来的 DOM 未指定对应的样式名，或者指定的是编译前的命名，所以并不能匹配到正确的样式。</p><h4 id="useCssModule"><a href="#useCssModule" class="headerlink" title="useCssModule"></a>useCssModule</h4><p>这是一个全新的 API ，面向在 script 部分操作 CSS Modules 。</p><p>在上面的CSS Modules部分可以知道，可以在 <code>style</code> 定义好样式，然后在 <code>template</code> 部分通过变量名来绑定样式。</p><p>那么如果有一天有个需求，需要通过 <code>v-html</code> 来渲染 HTML 代码，那这里的样式岂不是凉凉了？当然不会！</p><p>Vue 3 提供了一个 Composition API <code>useCssModule</code> 来帮助在 <code>setup</code> 函数里操作的 CSS Modules （对，只能在 setup或者 script setup 里使用）。</p><p><strong>基本用法：</strong></p><p>多绑定几个样式，再来操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p :class=&quot;$style.msg&quot;&gt;</span><br><span class="line">    &lt;span :class=&quot;$style.text&quot;&gt;Hello World!&lt;/span&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, useCssModule &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const style = useCssModule()</span><br><span class="line">    console.log(style)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style module&gt;</span><br><span class="line">.msg &#123;</span><br><span class="line">  color: #ff0000;</span><br><span class="line">&#125;</span><br><span class="line">.text &#123;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>可以看到打印出来的 <code>style</code> 是一个对象：</p><ul><li><code>key</code> 是在 <code>&lt;style modules&gt;</code> 里定义的原始样式名</li><li><code>value</code> 则是编译后的新样式名</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&#x27;home_msg_37Xmr&#x27;</span>,</span><br><span class="line">  <span class="attr">text</span>: <span class="string">&#x27;home_text_2woQJ&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以来配合 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals">模板字符串</a> 的使用，看看刚刚说的，要通过 <code>v-html</code> 渲染出来的内容应该如何绑定样式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div v-html=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, useCssModule &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    // 获取样式</span><br><span class="line">    const style = useCssModule()</span><br><span class="line"></span><br><span class="line">    // 编写模板内容</span><br><span class="line">    const content = `&lt;p class=&quot;$&#123;style.msg&#125;&quot;&gt;</span><br><span class="line">      &lt;span class=&quot;$&#123;style.text&#125;&quot;&gt;Hello World! —— from v-html&lt;/span&gt;</span><br><span class="line">    &lt;/p&gt;`</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      content,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style module&gt;</span><br><span class="line">.msg &#123;</span><br><span class="line">  color: #ff0000;</span><br><span class="line">&#125;</span><br><span class="line">.text &#123;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>是不是也非常简单？可能刚开始不太习惯，但写多几次其实这个功能也蛮好玩的！</p><p><strong>另外，需要注意的是，如果指定了 modules 的名称，那么必须传入对应的名称作为入参才可以正确拿到这些样式：</strong></p><p>比如指定了一个 classes 作为名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style module=&quot;classes&quot;&gt;</span><br><span class="line">/* ... */</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>那么需要通过传入 classes 这个名称才能拿到样式，否则会是一个空对象：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> style = <span class="title function_">useCssModule</span>(<span class="string">&#x27;classes&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>TIP  在 <code>const style = useCssModule()</code> 的时候，命名是随意的，跟在 <code>&lt;style module=&quot;classes&quot;&gt;</code> 这里指定的命名没有关系。</p></blockquote><h3 id="深度操作符"><a href="#深度操作符" class="headerlink" title="深度操作符"></a>深度操作符</h3><p>使用 scoped 后，父组件的样式将不会渗透到子组件中，也不能直接修改子组件的样式。</p><p>如果确实需要修改子组件的样式，必须通过 <code>::v-deep</code>（完整写法） 或者 <code>:deep</code>（快捷写法） 操作符来实现。</p><blockquote><p>TIP</p><ol><li>旧版的深度操作符是 <code>&gt;&gt;&gt;</code> 、 <code>/deep/</code> 和 <code>::v-deep</code>，现在 <code>&gt;&gt;&gt;</code> 和 <code>/deep/</code> 已进入弃用阶段（虽然暂时还没完全移除）</li><li>同时需要注意的是，旧版 <code>::v-deep</code> 的写法是作为组合器的方式，写在样式或者元素前面，如：<code>::v-deep .class-name &#123; /* ... */ &#125;</code>，现在这种写法也废弃了。</li></ol></blockquote><p>现在不论是 <code>::v-deep</code> 还是 <code>:deep</code> ，使用方法非常统一，来假设 .b 是子组件的样式名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">.a :deep(.b) &#123;</span><br><span class="line">  /* ... */</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>编译后：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span><span class="selector-attr">[data-v-f3f3eg9]</span> <span class="selector-class">.b</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>TIP 可以看到，新的 deep 写法是作为一个类似 JS “函数” 那样去使用，需要深度操作的样式或者元素名，作为 “入参” 去传入。</p><p>同理，如果使用 Less 或者 Stylus 这种支持嵌套写法的预处理器，也是可以这样去深度操作的：</p></blockquote><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">  :<span class="selector-tag">deep</span>(.b) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，除了操作子组件的样式，那些通过 <code>v-html</code> 创建的 DOM 内容，也不受作用域内的样式影响，也可以通过深度操作符来实现样式修改。</p><h3 id="使用-CSS-预处理器"><a href="#使用-CSS-预处理器" class="headerlink" title="使用 CSS 预处理器"></a>使用 CSS 预处理器</h3><p>在工程化的现在，可以说前端都几乎不写 CSS 了，都是通过 <code>sass</code>、<code>less</code>、<code>stylus</code> 等 CSS 预处理器来完成样式的编写。</p><p>为什么要用 CSS 预处理器？放一篇关于三大预处理器的点评，新开发者可以做个简单了解，具体的用法在对应的官网上有非常详细的说明。</p><p>可以查看了解：<a href="https://zhuanlan.zhihu.com/p/23382462">浅谈 CSS 预处理器，Sass、Less 和 Stylus</a></p><p>在 Vue 组件里使用预处理器非常简单，像 Vite 已内置了对预处理器文件的支持（可处理 <code>.less</code> 、 <code>.scss</code> 之类的预处理器扩展名文件），因此只需要安装对应的依赖到项目里。</p><p>这里以 <a href="https://github.com/less/less.js">Less</a> 为例，先安装该预处理器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为是在开发阶段使用，所以添加到 `devDependencies`</span></span><br><span class="line">npm i -D less</span><br></pre></td></tr></table></figure><p>接下来在 Vue 组件里，只需要在 <code>&lt;style /&gt;</code> 标签上，通过 <code>lang=&quot;less&quot;</code> 属性指定使用哪个预处理器，即可直接编写对应的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">// 定义颜色变量</span><br><span class="line">@color-black: #333;</span><br><span class="line">@color-red: #ff0000;</span><br><span class="line"></span><br><span class="line">// 父级标签</span><br><span class="line">.msg &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  // 其子标签可以使用嵌套写法</span><br><span class="line">  p &#123;</span><br><span class="line">    color: @color-black;</span><br><span class="line">    font-size: 14px;</span><br><span class="line">    // 支持多级嵌套</span><br><span class="line">    span &#123;</span><br><span class="line">      color: @color-red;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>编译后的 css 代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.msg</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.msg</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333333</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.msg</span> <span class="selector-tag">p</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预处理器也支持 <code>scoped</code>。</p><h2 id="Vue-Devtools"><a href="#Vue-Devtools" class="headerlink" title="Vue Devtools"></a>Vue Devtools</h2><p>Vue Devtools 是一个浏览器扩展，支持 Chrome 、 Firefox 等浏览器，需要先安装才能使用。</p><p>点击安装：<a href="https://devtools.vuejs.org/guide/installation.html">Vue Devtools 的浏览器扩展</a></p><p>当在 Vue 项目通过 <code>npm run dev</code> 等命令启动开发环境服务后，访问本地页面（如： <code>http://localhost:3000/</code> ），在页面上按 F12 唤起浏览器的控制台，会发现多了一个名为 <code>vue</code> 的面板。</p><p>面板的顶部有一个菜单可以切换不同的选项卡，菜单数量会根据不同项目有所不同，例如没有安装 Pinia 则不会出现 Pinia 选项卡，这里以其中一部分选项卡作为举例。</p><h3 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h3><p>Components 是以结构化的方式显示组件的调试信息，可以查看组件的父子关系，并检查组件的各种内部状态：</p><p><img src="/p/e930893f/3e26be0a15dc6863e534e51432026f49.jpg" alt="Vue Devtools 的 Components 界面"></p><h3 id="Routes"><a href="#Routes" class="headerlink" title="Routes"></a>Routes</h3><p>Routes 可以查看当前所在路由的配置信息：</p><p><img src="/p/e930893f/58952f0abc9fbad3903a3dc5e81c7b14.jpg" alt="Vue Devtools 的 Routes 界面"></p><h3 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h3><p>Timeline 是以时间线的方式追踪不同类型的数据，例如事件：</p><p><img src="/p/e930893f/2043dfa393db23fc46d5ee34215c48f8.jpg" alt="Vue Devtools 的 Timeline 界面"></p><h3 id="Pinia"><a href="#Pinia" class="headerlink" title="Pinia"></a>Pinia</h3><p>Pinia 是可以查看当前组件引入的全局状态情况：</p><p><img src="/p/e930893f/7980bce40ff75223abd18dfe09771b73.jpg" alt="Vue Devtools 的 Pinia 界面"></p><script>var description="Vue3入门"</script>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VScode环境配置</title>
      <link href="/p/9f7edc20.html"/>
      <url>/p/9f7edc20.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>安装</strong>：前往 VS Code 官方网站（<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a> ），根据你的操作系统（Windows、Mac 或 Linux）下载对应的安装包。下载完成后，运行安装程序，按照提示完成安装。</p><h2 id="VS-Code-的设置页面"><a href="#VS-Code-的设置页面" class="headerlink" title="VS Code 的设置页面"></a>VS Code 的设置页面</h2><blockquote><p>通过菜单操作</p></blockquote><ol><li>点击菜单栏中的 “文件” 选项。</li><li>在弹出的下拉菜单中，选择 “首选项”。</li><li>然后点击 “设置”，即可打开设置页面。</li></ol><blockquote><p>使用快捷键</p></blockquote><ol><li>在 Windows 和 Linux 系统上，可以使用 <code>Ctrl +,</code>（逗号）快捷键直接打开设置页面。</li><li>在 Mac 系统上，使用 <code>Command +,</code>（逗号）快捷键来打开设置页面。</li></ol><h2 id="VS-Code-配置文件"><a href="#VS-Code-配置文件" class="headerlink" title="VS Code 配置文件"></a>VS Code 配置文件</h2><p>以下是对给定的 VS Code 配置文件的分析、分类和问题修正：</p><h3 id="一、界面主题和图标主题相关"><a href="#一、界面主题和图标主题相关" class="headerlink" title="一、界面主题和图标主题相关"></a>一、界面主题和图标主题相关</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;workbench.colorTheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;One Dark Pro&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;workbench.iconTheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vscode-icons&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li><code>workbench.colorTheme</code> 用于设置 VS Code 的颜色主题，这里选择的是 “Default Light Modern” 主题，提供了一种明亮的现代风格的界面颜色。</li><li><code>workbench.iconTheme</code> 用于设置文件和文件夹等元素的图标主题，这里使用的是 “vscode-icons”，为 VS Code 的资源管理器等区域带来了丰富的图标。</li></ul><h3 id="二、远程开发相关"><a href="#二、远程开发相关" class="headerlink" title="二、远程开发相关"></a>二、远程开发相关</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;remote.SSH.remotePlatform&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;192.168.1.102(root)&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li>该配置用于远程开发，特别是通过 SSH 连接时。它指定了远程服务器 <code>192.168.1.102(root)</code> 的平台是 <code>linux</code>，这样 VS Code 可以根据平台信息进行相应的远程操作和适配。</li></ul><h3 id="三、资源管理器相关"><a href="#三、资源管理器相关" class="headerlink" title="三、资源管理器相关"></a>三、资源管理器相关</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;explorer.sortOrder&quot;</span><span class="punctuation">:</span> <span class="string">&quot;modified&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;explorer.confirmDelete&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li><code>explorer.sortOrder</code> 决定了资源管理器中文件和文件夹的排序方式，这里设置为 <code>modified</code>，表示按照修改时间排序。</li><li><code>explorer.confirmDelete</code> 原本设置为 <code>false</code>，表示在删除文件时不弹出确认对话框。但是在配置文件中存在重复设置，且后面的注释说明应该是最终保留该设置为 <code>false</code>，所以可以保留该配置。</li></ul><h3 id="四、Git-相关"><a href="#四、Git-相关" class="headerlink" title="四、Git 相关"></a>四、Git 相关</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;git.autofetch&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;git.enableSmartCommit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;workbench.editorAssociations&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;&#123;git,gitlens,git-graph&#125;:/**/*.&#123;md,csv,svg&#125;&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li><code>git.autofetch</code> 表示开启自动拉取 Git 仓库更新的功能。</li><li><code>git.enableSmartCommit</code> 启用智能提交功能，使提交操作更加便捷。</li><li><code>workbench.editorAssociations</code> 则是将与 Git 相关的文件（如 <code>git</code>、<code>gitlens</code>、<code>git-graph</code> 插件生成的文件，且文件后缀为 <code>md</code>、<code>csv</code>、<code>svg</code>）关联到默认编辑器。</li></ul><h3 id="五、不同语言的格式化相关"><a href="#五、不同语言的格式化相关" class="headerlink" title="五、不同语言的格式化相关"></a>五、不同语言的格式化相关</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;[markdown]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;harttle.md-padding-vscode&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;[javascript]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vscode.typescript-language-features&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;[html]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vscode.html-language-features&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;[json]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vscode.json-language-features&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;[vue]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;[typescript]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;[jsonc]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vscode.json-language-features&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li>对于不同的编程语言，设置了相应的默认格式化工具。例如，在编辑 <code>markdown</code> 文件时，使用 <code>harttle.md-padding-vscode</code> 进行格式化；在编辑 <code>vue</code> 或 <code>typescript</code> 文件时，使用 <code>esbenp.prettier-vscode</code> 进行格式化。</li></ul><h3 id="六、编辑器通用设置相关"><a href="#六、编辑器通用设置相关" class="headerlink" title="六、编辑器通用设置相关"></a>六、编辑器通用设置相关</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;editor.fontFamily&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#x27;MesloLGS NF&#x27;,Consolas, &#x27;Courier New&#x27;, monospace&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.mouseWheelZoom&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.insertSpaces&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.tabSize&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.wordWrap&quot;</span><span class="punctuation">:</span> <span class="string">&quot;on&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.autoClosingBrackets&quot;</span><span class="punctuation">:</span> <span class="string">&quot;always&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li><code>editor.fontFamily</code> 设定了编辑器使用的字体。</li><li><code>editor.mouseWheelZoom</code> 允许使用鼠标滚轮进行缩放操作。</li><li><code>editor.insertSpaces</code> 表示使用空格代替制表符，且 <code>editor.tabSize</code> 为 2，表示一个制表符等于 2 个空格。</li><li><code>editor.wordWrap</code> 为 <code>on</code> 表示自动换行。</li><li><code>editor.autoClosingBrackets</code> 总是自动闭合括号，提高代码输入效率。</li></ul><h3 id="七、保存时的代码操作相关"><a href="#七、保存时的代码操作相关" class="headerlink" title="七、保存时的代码操作相关"></a>七、保存时的代码操作相关</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;editor.formatOnSave&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;files.autoSave&quot;</span><span class="punctuation">:</span> <span class="string">&quot;afterDelay&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.codeActionsOnSave&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;source.fixAll.eslint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;explicit&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;source.fixAll&quot;</span><span class="punctuation">:</span> <span class="string">&quot;always&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>问题及修正</strong>：</p><ul><li>这里存在冲突，<code>editor.formatOnSave</code> 既被设置为 <code>true</code> 又被设置为 <code>false</code>，根据后面的注释，最终应该将 <code>editor.formatOnSave</code> 设置为 <code>false</code>。</li><li><code>editor.codeActionsOnSave</code> 中同时设置了 <code>source.fixAll.eslint</code> 和 <code>source.fixAll</code>，可能会引起混淆，根据注释，应该保留 <code>source.fixAll</code> 为 <code>always</code>，删除 <code>source.fixAll.eslint</code> 。</li></ul><p><strong>修改后的配置</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;editor.formatOnSave&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;files.autoSave&quot;</span><span class="punctuation">:</span> <span class="string">&quot;afterDelay&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.codeActionsOnSave&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;source.fixAll&quot;</span><span class="punctuation">:</span> <span class="string">&quot;always&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="八、JavaScript-相关特殊设置"><a href="#八、JavaScript-相关特殊设置" class="headerlink" title="八、JavaScript 相关特殊设置"></a>八、JavaScript 相关特殊设置</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;javascript.validate.enable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;emmet.includeLanguages&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;javascript&quot;</span><span class="punctuation">:</span> <span class="string">&quot;javascriptreact&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;emmet.triggerExpansionOnTab&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li><code>javascript.validate.enable</code> 关闭了 JavaScript 的代码校验功能。</li><li><code>emmet.includeLanguages</code> 将 JavaScript 关联到 <code>javascriptreact</code> 以支持 Emmet 功能。</li><li><code>emmet.triggerExpansionOnTab</code> 表示按下 <code>Tab</code> 键触发 Emmet 扩展，方便代码补全和快速输入。</li></ul><h3 id="九、Less-编译相关"><a href="#九、Less-编译相关" class="headerlink" title="九、Less 编译相关"></a>九、Less 编译相关</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;less.compile&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;out&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceRoot&#125;\\css\\&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li>该配置用于配置 Less 编译的输出目录，这里将编译输出目录设置为 <code>$&#123;workspaceRoot&#125;\\css\\</code>，表示将 Less 文件编译后输出到工作区根目录下的 <code>css</code> 文件夹。</li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="编码风格统一：EditorConfig"><a href="#编码风格统一：EditorConfig" class="headerlink" title="编码风格统一：EditorConfig"></a>编码风格统一：EditorConfig</h3><p><a href="https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig">EditorConfig for VS Code - Visual Studio Marketplace</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// .editorconfig</span><br><span class="line"></span><br><span class="line">root = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[*]</span><br><span class="line">charset = utf-8</span><br><span class="line">end_of_line = lf</span><br><span class="line">indent_size = 2</span><br><span class="line">indent_style = space</span><br><span class="line">insert_final_newline = <span class="literal">true</span></span><br><span class="line">max_line_length = 80</span><br><span class="line">trim_trailing_whitespace = <span class="literal">true</span></span><br><span class="line">insert_final_newline = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[*.md]</span><br><span class="line">max_line_length = off</span><br><span class="line">trim_trailing_whitespace = <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="代码自动格式化-prettier"><a href="#代码自动格式化-prettier" class="headerlink" title="代码自动格式化:prettier"></a>代码自动格式化:prettier</h3><ol><li><p>开启 Prettier :<a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">Prettier - Code formatter - Visual Studio Marketplace</a> </p></li><li><p>设置默认格式化 Editor</p></li><li><p>开启保存时格式话</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;editor.formatOnSave&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="comment">//在保存文件时自动调用 Prettier 对代码进行格式化。</span></span><br><span class="line">  <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esbenp.prettier-vscode&quot;</span><span class="punctuation">,</span> <span class="comment">//指定使用 Prettier 作为默认的代码格式化工具。</span></span><br><span class="line">   <span class="comment">// 常见的 Prettier 配置项</span></span><br><span class="line">  <span class="attr">&quot;prettier.semi&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="comment">// 在语句末尾添加分号。</span></span><br><span class="line">  <span class="attr">&quot;prettier.singleQuote&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 是否使用单引号</span></span><br><span class="line">  <span class="attr">&quot;prettier.trailingComma&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es&quot;</span><span class="punctuation">,</span> <span class="comment">//在多行对象、数组等的末尾添加尾随逗号</span></span><br><span class="line">  <span class="attr">&quot;prettier.arrowParens&quot;</span><span class="punctuation">:</span> <span class="string">&quot;always&quot;</span><span class="punctuation">,</span><span class="comment">//在箭头函数的参数周围总是添加括号，即使只有一个参数。</span></span><br><span class="line">  <span class="attr">&quot;prettier.printWidth&quot;</span><span class="punctuation">:</span> <span class="number">80</span><span class="punctuation">,</span> <span class="comment">//指定代码行的最大长度，超过该长度会尝试换行。</span></span><br><span class="line">  <span class="attr">&quot;prettier.tabWidth&quot;</span><span class="punctuation">:</span> <span class="number">2</span> <span class="comment">// 指定一个制表符等于 2 个空格。</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>你有更复杂的需求，可以在项目根目录下创建一个 <code>.prettierrc</code> 文件，以 JSON 或 YAML 格式来存储更详细的 Prettier 配置信息。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// 是否在语句末尾添加分号</span></span><br><span class="line">  <span class="attr">&quot;semi&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 是否使用单引号</span></span><br><span class="line">  <span class="attr">&quot;singleQuote&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 在对象、数组等的最后元素后面添加尾随逗号，可选值有 &quot;es&quot;、&quot;none&quot;、&quot;all&quot;</span></span><br><span class="line">  <span class="attr">&quot;trailingComma&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 代码行的最大长度，超过该长度会尝试换行</span></span><br><span class="line">  <span class="attr">&quot;printWidth&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 一个制表符等于几个空格</span></span><br><span class="line">  <span class="attr">&quot;tabWidth&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 是否使用制表符，这里设置为使用空格</span></span><br><span class="line">  <span class="attr">&quot;useTabs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 在对象的括号之间是否添加空格</span></span><br><span class="line">  <span class="attr">&quot;bracketSpacing&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 在 JSX 中是否使用单引号，这里设置为使用双引号</span></span><br><span class="line">  <span class="attr">&quot;jsxSingleQuote&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 使用的解析器，这里是 babylon</span></span><br><span class="line">  <span class="comment">// &quot;parser&quot;: &quot;babylon&quot;,</span></span><br><span class="line">  <span class="attr">&quot;arrowParens&quot;</span><span class="punctuation">:</span> <span class="string">&quot;always&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>.prettierrcignore</code> 文件的作用类似于 <code>.gitignore</code>，它用于告诉 Prettier 哪些文件或目录不需要进行格式化操作。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">node_modules/</span><br><span class="line">dist/</span><br><span class="line">build/</span><br><span class="line">*.min.js</span><br><span class="line">.husky</span><br><span class="line">*.svg</span><br><span class="line">*.sh</span><br></pre></td></tr></table></figure></li></ol><h3 id="JS-TS修复建议-ESLint"><a href="#JS-TS修复建议-ESLint" class="headerlink" title="JS&#x2F;TS修复建议:ESLint"></a>JS&#x2F;TS修复建议:ESLint</h3><p><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">ESLint - Visual Studio Marketplace</a></p><p>ESLint 是一个查找 JavaScript &#x2F; TypeScript 代码问题并提供修复建议的工具，换句话说就是可以约束的代码不会写出一堆 BUG ，它是代码健壮性的重要保障。</p><p>如果有一些文件需要排除检查，可以再创建一个 <code>.eslintignore</code> 文件在项目根目录下，里面添加要排除的文件或者文件夹名称：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dist/*</span><br></pre></td></tr></table></figure><p>项目根目录下创建一个名为 <code>.eslintrc.js</code> 文件，写入以下内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">root</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="attr">node</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">browser</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">extends</span>: [<span class="string">&#x27;plugin:vue/vue3-essential&#x27;</span>, <span class="string">&#x27;eslint:recommended&#x27;</span>, <span class="string">&#x27;prettier&#x27;</span>],</span><br><span class="line">  <span class="attr">parser</span>: <span class="string">&#x27;vue-eslint-parser&#x27;</span>,</span><br><span class="line">  <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">    <span class="attr">parser</span>: <span class="string">&#x27;@typescript-eslint/parser&#x27;</span>,</span><br><span class="line">    <span class="attr">ecmaVersion</span>: <span class="number">2020</span>,</span><br><span class="line">    <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&#x27;@typescript-eslint&#x27;</span>, <span class="string">&#x27;prettier&#x27;</span>],</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;no-console&#x27;</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;warn&#x27;</span> : <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;no-debugger&#x27;</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;warn&#x27;</span> : <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;prettier/prettier&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;vue/multi-word-component-names&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">globals</span>: &#123;</span><br><span class="line">    <span class="attr">defineProps</span>: <span class="string">&#x27;readonly&#x27;</span>,</span><br><span class="line">    <span class="attr">defineEmits</span>: <span class="string">&#x27;readonly&#x27;</span>,</span><br><span class="line">    <span class="attr">defineExpose</span>: <span class="string">&#x27;readonly&#x27;</span>,</span><br><span class="line">    <span class="attr">withDefaults</span>: <span class="string">&#x27;readonly&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后安装对应的依赖（记得添加 <code>-D</code> 参数添加到 <code>devDependencies</code> ，因为都是开发环境下使用的）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 npm：</span></span><br><span class="line">npm install eslint eslint-config-prettier eslint-plugin-prettier eslint-plugin-vue @typescript-eslint/eslint-plugin @typescript-eslint/parser prettier -D</span><br><span class="line"><span class="comment"># 使用 yarn：</span></span><br><span class="line">yarn add eslint eslint-config-prettier eslint-plugin-prettier eslint-plugin-vue @typescript-eslint/eslint-plugin @typescript-eslint/parser prettier --dev</span><br></pre></td></tr></table></figure><ul><li><code>-D</code> 或 <code>--dev</code>：表示将这些依赖添加到 <code>devDependencies</code> 中，因为这些依赖主要用于开发环境，如代码检查、格式化等，而不是运行时所需的依赖。</li><li><code>eslint</code>：是 ESLint 的核心包，用于代码检查。</li><li><code>eslint-config-prettier</code>：用于关闭 ESLint 中与 Prettier 冲突的规则，使 ESLint 和 Prettier 可以更好地协作。</li><li><code>eslint-plugin-prettier</code>：将 Prettier 作为 ESLint 的规则，让 ESLint 可以使用 Prettier 的格式化规则进行检查。</li><li><code>eslint-plugin-vue</code>：为 Vue 项目提供 ESLint 插件，帮助检查 Vue 组件和模板中的代码。</li><li><code>@typescript-eslint/eslint-plugin</code> 和 <code>@typescript-eslint/parser</code>：如果你的项目使用 TypeScript，这些插件可以帮助 ESLint 更好地检查 TypeScript 代码。</li><li><code>prettier</code>：用于代码格式化，确保代码风格的一致性。</li></ul><h3 id="Chinese-Simplified"><a href="#Chinese-Simplified" class="headerlink" title="Chinese (Simplified)"></a>Chinese (Simplified)</h3><p>VSCode 安装后默认是英文本，需要自己进行汉化配置， VSCode 的特色就是插件化处理各种功能，语言方面也一样。</p><p>安装该插件并启用，即可让 VSCode 显示为简体中文。</p><p>点击下载：<a href="https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans">Chinese (Simplified)</a></p><h3 id="Vue-Official-Volar"><a href="#Vue-Official-Volar" class="headerlink" title="Vue - Official(Volar )"></a>Vue - Official(Volar )</h3><blockquote><p><strong>Volar 取代了 Vetur 作为 Vue 3 的官方扩展，如果之前已经安装了 Vetur ，请确保在 Vue 3 的项目中禁用它。</strong></p></blockquote><p>Vue 官方推荐的 VSCode 扩展，用以代替 Vue 2 时代的 <a href="https://marketplace.visualstudio.com/items?itemName=octref.vetur">Vetur</a> ，提供了 Vue 3 的语言支持、 TypeScript 支持、基于 <a href="https://github.com/johnsoncodehk/volar/tree/master/packages/vue-tsc">vue-tsc</a> 的类型检查等功能。</p><p>点击下载：<a href="https://marketplace.visualstudio.com/items?itemName=Vue.volar">Vue - Official - Visual Studio Marketplace</a></p><h3 id="Vue-VSCode-Snippets"><a href="#Vue-VSCode-Snippets" class="headerlink" title="Vue VSCode Snippets"></a>Vue VSCode Snippets</h3><p>从实际使用 Vue 的角度提供 Vue 代码片段的生成，可以通过简单的命令，在 .vue 文件里实现大篇幅的代码片段生成，例如：</p><ol><li>输入 <code>ts</code> 可以快速创建一个包含了 <code>template</code> + <code>script</code> + <code>style</code> 的 Vue 组件模板（可选 2.x 、3.x 以及 class 风格的模板）</li><li>也可以通过输入带有 <code>v3</code> 开头的指令来快速生成 Vue 3 的 API 。</li></ol><p>下面是输入了 <code>ts</code> 两个字母之后，用箭头选择 <code>vbase-3-ts</code> 自动生成的一个模板片段，在开发过程中非常省事：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>点击下载：<a href="https://marketplace.visualstudio.com/items?itemName=sdras.vue-vscode-snippets">Vue VSCode Snippets</a></p><h3 id="Auto-Close-Tag"><a href="#Auto-Close-Tag" class="headerlink" title="Auto Close Tag"></a>Auto Close Tag</h3><p>可以快速完成 HTML 标签的闭合，除非通过 <code>.jsx</code> &#x2F; <code>.tsx</code> 文件编写 Vue 组件，否则在 <code>.vue</code> 文件里写 <code>template</code> 的时候肯定用得上。</p><p>点击下载：<a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-close-tag">Auto Close Tag</a></p><h3 id="Auto-Rename-Tag"><a href="#Auto-Rename-Tag" class="headerlink" title="Auto Rename Tag"></a>Auto Rename Tag</h3><p>假如要把 <code>div</code> 修改为 <code>section</code>，不需要再把 <code>&lt;div&gt;</code> 然后找到代码尾部的 <code>&lt;/div&gt;</code> 才能修改，只需要选中前面或后面的半个标签直接修改，插件会自动把闭合部分也同步修改，对于篇幅比较长的代码调整非常有帮助。</p><p>点击下载：<a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag">Auto Rename Tag</a></p><h2 id="最终配置文件"><a href="#最终配置文件" class="headerlink" title="最终配置文件"></a>最终配置文件</h2><p>以下是整理后的最终配置文件，删除了冲突和冗余的配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;workbench.colorTheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Default Light Modern&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;workbench.iconTheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vscode-icons&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;remote.SSH.remotePlatform&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;192.168.1.102(sun)&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;explorer.sortOrder&quot;</span><span class="punctuation">:</span> <span class="string">&quot;modified&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;explorer.confirmDelete&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;git.autofetch&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;git.enableSmartCommit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;workbench.editorAssociations&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;&#123;git,gitlens,git-graph&#125;:/**/*.&#123;md,csv,svg&#125;&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;[markdown]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;harttle.md-padding-vscode&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;[javascript]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vscode.typescript-language-features&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;[html]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vscode.html-language-features&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;[json]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vscode.json-language-features&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;[vue]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;[typescript]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;[jsonc]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vscode.json-language-features&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.fontFamily&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#x27;MesloLGS NF&#x27;,Consolas, &#x27;Courier New&#x27;, monospace&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;terminal.integrated.fontSize&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.mouseWheelZoom&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.insertSpaces&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.tabSize&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.wordWrap&quot;</span><span class="punctuation">:</span> <span class="string">&quot;on&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.autoClosingBrackets&quot;</span><span class="punctuation">:</span> <span class="string">&quot;always&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.formatOnSave&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esbenp.prettier-vscode&quot;</span><span class="punctuation">,</span> <span class="comment">//指定使用 Prettier 作为默认的代码格式化工具。</span></span><br><span class="line">  <span class="attr">&quot;files.autoSave&quot;</span><span class="punctuation">:</span> <span class="string">&quot;afterDelay&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.codeActionsOnSave&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;source.fixAll&quot;</span><span class="punctuation">:</span> <span class="string">&quot;always&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;javascript.validate.enable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;emmet.includeLanguages&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;javascript&quot;</span><span class="punctuation">:</span> <span class="string">&quot;javascriptreact&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;emmet.triggerExpansionOnTab&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;less.compile&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;out&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceRoot&#125;\\css\\&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><script>var description="Visual Studio Code（简称 VS Code）是一款由微软开发的免费、开源且跨平台的代码编辑器，深受开发者喜爱。"</script>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VScode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CompletableFuture异步回调</title>
      <link href="/p/ab3134ba.html"/>
      <url>/p/ab3134ba.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="CompletableFuture详解"><a href="#CompletableFuture详解" class="headerlink" title="CompletableFuture详解"></a>CompletableFuture详解</h2><p>CompletableFuture是JDK 1.8引入的实现类，该类实现了<code>Future</code>和<code>CompletionStage</code>两个接口。该类的实例作为一个异步任务，可以在自己异步执行完成之后触发一些其他的异步任务，从而达到异步回调的效果。</p><h3 id="CompletableFuture的UML类关系"><a href="#CompletableFuture的UML类关系" class="headerlink" title="CompletableFuture的UML类关系"></a>CompletableFuture的UML类关系</h3><p><img src="/p/ab3134ba/b9fc51fb973dc11ca08d2b8d4f49d162.png"></p><h3 id="CompletionStage接口"><a href="#CompletionStage接口" class="headerlink" title="CompletionStage接口"></a>CompletionStage接口</h3><p>顾名思义，Stage是阶段的意思。CompletionStage代表某个同步或者异步计算的一个阶段，或者一系列异步任务中的一个子任务（或者阶段性任务）。</p><p>每个CompletionStage子任务所包装的可以是一个Function、Consumer或者Runnable函数式接口实例。这三个常用的函数式接口的特点如下：</p><ul><li><code>Function</code><br>Function接口的特点是：<strong>有输入、有输出</strong>。包装了Function实例的CompletionStage子任务需要一个输入参数，并会产生一个输出结果到下一步。</li><li><code>Runnable</code><br>Runnable接口的特点是：<strong>无输入、无输出</strong>。包装了Runnable实例的CompletionStage子任务既不需要任何输入参数，又不会产生任何输出。</li><li><code>Consumer</code><br>Consumer接口的特点是：<strong>有输入、无输出</strong>。包装了Consumer实例的CompletionStage子任务需要一个输入参数，但不会产生任何输出。</li></ul><p>多个<code>CompletionStage</code>构成了一条任务流水线，一个环节执行完成了可以将结果移交给下一个环节（子任务）。多个<code>CompletionStage</code>子任务之间可以使用链式调用，下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">oneStage.thenApply(x-&gt;square(x))</span><br><span class="line">        .thenAccept(y-&gt;System.out.println(y))</span><br><span class="line">        .thenRun(()-&gt;System.out.println())</span><br></pre></td></tr></table></figure><p>对以上例子中的CompletionStage子任务说明如下：</p><ul><li><code>oneStage</code>是一个<code>CompletionStage</code>子任务，这是一个前提。</li><li><code>x -&gt; square(x)</code>是一个Function类型的Lambda表达式，被<code>thenApply()</code>方法包装成了一个CompletionStage子任务，该子任务需要接收一个参数x，然后输出一个结果——x的平方值。</li><li><code>“y -&gt; System.out.println(y)</code>是一个Consumer类型的Lambda表达式，被<code>thenAccept()</code>方法包装成了一个CompletionStage子任务，该子任务需要消耗上一个子任务的输出值，但是此子任务并没有输出。</li><li><code>() -&gt; System.out.println()</code>是一个Runnable类型的Lambda表达式，被<code>thenRun()</code>方法包装成了一个CompletionStage子任务，既不消耗上一个子任务的输出，又不产生结果。</li></ul><p><code>CompletionStage</code>代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另一个阶段。虽然一个子任务可以触发其他子任务，但是并不能保证后续子任务的执行顺序。</p><h3 id="runAsync和supplyAsync"><a href="#runAsync和supplyAsync" class="headerlink" title="runAsync和supplyAsync"></a>runAsync和supplyAsync</h3><p>CompletionStage子任务的创建是通过CompletableFuture完成的。CompletableFuture类提供了非常强大的Future的扩展功能来帮助我们简化异步编程的复杂性，提供了函数式编程的能力来帮助我们通过回调的方式处理计算结果，也提供了转换和组合<code>CompletionStage()</code>的方法。</p><p><code>CompletableFuture</code>定义了一组方法用于创建<code>CompletionStage</code>子任务（或者阶段性任务），基础的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子任务包装一个Supplier实例，并调用ForkJoinPool.commonPool()线程来执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(asyncPool, supplier);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子任务包装一个Supplier实例，并使用指定的executor线程池来执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier,</span></span><br><span class="line"><span class="params">                                                   Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(screenExecutor(executor), supplier);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//子任务包装一个Runnable实例，并调用ForkJoinPool.commonPool()线程来执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncRunStage(asyncPool, runnable);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//子任务包装一个Runnable实例，并使用指定的executor线程池来执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable,</span></span><br><span class="line"><span class="params">                                               Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncRunStage(screenExecutor(executor), runnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用CompletableFuture创建CompletionStage子任务时，如果没有指定Executor线程池，在<strong>默认情况下CompletionStage会使用公共的<code>ForkJoinPool</code>线程池</strong>。</p><p>下面是两个创建CompletionStage子任务简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runAsyncDemo</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        sleepSeconds(<span class="number">1</span>);<span class="comment">// 模拟执行1秒</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;run end ...&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 等待异步任务执行完成，限时等待2秒</span></span><br><span class="line">    future.get(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">supplyAsyncDemo</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    CompletableFuture&lt;Long&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        sleepSeconds(<span class="number">1</span>);<span class="comment">// 模拟执行1秒</span></span><br><span class="line">        System.out.println(<span class="string">&quot;supply end ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() - start;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 等待异步任务执行完成，限时等待2秒</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> future.get(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">    System.out.println(<span class="string">&quot;异步执行耗时（秒） = &quot;</span> + time/<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置子任务回调钩子"><a href="#设置子任务回调钩子" class="headerlink" title="设置子任务回调钩子"></a>设置子任务回调钩子</h3><p>可以为CompletionStage子任务设置特定的回调钩子，当计算结果完成或者抛出异常的时候，执行这些特定的回调钩子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置子任务完成时的回调钩子</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenComplete</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> Throwable&gt; action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(<span class="literal">null</span>, action);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置子任务完成时的回调钩子，可能不在同一线程执行</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenCompleteAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> Throwable&gt; action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(asyncPool, action);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置子任务完成时的回调钩子，提交给线程池executor执行</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenCompleteAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> Throwable&gt; action, Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(screenExecutor(executor), action);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置异常处理的回调钩子</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">exceptionally</span><span class="params">(</span></span><br><span class="line"><span class="params">        Function&lt;Throwable, ? extends T&gt; fn)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> uniExceptionallyStage(fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个CompletionStage子任务设置完成钩子和异常钩子的简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">whenCompleteDemo</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建异步任务</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//模拟执行一秒</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:抛出异常&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(Thread.currentThread().getName()+<span class="string">&quot;:发生异常&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//设置异步任务执行完成后的回调钩子</span></span><br><span class="line">        future.whenComplete(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;Void, Throwable&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Void unused, Throwable throwable)</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:执行完成!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置异步任务发生异常后的回调钩子</span></span><br><span class="line">        future.exceptionally(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Throwable, Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Void <span class="title function_">apply</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:执行失败！&quot;</span> + throwable.getMessage());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//获取异步任务的结果</span></span><br><span class="line">        future.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        whenCompleteDemo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h3 id="异常回调钩子"><a href="#异常回调钩子" class="headerlink" title="异常回调钩子"></a>异常回调钩子</h3><p>调用<code>cancel()</code>方法取消<code>CompletableFuture</code>时，任务被视为异常完成，<code>completeExceptionally()方</code>法所设置的异常回调钩子也会被执行。</p><p>如果没有设置异常回调钩子，发生内部异常时会有两种情况发生：</p><ul><li><p>在调用get()和get(long,TimeUnit)方法启动任务时，如果遇到内部异常，get()方法就会抛出ExecutionException(执行异常)。</p></li><li><p>在调用join()和getNow(T)启动任务时(大多数情况下都是如此)，如果遇到内部异常，join()和getNow(T)方法就会抛出CompletionException。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureCancelExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 CompletableFuture</span></span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟一个长时间运行的任务</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Task completed&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task was interrupted&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Task interrupted&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试在 2 秒内获取结果</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            future.get(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException | TimeoutException e) &#123;</span><br><span class="line">            <span class="comment">// 超时处理</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Timeout occurred, cancelling the future&quot;</span>);</span><br><span class="line">            <span class="comment">// 取消 CompletableFuture</span></span><br><span class="line">            future.cancel(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查 future 是否被取消</span></span><br><span class="line">        <span class="keyword">if</span> (future.isCancelled()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The future has been cancelled.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果未取消，尝试获取结果</span></span><br><span class="line">                System.out.println(future.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用handle-方法统一处理异常和结果"><a href="#调用handle-方法统一处理异常和结果" class="headerlink" title="调用handle()方法统一处理异常和结果"></a>调用handle()方法统一处理异常和结果</h3><p>除了分别通过<code>whenComplete</code>、<code>exceptionally</code>设置完成钩子、异常钩子之外，还可以调用<code>handle()</code>方法统一处理结果和异常。</p><p>handle()方法有三个重载版本，声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//在执行任务的同一个线程中处理异常和结果</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handle</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniHandleStage(<span class="literal">null</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可能不在执行任务的同一个线程中处理异常和结果</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handleAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniHandleStage(asyncPool, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在指定线程池executor中处理异常和结果</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handleAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn, Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniHandleStage(screenExecutor(executor), fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureExceptionHandling</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 CompletableFuture</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟一个可能抛出异常的操作</span></span><br><span class="line">            <span class="keyword">if</span> (Math.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Something went wrong&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 whenComplete 处理结果或异常</span></span><br><span class="line">        future.whenComplete((result, exception) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (exception == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task completed successfully with result: &quot;</span> + result);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task completed with exception: &quot;</span> + exception.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 exceptionally 处理异常</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; futureWithExceptionHandler = future.exceptionally(ex -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Exception occurred: &quot;</span> + ex.getMessage());</span><br><span class="line">            <span class="comment">// 返回一个默认值</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 handle 处理结果或异常</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; futureWithHandler = future.handle((result, exception) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (exception!= <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Handling exception: &quot;</span> + exception.getMessage());</span><br><span class="line">                <span class="comment">// 返回一个默认值</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取结果，可能会阻塞等待</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> futureWithHandler.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;Final result: &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Task completed with exception: java.lang.RuntimeException: Something went wrong</span><br><span class="line">Exception occurred: java.lang.RuntimeException: Something went wrong</span><br><span class="line">Handling exception: java.lang.RuntimeException: Something went wrong</span><br><span class="line">Final result: -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h3><p>默认情况下，通过静态方法<code>runAsync()</code>、<code>supplyAsync()</code>创建的CompletableFuture任务会使用公共的<code>ForkJoinPool</code>线程池，默认的线<br>程数是CPU的核数。当然，它的线程数可以通过以下JVM参数设置：<code>-Djava.util.concurrent.ForkJoinPool.common.parallelism</code></p><p>问题是，如果所有CompletableFuture共享一个线程池，那么一旦有任务执行一些很慢的IO操作，就会导致线程池中的所有线程都阻塞在IO操作上，造成线程饥饿，进而影响整个系统的性能。所以，<strong>强烈建议大家根据不同的业务类型创建不同的线程池，以避免互相干扰。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureWithThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用自定义线程池创建 CompletableFuture</span></span><br><span class="line">        CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Task 1 completed&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Task 1 interrupted&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, executorService);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Task 2 completed&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Task 2 interrupted&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, executorService);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当两个任务都完成时执行操作</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; combinedFuture = future1.thenCombine(future2, (result1, result2) -&gt; &#123;</span><br><span class="line">            System.out.println(result1);</span><br><span class="line">            System.out.println(result2);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待组合任务完成</span></span><br><span class="line">            combinedFuture.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭线程池</span></span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步任务的串行执行"><a href="#异步任务的串行执行" class="headerlink" title="异步任务的串行执行"></a>异步任务的串行执行</h2><p>如果两个异步任务需要串行（一个任务依赖另一个任务）执行，可以通过<code>CompletionStage</code>接口的<code>thenApply()</code>、<code>thenAccept()</code>、<code>thenRun()</code>和<code>thenCompose()</code>四个方法来实现。</p><ul><li><code>thenApply</code>：<ul><li>它允许你将一个同步操作应用到 <code>CompletableFuture</code> 的结果上，并将结果包装在一个新的 <code>CompletableFuture</code> 中。</li><li>适用于对异步任务的结果进行简单的转换或计算，并且需要继续以 <code>CompletableFuture</code> 的形式传递结果。</li></ul></li><li><code>thenAccept</code>：<ul><li>当你只关心上一个任务的结果而不需要产生新的结果时使用。</li><li>通常用于执行与结果相关的副作用操作，如将结果存储到数据库、发送通知等。</li></ul></li><li><code>thenRun</code>：<ul><li>当你不关心上一个任务的结果，只需要在任务完成后执行一些操作时使用。</li><li>适用于执行一些独立的清理工作或日志记录。</li></ul></li><li><code>thenCompose</code>：<ul><li>用于将多个 <code>CompletableFuture</code> 串联起来，避免嵌套的 <code>CompletableFuture</code>。</li><li>可以将前一个任务的结果作为输入来创建新的 <code>CompletableFuture</code>，实现链式调用。</li></ul></li></ul><h3 id="thenApply-方法"><a href="#thenApply-方法" class="headerlink" title="thenApply()方法"></a>thenApply()方法</h3><p><code>thenApply</code><strong>接收上一个任务的结果，对结果进行处理并返回一个新结果，可用于对结果进行转换或进一步计算。</strong>一个 <code>Function&lt;T, U&gt;</code>，其中 T 是上一个 CompletableFuture 的结果类型，U 是要转换的新结果类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后一个任务与前一个任务在同一个线程中执行    </span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(<span class="literal">null</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后一个任务与前一个任务不在同一个线程中执行</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(asyncPool, fn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后一个任务在指定的executor线程池中执行</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn, Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(screenExecutor(executor), fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>thenApply的三个重载版本有一个共同的参数fn，该参数表示要串行执行的第二个异步任务，它的类型为Function。fn的类型声明涉及两个泛型参数，具体如下：</p><ul><li>泛型参数 T：上一个任务所返回结果的类型。</li><li>泛型参数 U：当前任务的返回值类型。</li></ul><p>作为示例，调用thenApply分两步计算（10+10）*2，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThenApplyExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个 CompletableFuture，初始值为 10</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; initialFuture = CompletableFuture.completedFuture(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一步：将初始值 10 加 10</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; stepOneFuture = initialFuture.thenApply(result -&gt; result + <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二步：将第一步的结果乘以 2</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; finalFuture = stepOneFuture.thenApply(result -&gt; result * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取最终结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">finalResult</span> <span class="operator">=</span> finalFuture.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;The final result is: &quot;</span> + finalResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="thenRun-方法"><a href="#thenRun-方法" class="headerlink" title="thenRun()方法"></a>thenRun()方法</h3><p><code>thenRun()</code>方法与<code>thenApply()</code>方法不同的是，<strong>不关心任务的处理结果</strong>。只要前一个任务执行完成，就开始执行后一个串行任务<strong>。不接收上一个任务的结果，仅执行一个操作，常用于执行无参的副作用操作，例如记录日志或执行一些清理工作。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后一个任务与前一个任务在同一个线程中执行</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRun</span><span class="params">(Runnable action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniRunStage(<span class="literal">null</span>, action);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后一个任务与前一个任务不在同一个线程中执行</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRunAsync</span><span class="params">(Runnable action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniRunStage(asyncPool, action);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后一个任务在executor线程池中执行</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRunAsync</span><span class="params">(Runnable action,</span></span><br><span class="line"><span class="params">                                            Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniRunStage(screenExecutor(executor), action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从方法的声明可以看出，<code>thenRun()</code>方法同thenApply()方法类似，不同的是前一个任务处理完成后，thenRun()并不会把计算的结果传给后一个任务，而且后一个任务也没有结果输出。<br>thenRun系列方法中的action参数是<code>Runnable</code>类型的，所以<code>thenRun()</code>既不能接收参数又不支持返回值。</p><h3 id="thenAccept-方法"><a href="#thenAccept-方法" class="headerlink" title="thenAccept()方法"></a>thenAccept()方法</h3><p><code>thenAccept()</code>方法对<code>thenRun()</code>、<code>thenApply()</code>的特点进行了折中，调用此方法时<strong>后一个任务可以接收（或消费）前一个任务的处理结果，但是后一个任务没有结果输出</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAccept</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniAcceptStage(<span class="literal">null</span>, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniAcceptStage(asyncPool, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action,</span></span><br><span class="line"><span class="params">                                               Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniAcceptStage(screenExecutor(executor), action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>thenAccept系列方法的回调参数为action，它的类型为<code>Consumer&lt;? super T&gt;</code>接口，其中 <code>T</code> 是上一个 <code>CompletableFuture</code> 的结果类型。</p><h3 id="thenCompose-方法"><a href="#thenCompose-方法" class="headerlink" title="thenCompose()方法"></a>thenCompose()方法</h3><p><code>thenCompose()</code>方法在功能上与<code>thenApply()</code>、<code>thenAccept()</code>、<code>thenRun(</code>)一样，可以对两个任务进行串行的调度操作，第一个任务操作完成时，将它的结果作为参数传递给第二个任务。</p><p>接收上一个任务的结果，将结果作为输入创建一个新的 <code>CompletableFuture</code>，用于将多个 <code>CompletableFuture</code> 链式组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenCompose</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniComposeStage(<span class="literal">null</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenComposeAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniComposeStage(asyncPool, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenComposeAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn,</span></span><br><span class="line"><span class="params">    Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniComposeStage(screenExecutor(executor), fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>thenCompose()</code>方法要求第二个任务的返回值是一个CompletionStage异步实例。因此，可以调用<code>CompletableFuture.supplyAsync()</code>方法将第二个任务所要调用的普通异步方法包装成一个CompletionStage异步实例。</p><p>作为演示，调用thenCompose分两步计算（10+10）*2，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThenComposeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个初始的 CompletableFuture，其结果为 10</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; initialFuture = CompletableFuture.completedFuture(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 thenCompose 进行链式操作</span></span><br><span class="line">        CompletableFuture&lt;String&gt; finalFuture = initialFuture.thenCompose(result -&gt; &#123;</span><br><span class="line">            <span class="comment">// 将初始结果加 10</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">intermediateResult</span> <span class="operator">=</span> result + <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 创建一个新的 CompletableFuture，其结果是将中间结果乘以 2 并转换为字符串</span></span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">finalResult</span> <span class="operator">=</span> intermediateResult * <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;The final result is: &quot;</span> + finalResult;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取最终结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> finalFuture.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步任务的合并执行"><a href="#异步任务的合并执行" class="headerlink" title="异步任务的合并执行"></a>异步任务的合并执行</h2><p>如果某个任务同时依赖另外两个异步任务的执行结果，就需要对另外两个异步任务进行合并。以泡茶喝为例，“泡茶喝”任务需要对“烧水”任务与“清洗”任务进行合并。对两个异步任务的合并可以通过CompletionStage接口的<code>thenCombine()</code>、<code>runAfterBoth()</code>、<code>thenAcceptBoth()</code>三个方法来实现。这三个方法的不同之处主要在于其核心参数fn、action、consumer的类型不同，分别为<code>Function&lt;T,R&gt;</code>、<code>Runnable</code>、<code>Consumer&lt;? super T&gt;</code>类型。</p><ul><li><code>thenCombine()</code>：<ul><li>可以将两个独立的 <code>CompletableFuture</code> 的结果进行合并，产生一个新的结果，该结果存储在新的 <code>CompletableFuture</code> 中。</li><li>适用于需要对两个结果进行计算或组合的场景。</li></ul></li><li><code>runAfterBoth()</code>：<ul><li>主要用于在两个任务完成后执行一个操作，不关心任务的结果，仅关心任务是否完成。</li><li>适合于执行一些与结果无关的任务，如发送通知或更新状态。</li></ul></li><li><code>thenAcceptBoth()</code>：<ul><li>用于对两个 <code>CompletableFuture</code> 的结果进行处理，不产生新的结果，只执行副作用操作。</li><li>可以用于执行一些依赖于两个任务结果的操作，如更新 UI 或存储结果。</li></ul></li></ul><h3 id="thenCombine-方法"><a href="#thenCombine-方法" class="headerlink" title="thenCombine()方法"></a>thenCombine()方法</h3><p><code>thenCombine()</code>会在两个CompletionStage任务都执行完成后，把两个任务的结果一起交给thenCombine()来处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并代表第二步任务（参数other）的CompletionStage实例，返回第三步任务的CompletionStage</span></span><br><span class="line">    <span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="title function_">thenCombine</span><span class="params">(</span></span><br><span class="line"><span class="params">    CompletionStage&lt;? extends U&gt; other,</span></span><br><span class="line"><span class="params">    BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> biApplyStage(<span class="literal">null</span>, other, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不一定在同一个线程中执行第三步任务的CompletionStage实例</span></span><br><span class="line"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="title function_">thenCombineAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    CompletionStage&lt;? extends U&gt; other,</span></span><br><span class="line"><span class="params">    BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> biApplyStage(asyncPool, other, fn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三步任务的CompletionStage实例在指定的executor线程池中执行</span></span><br><span class="line"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="title function_">thenCombineAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    CompletionStage&lt;? extends U&gt; other,</span></span><br><span class="line"><span class="params">    BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn, Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> biApplyStage(screenExecutor(executor), other, fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>thenCombine()</code>方法的调用者为第一步的CompletionStage实例，该方法的第一个参数为第二步的CompletionStage实例，该方法的返回值为第三步的CompletionStage实例。<strong>在逻辑上，<code>thenCombine()</code>方法的功能是将第一步、第二步的结果合并到第三步上。</strong></p><p>thenCombine系列方法有两个核心参数：</p><ul><li><code>other</code>参数：表示待合并的第二步任务的CompletionStage实例。</li><li><code>fn</code>参数：表示第一个任务和第二个任务执行完成后，第三步需要执行的逻辑。fn参数的类型为<code>BiFunction&lt;? super T,? super U,? extends V&gt;</code>，该类型的声明涉及三个泛型参数，具体如下：<ul><li>泛型参数 T：表示第一个任务所返回结果的类型。</li><li>泛型参数 U：表示第二个任务所返回结果的类型。</li><li>泛型参数 V：表示第三个任务所返回结果的类型。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureCombinations</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建两个 CompletableFuture</span></span><br><span class="line">        CompletableFuture&lt;String&gt; futureA = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;String&gt; futureB = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;World&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// thenCombine 示例</span></span><br><span class="line">        CompletableFuture&lt;String&gt; combinedFuture = futureA.thenCombine(futureB, (a, b) -&gt; a + <span class="string">&quot; &quot;</span> + b);</span><br><span class="line">        System.out.println(combinedFuture.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="runAfterBoth-方法"><a href="#runAfterBoth-方法" class="headerlink" title="runAfterBoth()方法"></a>runAfterBoth()方法</h3><p><code>runAfterBoth()</code>方法跟<code>thenCombine()</code>方法不一样的是，<code>runAfterBoth()</code>方法<strong>不关心每一步任务的输入参数和处理结果</strong>。<code>runAfterBoth()</code>方法有三个重载版本，声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并第二步任务的CompletionStage实例，返回第三步任务的CompletionStage</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAfterBoth</span><span class="params">(CompletionStage&lt;?&gt; other,</span></span><br><span class="line"><span class="params">                                            Runnable action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> biRunStage(<span class="literal">null</span>, other, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAfterBothAsync</span><span class="params">(CompletionStage&lt;?&gt; other,</span></span><br><span class="line"><span class="params">                                                 Runnable action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> biRunStage(asyncPool, other, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAfterBothAsync</span><span class="params">(CompletionStage&lt;?&gt; other,</span></span><br><span class="line"><span class="params">                                                 Runnable action,</span></span><br><span class="line"><span class="params">                                                 Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> biRunStage(screenExecutor(executor), other, action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runAfterBoth()</code>方法的调用者为第一步任务的CompletionStage实例，runAfterBoth()方法的第一个参数为第二步任务的CompletionStage实例，runAfterBoth()方法的返回值为第三步的<br>CompletionStage实例。<br><strong>在逻辑上，第一步任务和第二步任务是并行执行的，thenCombine()方法的功能是将第一步、第二步的结果合并到第三步任务上</strong>。与thenCombine系列方法不同，runAfterBoth系列方法的第二个参<br>数action为<code>Runnable</code>类型，表示它的第一步任务、第二步任务、第三步任务既没有输入值，又没有输出值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureCombinations</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建两个 CompletableFuture</span></span><br><span class="line">        CompletableFuture&lt;String&gt; futureA = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;String&gt; futureB = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;World&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// runAfterBoth 示例</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; runAfterFuture = futureA.runAfterBoth(futureB, () -&gt; System.out.println(<span class="string">&quot;Both futures completed running&quot;</span>));</span><br><span class="line">        runAfterFuture.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="thenAcceptBoth-方法"><a href="#thenAcceptBoth-方法" class="headerlink" title="thenAcceptBoth()方法"></a>thenAcceptBoth()方法</h3><p><code>thenAcceptBoth()</code>方法对<code>runAfterBoth()</code>方法和<code>thenCombine()</code>方法的特点进行了折中，调用该方法，第三个任务可以接收其合并过来的第一个任务、第二个任务的处理结果，但是<strong>第三个任务（合并任务）却不能返回结果</strong>。</p><p>thenAcceptBoth()方法有三个重载版本，三个版本的声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptBoth</span><span class="params">(</span></span><br><span class="line"><span class="params">    CompletionStage&lt;? extends U&gt; other,</span></span><br><span class="line"><span class="params">    BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> U&gt; action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> biAcceptStage(<span class="literal">null</span>, other, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptBothAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    CompletionStage&lt;? extends U&gt; other,</span></span><br><span class="line"><span class="params">    BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> U&gt; action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> biAcceptStage(asyncPool, other, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptBothAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    CompletionStage&lt;? extends U&gt; other,</span></span><br><span class="line"><span class="params">    BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> U&gt; action, Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> biAcceptStage(screenExecutor(executor), other, action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>thenAcceptBoth系列方法的第二个参数为需要合并的第二步任务的CompletionStage实例。第三个参数为第三个任务的回调函数，该参数名称为action，它的类型为<code>BiConsumer&lt;? super T,? super U&gt;</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureCombinations</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建两个 CompletableFuture</span></span><br><span class="line">        CompletableFuture&lt;String&gt; futureA = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;String&gt; futureB = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;World&quot;</span>);</span><br><span class="line">        </span><br><span class="line">       <span class="comment">// thenAcceptBoth 示例</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; acceptBothFuture = futureA.thenAcceptBoth(futureB, (a, b) -&gt; System.out.println(<span class="string">&quot;Accepted both: &quot;</span> + a + <span class="string">&quot; &quot;</span> + b));</span><br><span class="line">        acceptBothFuture.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allOf-等待所有的任务结束"><a href="#allOf-等待所有的任务结束" class="headerlink" title="allOf()等待所有的任务结束"></a>allOf()等待所有的任务结束</h3><p>CompletionStage接口的<code>allOf()</code>会等待所有的任务结束，以合并所有的任务。thenCombine()只能合并两个任务，**如果需要合并多个异步任务，那么可以调用<code>allOf()</code>**。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; future1 = CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;模拟异步任务1&quot;</span>));</span><br><span class="line">    CompletableFuture&lt;Void&gt; future2 = CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;模拟异步任务2&quot;</span>));</span><br><span class="line">    CompletableFuture&lt;Void&gt; future3 = CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;模拟异步任务3&quot;</span>));</span><br><span class="line">    CompletableFuture&lt;Void&gt; future4 = CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;模拟异步任务4&quot;</span>));</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(future1, future2, future3, future4);</span><br><span class="line">    all.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步任务的选择执行"><a href="#异步任务的选择执行" class="headerlink" title="异步任务的选择执行"></a>异步任务的选择执行</h2><p>CompletableFuture对异步任务的选择执行不是按照某种条件进行选择的，而是按照执行速度进行选择的：前面两个并行任务，谁的结果返回速度快，谁的结果将作为第三步任务的输入。</p><p>对两个异步任务的选择可以通过CompletionStage接口的<code>applyToEither()</code>、<code>runAfterEither()</code>和<code>acceptEither()</code>三个方法来实现。</p><ol><li><code>applyToEither()</code>：<ul><li>该方法用于处理两个 <code>CompletableFuture</code> 中先完成的那个结果。</li><li>在示例中，<code>future1.applyToEither(future2, result -&gt; &quot;The first completed result is: &quot; + result);</code> 表示当 <code>future1</code> 或 <code>future2</code> 中的任意一个完成时，将其结果作为输入，在前面添加 <code>&quot;The first completed result is: &quot;</code> 并存储在 <code>resultFuture</code> 中。</li><li>可以根据具体需求修改 <code>Function</code> 来对先完成的结果进行不同的处理或转换。</li></ul></li><li><code>runAfterEither()</code>：<ul><li>当你不关心哪个 <code>CompletableFuture</code> 先完成，也不关心它们的结果，只需要在任意一个完成时执行一个操作时使用。</li><li>在示例中，<code>future1.runAfterEither(future2, () -&gt; System.out.println(&quot;One of the futures completed&quot;));</code> 会在 <code>future1</code> 或 <code>future2</code> 中的任意一个完成后打印一条消息。</li><li>常用于执行一些清理工作或日志记录等副作用操作，不依赖于具体的结果。</li></ul></li><li><code>acceptEither()</code>：<ul><li>当你需要在两个 <code>CompletableFuture</code> 中的任意一个完成时，使用其结果进行一些操作，但不产生新的结果时使用。</li><li>在示例中，<code>future1.acceptEither(future2, result -&gt; System.out.println(&quot;The first completed result is: &quot; + result));</code> 会在 <code>future1</code> 或 <code>future2</code> 中的任意一个完成后打印出其结果。</li><li>适用于对先完成的结果进行一些副作用操作，如更新 UI 或存储结果。</li></ul></li></ol><h3 id="applyToEither-方法"><a href="#applyToEither-方法" class="headerlink" title="applyToEither()方法"></a>applyToEither()方法</h3><p>两个CompletionStage谁返回结果的速度快，applyToEither()方法就用这个最快的CompletionStage的结果进行下一步（第三步）的回调操作。</p><p>applyToEither()方法有三个重载版本，三个版本的声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">applyToEither</span><span class="params">(</span></span><br><span class="line"><span class="params">    CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="built_in">super</span> T, U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> orApplyStage(<span class="literal">null</span>, other, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">applyToEitherAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="built_in">super</span> T, U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> orApplyStage(asyncPool, other, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">applyToEitherAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="built_in">super</span> T, U&gt; fn,</span></span><br><span class="line"><span class="params">    Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> orApplyStage(screenExecutor(executor), other, fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureEitherExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建两个 CompletableFuture</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; futureA = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟不同的完成时间</span></span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; futureB = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟不同的完成时间</span></span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// applyToEither 示例</span></span><br><span class="line">        CompletableFuture&lt;String&gt; applyEitherFuture = futureA.applyToEither(futureB, result -&gt; <span class="string">&quot;The first completed value is: &quot;</span> + result);</span><br><span class="line">        System.out.println(applyEitherFuture.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The first completed value is: 10</span></span><br></pre></td></tr></table></figure><h3 id="runAfterEither-方法"><a href="#runAfterEither-方法" class="headerlink" title="runAfterEither()方法"></a>runAfterEither()方法</h3><p>runAfterEither()方法的功能为：前面两个CompletionStage实例，任何一个完成了都会执行第三步回调操作。三个任务的回调函数都是Runnable类型的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.fulsun._13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureEitherExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建两个 CompletableFuture</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; futureA = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟不同的完成时间</span></span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; futureB = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟不同的完成时间</span></span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// runAfterEither 示例 只会输出一次</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; runEitherFuture = futureA.runAfterEither(futureB, () -&gt; System.out.println(<span class="string">&quot;One of the futures has completed&quot;</span>));</span><br><span class="line">        runEitherFuture.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用runAfterEither()方法，只要前面两个CompletionStage实例其中一个执行完成，就开始执行第三步的CompletionStage实例。</p><h3 id="acceptEither-方法"><a href="#acceptEither-方法" class="headerlink" title="acceptEither()方法"></a>acceptEither()方法</h3><p><code>acceptEither()</code>方法对<code>applyToEither()</code>方法和<code>runAfterEither()</code>方法的特点进行了折中，两个CompletionStage谁返回结果的速度快，<code>acceptEither()</code>就用那个最快的CompletionStage的结果作为下一步（第三步）的输入，但是<strong>第三步没有输出</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">acceptEither</span><span class="params">(</span></span><br><span class="line"><span class="params">    CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> orAcceptStage(<span class="literal">null</span>, other, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">acceptEitherAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> orAcceptStage(asyncPool, other, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">acceptEitherAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="built_in">super</span> T&gt; action,</span></span><br><span class="line"><span class="params">    Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> orAcceptStage(screenExecutor(executor), other, action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.fulsun._13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureEitherExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建两个 CompletableFuture</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; futureA = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟不同的完成时间</span></span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; futureB = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟不同的完成时间</span></span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// acceptEither 示例</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; acceptEitherFuture = futureA.acceptEither(futureB, result -&gt; System.out.println(<span class="string">&quot;The first completed value is: &quot;</span> + result));</span><br><span class="line">        acceptEitherFuture.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The first completed value is: 10</span></span><br></pre></td></tr></table></figure><h2 id="CompletableFuture的综合案例"><a href="#CompletableFuture的综合案例" class="headerlink" title="CompletableFuture的综合案例"></a>CompletableFuture的综合案例</h2><h3 id="泡茶喝实例"><a href="#泡茶喝实例" class="headerlink" title="泡茶喝实例"></a>泡茶喝实例</h3><p>使用CompletableFuture实现泡茶喝实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrinkTea</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 任务 1：洗水壶 -&gt; 烧开水</span></span><br><span class="line">        CompletableFuture&lt;Boolean&gt; hotJob = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;洗水壶...&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;烧开水...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;水烧开了...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任务 2：洗茶壶 -&gt; 洗茶杯 -&gt; 拿茶叶</span></span><br><span class="line">        CompletableFuture&lt;Boolean&gt; washJob = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;洗茶壶...&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;洗茶杯...&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;拿茶叶...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;洗完了...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任务 3：任务 1 和任务 2 完成后执行泡茶</span></span><br><span class="line">        CompletableFuture&lt;String&gt; drinkJob = hotJob.thenCombine(washJob, (hotOk, washOK) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;泡茶...&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (hotOk &amp;&amp; washOK) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;泡茶喝，茶喝完&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;茶喝完了&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;没有喝到茶&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待任务 3 执行结果</span></span><br><span class="line">        drinkJob.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个RPC调用"><a href="#多个RPC调用" class="headerlink" title="多个RPC调用"></a>多个RPC调用</h3><p>使用CompletableFuture进行多个RPC调用，参考代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureRpcExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟的 RPC 调用方法，返回一个 CompletableFuture</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;String&gt; <span class="title function_">rpcCall</span><span class="params">(String request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟 RPC 调用的延迟</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Response from &quot;</span> + request;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个线程池，可根据实际情况调整大小</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储多个 RPC 请求</span></span><br><span class="line">        List&lt;String&gt; requests = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        requests.add(<span class="string">&quot;RPC1&quot;</span>);</span><br><span class="line">        requests.add(<span class="string">&quot;RPC2&quot;</span>);</span><br><span class="line">        requests.add(<span class="string">&quot;RPC3&quot;</span>);</span><br><span class="line">        requests.add(<span class="string">&quot;RPC4&quot;</span>);</span><br><span class="line">        requests.add(<span class="string">&quot;RPC5&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储多个 CompletableFuture</span></span><br><span class="line">        List&lt;CompletableFuture&lt;String&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发起多个 RPC 调用</span></span><br><span class="line">        <span class="keyword">for</span> (String request : requests) &#123;</span><br><span class="line">            CompletableFuture&lt;String&gt; future = rpcCall(request);</span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 allOf 组合多个 CompletableFuture</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; allFutures = CompletableFuture.allOf(futures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有 RPC 调用完成</span></span><br><span class="line">        allFutures.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 收集所有结果</span></span><br><span class="line">        List&lt;String&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (CompletableFuture&lt;String&gt; future : futures) &#123;</span><br><span class="line">            <span class="comment">// 使用 join 方法获取结果，避免异常处理</span></span><br><span class="line">            results.add(future.join());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印结果</span></span><br><span class="line">        <span class="keyword">for</span> (String result : results) &#123;</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script>var description="CompletableFuture，该类实现了Future接口，还具备函数式编程的能力。"</script>]]></content>
      
      
      <categories>
          
          <category> 多线程编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CompletableFuture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发异步回调模式</title>
      <link href="/p/bfa8a208.html"/>
      <url>/p/bfa8a208.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h2><p>这里使用阻塞模式和异步回调模式分别实现其中的异步泡茶流程。强调一下，这里直接略<strong>过顺序执行</strong>的冒泡工序，那个效率太低了。</p><p>为了异步执行整个泡茶流程，分别设计三个线程：</p><ul><li>泡茶线程（MainThread，主线程）、烧水线程（HotWaterThread）和清洗线程（WashThread）。</li><li>泡茶线程的工作是：启动清洗线程、启动烧水线程，等清洗、烧水的工作完成后，泡茶喝；</li><li>清洗线程的工作是：洗茶壶、洗茶杯；</li><li>烧水线程的工作是：洗好水壶，灌上凉水，放在火上，一直等水烧开。</li></ul><p>下面分别使用阻塞模式、回调模式实现泡茶的案例。</p><h2 id="join：异步阻塞之闷葫芦"><a href="#join：异步阻塞之闷葫芦" class="headerlink" title="join：异步阻塞之闷葫芦"></a>join：异步阻塞之闷葫芦</h2><p>阻塞模式实现泡茶实例首先从基础的多线程join合并实验入手。<strong>join操作的原理是阻塞当前的线程，直到待合并的目标线程执行完成。</strong></p><p><img src="/p/bfa8a208/f15bfb4ddef90e599b9af7104eab8823.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCurrentThradName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HotWarterThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">HotWarterThread</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="string">&quot;** 烧水-Thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;洗好水壶...&quot;</span>);</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;灌上泉水...&quot;</span>);</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;放在火上...&quot;</span>);</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;等待烧开...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;水烧开了...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;烧水线程被中断了...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(getCurrentThradName() + <span class="string">&quot;烧水线程结束了...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WashThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">WashThread</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="string">&quot;** 清洗-Thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;洗茶壶...&quot;</span>);</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;洗茶杯...&quot;</span>);</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;拿茶叶...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;清洗完了...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;清洗线程被中断了...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;清洗线程结束了...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HotWarterThread</span> <span class="variable">hThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotWarterThread</span>();</span><br><span class="line">        <span class="type">WashThread</span> <span class="variable">wThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WashThread</span>();</span><br><span class="line">        wThread.start();</span><br><span class="line">        hThread.start();</span><br><span class="line">        <span class="comment">// ... 在等待烧水和清洗时，可以干点其他事情</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 合并烧水和清洗线程</span></span><br><span class="line">            hThread.join();</span><br><span class="line">            wThread.join();</span><br><span class="line">            Thread.currentThread().setName(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line">            System.out.println(getCurrentThradName() + <span class="string">&quot;烧水和清洗都完成了...&quot;</span>);</span><br><span class="line">            System.out.println(getCurrentThradName() + <span class="string">&quot;泡茶喝...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程被中断了...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="join-方法详解"><a href="#join-方法详解" class="headerlink" title="join()方法详解"></a>join()方法详解</h3><p>join()方法的应用场景如下：</p><ul><li><strong>A线程调用B线程的join()方法，等待B线程执行完成，在B线程没有完成前，A线程阻塞。</strong></li><li>Join()方法有三个重载版本：<ul><li><code>void join()</code>：A线程等待B线程执行结束后，A线程重启执行。</li><li><code>void join(long millis)</code>：A线程等待B线程执行一段时间，最长等待时间为millis毫秒。超过millis毫秒后，不论B线程是否结束，A线程重启执行。</li><li><code>void join(long millis,int nanos)</code>：等待乙方线程执行一段时间，最长等待时间为millis毫秒加nanos纳秒。超过时间后，不论乙方是否结束，甲方线程都重启执行。</li></ul></li><li>强调一下容易混淆的几点：<ul><li><code>join()</code>是实例方法不是静态方法，需要使用线程对象去调用，如thread.join()。</li><li>调用join()时，不是thread所指向的目标线程阻塞，而是当前线程阻塞。</li><li>只有等到thread所指向的线程执行完成或者超时，当前线程才能启动执行。</li></ul></li><li>join()有一个问题：<ul><li>被合并线程没有返回值。比如，在烧水的实例中，如果烧水线程执行结束，main线程是没有办法知道结果的。同样，清洗线程的执行结果，main线程（泡茶线程）也是没有办法知道的。形象地说，<strong>join线程合并就像一个闷葫芦，只能发起合并线程，不能取到执行结果。</strong></li></ul></li></ul><h3 id="join-的实现源码"><a href="#join-的实现源码" class="headerlink" title="join()的实现源码"></a>join()的实现源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line"><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>); <span class="comment">//阻塞当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay); <span class="comment">//限时阻塞当前线程</span></span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现原理是不停地检查join线程是否存活，如果join线程存活，wait(0)就永远等下去，直至join线程终止后，线程的<code>this.notifyAll()</code>方法会被调用（该方法是在JVM中实现的，JDK中并不会看到源码），join()方法将退出循环，恢复业务逻辑执行。很显然这种循环检查的方式比较低效。</p><p>除此之外，调用join()缺少很多灵活性，比如实际项目中很少自己单独创建线程，而是使用Executor，这进一步减少了join()的使用<br>场景，所以join()的使用多数停留在Demo演示上。</p><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>为了获取异步线程的返回结果，Java在1.5版本之后提供了一种新的多线程创建方式——FutureTask方式。FutureTask方式包含一系列Java相关的类，处于<code>java.util.concurrent</code>包中。使用FutureTask方式进行异步调用时，所涉及的重要组件为FutureTask类和Callable接口。</p><p>由于Runnable有一个重要的问题，它的<code>run()</code>方法是没有返回值的，因此Runnable不能用在需要有返回值的场景。为了解决Runnable接口的问题，Java定义了一个新的和Runnable类似的接口——<code>Callable</code>接口，并且将其中被异步执行的业务处理抽象方法——<code>run()</code>方法改名为<code>call()</code>方法，但是**<code>call()</code>方法有返回值**。</p><h3 id="FutureTask获取异步结果"><a href="#FutureTask获取异步结果" class="headerlink" title="FutureTask获取异步结果"></a>FutureTask获取异步结果</h3><p>通过FutureTask类和Callable接口的联合使用可以创建能获取异步执行结果的线程。具体的步骤重复介绍如下：</p><ol><li>创建一个Callable接口的实现类，并实现它的call()方法，编写好异步执行的具体逻辑，并且可以有返回值。</li><li>使用Callable实现类的实例构造一个FutureTask实例。</li><li>使用FutureTask实例作为Thread构造器的target入参，构造新的Thread线程实例。</li><li>调用Thread实例的start()方法启动新线程，启动新线程的run()方法并发执行。其内部的执行过程为：启动Thread实例的run()方法并发执行后，会执行FutureTask实例的run()方法，最终会并发执行Callable实现类的call()方法。</li><li>调用FutureTask对象的get()方法阻塞性地获得并发线程的执行结果。</li></ol><h3 id="FutureTask实现异步泡茶喝"><a href="#FutureTask实现异步泡茶喝" class="headerlink" title="FutureTask实现异步泡茶喝"></a>FutureTask实现异步泡茶喝</h3><p>join版本泡茶示例中有一个很大的问题，就是主线程获取不到异步线程的返回值。打个比方，如果烧水线程出了问题，或者清<br>洗线程出了问题，main线程（泡茶线程）没有办法知道。哪怕不具备泡茶条件，main线程（泡茶线程）也只能继续泡茶喝。</p><p>使用FutureTask实现异步泡茶喝，main线程可以获取烧水线程、清洗线程的执行结果，然后根据结果判断是否具备泡茶条件，如果具备泡茶条件再泡茶。</p><p><img src="/p/bfa8a208/c077e8b8cc88622bef976bc9dab1d938.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.fulsun._11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaFutureDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCurrentThradName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HotWarterJob</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Boolean&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Boolean <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;洗好水壶...&quot;</span>);</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;灌上泉水...&quot;</span>);</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;放在火上...&quot;</span>);</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;等待烧开...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;水烧开了...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;烧水线程被中断了...&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(getCurrentThradName() + <span class="string">&quot;烧水线程结束了...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WashJob</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Boolean&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Boolean <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;洗茶壶...&quot;</span>);</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;洗茶杯...&quot;</span>);</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;拿茶叶...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;清洗完了...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;清洗线程被中断了...&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;清洗线程结束了...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">drinkTea</span><span class="params">(<span class="type">boolean</span> warterOk, <span class="type">boolean</span> cupOk)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (warterOk &amp;&amp; cupOk) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;烧水和清洗都完成了...泡茶喝...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!warterOk) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;烧水失败，没有茶喝了...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!cupOk) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;清洗失败，没有茶喝了...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">        Callable&lt;Boolean&gt; hJob = <span class="keyword">new</span> <span class="title class_">HotWarterJob</span>();<span class="comment">//③</span></span><br><span class="line">        FutureTask&lt;Boolean&gt; hTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(hJob);<span class="comment">//④</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">hThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(hTask, <span class="string">&quot;** 烧水Thread&quot;</span>);<span class="comment">//⑤</span></span><br><span class="line"></span><br><span class="line">        Callable&lt;Boolean&gt; wJob = <span class="keyword">new</span> <span class="title class_">WashJob</span>();<span class="comment">//③</span></span><br><span class="line">        FutureTask&lt;Boolean&gt; wTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(wJob);<span class="comment">//④</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">wThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(wTask, <span class="string">&quot;$$ 清洗Thread&quot;</span>);<span class="comment">//⑤</span></span><br><span class="line">        hThread.start();</span><br><span class="line">        wThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... 在等待烧水和清洗时，可以干点其他事情</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">warterOk</span> <span class="operator">=</span> hTask.get();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">cupOk</span> <span class="operator">=</span> wTask.get();</span><br><span class="line">            drinkTea(warterOk, cupOk);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException | InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的泡茶喝实例代码中使用了Callable接口来替代Runnable接口，并且在call方法中返回了异步线程的执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WashJob</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Boolean&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//业务代码，并且有执行结果返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从Callable异步逻辑到异步线程需要创建一个<code>FutureTask</code>实例，并<strong>通过FutureTask实例创建新的线程</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;Boolean&gt; hJob = <span class="keyword">new</span> <span class="title class_">HotWarterJob</span>();<span class="comment">//异步逻辑</span></span><br><span class="line"><span class="comment">//包装异步逻辑的异步任务实例</span></span><br><span class="line">FutureTask&lt;Boolean&gt; hTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Boolean&gt;(hJob); </span><br><span class="line"><span class="comment">//异步线程</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">hThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(hTask, <span class="string">&quot;** 烧水-Thread&quot;</span>);</span><br></pre></td></tr></table></figure><p>FutureTask和Callable都是泛型类，泛型参数表示返回结果的类型。所以，在使用时它们两个实例的泛型参数需要保持一致。最后，通过FutureTask实例取得异步线程的执行结果。一般来说，通过FutureTask实例的get方法可以获取线程的执行结果。</p><p>因为通过FutureTask的get()方法获取异步结果时，主线程也会被阻塞。这一点FutureTask和join是一致的，它们都是<code>异步阻塞模式</code>。</p><p>异步阻塞的效率往往比较低，被阻塞的主线程不能干任何事情，唯一能干的就是傻傻等待。原生Java API除了阻塞模式的获取结果<br>外，并没有实现非阻塞的异步结果获取方法。如果需要用到获取的异步结果，得引入一些额外的框架，接下来将会介绍谷歌的Guava框架。</p><h2 id="异步回调与主动调用"><a href="#异步回调与主动调用" class="headerlink" title="异步回调与主动调用"></a>异步回调与主动调用</h2><p>在前面的泡茶喝实例中，不论主线程调用join()进行闷葫芦式线程同步，还是使用<code>Future.get()</code>获取异步线程的执行结果，都属于<strong>主动模式的调用</strong>。</p><p>在泡茶喝的例子中，泡茶线程是调用线程，烧水（或者清洗）线程是被调用线程，调用线程和被调用线程之间是一种主动关系，而不<br>是被动关系。泡茶线程需要主动获取烧水（或者清洗）线程的执行结果。</p><ul><li><p>调用<code>join()</code>或<code>Future.get()</code>进行同步时，泡茶线程和烧水（或者清洗）线程之间的主动关系如图所示。</p><p><img src="/p/bfa8a208/506b7f1d782dc7df9c10a2a5a732042d.png"></p></li><li><p><strong>主动调用</strong>是一种阻塞式调用，它是一种单向调用，“调用方”要等待“被调用方”执行完毕才返回。如果“被调用方”的执行时间很长，那么“调用方”线程需要阻塞很长一段时间。</p></li><li><p>如何将主动调用的方向进行反转呢？这就是<strong>异步回调。回调是一种反向的调用模式，也就是说，被调用方在执行完成后，会反向执行“调用方”所设置的钩子方法。</strong>使用回调模式将泡茶线程和烧水（或者清洗）线程之间的“主动”关系进行反转:</p><p><img src="/p/bfa8a208/eae0cc0df34c546d538d56ad9f88497e.png"></p><ul><li>实质上，在回调模式中负责执行回调方法的具体线程已经不再是调用方的线程（如示例中的泡茶线程），而是变成了异步的被调用方的线程（如烧水线程）。</li><li>Java中回调模式的标准实现类为<code>CompletableFuture</code>，由于该类出现的时间比较晚，因此很多著名的中间件如Guava、Netty等都提供了自己的异步回调模式API供开发者使用。开发者还可以使用RxJava响应式编程组件进行异步回调的开发。</li></ul></li></ul><h2 id="Guava的异步回调模式"><a href="#Guava的异步回调模式" class="headerlink" title="Guava的异步回调模式"></a>Guava的异步回调模式</h2><p>Guava是Google提供的Java扩展包，它提供了一种异步回调的解决方案。Guava中与异步回调相关的源码处于<code>com.google.common.util.concurrent</code>包中。包中的很多类都用于对<code>java.util.concurrent</code>的能力扩展和能力增强。比如，Guava的异步任务接口<code>ListenableFuture</code>扩展了Java的Future接口，实现了异步回调的能力。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>30.1.1-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="详解FutureCallback"><a href="#详解FutureCallback" class="headerlink" title="详解FutureCallback"></a>详解FutureCallback</h3><p>总体来说，Guava主要增强了Java而不是另起炉灶。为了实现异步回调方式获取异步线程的结果，Guava做了以下增强：</p><ul><li>引入了一个新的接口<code>ListenableFuture</code>，继承了Java的Future接口，使得Java的Future异步任务在Guava中能被监控和非阻塞获取异步结果。</li><li>引入了一个新的接口<code>FutureCallback</code>，这是一个独立的新接口。该接口的目的是在异步任务执行完成后，根据异步结果完成不同的回调处理，并且可以处理异步结果。</li><li><code>FutureCallback</code>是一个新增的接口，用来填写异步任务执行完后的监听逻辑。FutureCallback拥有两个回调方法：<ul><li><code>onSuccess()</code>方法，在异步任务执行成功后被回调。调用时，异步任务的执行结果作为onSuccess方法的参数被传入。</li></ul></li><li><code>onFailure()</code>方法，在异步任务执行过程中抛出异常时被回调。调用时，异步任务所抛出的异常作为onFailure方法的参数被传入。</li></ul><p>FutureCallback的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FutureCallback</span>&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(<span class="meta">@Nullable</span> V result)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Guava的FutureCallback与Java的Callable名字相近，实质不同，存在本质的区别：</p><ol><li>Java的<code>Callable</code>接口代表的是<strong>异步执行的逻辑</strong>。</li><li>Guava的<code>FutureCallback</code>接口代表的是Callable<strong>异步逻辑执行完成之后，根据成功或者异常两种情形所需要才可能执行Guava中的FutureCallback结果回调</strong>。</li></ol><h3 id="详解ListenableFuture"><a href="#详解ListenableFuture" class="headerlink" title="详解ListenableFuture"></a>详解ListenableFuture</h3><p>Guava引入了一个新接口ListenableFuture，它继承了Java的Future接口，增强了被监控的能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ListenableFuture</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">  <span class="comment">//此方法由Guava内部调用</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(Runnable listener, Executor executor)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ListenableFuture</code>仅仅增加了一个<code>addListener()</code>方法。它的作用就是<code>FutureCallback</code>善后回调逻辑封装成一个内部的Runnable异步回调任务，在Callable异步任务完成后回调FutureCallback善后逻辑。在实际编程中，<code>addListener()</code>不会使用到。</p><blockquote><p>在实际编程中，如何将FutureCallback回调逻辑绑定到异步的ListenableFuture任务呢？</p></blockquote><p>可以使用Guava的Futures工具类，它有一个addCallback()静态方法，可以将FutureCallback的回调实例绑定到ListenableFuture异步任务。下面是一个简单的绑定实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加一个回调，当异步任务完成时会执行这个回调</span></span><br><span class="line">Futures.addCallback(future, <span class="keyword">new</span> <span class="title class_">com</span>.google.common.util.concurrent.FutureCallback&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String result)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异步操作成功，结果是： &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异步操作失败，原因是： &quot;</span> + t.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, MoreExecutors.directExecutor());</span><br></pre></td></tr></table></figure><h3 id="ListenableFuture异步任务"><a href="#ListenableFuture异步任务" class="headerlink" title="ListenableFuture异步任务"></a>ListenableFuture异步任务</h3><p>如果要获取Guava的ListenableFuture异步任务实例，主要通过向线程池（ThreadPool）提交Callable任务的方式获取。不过，这里所说的线程池不是Java的线程池，而是经过Guava自己定制过的Guava线程池。</p><p>Guava线程池是对Java线程池的一种装饰。创建Guava线程池的方法如下：</p><ul><li><p>首先创建Java线程池，然后以其作为Guava线程池的参数再构造一个Guava线程池。有了Guava的线程池之后，就可以通过<code>submit()</code>方法<br>来提交任务了，任务提交之后的返回结果就是我们所要的ListenableFuture异步任务实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java线程池</span></span><br><span class="line"> <span class="type">ExecutorService</span> <span class="variable">jPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"> <span class="comment">// Guava线程池</span></span><br><span class="line"> <span class="type">ListeningExecutorService</span> <span class="variable">gPool</span> <span class="operator">=</span> MoreExecutors.listeningDecorator(jPool);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>取到了ListenableFuture实例后，通过<code>Futures.addCallback()</code>方法将FutureCallback回调逻辑的实例绑定到ListenableFuture异步任务实例，实现异步执行完成后的回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//submit()方法用来提交任务，返回异步任务实例</span></span><br><span class="line"> ListenableFuture&lt;Boolean&gt; hFuture = gPool.submit(hJob);</span><br><span class="line"> <span class="comment">//绑定回调实例</span></span><br><span class="line"> Futures.addCallback(listenableFuture, <span class="keyword">new</span> <span class="title class_">FutureCallback</span>&lt;Boolean&gt;()&#123;</span><br><span class="line"> <span class="comment">//有两种实现回调的方法 onSuccess()/onFailure()</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="Guava实现泡茶喝的实例"><a href="#Guava实现泡茶喝的实例" class="headerlink" title="Guava实现泡茶喝的实例"></a>Guava实现泡茶喝的实例</h3><p>基于Guava异步回调模式的泡茶喝程序的执行流程如图:</p><p><img src="/p/bfa8a208/e77fe8e7d9718f50d36e32ce3cd01f9d.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuavaFutureDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCurrentThradName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HotWarterJob</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Boolean&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Boolean <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;洗好水壶...&quot;</span>);</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;灌上泉水...&quot;</span>);</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;放在火上...&quot;</span>);</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;等待烧开...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;水烧开了...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;烧水线程被中断了...&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(getCurrentThradName() + <span class="string">&quot;烧水线程结束了...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WashJob</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Boolean&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Boolean <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;洗茶壶...&quot;</span>);</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;洗茶杯...&quot;</span>);</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;拿茶叶...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;清洗完了...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(getCurrentThradName() + <span class="string">&quot;清洗线程被中断了...&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(getCurrentThradName() +<span class="string">&quot;清洗线程结束了...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">drinkTea</span><span class="params">(<span class="type">boolean</span> warterOk, <span class="type">boolean</span> cupOk)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (warterOk &amp;&amp; cupOk) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;烧水和清洗都完成了...泡茶喝...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!warterOk) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;烧水失败，没有茶喝了...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!cupOk) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;清洗失败，没有茶喝了...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 泡茶喝的工作</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DrinkJob</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">waterOk</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">cupOk</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 泡茶喝，回调方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drinkTea</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (waterOk &amp;&amp; cupOk) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;烧水和清洗都完成了...泡茶喝...&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.waterOk = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;泡茶喝线程&quot;</span>);</span><br><span class="line">        <span class="type">DrinkJob</span> <span class="variable">drinkJob</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DrinkJob</span>();</span><br><span class="line">        <span class="comment">// 烧水的业务逻辑</span></span><br><span class="line">        Callable&lt;Boolean&gt; hotJob = <span class="keyword">new</span> <span class="title class_">HotWarterJob</span>();</span><br><span class="line">        <span class="comment">// 清洗的业务逻辑</span></span><br><span class="line">        Callable&lt;Boolean&gt; washJob = <span class="keyword">new</span> <span class="title class_">WashJob</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Java 线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">jPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 包装Java线程池，构造guava 线程池</span></span><br><span class="line">        <span class="type">ListeningExecutorService</span> <span class="variable">gPool</span> <span class="operator">=</span> MoreExecutors.listeningDecorator(jPool);</span><br><span class="line">        <span class="comment">// 烧水的回调钩子</span></span><br><span class="line">        FutureCallback&lt;Boolean&gt; hotWaterHook = <span class="keyword">new</span> <span class="title class_">FutureCallback</span>&lt;Boolean&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(<span class="meta">@Nullable</span> Boolean result)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                    drinkJob.waterOk = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 执行回调方法</span></span><br><span class="line">                    drinkJob.drinkTea();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;烧水失败，没有茶喝了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 启动烧水线程</span></span><br><span class="line">        ListenableFuture&lt;Boolean&gt; hotFuture = gPool.submit(hotJob);</span><br><span class="line">        <span class="comment">// 设置烧水任务的回调钩子</span></span><br><span class="line">        Futures.addCallback(hotFuture, hotWaterHook, gPool);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清洗的回调钩子</span></span><br><span class="line">        FutureCallback&lt;Boolean&gt; washHook = <span class="keyword">new</span> <span class="title class_">FutureCallback</span>&lt;Boolean&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(<span class="meta">@Nullable</span> Boolean result)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                    drinkJob.cupOk = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 执行回调方法</span></span><br><span class="line">                    drinkJob.drinkTea();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;清洗失败，没有茶喝了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 启动清洗线程</span></span><br><span class="line">        ListenableFuture&lt;Boolean&gt; washFuture = gPool.submit(washJob);</span><br><span class="line">        <span class="comment">// 设置清洗任务的回调钩子</span></span><br><span class="line">        Futures.addCallback(washFuture, washHook, gPool);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;干点其他事情......&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>洗好水壶...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>灌上泉水...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>放在火上...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>等待烧开...</span><br><span class="line">泡茶喝线程干点其他事情......</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>洗茶壶...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>洗茶杯...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>拿茶叶...</span><br><span class="line">泡茶喝线程执行完成</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>清洗完了...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>清洗线程结束了...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>水烧开了...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>烧水线程结束了...</span><br><span class="line">烧水和清洗都完成了...泡茶喝...</span><br></pre></td></tr></table></figure><p>以上结果，烧水线程为pool-1-thread-1，清洗线程为pool-1-thread-2，在二者完成之前，泡茶喝线程已经执行完了。泡茶喝的工<br>作在异步回调方法drinkTea()中执行，执行的线程并不是“泡茶喝”线程，而是烧水线程和清洗线程.</p><h3 id="Guava异步回调和Java异步调用的区别"><a href="#Guava异步回调和Java异步调用的区别" class="headerlink" title="Guava异步回调和Java异步调用的区别"></a>Guava异步回调和Java异步调用的区别</h3><p>总结一下Guava异步回调和Java的FutureTask异步调用的区别，具体如下：</p><ol><li>FutureTask是主动调用的模式，“调用线程”主动获得异步结果，在获取异步结果时处于阻塞状态，并且会一直阻塞，直到拿到<br>异步线程的结果。</li><li>Guava是异步回调模式，“调用线程”不会主动获得异步结果，而是准备好回调函数，并设置好回调钩子，执行回调函数的并不<br>是“调用线程”自身，回调函数的执行者是“被调用线程”，“调用线程”在执行完自己的业务逻辑后就已经结束了，当回调函数被执行<br>时，“调用线程”可能已经结束很久了。</li></ol><table><thead><tr><th>比较项</th><th>Guava 异步回调</th><th>Java FutureTask 异步调用</th></tr></thead><tbody><tr><td>回调处理</td><td>有 <code>onSuccess</code> 和 <code>onFailure</code> 回调，任务完成自动触发，无需 <code>get()</code> 阻塞</td><td>无直接回调，依赖 <code>isDone()</code> 检查，<code>get()</code> 阻塞，手动处理异常</td></tr><tr><td>灵活性</td><td>可方便组合多个任务，支持结果转换</td><td>较基础，多任务组合和结果转换需更多手动编码</td></tr><tr><td>使用场景</td><td>复杂异步任务，需任务组合与结果转换</td><td>简单异步任务，仅执行并获取结果</td></tr></tbody></table><h2 id="Netty的异步回调模式"><a href="#Netty的异步回调模式" class="headerlink" title="Netty的异步回调模式"></a>Netty的异步回调模式</h2><p>Netty和Guava一样，实现了自己的异步回调体系：Netty继承和扩展了JDK Future系列异步回调的API，定义了自身的Future系列接口和<br>类，实现了异步任务的监控、异步执行结果的获取。总体来说，Netty对Java Future异步任务的扩展如下：</p><ul><li>继承Java的Future接口得到了一个新的属于Netty自己的Future异步任务接口，该接口对原有的接口进行了增强，使得Netty异步任务能够非阻塞地处理回调结果。注意，Netty没有修改Future的名称，只是调整了所在的包名，Netty的Future类的包名和Java的Future接口的包不同。</li><li>引入了一个新接口——GenericFutureListener，用于表示异步执行完成的监听器。这个接口和Guava的FutureCallback回调接口不同。Netty使用了监听器的模式，异步任务执行完成后的回调逻辑抽象成了Listener监听器接口。可以将Netty的GenericFutureListener监听器接口加入Netty异步任务Future中，实现对异步任务执行状态的事件监听。</li></ul><p>总体来说，在异步非阻塞回调的设计思路上，Netty和Guava是一致的。对应关系为：</p><ul><li>Netty的Future接口可以对应到Guava的ListenableFuture接口。</li><li>Netty的GenericFutureListener接口可以对应到Guava的FutureCallback接口。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.85.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 可以根据需要使用最新的稳定版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="GenericFutureListener接口详解"><a href="#GenericFutureListener接口详解" class="headerlink" title="GenericFutureListener接口详解"></a>GenericFutureListener接口详解</h3><p>前面提到，和Guava的FutureCallback一样，Netty新增了一个接口，用来封装异步非阻塞回调的逻辑，那就是<code>GenericFutureListener </code>接口。<code>GenericFutureListener</code>位于<code>io.netty.util.concurrent</code>包中，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.util.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.EventListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenericFutureListener</span>&lt;F <span class="keyword">extends</span> <span class="title class_">Future</span>&lt;?&gt;&gt; <span class="keyword">extends</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line">    <span class="comment">//监听器的回调方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(F var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>GenericFutureListener拥有一个回调方法<code>operationComplete()</code>，表示异步任务操作完成。在Future异步任务执行完成后将回调此方法。大多数情况下，<strong>Netty的异步回调代码编写在<code>GenericFutureListener</code>接口的实现类的<code>operationComplete</code>方法中</strong>。</p><p>说明一下，<code>GenericFutureListener</code>的父接口<code>EventListener</code>是一个空接口，没有任何抽象方法，是一个仅仅具有标识作用的接口。</p><h3 id="Netty的Future接口详解"><a href="#Netty的Future接口详解" class="headerlink" title="Netty的Future接口详解"></a>Netty的Future接口详解</h3><p>Netty也对Java的Future接口进行了扩展，并且名称没有变，还是叫作<code>Future</code>接口，实现在<code>io.netty.util.concurrent包中。和Guava的</code>ListenableFuture&#96;一样，Netty的Future接口扩展了一系列方法，对执行的过程进行监控，对异步回调完成事件进行Listen监听并且回调。</p><p>Netty的<code>Future</code>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.util.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">java</span>.util.concurrent.Future&lt;V&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSuccess</span><span class="params">()</span>; <span class="comment">// 判断异步执行是否成功</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancellable</span><span class="params">()</span>; <span class="comment">// 判断异步执行是否取消</span></span><br><span class="line"></span><br><span class="line">    Throwable <span class="title function_">cause</span><span class="params">()</span>; <span class="comment">// 获取异步任务异常的原因</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加异步任务执行完成Listener监听器</span></span><br><span class="line">    Future&lt;V&gt; <span class="title function_">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line">    Future&lt;V&gt; <span class="title function_">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt;... var1)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 移除异步任务执行完成Listener监听器</span></span><br><span class="line">    Future&lt;V&gt; <span class="title function_">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt; var1)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Netty的Future接口一般不会直接使用，使用过程中会使用它的子接口。Netty有一系列子接口，代表不同类型的异步任务，</p><ul><li>**<code>ChannelFuture</code>**：<ul><li>与 <code>Channel</code> 操作相关联，当执行 <code>Channel</code> 的异步操作（如 <code>bind</code>、<code>connect</code>、<code>write</code>、<code>close</code> 等）时会返回该类型的 <code>Future</code> 对象。</li><li>重要方法：<ul><li><code>addListener(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt; listener)</code>：添加监听器，当操作完成时会调用监听器的 <code>operationComplete</code> 方法，以便处理操作成功或失败的情况。</li><li><code>sync()</code>：同步等待操作完成，操作失败会抛出异常。</li><li><code>await()</code>：等待操作完成，不抛出异常，返回操作是否成功。</li></ul></li></ul></li><li>**<code>Promise</code>**：<ul><li>不仅可以表示异步操作的结果，还可以设置操作的结果，是一个可写的 <code>Future</code>。</li><li>重要方法：<ul><li><code>setSuccess(V result)</code>：设置操作成功的结果。</li><li><code>setFailure(Throwable cause)</code>：设置操作失败的原因。</li><li><code>trySuccess(V result)</code>：尝试设置操作成功结果，若已设置过结果或操作已取消，返回 <code>false</code>。</li><li><code>tryFailure(Throwable cause)</code>：尝试设置操作失败原因，若已设置过结果或操作已取消，返回 <code>false</code>。</li></ul></li></ul></li></ul><p>这些子接口扩展了 <code>Future</code> 接口的基本功能，使其更适合 Netty 的异步编程场景，为网络操作提供了方便的异步结果处理和操作控制机制。使用它们可以更灵活地管理网络操作的结果，避免阻塞线程，提高程序性能和可扩展性。在实际应用中，根据具体的网络操作需求，选择合适的子接口可以更好地实现异步编程和错误处理等功能。例如，在服务器启动和关闭操作中使用 <code>ChannelFuture</code> 处理 <code>bind</code> 和 <code>close</code> 的结果，在需要手动控制操作结果时使用 <code>Promise</code> 接口。</p><h3 id="ChannelFuture的使用"><a href="#ChannelFuture的使用" class="headerlink" title="ChannelFuture的使用"></a>ChannelFuture的使用</h3><p>在Netty网络编程中，网络连接通道的输入、输出处理都是异步进行的，都会返回一个ChannelFuture接口的实例。通过返回的异步任务实例可以为其增加异步回调的监听器。在异步任务真正完成后，回调执行。</p><p>Netty的网络连接的异步回调实例代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// connect是异步的，仅仅是提交异步任务</span></span><br><span class="line"><span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;www.baidu.com&quot;</span>, <span class="number">80</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// connect的异步任务真正执行完成后，future回调监听器会执行</span></span><br><span class="line">future.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (channelFuture.isSuccess()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Connection  established&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Connection  attempt failed&quot;</span>);</span><br><span class="line">            channelFuture.cause().printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>GenericFutureListener</code>接口在Netty中是一个基础类型接口。在网络编程的异步回调中，一般使用Netty中提供的某个子接口，如<code>ChannelFutureListener</code>接口。在上面的代码中，使用到的是这个子接口。</p><h3 id="Netty的出站和入站异步回调"><a href="#Netty的出站和入站异步回调" class="headerlink" title="Netty的出站和入站异步回调"></a>Netty的出站和入站异步回调</h3><p>Netty的出站和入站操作都是异步的。异步回调的方法和前面Netty建立的异步回调是一样的。下面以经典的NIO出站操作write为例说明<code>ChannelFuture</code>的使用。在write操作调用后，Netty并没有立即完成对Java NIO底层连接的写入操作，底层的写入操作是异步执行的，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write()输出方法，返回的是一个异步任务</span></span><br><span class="line"><span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> ctx.channel().write(msg);</span><br><span class="line"><span class="comment">// 为异步任务加上监听器</span></span><br><span class="line">future.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> &#123;</span><br><span class="line">        <span class="comment">// write操作完成后的回调代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在write操作完成后立即返回，返回的是一个ChannelFuture接口的实例。通过这个实例可以绑定异步回调监听器，编写异步回调的逻辑。</p><h3 id="EchoServer-示例"><a href="#EchoServer-示例" class="headerlink" title="EchoServer 示例"></a>EchoServer 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.fulsun._12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EchoServer</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 接收连接的 EventLoopGroup</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 处理连接的 EventLoopGroup</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">// 添加 String 编解码器</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                            <span class="comment">// 添加 EchoServerHandler 处理客户端发送的数据</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">EchoServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 绑定端口，启动服务器</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> b.bind(port).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待服务器关闭</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭 EventLoopGroup</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">EchoServer</span>(port).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">        <span class="comment">// 接收到客户端发送的数据，直接回写回去</span></span><br><span class="line">        ctx.writeAndFlush(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.fulsun._12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFutureListener;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">EchoClientHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发起连接</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送数据</span></span><br><span class="line">            future.channel().writeAndFlush(<span class="string">&quot;Hello, Echo Server&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待连接关闭</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EchoClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">        <span class="comment">// 接收到服务器返回的数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Received from server: &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script>var description="介绍比较常用的第三方异步回调技术。"</script>]]></content>
      
      
      <categories>
          
          <category> 多线程编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异步回调 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发设计模式</title>
      <link href="/p/b664c132.html"/>
      <url>/p/b664c132.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="线程安全的单例模式"><a href="#线程安全的单例模式" class="headerlink" title="线程安全的单例模式"></a>线程安全的单例模式</h2><p>单例模式是常见的一种设计模式，一般用于全局对象管理，比如XML读写实例、系统配置实例、任务调度实例、数据库连接池实例等。</p><h3 id="从饿汉式单例到懒汉式单"><a href="#从饿汉式单例到懒汉式单" class="headerlink" title="从饿汉式单例到懒汉式单"></a>从饿汉式单例到懒汉式单</h3><p>按照单例对象被初始化的时机，单例模式一般分为懒汉式、饿汉式两种。饿汉式单例在类被加载时就直接被初始化，参考代码具体如<br>下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 私有构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton1</span> <span class="variable">single</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉单例模式的优点是足够简单、安全。其缺点是：单例对象在类被加载时，实例就直接被初始化了。很多时候，在类被加载时并不需要进行单例初始化，所以需要对单例的初始化予以延迟，一直到实<br>例使用的时候初始化。<strong>在使用的时候才对单例进行初始化，这就是懒汉单例模式。</strong>懒汉单例模式的参考代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ASingleton</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> ASingleton instance; <span class="comment">// 静态成员</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ASingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取单例的方法</span></span><br><span class="line">    <span class="keyword">static</span> ASingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) <span class="comment">//①</span></span><br><span class="line">        &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">ASingleton</span>(); <span class="comment">//②</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上懒汉单例模式的实现大家都很熟悉，估计也编写过类似的代码。以上参考实现在单线程场景中是合理的、安全的。在第一次被调用时，getInstance()方法会新建一个ASingleton实例，但之后访问时<br>返回的是第一次新建的ASingleton实例。多线程并发访问getInstance()方法时，问题就出来了：不同的线程有可能同时进入代码①处的条件判断，多次执行代码②，从而新建多个ASingleton对象。</p><h3 id="使用内置锁保护懒汉式单例"><a href="#使用内置锁保护懒汉式单例" class="headerlink" title="使用内置锁保护懒汉式单例"></a>使用内置锁保护懒汉式单例</h3><p>如何确保单例只创建一次，可以使用synchronized内置锁进行单例获取同步，确保同时只能有一个线程进入临界区执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用synchronized内置锁进行单例获取同步</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> BSingleton instance; <span class="comment">// 保持单例的静态成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 私有构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取单例的方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">synchronized</span> BSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">BSingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getInstance()方法加synchronized关键字之后，可以保证在并发执行时不出错。问题是：每次执行getInstance()方法都要用到同步，在争用激烈的场景下，内置锁会升级为重量级锁，开销大、性能差，所以不推荐高并发线程使用这种方式的单例模式。</p><h3 id="双重检查锁单例模式"><a href="#双重检查锁单例模式" class="headerlink" title="双重检查锁单例模式"></a>双重检查锁单例模式</h3><p>实际上，单例模式的加锁操作只有单例在第一次创建的时候才需要用到，之后的单例获取操作都没必要再加锁。所以，可以先判断单例对象是否已经被初始化，如果没有，加锁后再初始化，这种模式被<br>叫作双重检查锁（Double Checked Locking）单例模式。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双重检查的懒汉式单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ESingleton</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> ESingleton instance;<span class="comment">// 保持单例的静态成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ESingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 私有构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">synchronized</span> ESingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) <span class="comment">// 检查①</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ESingleton.class)<span class="comment">// 加锁</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) <span class="comment">// 检查②</span></span><br><span class="line">                &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">ESingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>检查单例对象是否被初始化，如果已被初始化，就立即返回单例对象。这是第一次检查，对应示例代码中的检查①，此次检查不需要使用锁进行线程同步，用于提高获取单例对象的性能。</li><li>如果单例没有被初始化，就试图进入临界区进行初始化操作，此时才去获取锁</li><li>进入临界区之后，再次检查单例对象是否已经被初始化，如果还没被初始化，就初始化一个实例。这是第二次检查，对应代码中的检查②，此次检查在临界区内进行。<ul><li>为什么在临界区内还需要执行一次检查呢？</li><li>答案是：在多个线程竞争的场景下，可能同时不止一个线程通过了第一次检查（检查①），此时第一个通过“检查①”的线程将首先进入临界区，而其他通过“检查①”的线程将被阻塞，在第一个线程实例化单例对象释放锁之后，其他线程可能获取到锁进入临界区，实际上单例已经被初始化了，所以哪怕进入了临界区，其他线程并没有办法通过“检查②”的条件判断，无法执行重复的初始化。</li></ul></li></ul><p>双重检查不仅避免了单例对象在多线程场景中的反复初始化，而且除了初始化的时候需要现加锁外，后续的所有调用都不需要加锁而直接返回单例，从而提升了获取单例时的性能。</p><h3 id="使用双重检查锁-volatile"><a href="#使用双重检查锁-volatile" class="headerlink" title="使用双重检查锁+volatile"></a>使用双重检查锁+volatile</h3><p>表面上，使用双重检查锁机制的单例模式一切看上去都很完美，其实并不是这样的。那么问题出现在哪里呢？下面这行代码实际大有玄机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化单例</span></span><br><span class="line">instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>()</span><br></pre></td></tr></table></figure><p>这行初始化单例代码转换成汇编指令（具有原子性的指令）后，大致会细分成三个：</p><ol><li>分配一块内存M。</li><li>在内存M上初始化Singleton对象。</li><li>M的地址赋值给instance变量。</li></ol><p>编译器、CPU都可能对没有内存屏障、数据依赖关系的操作进行重排序，上述的三个指令优化后可能就变成了这样：</p><ol><li>分配一块内存M。</li><li>将M的地址赋值给instance变量。</li><li>在内存M上初始化Singleton对象。</li></ol><p>这里假设两个线程以下面的次序执行：</p><ol><li>线程A先执行getInstance()方法，当执行到分配一块内存并将地址赋值给M后，恰好发生了线程切换。此时，线程A还没来得及将M指向的内存初始化。</li><li>线程B刚进入getInstance()方法，判断if语句instance是否为空，此时的instance不为空，线程B直接获取到了未初始化的instance变量。</li><li>由于线程B得到的是一个未初始化完全的对象，因此访问instance成员变量的时候可能发生异常。</li></ol><p>如何确保线程B获取的是一个完成初始化的单例呢？<strong>可以通过volatile禁止指令重排</strong>。双重检查锁+volatile相结合的单例模式实现大致的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 volatile 关键字保证可见性和禁止指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次检查，如果 instance 不为 null，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 同步块，保证多线程环境下只创建一个实例</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 第二次检查，防止多个线程同时进入同步块时重复创建实例</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态内部类方式"><a href="#静态内部类方式" class="headerlink" title="静态内部类方式"></a>静态内部类方式</h3><p>虽然通过双重检查锁+volatile相结合的方式能实现高性能、线程安全的单例模式，但是该实现的底层原理比较复杂，写法烦琐。另一种易于理解、编程简单的单例模式的实现为使用静态内部类实例懒汉<br>式单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类，用于持有单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 final 关键字确保该实例一旦创建就不会被修改</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供获取单例的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用静态内部类实现懒汉式单例模式只有在getInstance()被调用时才去加载内部类并且初始化单例，该方式既解决了线程安全问题，又解决了写法烦琐问题。</p><h2 id="Master-Worker模式"><a href="#Master-Worker模式" class="headerlink" title="Master-Worker模式"></a>Master-Worker模式</h2><p>Master-Worker模式是一种常见的高并发模式，它的核心思想是任务的调度和执行分离，调度任务的角色为Master，执行任务的角色为Worker，Master负责接收、分配任务和合并（Merge）任务结果，<br>Worker负责执行任务。</p><p>Master-Worker模式是一种归并类型的模式。举一个例子，在TCP服务端的请求处理过程中，大量的客户端连接相当于大量的任务，Master需要将这些任务存储在一个任务队列中，然后分发给各个Worker，每个Worker是一个工作线程，负责完成连接的传输处理。</p><h3 id="参考实现"><a href="#参考实现" class="headerlink" title="参考实现"></a>参考实现</h3><p>假设一个场景，需要执行N个任务，将这些任务的结果进行累加求和，如果任务太多，就可以采用Master-Worker模式来实现。Master持有workerCount个Worker，并且负责接收任务，然后分发给Worker，最后在回调函数中对Worker的结果进行归并求和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Worker线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; subTask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(List&lt;Integer&gt; subTask)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subTask = subTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">subResult</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : subTask) &#123;</span><br><span class="line">            subResult += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 假设这里有一个机制可以将结果返回给Master，这里简化处理，直接打印</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Worker result: &quot;</span> + subResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Master类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Master</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; task;</span><br><span class="line">    <span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Future&lt;?&gt;&gt; futures;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Master</span><span class="params">(List&lt;Integer&gt; task)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.task = task;</span><br><span class="line">        <span class="comment">// 创建一个线程池，这里简单地使用固定大小的线程池</span></span><br><span class="line">        <span class="built_in">this</span>.executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">this</span>.futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submitTasks</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 将任务划分为多个子任务，这里简单地将数组划分为大小相近的子数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> task.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">subTaskSize</span> <span class="operator">=</span> size / <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> i * subTaskSize;</span><br><span class="line">            <span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> (i == <span class="number">4</span>)? size : (i + <span class="number">1</span>) * subTaskSize;</span><br><span class="line">            List&lt;Integer&gt; subTask = task.subList(startIndex, endIndex);</span><br><span class="line">            <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(subTask);</span><br><span class="line">            <span class="comment">// 提交任务到线程池，并保存Future对象</span></span><br><span class="line">            Future&lt;?&gt; future = executorService.submit(worker);</span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">collectResults</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这里只是简单地等待所有任务完成，实际应用中可能需要收集结果并进行汇总</span></span><br><span class="line">        <span class="keyword">for</span> (Future&lt;?&gt; future : futures) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                future.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MasterWorkerExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            task.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Master</span> <span class="variable">master</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Master</span>(task);</span><br><span class="line">        master.submitTasks();</span><br><span class="line">        master.collectResults();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中：</p><ul><li><code>Worker</code>类实现了<code>Runnable</code>接口，它的<code>run</code>方法用于计算分配给它的子任务（子数组元素的和）。</li><li><code>Master</code>类负责管理任务。它在构造函数中初始化了任务列表和线程池，<code>submitTasks</code>方法用于将任务分解并分发给<code>Worker</code>线程，<code>collectResults</code>方法用于等待所有任务完成（实际应用中还可以收集和汇总结果）。</li><li>在<code>main</code>方法中，创建了一个整数列表作为任务，然后创建<code>Master</code>对象，提交任务并收集结果。</li></ul><ol><li>适用场景<ul><li><strong>计算密集型任务</strong>：例如科学计算中的矩阵运算、大规模数据的统计分析（如计算海量数据的平均值、方差等）。通过 Master - Worker 模式，可以将复杂的计算任务分解为多个小的计算子任务，利用多核 CPU 的并行计算能力，加速任务的完成。</li><li><strong>数据处理任务</strong>：如对大型文件的处理，将文件内容分割为多个部分，每个 Worker 线程处理一部分内容，最后由 Master 汇总处理结果，像是文本文件的词频统计、日志文件的分析等。</li></ul></li><li>优点<ul><li><strong>提高性能</strong>：通过并行处理任务，能够充分利用系统资源，显著缩短任务的执行时间，特别是在多核处理器环境下。</li><li><strong>任务分解和管理清晰</strong>：Master 负责任务的分解和结果的收集，Worker 专注于执行子任务，这种分工使得代码结构清晰，易于理解和维护。</li></ul></li><li>缺点<ul><li><strong>实现复杂度增加</strong>：相比简单的单线程任务处理，Master - Worker 模式需要考虑任务的分解、线程间的通信和同步、结果的收集等多个方面，增加了代码的复杂性。</li><li><strong>资源管理问题</strong>：如果任务划分不合理，可能导致某些 Worker 线程负载过重，而其他线程空闲，影响整体性能。同时，线程的创建和销毁也会消耗一定的系统资源，需要合理地使用线程池来优化。</li></ul></li></ol><h2 id="ForkJoin模式"><a href="#ForkJoin模式" class="headerlink" title="ForkJoin模式"></a>ForkJoin模式</h2><p>“分而治之”是一种思想，所谓“分而治之”，就是把一个复杂的算法问题按一定的“分解”方法分为规模较小的若干部分，然后逐个解决，分别找出各部分的解，最后把各部分的解组成整个问题的<br>解。“分而治之”思想在软件体系结构设计、模块化设计、基础算法中得到了非常广泛的应用。许多基础算法都运用了“分而治之”的思想，比如二分查找、快速排序等。</p><p>Master-Worker模式是“分而治之”思想的一种应用，与MasterWorker模式不同，ForkJoin模式没有Master角色，其所有的角色都是Worker，ForkJoin模式中的Worker将大的任务分割成小的任务，一直到任务的规模足够小，可以使用很简单、直接的方式来完成。</p><p>ForkJoin模式先把一个大任务分解成许多个独立的子任务，然后开启多个线程并行去处理这些子任务。有可能子任务还是很大而需要进一步分解，最终得到足够小的任务。ForkJoin模式借助了现代计算机多核的优势并行处理数据。</p><p>通常情况下，ForkJoin模式将分解出来的子任务放入双端队列中，然后几个启动线程从双端队列中获取任务并执行。子任务执行的结果放到一个队列中，各个线程从队列中获取数据，然后进行局部结果的合并，得到最终结果。</p><h3 id="ForkJoin框架"><a href="#ForkJoin框架" class="headerlink" title="ForkJoin框架"></a>ForkJoin框架</h3><p>JUC包提供了一套ForkJoin框架的实现，具体以ForkJoinPool线程池的形式提供，并且该线程池在Java 8的Lambda并行流框架中充当着底层框架的角色。JUC包的ForkJoin框架包含如下组件：</p><ol><li>ForkJoinPool：执行任务的线程池，继承了AbstractExecutorService类。</li><li>ForkJoinWorkerThread：执行任务的工作线程（ForkJoinPool线程池中的线程）。每个线程都维护着一个内部队列，用于存放“内部任务”该类继承了Thread类。</li><li>ForkJoinTask：用于ForkJoinPool的任务抽象类，实现了Future接口。</li><li><code>RecursiveTask</code>：带返回结果的递归执行任务，是ForkJoinTask的子类，在子任务带返回结果时使用。</li><li><code>RecursiveAction</code>：不返回结果的递归执行任务，是ForkJoinTask的子类，在子任务不带返回结果时使用。</li></ol><p>因为ForkJoinTask比较复杂，并且其抽象方法比较多，故在日常使用时一般不会直接继承ForkJoinTask来实现自定义的任务类，而是通过继承ForkJoinTask两个子类RecursiveTask或者RecursiveAction<br>之一去实现自定义任务类，自定义任务类需要实现这些子类的compute()方法，该方法的执行流程一般如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 任务足够小</span><br><span class="line"> 直接返回结果</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> 分割成N个子任务</span><br><span class="line"> 依次调用每个子任务的fork方法执行子任务</span><br><span class="line"> 依次调用每个子任务的join方法，等待子任务完成，然后合并执行结果</span><br></pre></td></tr></table></figure><h3 id="ForkJoin框架使用实战"><a href="#ForkJoin框架使用实战" class="headerlink" title="ForkJoin框架使用实战"></a>ForkJoin框架使用实战</h3><p>假设需要计算0～100的累加求和，可以使用ForkJoin框架完成。首先需要设计一个可以递归执行的异步任务子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccumulateTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 累加的起始编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="comment">// 累加的结束编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccumulateTask</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 判断任务的规模：若规模小则可以直接计算</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">canCompute</span> <span class="operator">=</span> (end - start) &lt;= THRESHOLD;</span><br><span class="line">        <span class="comment">// 若任务已经足够小，则可以直接计算</span></span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="comment">// 直接计算并返回结果，Recursive结束</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行任务，计算&quot;</span> + start + <span class="string">&quot;到&quot;</span> + end + <span class="string">&quot;的和，结果是：&quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 任务过大，需要切割，Recursive 递归计算</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;切割任务：将&quot;</span> + start + <span class="string">&quot;到&quot;</span> + end + <span class="string">&quot;的和一分为二&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 切割成两个子任务</span></span><br><span class="line">            <span class="type">AccumulateTask</span> <span class="variable">lTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccumulateTask</span>(start, middle);</span><br><span class="line">            <span class="type">AccumulateTask</span> <span class="variable">rTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccumulateTask</span>(middle + <span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">// 依次调用每个子任务的fork()方法执行子任务</span></span><br><span class="line">            lTask.fork();</span><br><span class="line">            rTask.fork();</span><br><span class="line">            <span class="comment">// 等待子任务完成，依次调用每个子任务的join()方法合并执行结果</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">leftResult</span> <span class="operator">=</span> lTask.join();</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightResult</span> <span class="operator">=</span> rTask.join();</span><br><span class="line">            <span class="comment">// 合并子任务执行结果</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>自定义的异步任务子类AccumulateTask继承自RecursiveTask，每一次执行可以携带返回值。AccumulateTask通过THRESHOLD常量设置子任务分解的阈值，并在它的compute()方法中进行阈值判断，判断的逻辑如下：</p><ul><li>若当前的计算规模（这里为求和的数字个数）大于THRESHOLD，就当前子任务需要进一步分解，若当前的计算规模没有大于THRESHOLD，则直接计算（这里为求和）。</li><li>如果子任务可以直接执行，就进行求和操作，并返回结果。如果任务进行了分解，就需要等待所有的子任务执行完毕、然后对各个分解结果求和。如果一个任务分解为多个子任务（含两个），就依<br>次调用每个子任务的fork()方法执行子任务，然后依次调用每个子任务的join()方法合并执行结果。</li></ul><p>使用ForkJoinPool调度<code>AccumulateTask()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception, TimeoutException &#123;</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        <span class="comment">//创建一个累加任务，计算由1加到10</span></span><br><span class="line">        <span class="type">AccumulateTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccumulateTask</span>(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//执行任务</span></span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> result.get(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">//预期的结果为5050</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结果为：&quot;</span> + sum+<span class="string">&quot;,预期结果为5050&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">9</span>切割任务：将<span class="number">1</span>到<span class="number">10</span>的和一分为二</span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">9</span>切割任务：将<span class="number">1</span>到<span class="number">5</span>的和一分为二</span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">2</span>执行任务，计算<span class="number">1</span>到<span class="number">3</span>的和，结果是：<span class="number">6</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">4</span>执行任务，计算<span class="number">4</span>到<span class="number">5</span>的和，结果是：<span class="number">9</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">11</span>切割任务：将<span class="number">6</span>到<span class="number">10</span>的和一分为二</span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">2</span>执行任务，计算<span class="number">9</span>到<span class="number">10</span>的和，结果是：<span class="number">19</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">4</span>执行任务，计算<span class="number">6</span>到<span class="number">8</span>的和，结果是：<span class="number">21</span></span><br><span class="line">结果为：<span class="number">55</span></span><br></pre></td></tr></table></figure><h3 id="ForkJoin框架的核心API"><a href="#ForkJoin框架的核心API" class="headerlink" title="ForkJoin框架的核心API"></a>ForkJoin框架的核心API</h3><p>ForkJoin框架的核心是ForkJoinPool线程池。该线程池使用一个无锁的栈来管理空闲线程，如果一个工作线程暂时取不到可用的任务，则可能被挂起，而挂起的线程将被压入由ForkJoinPool维护的栈<br>中，待有新任务到来时，再从栈中唤醒这些线程。</p><blockquote><p>ForkJoinPool的构造器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ForkJoinPool</span><span class="params">(<span class="type">int</span> parallelism,</span></span><br><span class="line"><span class="params">                    ForkJoinWorkerThreadFactory factory,</span></span><br><span class="line"><span class="params">                    UncaughtExceptionHandler handler,</span></span><br><span class="line"><span class="params">                    <span class="type">boolean</span> asyncMode)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(checkParallelism(parallelism),</span><br><span class="line">         checkFactory(factory),</span><br><span class="line">         handler,</span><br><span class="line">         asyncMode ? FIFO_QUEUE : LIFO_QUEUE,</span><br><span class="line">         <span class="string">&quot;ForkJoinPool-&quot;</span> + nextPoolId() + <span class="string">&quot;-worker-&quot;</span>);</span><br><span class="line">    checkPermission();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对以上构造器的4个参数具体介绍如下：</p><ol><li><code>parallelism</code>：可并行级别<br>ForkJoin框架将依据parallelism设定的级别决定框架内并行执行的线程数量。并行的每一个任务都会有一个线程进行处理，但parallelism属性并不是ForkJoin框架中最大的线程数量，该属性和<br>ThreadPoolExecutor线程池中的corePoolSize、maximumPoolSize属性有区别，因为ForkJoinPool的结构和工作方式与ThreadPoolExecutor完全不一样。ForkJoin框架中可存在的线程数量和parallelism参数值并不是绝对关联的。</li><li><code>factory</code>：线程创建工厂<br>当ForkJoin框架创建一个新的线程时，同样会用到线程创建工厂。只不过这个线程工厂不再需要实现ThreadFactory接口，而是需要实现ForkJoinWorkerThreadFactory接口。后者是一个函数式接口，只需要实现一个名叫newThread()的方法。在ForkJoin框架中有一个默认的ForkJoinWorkerThreadFactory接口实现<code>DefaultForkJoinWorkerThreadFactory</code>。</li><li><code>handler</code>：异常捕获处理程序<br>当执行的任务中出现异常，并从任务中被抛出时，就会被handle捕获。</li><li><code>asyncMode</code>：异步模式<br>asyncMode参数表示任务是否为异步模式，其默认值为false。<strong>如果asyncMode为true，就表示子任务的执行遵循FIFO（先进先出）顺序，并且子任务不能被合并；如果asyncMode为false，就表示子任务的执行遵循LIFO（后进先出）顺序，并且子任务可以被合并。</strong>虽然从字面意思来看asyncMode是指异步模式，它并不是指ForkJoin框架的调度模式采用是同步模式还是异步模式工作，仅仅指任务的调度方式。</li></ol><p>ForkJoin框架中为每一个独立工作的线程准备了对应的待执行任务队列，这个任务队列是使用数组进行组合的双向队列。asyncMode模式的主要意思指的是待执行任务可以使用FIFO（先进先出）的工作模式，也可以使用LIFO（后进先出）的工作模式，工作模式为FIFO（先进先出）的任务适用于工作线程只负责运行异步事件，不需要合并结果的异步任务。</p><blockquote><p>ForkJoinPool无参数的、默认的构造器如下：</p></blockquote><p>该构造器的parallelism值为CPU核数；factory值为defaultForkJoinWorkerThreadFactory默认的线程工厂；异常捕获处理程序handler值为null，表示不进行异常处理；异步模式asyncMode<br>值为false，使用LIFO（后进先出）的、可以合并子任务的模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ForkJoinPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// //并行度，默认为CPU数，最小为1</span></span><br><span class="line">    <span class="built_in">this</span>(Math.min(MAX_CAP, Runtime.getRuntime().availableProcessors()),</span><br><span class="line">         defaultForkJoinWorkerThreadFactory, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ForkJoinPool的common通用池</p></blockquote><p>很多场景可以直接使用ForkJoinPool定义的common通用池，调用<code>ForkJoinPool.commonPool()</code>方法可以获取该ForkJoin线程池，该线程池通过makeCommonPool()来构造，具体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ForkJoinPool <span class="title function_">commonPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// assert common != null : &quot;static init error&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> common;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ForkJoinPool <span class="title function_">makeCommonPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">parallelism</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">ForkJoinWorkerThreadFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">UncaughtExceptionHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;  <span class="comment">// ignore exceptions in accessing/parsing properties</span></span><br><span class="line">        <span class="comment">//并行度</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">pp</span> <span class="operator">=</span> System.getProperty</span><br><span class="line">            (<span class="string">&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;</span>);</span><br><span class="line">        <span class="comment">//线程工厂 </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fp</span> <span class="operator">=</span> System.getProperty</span><br><span class="line">            (<span class="string">&quot;java.util.concurrent.ForkJoinPool.common.threadFactory&quot;</span>);</span><br><span class="line">        <span class="comment">//异常处理类</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">hp</span> <span class="operator">=</span> System.getProperty</span><br><span class="line">            (<span class="string">&quot;java.util.concurrent.ForkJoinPool.common.exceptionHandler&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="literal">null</span>)</span><br><span class="line">            parallelism = Integer.parseInt(pp);</span><br><span class="line">        <span class="keyword">if</span> (fp != <span class="literal">null</span>)</span><br><span class="line">            factory = ((ForkJoinWorkerThreadFactory)ClassLoader.</span><br><span class="line">                       getSystemClassLoader().loadClass(fp).newInstance());</span><br><span class="line">        <span class="keyword">if</span> (hp != <span class="literal">null</span>)</span><br><span class="line">            handler = ((UncaughtExceptionHandler)ClassLoader.</span><br><span class="line">                       getSystemClassLoader().loadClass(hp).newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() == <span class="literal">null</span>)</span><br><span class="line">            factory = <span class="keyword">new</span> <span class="title class_">DefaultCommonPoolForkJoinWorkerThreadFactory</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// use security-managed default</span></span><br><span class="line">            factory = <span class="keyword">new</span> <span class="title class_">InnocuousForkJoinWorkerThreadFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//默认并行度为cores-1</span></span><br><span class="line">    <span class="keyword">if</span> (parallelism &lt; <span class="number">0</span> &amp;&amp; <span class="comment">// default 1 less than #cores</span></span><br><span class="line">        (parallelism = Runtime.getRuntime().availableProcessors() - <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">        parallelism = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (parallelism &gt; MAX_CAP)</span><br><span class="line">        parallelism = MAX_CAP;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(parallelism, factory, handler, LIFO_QUEUE,</span><br><span class="line">                            <span class="string">&quot;ForkJoinPool.commonPool-worker-&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用common池的优点是可以<strong>通过指定系统属性的方式定义“并行度、线程工厂和异常处理类”</strong>，并且common池使用的是同步模式，也就是说可以支持任务合并。</p><ol><li><p>通过系统属性的方式指定parallelism值的示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;</span>, <span class="string">&quot;8&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过Java指令选项的方式指定parallelism值</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.util.concurrent.ForkJoinPool.common.parallelism=8</span><br></pre></td></tr></table></figure></li></ol><p>其他的参数值如异常处理程序handler，都可以通过以上两种方式指定。</p><blockquote><p>向ForkJoinPool线程池提交任务的方式</p></blockquote><ol><li>外部任务（External&#x2F;Submissions Task）提交向ForkJoinPool提交外部任务有三种方式：<ul><li>方式一是调用invoke()方法，该方法提交任务后线程会等待，等到任务计算完毕返回结果；</li><li>方式二是调用execute()方法提交一个任务来异步执行，无返回结果；</li><li>方式三是调用submit()方法提交一个任务，并且会返回一个ForkJoinTask实例，之后适当的时候可通过ForkJoinTask实例获取执行结果。</li></ul></li><li>子任务（Worker Task）提交<ul><li>向ForkJoinPool提交子任务的方法相对比较简单，由任务实例的fork()方法完成。当任务被分割之后，内部会调用ForkJoinPool.WorkQueue.push()方法直接把任务放到内部队列中等待<br>被执行。</li></ul></li></ol><h3 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h3><p>ForkJoinPool线程池的任务分为“外部任务”和“内部任务”，两种任务的存放位置不同：</p><ul><li>外部任务存放在ForkJoinPool的全局队列中。</li><li>子任务会作为“内部任务”放到内部队列中，ForkJoinPool池中的每个线程都维护着一个内部队列，用于存放这些“内部任务”。</li></ul><p>由于ForkJoinPool线程池通常有多个工作线程，与之相对应的就会有多个任务队列，这就会出现任务分配不均衡的问题：有的队列任务多，忙得不停，有的队列没有任务，一直空闲。那么有没有一种机<br>制帮忙将任务从繁忙的线程分摊给空闲的线程呢？答案是使用工作窃取算法。</p><p>工作窃取算法的核心思想是：工作线程自己的活干完了之后，会去看看别人有没有没干完的活，如果有就拿过来帮忙干。<strong>工作窃取算法的主要逻辑：每个线程拥有一个双端队列（本地队列），用于存放</strong><br><strong>需要执行的任务，当自己的队列没有任务时，可以从其他线程的任务队列中获得一个任务继续执行</strong></p><p>在实际进行任务窃取操作的时候，操作线程会进行其他线程的任务队列的扫描和任务的出队尝试。为什么说是尝试？因为完全有可能操作失败，主要原因是并行执行肯定涉及线程安全的问题，假如在窃取过程中该任务已经开始执行，那么任务的窃取操作就会失败。</p><p>如何尽量避免在任务窃取中发生的线程安全问题呢？一种简单的优化方法是：在线程自己的本地队列采取LIFO（后进先出）策略，窃取其他任务队列的任务时采用FIFO（先进先出）策略。简单来说，<strong>获取自己队列的任务时从头开始，窃取其他队列的任务时从尾开始</strong>。由于窃取的动作十分快速，会大量降低这种冲突，也是一种优化方式</p><p><img src="/p/b664c132/b663562e9fea9255c20ea63bf3faeac8.png"></p><h3 id="ForkJoin框架的原理"><a href="#ForkJoin框架的原理" class="headerlink" title="ForkJoin框架的原理"></a>ForkJoin框架的原理</h3><p>ForkJoin框架的核心原理大致如下：</p><ol><li>ForkJoin框架的线程池ForkJoinPool的任务分为“外部任务”和“内部任务”。</li><li>“外部任务”放在ForkJoinPool的全局队列中。</li><li>ForkJoinPool池中的每个线程都维护着一个任务队列，用于存放“内部任务”，线程切割任务得到的子任务会作为“内部任务”放到内部队列中。</li><li>当工作线程想要拿到子任务的计算结果时，先判断子任务有没有完成，如果没有完成，再判断子任务有没有被其他线程“窃取”，如果子任务没有被窃取，就由本线程来完成；一旦子任务被窃<br>取了，就去执行本线程“内部队列”的其他任务，或者扫描其他的任务队列并窃取任务。</li><li>当工作线程完成其“内部任务”，处于空闲状态时，就会扫描其他的任务队列窃取任务，尽可能不会阻塞等待。</li></ol><p><img src="/p/b664c132/d0640e8bca590f2ec26e4fa770aee8f6.png"></p><p>总之，ForkJoin线程在等待一个任务完成时，要么自己来完成这个任务，要么在其他线程窃取了这个任务的情况下，去执行其他任务，是不会阻塞等待的，从而避免资源浪费，除非所有任务队列都为<br>空。</p><p>工作窃取算法的优点如下：</p><ol><li>线程是不会因为等待某个子任务的执行或者没有内部任务要执行而被阻塞等待、挂起的，而是会扫描所有的队列窃取任务，直到所有队列都为空时才会被挂起。</li><li>ForkJoin框架为每个线程维护着一个内部任务队列以及一个全局的任务队列，而且任务队列都是双向队列，可从首尾两端来获取任务，极大地减少了竞争的可能性，提高并行的性能。</li></ol><p>ForkJoinPool适合需要“分而治之”的场景，特别是分治之后递归调用的函数，例如快速排序、二分搜索、大整数乘法、矩阵乘法、棋盘覆盖、归并排序、线性时间选择、汉诺塔问题等。ForkJoinPool<br>适合调度的任务为CPU密集型任务，如果任务存在I&#x2F;O操作、线程同步操作、sleep()睡眠等较长时间阻塞的情况，最好配合使用ManagedBlocker进行阻塞管理。总体来说，ForkJoinPool不适合进行<br>IO密集型、混合型的任务调度。</p><h2 id="Future模式"><a href="#Future模式" class="headerlink" title="Future模式"></a>Future模式</h2><p>Future模式是高并发设计与开发过程中常见的设计模式，它的核心思想是异步调用。对于Future模式来说，它不是立即返回我们所需要的数据，但是它会返回一个契约（或异步任务），将来我们可以凭借这个契约（或异步任务）获取需要的结果。</p><p>在进行传统的RPC（远程调用）时，同步调用RPC是一段耗时的过程。当客户端发出RPC请求后，服务端完成请求处理需要很长的一段时间才会返回，这个过程中客户端一直在等待，直到数据返回后，再进行其他任务的处理。</p><p>现有一个Client同步对三个Server分别进行一次RPC调用，假设一次远程调用的时间为500毫秒，则一个Client同步对三个Server分别进行一次RPC调用的总时间需要耗费1500毫秒。如果要节省这个总时间，可以使用Future模式对其进行改造，将同步的RPC调用改为异步并发的RPC调用。</p><p>Future模式的核心思想是异步调用，有点类似于异步的Ajax请求。当调用某个耗时方法时，可以不急于立刻获取结果，而是让被调<br>用者立刻返回一个契约（或异步任务），并且将耗时的方法放到另外的线程中执行，后续凭契约再去获取异步执行的结果。在具体的实现上，Future模式和异步回调模式既有区别，又有联系。<strong>Java的<code>Future</code>实现类并没有支持异步回调，仍然需要主动获取耗时任务的结果；而Java 8中的<code>CompletableFuture</code>组件实现了异步回调模式。</strong></p><script>var description="介绍在高并发场景常用的几种模式：线程安全的单例模式、ForkJoin模式、生产者-消费者模式、Master-Worker模式和Future模式。"</script>]]></content>
      
      
      <categories>
          
          <category> 多线程编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC容器类</title>
      <link href="/p/b8eea230.html"/>
      <url>/p/b8eea230.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="线程安全的同步容器类"><a href="#线程安全的同步容器类" class="headerlink" title="线程安全的同步容器类"></a>线程安全的同步容器类</h2><p>Java同步容器类通过Synchronized（内置锁）来实现同步的容器，比如<code>Vector</code>、<code>HashTable</code>以及<code>SynchronizedList</code>等容器。线程安全的同步容器类主要有Vector、Stack、HashTable等。另外，Java还提供了一组包装方法，将一个普通的基础容器包装成一个线程安全的同步容器。例如通过Collections.synchronized包装方法能将一个普通的SortedSet容器包装成一个线程安全的SortedSet同步容器。</p><h3 id="Collections-synchronize"><a href="#Collections-synchronize" class="headerlink" title="Collections.synchronize"></a>Collections.synchronize</h3><p><code>Collections.synchronized</code> 相关的包装方法是 Java 中用于将非线程安全的集合类转换为线程安全的集合类的工具方法，位于 <code>java.util.Collections</code> 类中。</p><p>以下是一些常见的 <code>Collections.synchronized</code> 包装方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedListExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建非线程安全的List</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 使用synchronizedList方法包装为线程安全的List</span></span><br><span class="line">        List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedSetExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建非线程安全的Set</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 使用synchronizedSet方法包装为线程安全的Set</span></span><br><span class="line">        Set&lt;String&gt; synchronizedSet = Collections.synchronizedSet(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedSortedSetIterationExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeSet&lt;Integer&gt; originalSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        originalSet.add(<span class="number">1</span>);</span><br><span class="line">        originalSet.add(<span class="number">2</span>);</span><br><span class="line">        originalSet.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        SortedSet&lt;Integer&gt; synchronizedSortedSet = Collections.synchronizedSortedSet(originalSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 错误的迭代方式（会导致并发问题）</span></span><br><span class="line">        <span class="comment">// for (Integer num : synchronizedSortedSet) &#123;</span></span><br><span class="line">        <span class="comment">//     System.out.println(num);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正确的迭代方式，手动加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (synchronizedSortedSet) &#123;</span><br><span class="line">            Iterator&lt;Integer&gt; iterator = synchronizedSortedSet.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                System.out.println(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedMapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建非线程安全的Map</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 使用synchronizedMap方法包装为线程安全的Map</span></span><br><span class="line">        Map&lt;String, Integer&gt; synchronizedMap = Collections.synchronizedMap(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedSortedMapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建非线程安全的SortedMap</span></span><br><span class="line">        SortedMap&lt;String, Integer&gt; sortedMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 使用synchronizedSortedMap方法包装为线程安全的SortedMap</span></span><br><span class="line">        SortedMap&lt;String, Integer&gt; synchronizedSortedMap = Collections.synchronizedSortedMap(sortedMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步容器面临的问题"><a href="#同步容器面临的问题" class="headerlink" title="同步容器面临的问题"></a>同步容器面临的问题</h3><p>可以通过查看Vector、HashTable、java.util.Collections同步包装内部类的源码，发现这些同步容器实现线程安全的方式是：在需要同步访问的方法上添加关键字synchronized。由于锁的存在，同步容器的操作在同一时刻只能有一个线程执行，这使得原本可以并行执行的操作变成了串行执行。比如多个线程对容器进行读写操作时，<strong>不能并发进行，会降低系统的吞吐量</strong>。</p><p>Collections 虽能把基础容器包装成线程安全的同步容器，但这类同步容器包装类在对元素进行迭代时，无法执行元素添加操作。</p><p>为了解决同步容器的性能问题，有了JUC高并发容器。</p><h2 id="JUC高并发容器"><a href="#JUC高并发容器" class="headerlink" title="JUC高并发容器"></a>JUC高并发容器</h2><p>JUC基于非阻塞算法（Lock Free，无锁编程）提供了一组高并发容器，包括高并发的List、Set、Queue、Map容器。</p><h3 id="什么是高并发容器"><a href="#什么是高并发容器" class="headerlink" title="什么是高并发容器"></a>什么是高并发容器</h3><p>JUC高并发容器是基于非阻塞算法（或者无锁编程算法）实现的容器类，无锁编程算法主要通过CAS（Compare And Swap）+Volatile组合实现，通过CAS保障操作的原子性，通过volatile保障变量内存的可见性。</p><p>无锁编程算法的主要优点如下：</p><ol><li>开销较小：不需要在内核态和用户态之间切换进程。</li><li>读写不互斥：只有写操作需要使用基于CAS机制的乐观锁，读读操作之间可以不用互斥。</li></ol><p>JUC包中提供了List、Set、Queue、Map各种类型的高并发容器，如<code>ConcurrentHashMap</code>、<code>ConcurrentSkipListMap</code>、<code>ConcurrentSkipListSet</code>、<code>CopyOnWriteArrayList</code>和<code>CopyOnWriteArraySet</code>。在性能上，ConcurrentHashMap通常优于同步的HashMap，ConcurrentSkipListMap通常优于同步的TreeMap。当读取和遍历操作远远大于列表的更新操作时，CopyOnWriteArrayList优于同步的ArrayList。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>JUC包中的高并发List主要有<code>CopyOnWriteArrayList</code>，对应的基础容器为ArrayList。</p><p><code>CopyOnWriteArrayList</code>相当于线程安全的ArrayList，它实现了List接口。在读多写少的场景中，其性能远远高于ArrayList的同步包装容器。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>JUC包中的Set主要有<code>CopyOnWriteArraySet</code>和<code>ConcurrentSkipListSe</code>t。</p><ul><li><p><code>CopyOnWriteArraySet</code>继承自AbstractSet类，对应的基础容器为<code>HashSet</code>。其内部组合了一个CopyOnWriteArrayList对象，它的核心操作是基于CopyOnWriteArrayList实现的。</p></li><li><p><code>ConcurrentSkipListSet</code>是线程安全的有序集合，对应的基础容器为<code>TreeSet</code>。它继承自AbstractSet，并实现了NavigableSet接口。<code>ConcurrentSkipListSet</code>是通过ConcurrentSkipListMap实现的。</p></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>JUC包中Map主要有<code>ConcurrentHashMap</code>和<code>ConcurrentSkipListMap</code>。</p><ul><li><p><code>ConcurrentHashMap</code>对应的基础容器为<code>HashMap</code>。JDK 6中的<code>ConcurrentHashMap</code>采用一种更加细粒度的“分段锁”加锁机制，JDK8中采用CAS无锁算法。</p></li><li><p><code>ConcurrentSkipListMap</code>对应的基础容器为<code>TreeMap</code>。其内部的Skip List（跳表）结构是一种可以代替平衡树的数据结构，默认是按照Key值升序的。</p></li></ul><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>JUC包中的Queue的实现类包括三类：单向队列、双向队列和阻塞队列。</p><ul><li><p><code>ConcurrentLinkedQueue</code>是基于列表实现的单向队列，按照FIFO（先进先出）原则对元素进行排序。新元素从队列尾部插入，而获取队列元素则需要从队列头部获取。</p></li><li><p><code>ConcurrentLinkedDeque</code>是基于链表的<strong>双向队列，但是该队列不允许null元素</strong>。作为双向队列，<code>ConcurrentLinkedDeque</code>可以当作“栈来使用，并且高效地支持并发环境。</p></li><li><p>除了提供普通的单向队列、双向队列外，JUC拓展了队列，增加了可阻塞的插入和获取等操作，提供了一组阻塞队列，具体如下：</p><ul><li><code>ArrayBlockingQueue</code>：基于数组实现的可阻塞的FIFO队列。</li><li><code>LinkedBlockingQueue</code>：基于链表实现的可阻塞的FIFO队列。</li><li><code>PriorityBlockingQueue</code>：按优先级排序的队列。</li><li><code>DelayQueue</code>：按照元素的Delay时间进行排序的队列。</li><li><code>SynchronousQueue</code>：无缓冲等待队列。</li></ul></li></ul><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>在很多应用场景中读操作常远超写操作，读操作不修改原有数据，每次读取都加锁是资源浪费，应允许多线程同时访问List内部数据（读操作线程安全）。写时复制（Copy On Write，COW）是计算机程序设计领域的优化策略，其核心思想为多个访问器访问资源时指向同一资源，若有修改器要修改该资源，系统会给修改器复制专用副本，其他访问器看到的资源不变且修改过程对它们透明，COW的主要优点是无修改器修改资源时不会创建副本，多个访问器可共享同一份资源。 </p><h3 id="CopyOnWriteArrayList的使用"><a href="#CopyOnWriteArrayList的使用" class="headerlink" title="CopyOnWriteArrayList的使用"></a>CopyOnWriteArrayList的使用</h3><p>前面讲到，Collections可以将基础容器包装为线程安全的同步容器，但是这些同步容器包装类在进行元素迭代时并不能进行元素添加操作。下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个普通的ArrayList</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;元素1&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;元素2&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;元素3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Collections将其包装为线程安全的同步容器</span></span><br><span class="line">        List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试迭代并添加元素，会抛出异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (String element : synchronizedList) &#123;</span><br><span class="line">                <span class="comment">// 这里尝试添加新元素，会导致异常</span></span><br><span class="line">                synchronizedList.add(<span class="string">&quot;新元素&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;出现异常: &quot;</span> + e);</span><br><span class="line">            <span class="comment">// 输出的异常信息通常为：java.util.ConcurrentModificationException</span></span><br><span class="line">            <span class="comment">// 表明在迭代过程中不允许进行这样的修改操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该如何解决此问题呢？可使用<code>CopyOnWriteArrayList</code>替代<code>Collections.synchronizedList</code>同步包装实例，具体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用Collections.synchronizedList包装的示例</span></span><br><span class="line">        List&lt;String&gt; synchronizedList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="comment">// 向同步列表中添加元素</span></span><br><span class="line">        synchronizedList.add(<span class="string">&quot;元素1&quot;</span>);</span><br><span class="line">        synchronizedList.add(<span class="string">&quot;元素2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在多线程环境下尝试迭代并修改（添加元素）</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Iterator&lt;String&gt; iterator = synchronizedList.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                    System.out.println(<span class="string">&quot;迭代元素: &quot;</span> + element);</span><br><span class="line">                    <span class="comment">// 这里尝试添加元素，会导致异常</span></span><br><span class="line">                    synchronizedList.add(<span class="string">&quot;新元素&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;使用Collections.synchronizedList出现异常: &quot;</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用CopyOnWriteArrayList的示例</span></span><br><span class="line">        CopyOnWriteArrayList&lt;String&gt; copyOnWriteArrayList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        copyOnWriteArrayList.add(<span class="string">&quot;元素A&quot;</span>);</span><br><span class="line">        copyOnWriteArrayList.add(<span class="string">&quot;元素B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在多线程环境下尝试迭代并修改（添加元素）</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            Iterator&lt;String&gt; iterator = copyOnWriteArrayList.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                System.out.println(<span class="string">&quot;迭代元素: &quot;</span> + element);</span><br><span class="line">                <span class="comment">// 使用CopyOnWriteArrayList可以在迭代时添加元素，不会出现异常</span></span><br><span class="line">                copyOnWriteArrayList.add(<span class="string">&quot;新元素&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待线程执行完毕</span></span><br><span class="line">            thread1.join();</span><br><span class="line">            thread2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Collections.synchronizedList最终元素个数: &quot;</span> + synchronizedList.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;CopyOnWriteArrayList最终元素个数: &quot;</span> + copyOnWriteArrayList.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CopyOnWriteArrayList的原理"><a href="#CopyOnWriteArrayList的原理" class="headerlink" title="CopyOnWriteArrayList的原理"></a>CopyOnWriteArrayList的原理</h3><p><strong>CopyOnWrite（写时复制）就是在修改器对一块内存进行修改时，不直接在原有内存块上进行写操作，而是将内存复制一份，在新的内存中进行写操作，写完之后，再将原来的指针（或者引用）指向新的内存，原来的内存被回收</strong>。</p><p>CopyOnWriteArrayList是写时复制思想的一种典型实现，其含有一个指向操作内存的内部指针array，而可变操作（add、set等）是在array数组的副本上进行的。当元素需要被修改或者增加时，并不直接在array指向的原有数组上操作，而是首先对array进行一次复制，将修改的内容写入复制的副本中。写完之后，再将内部指针array指向新的副本，这样就可以确保修改操作不会影响访问器的读取操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** 对所有的修改器方法进行保护，访问器方法并不需要保护 */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部维护的就是一个数组</span></span><br><span class="line">    <span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line">    <span class="comment">// 该数组被 volatile 修饰，能够保证数据的内存可见性。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取内部对象数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">     <span class="keyword">return</span> array;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置内部对象数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setArray</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">     array = a;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取操作"><a href="#读取操作" class="headerlink" title="读取操作"></a>读取操作</h3><p>访问器的读取操作没有任何同步控制和锁操作，理由是内部数组array不会发生修改，只会被另一个array替换，因此可以保证数据安<br>全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the array.  Non-private so as to also be accessible</span></span><br><span class="line"><span class="comment"> * from CopyOnWriteArraySet class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">get</span><span class="params">(Object[] a, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写入操作"><a href="#写入操作" class="headerlink" title="写入操作"></a>写入操作</h3><p>CopyOnWriteArrayList的写入操作add()方法<strong>在执行时加了独占锁以确保只能有一个线程进行写入操作</strong>，避免多线程写的时候会复制出多个副本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">  <span class="comment">//1. 使用Lock,保证写线程在同一时刻只有一个</span></span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//2. 获取旧数组引用</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 创建新的数组，并将旧数组的数据复制到新数组中</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 往新数组中添加新的数据</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 将旧数组引用指向新的数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>add()</code>操作可以看出，在每次进行添加操作时，<code>CopyOnWriteArrayList</code>底层都是<strong>重新复制一份数组，再往新的数组中添加新元素，待添加完了，再将新的array引用指向新的数组</strong>。当<code>add()</code>操作完成后，array的引用就已经指向另一个存储空间了。</p><p>既然每次添加元素的时候都会重新复制一份新的数组，那就带来了一个问题，就是增加了内存的开销<strong>，如果容器的写操作比较频繁，那么其开销就比较大</strong>。所以，在实际应用的时候，CopyOnWriteArrayList并不适合进行添加操作。但是在并发场景下，迭代操作比较频繁，CopyOnWriteArrayList就是一个不错的选择。</p><h3 id="迭代器实现"><a href="#迭代器实现" class="headerlink" title="迭代器实现"></a>迭代器实现</h3><p>CopyOnWriteArray有自己的迭代器，该迭代器不会检查修改状态，也无须检查状态。为什么呢？因为被迭代的array数组可以说是只读的，不会有其他线程能够修改它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">COWIterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">ListIterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">/** Snapshot of the array */</span></span><br><span class="line">    <span class="comment">/**对象数组的快照（snapshot）*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line">    <span class="comment">/** Index of element to be returned by subsequent call to next.  */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cursor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">COWIterator</span><span class="params">(Object[] elements, <span class="type">int</span> initialCursor)</span> &#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器的快照成员会在构造迭代器的时候使用<code>CopyOnWriteArrayList</code>的array成员去初始化，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取迭代器</span></span><br><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">COWIterator</span>&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回操作内存</span></span><br><span class="line"> <span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">     <span class="keyword">return</span> array;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="CopyOnWriteArrayList的优点"><a href="#CopyOnWriteArrayList的优点" class="headerlink" title="CopyOnWriteArrayList的优点"></a>CopyOnWriteArrayList的优点</h3><p><code>CopyOnWriteArrayList</code>有一个显著的优点，那就是读取、遍历操作不需要同步，速度会非常快。所以，<code>CopyOnWriteArrayList</code>适用于读操作多、写操作相对较少的场景（读多写少），比如可以在进行“黑名单”拦截时使用<code>CopyOnWriteArrayList</code>。</p><h3 id="CopyOnWriteArrayList和ReentrantReadWriteLock的比较"><a href="#CopyOnWriteArrayList和ReentrantReadWriteLock的比较" class="headerlink" title="CopyOnWriteArrayList和ReentrantReadWriteLock的比较"></a>CopyOnWriteArrayList和ReentrantReadWriteLock的比较</h3><p><code>CopyOnWriteArrayList</code>和<code>ReentrantReadWriteLock</code>读写锁的思想非常类似，即读读共享、写写互斥、读写互斥、写读互斥。但是前者相比后者的更进一步：为了将读取的性能发挥到极致，**<code>CopyOnWriteArrayList</code>读取是完全不用加锁的，而且写入也不会阻塞读取操作，只有写入和写入之间需要进行同步等待，读操作的性能得到大幅度提升**。</p><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>在多线程环境中，通过BlockingQueue（阻塞队列）可以很容易地实现多线程之间的数据共享和通信，比如在经典的“生产者”和“消费者”模型中，通过BlockingQueue可以完成一个高性能的实现版本。</p><h3 id="BlockingQueue的特点"><a href="#BlockingQueue的特点" class="headerlink" title="BlockingQueue的特点"></a>BlockingQueue的特点</h3><p>阻塞队列与普通队列（ArrayDeque等）之间的最大不同点在于阻塞队列提供了阻塞式的添加和删除方法。</p><ol><li><strong>阻塞添加</strong><ul><li>阻塞添加是指当阻塞队列元素已满时，队列会阻塞添加元素的线程，直到队列元素不满时，才重新唤醒线程执行元素添加操作。</li></ul></li><li><strong>阻塞删除</strong><ul><li>阻塞删除是指在队列元素为空时，删除队列元素的线程将被阻塞，直到队列不为空时，才重新唤醒删除线程，再执行删除操作。</li></ul></li></ol><h3 id="阻塞队列的常用方法"><a href="#阻塞队列的常用方法" class="headerlink" title="阻塞队列的常用方法"></a>阻塞队列的常用方法</h3><p>先来看看阻塞队列接口提供的主要方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Queue</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//将指定的元素添加到此队列的尾部</span></span><br><span class="line">    <span class="comment">//在成功时返回true，如果此队列已满，就抛出IllegalStateException</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//非阻塞式添加：将指定的元素添加到此队列的尾部（如果立即可行且不会超过该队列的容量）</span></span><br><span class="line">    <span class="comment">//如果该队列已满，就直接返回</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//限时阻塞式添加：将指定的元素添加到此队列的尾部</span></span><br><span class="line">    <span class="comment">//如果该队列已满，那么在到达指定的等待时间之前，添加线程会阻塞，等待可用的空间，该方法可中断</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞式添加：将指定的元素添加到此队列的尾部，如果该队列已满，就一直等待（阻塞）</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞式删除：获取并移除此队列的头部，如果没有元素就等待（阻塞）</span></span><br><span class="line">    <span class="comment">//直到有元素，将唤醒等待线程执行该操作</span></span><br><span class="line">    E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//非阻塞式删除：获取并移除此队列的头部，如果没有元素就直接返回null（空）</span></span><br><span class="line">    E <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//限时阻塞式删除:获取并移除此队列的头部，在指定的等待时间前一直等待获取元素，超过时间，方法将结束</span></span><br><span class="line">    E <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取但不移除此队列的头元素，没有则抛出异常</span></span><br><span class="line">    NoSuchElementException E <span class="title function_">element</span><span class="params">()</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取但不移除此队列的头元素，如果此队列为空，就返回null</span></span><br><span class="line">    E <span class="title function_">peek</span><span class="params">()</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//从此队列中移除指定元素，返回删除是否成功</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4个特征说明如下：</p><ol><li><strong>抛出异常</strong>: 如果试图的操作无法立即执行，就抛出一个异常。</li><li><strong>特殊值</strong>: 如果尝试的操作无法立即执行，就返回一个特定的值（通常是true&#x2F;false）。</li><li><strong>阻塞</strong>:如果尝试的操作无法立即执行，该方法的调用就会发生阻塞，直到能够执行。</li><li><strong>限时阻塞</strong>:如果尝试的操作无法立即执行，该方法的调用就会发生阻塞，直到能够执行，但等待时间不会超过设置的上限值。</li></ol><table><thead><tr><th>操作类型</th><th>抛出异常</th><th>特殊值</th><th>阻塞</th><th>限时阻塞</th></tr></thead><tbody><tr><td>添加</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>删除</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>获取元素</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><blockquote><p><strong>添加类方法</strong></p></blockquote><ul><li><code>add(E e)</code>：添加成功则返回true，失败就抛出IllegalStateException异常。</li><li><code>offer(E e)</code>：成功则返回true，如果此队列已满，就返回false。</li><li><code>put(E e)</code>：将元素添加至此队列的尾部，如果该队列已满，就一直阻塞。</li></ul><blockquote><p><strong>删除类方法</strong></p></blockquote><ul><li><code>poll()</code>：获取并移除此队列的头元素，若队列为空，则返回null。</li><li><code>take()</code>：获取并移除此队列的头元素，若没有元素，则一直阻塞。</li><li><code>remove(Object o)</code>：移除指定元素，成功则返回true，失败则返回false。</li></ul><blockquote><p><strong>获取元素类方法</strong></p></blockquote><ul><li><code>element()</code>：获取但不移除此队列的头元素，没有元素则抛出异常。</li><li><code>peek()</code>：获取但不移除此队列的头元素，若队列为空，则返回null。</li></ul><h3 id="常见的BlockingQueue"><a href="#常见的BlockingQueue" class="headerlink" title="常见的BlockingQueue"></a>常见的BlockingQueue</h3><p>在了解了BlockingQueue的主要方法后，接下来介绍一下BlockingQueue家族大致有哪些成员。BlockingQueue的实现类有<br>ArrayBlockingQueue、DelayQueue、LinkedBlockingDeque、PriorityBlockingQueue、SynchronousQueue等。</p><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>ArrayBlockingQueue是一个常用的阻塞队列，<strong>是基于数组实现的，其内部使用一个定长数组来存储元素</strong>。除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整型变量，分别标识着队列的头部和尾部在数组中的位置。</p><p>ArrayBlockingQueue的<strong>添加和删除操作共用同一个锁对象，由此意味着添加和删除无法并行运行</strong>，这点不同于LinkedBlockingQueue。ArrayBlockingQueue完全可以将添加和删除的锁分离，从而添加和删除操作完全并行。Doug Lea之所以没这样去做，是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧。</p><p>为什么ArrayBlockingQueue比LinkedBlockingQueue更加常用？前者在添加或删除元素时不会产生或销毁任何额外的Node（节点）实例，而后者会生成一个额外的Node实例。在长时间、高并发处理大批量数据的场景中，LinkedBlockingQueue产生的额外Node实例会加大系统的GC压力。</p><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue是基于链表的阻塞队列，其内部也维持着一个数据缓冲队列（该队列由一个链表构成）。<strong>LinkedBlockingQueue对于添加和删除元素分别采用了独立的锁来控制数据同步</strong>，这也意味着在高并发的情况下，生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p><p>需要注意的是，在新建一个LinkedBlockingQueue对象时，若没有指定其容量大小，则LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就已经被消耗殆尽了。</p><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取该元素。<strong>DelayQueue是一个没有大小限制的队列，因此往队列中添加数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</strong></p><p>DelayQueue的使用场景较少，但是相当巧妙，常见的例子是使用DelayQueue来管理一个超时未响应的连接队列。</p><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>基于优先级的阻塞队列和DelayQueue类似，<strong>PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者</strong>。在使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。</p><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么大家都在集市等待。相对于有缓冲的阻塞队列（如LinkedBlockingQueue）来说，<strong>SynchronousQueue少了中间缓冲区（如仓库）的环节</strong>。如果有仓库，生产者直接把产品批发给仓库，不需要关心仓库最终会将这些产品发给哪些消费者，由于仓库可以中转部分商品，总体来说有仓库进行生产和消费的吞吐量高一些。反过来说，又因为仓库的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低，所以<strong>对单个消息的响应要求高的场景可以使用SynchronousQueue</strong>。</p><p>声明一个SynchronousQueue有两种不同的方式：公平模式和非公平模式。公平模式的SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体现出整体的公平特征。非公平模式（默认情况）的SynchronousQueue采用非公平锁，同时配合一个LIFO堆栈（TransferStack内部实例）来管理多余的生产者和消费者。对于后一种模式，如果生产者和消费者的处理速度有差距，就很容易出现线程饥渴的情况，即可能出现某些生产者或者消费者的数据永远都得不到处理。</p><h2 id="ArrayBlockingQueue的基本使用"><a href="#ArrayBlockingQueue的基本使用" class="headerlink" title="ArrayBlockingQueue的基本使用"></a>ArrayBlockingQueue的基本使用</h2><p>下面通过ArrayBlockingQueue队列实现一个生产者-消费者的案例，通过该案例简单了解其使用方式和方法。具体的代码在前面的生<br>产者和消费者实现基础上进行迭代——Consumer（消费者）和Producer（生产者）通过ArrayBlockingQueue队列获取和添加元素。</p><ul><li>其中，消费者调用take()方法获取元素，当队列没有元素时就阻塞；</li><li>生产者调用put()方法添加元素，当队列满时就阻塞。</li></ul><p>通过这种方式便可以实现生产者-消费者模式，比直接使用等待唤醒机制或者Condition条件队列更加简单。</p><h3 id="实现生产者-消费者模式"><a href="#实现生产者-消费者模式" class="headerlink" title="实现生产者-消费者模式"></a>实现生产者-消费者模式</h3><p>DataBuffer（共享数据区）使用一个ArrayBlockingQueue用于缓存数据，具体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义共享数据区DataBuffer类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataBuffer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayBlockingQueue&lt;Integer&gt; buffer;  <span class="comment">// 使用Integer类型举例，可根据实际替换为其他类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataBuffer</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        buffer = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者调用的放入数据方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putData</span><span class="params">(<span class="type">int</span> data)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        buffer.put(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者调用的获取数据方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getData</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> buffer.take();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataBuffer dataBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(DataBuffer dataBuffer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dataBuffer = dataBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  <span class="comment">// 简单循环生产10个元素示例，可按需调整</span></span><br><span class="line">                dataBuffer.putData(i);</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者生产了元素: &quot;</span> + i);</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);  <span class="comment">// 模拟生产耗时，可按需调整时间间隔</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataBuffer dataBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(DataBuffer dataBuffer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dataBuffer = dataBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> dataBuffer.getData();</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者消费了元素: &quot;</span> + element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerWithDataBufferExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DataBuffer</span> <span class="variable">dataBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataBuffer</span>(<span class="number">5</span>);  <span class="comment">// 创建共享数据区，队列大小设置为5，可按需调整</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(dataBuffer));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(dataBuffer));</span><br><span class="line"></span><br><span class="line">        producerThread.start();</span><br><span class="line">        consumerThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            producerThread.join();</span><br><span class="line">            consumerThread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayBlockingQueue构造器"><a href="#ArrayBlockingQueue构造器" class="headerlink" title="ArrayBlockingQueue构造器"></a>ArrayBlockingQueue构造器</h3><p>创建公平与非公平阻塞队列的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认非公平阻塞队列</span></span><br><span class="line"><span class="type">ArrayBlockingQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(capacity);</span><br><span class="line"><span class="comment">//公平阻塞队列</span></span><br><span class="line"><span class="type">ArrayBlockingQueue</span> <span class="variable">queue1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(capacity,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>ArrayBlockingQueue的两个构造器的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只带一个capacity参数的构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(capacity, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//带两个参数的构造器</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">     <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity]; </span><br><span class="line">     lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(fair); <span class="comment">//根据fair参数构造公平锁/获取非公平锁</span></span><br><span class="line">     notEmpty = lock.newCondition(); <span class="comment">//有元素加入，队列为非空</span></span><br><span class="line">     notFull = lock.newCondition(); <span class="comment">//有元素被取出，队列为未满</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>ArrayBlockingQueue内部的阻塞队列是通过重入锁ReenterLock和Condition条件队列实现的，接下来看看其内部的成员变量</p><h3 id="ArrayBlockingQueue内部的成员变量"><a href="#ArrayBlockingQueue内部的成员变量" class="headerlink" title="ArrayBlockingQueue内部的成员变量"></a>ArrayBlockingQueue内部的成员变量</h3><p>ArrayBlockingQueue是一个基于数组（Array）实现的有界阻塞队列，内部成员变量如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayBlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储数据的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取、删除元素的索引，主要用于take、poll、peek、remove方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素的索引，主要用于 put、offer、add方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> putIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 控制并发访问的显式锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * notEmpty条件对象，用于通知take线程（消费队列），可执行删除操</span></span><br><span class="line"><span class="comment">     * 作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * notFull条件对象，用于通知put线程（生产队列），可执行添加操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">Itrs</span> <span class="variable">itrs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayBlockingQueue内部是通过数组对象items来存储所有的数据的，通过ReentrantLock类型的成员lock控制添加线程与删除线程的并<br>发访问。ArrayBlockingQueue使用等待条件对象notEmpty成员来存放或唤醒被阻塞的消费（take）线程，当数组对象items有元素时，告诉<br>take线程可以执行删除操作。同理，ArrayBlockingQueue使用等待条件对象notFull成员来存放或唤醒被阻塞的生产（put）线程，当队列<br>未满时，告诉put线程可以执行添加元素的操作。</p><p><strong>ArrayBlockingQueue的<code>takeIndex</code>成员为消费（或删除元素）的索引</strong>，标识的是下一个方法（take、poll、peek、remove）被调用时获<br>取数组元素的位置。**<code>putIndex</code>成员为生产（或添加元素）的索引**，代表下一种方法（put、offer、add）被调用时元素添加到数组中的位<br>置。</p><h3 id="add-方法的实现"><a href="#add-方法的实现" class="headerlink" title="add()方法的实现"></a>add()方法的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractQueue</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出，add()方法间接调用了offer()方法，如果offer()方法添加失败，那么add()将抛出IllegalStateException异常，如果offer()方法添加成功，那么add()返回true。</p><h3 id="offer-方法的实现"><a href="#offer-方法的实现" class="headerlink" title="offer()方法的实现"></a>offer()方法的实现</h3><p>offer()方法根据数组是否满了，分两种场景进行操作：</p><ul><li>如果数组满了，就直接释放锁，然后返回false。</li><li>如果数组没满，就将元素入队（加入数组），然后返回true。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayBlockingQueue</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    checkNotNull(e); <span class="comment">//检查元素是否为null</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == items.length) <span class="comment">//判断数组是否已满</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            enqueue(e); <span class="comment">//添加元素到队列</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="enqueue-方法的实现"><a href="#enqueue-方法的实现" class="headerlink" title="enqueue()方法的实现"></a>enqueue()方法的实现</h3><p>offer()调用了enqueue(E x)元素入队方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayBlockingQueue</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(E x)</span> &#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items; <span class="comment">//获取当前数组</span></span><br><span class="line">    items[putIndex] = x; <span class="comment">//通过putIndex索引对数组进行赋值</span></span><br><span class="line">    <span class="comment">//索引自增，如果已经是最后一个位置，重新设置 putIndex=0</span></span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++; <span class="comment">//队列中元素数量加1</span></span><br><span class="line">    notEmpty.signal(); <span class="comment">//唤醒调用take()方法的线程，执行元素获取操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，由于进入enqueue()方法意味着数组没满，因此enqueue()方法可以通过putIndex索引直接将元素添加到数组items中，然后调整putIndex索引值。其次，enqueue()完成尾部的插入后，将自己的元素个数成员count+1。最后，enqueue()通过调用notFull.notEmpty()唤醒一个消费（或删除）线程。</p><blockquote><p>这里大家可能会疑惑：当putIndex索引大小等于数组长度时，为什么需要将putIndex重新设置为0呢？</p></blockquote><p>这是因为获取元素时总是在队列头部（takeIndex索引）操作，添加元素总是在队列尾部（putIndex索引）操作，而ArrayBlockingQueue将内部数组作为环形队列使用，所以在更新后索引值与数组长度相等时需要进行校正，下一个值就需要从数组的第一个元素（索引值0）开始操作。</p><h3 id="阻塞式添加元素：put-方法的原理"><a href="#阻塞式添加元素：put-方法的原理" class="headerlink" title="阻塞式添加元素：put()方法的原理"></a>阻塞式添加元素：put()方法的原理</h3><p>首先来看阻塞式添加元素。在队列满而不能添加元素时，执行添加元素的线程会被阻塞。put()方法是一个阻塞的方法，如果队列元素已满，那么当前线程会被加入notFull条件对象的等待队列中，直到队列有空位置才会被唤醒执行添加操作。但如果队列没有满，就直接调用enqueue(e)方法将元素加入数组队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">//该方法可中断</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//当队列元素个数与数组长度相等时，无法添加元素</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            <span class="comment">//将当前调用线程挂起，添加到notFull条件队列中，等待被唤醒</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e); ;<span class="comment">//如果队列没有满，就直接添加</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面总结一下put()方法的添加操作流程。</p><ol><li>获取putLock锁。</li><li>如果队列已满，就被阻塞，put线程进入notFull的等待队列中排队，等待被唤醒。</li><li>如果队列未满，元素通过enqueue方法入队。</li><li>释放putLock锁。</li><li>当队列已满时，新到来的put线程将被添加到notFull的条件队列中进行阻塞等待</li></ol><h3 id="非阻塞式删除元素：poll-方法的原理"><a href="#非阻塞式删除元素：poll-方法的原理" class="headerlink" title="非阻塞式删除元素：poll()方法的原理"></a>非阻塞式删除元素：poll()方法的原理</h3><p>poll()方法删除获取此队列的头元素，若队列为空，则立即返回null。poll()方法的实现比较简单，其具体的删除操作委托给了<code>dequeue(E x)</code>元素出队方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//判断队列是否为null，不为null执行dequeue()方法，否则返回null</span></span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="literal">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dequeue-E-x-元素出队"><a href="#dequeue-E-x-元素出队" class="headerlink" title="dequeue(E x)元素出队"></a>dequeue(E x)元素出队</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除队列头元素并返回</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="comment">//拿到当前数组的数据</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="comment">//获取要删除的对象</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) items[takeIndex];</span><br><span class="line">    <span class="comment">//清空位置：将数组中的takeIndex索引位置设置为null</span></span><br><span class="line">    items[takeIndex] = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//takeIndex索引加1并判断是否与数组长度相等</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        <span class="comment">//如果相等就说明已到尽头，恢复为0</span></span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--; ;<span class="comment">//元素个数减1</span></span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//同时更新迭代器中的元素数据</span></span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    notFull.signal(); <span class="comment">//删除了元素说明队列有空位，唤醒notFull条件等待队列中的put线程，执行添加操作</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>进入dequeue()方法，意味着takeIndex位置有元素可以删除，反过来说，如果takeIndex位置没有元素，就不会进入此方法。所以，第一步是拿到takeIndex位置的元素。</li><li>将takeIndex位置后移（自增），移动到下一个位置，无论一个位置有没有元素都没有关系，总之移动之后的takeIndex新位置会是下一轮删除元素的位置。</li><li>如果takeIndex自增之后值为items.length，说明takeIndex的索引已到数组尽头，就将其值校正为0，表示下一次从头部开始删除元素，达到环形队列的效果。</li><li>删除了元素说明队列有空位，唤醒notFull条件等待队列中的一个put线程，执行添加操作。</li></ol><h3 id="阻塞式删除元素：take-方法的原理"><a href="#阻塞式删除元素：take-方法的原理" class="headerlink" title="阻塞式删除元素：take()方法的原理"></a>阻塞式删除元素：take()方法的原理</h3><p>take()方法是一个可阻塞、可中断的删除方法，主要做了两件事：</p><ul><li><p>如果队列没有数据，就将线程加入notEmpty等待队列并阻塞线程，一直到有生产者插入数据后通过notEmpty发出一个消息，notEmpty将从其等待队列唤醒一个消费（或者删除）节点，同时启动该消费线程。</p></li><li><p>如果队列有数据，就通过dequeue()执行元素的删除（或消费）操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从队列头部移除元素，队列没有元素就阻塞，可中断</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">//可中断</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果队列没有元素</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//执行阻塞操作</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue(); <span class="comment">//如果队列有元素就执行删除操作</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>take()方法其实很简单，有就删除，没有就阻塞。如果队列没有数据，就将线程加入notEmpty条件队列等待，如果有新的put线程添加了数据，那么put操作将会唤醒一个处于阻塞状态的take线程执行消费（或删除）操作</p><h3 id="peek-直接返回当前队列的头元素"><a href="#peek-直接返回当前队列的头元素" class="headerlink" title="peek()直接返回当前队列的头元素"></a>peek()直接返回当前队列的头元素</h3><p>peek()方法从takeIndex（头部位置）直接就可以获取最早被添加的元素，所以效率是比较高的，如果不存在就返回null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//直接返回当前队列的头元素，但不删除</span></span><br><span class="line">        <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// null when queue is empty</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> E <span class="title function_">itemAt</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) items[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>ConcurrentHashMap是一个常用的高并发容器类，也是一种线程安全的哈希表。<strong>Java 7以及之前版本中的ConcurrentHashMap使用Segment（分段锁）技术将数据分成一段一段存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问</strong>。</p><p>Java 8对其内部的存储结构进行了优化，使之在性能上有进一步的提升。ConcurrentHashMap和同步容器HashTable的主要区别在锁的类型和粒度上：<strong>HashTable实现同步是利用synchronized关键字进行锁定的，其实是针对整张哈希表进行锁定的，即每次锁住整张表让线程独占，虽然解决了线程安全问题，但是造成了巨大的资源浪费。</strong></p><h3 id="HashMap和HashTable的问题"><a href="#HashMap和HashTable的问题" class="headerlink" title="HashMap和HashTable的问题"></a>HashMap和HashTable的问题</h3><p>基础容器HashMap是线程不安全的，在多线程环境下，使用HashMap进行put操作时，可能会引起死循环，导致CPU利用率飙升，甚至接近100%，所以在高并发情况下是不能使用HashMap的。于是JDK提供了一个线程安全的Map——HashTable，HashTable虽然线程安全，但效率低下。HashTable和HashMap的实现原理几乎一样，区别有两点：<br>（1）HashTable不允许key和value为null。<br>（2）HashTable使用synchronized来保证线程安全，包含get()&#x2F;put()在内的所有相关需要进行同步执行的方法都加上了synchronized关键字，对这个Hash表进行锁定。</p><p>HashTable线程安全策略的代价非常大，这相当于给整个哈希表加了一把大锁。当一个线程访问HashTable的同步方法时，其他访问HashTable同步方法的线程就会进入阻塞或轮询状态。若有一个线程在调用put()方法添加元素，则其他线程不但不能调用put()方法添加元素，而且不能调用get()方法来获取元素，相当于将所有的操作串行化。所以，HashTable的效率非常低下。</p><h3 id="JDK-1-7版本ConcurrentHashMap的结构"><a href="#JDK-1-7版本ConcurrentHashMap的结构" class="headerlink" title="JDK 1.7版本ConcurrentHashMap的结构"></a>JDK 1.7版本ConcurrentHashMap的结构</h3><p>JDK 1.7的ConcurrentHashMap的锁机制基于粒度更小的分段锁，分段锁也是提升多并发程序性能的重要手段之一，和LongAdder一样，属于热点分散型的削峰手段。</p><p>分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，分段锁技术将Key分成一个一个小Segment存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。</p><p>ConcurrentHashMap的内部结构的层次关系为<code>ConcurrentHashMap→Segment[]→HashEntry[]</code>。这样设计的好处在于，每次访问的时候只需要将一个Segment锁定，而不需要将整个Map类型集合都锁定。</p><p><img src="/p/b8eea230/c6abf87759f8221e73f4aeff2a1a633d.png"></p><p>JDK 1.7中的ConcurrentHashMap由 Segment 数组结构和 HashEntry 数组构成的。一个ConcurrentHashMap中包含一个Segment数组，一个Segment中包含一个HashEntry数组，每个元素是一个链表结构（一个Hash表的桶）。</p><p>Segment 是一种可重入的锁 ReentrantLock，HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap 类似，是一种数组和链表结构，一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。</p><blockquote><p>ConcurrentHashMap 读写过程如下：</p></blockquote><ul><li><strong>get 方法</strong><ol><li>为输入的 Key 做 Hash 运算，得到 hash 值。</li><li>通过 hash 值，定位到对应的 Segment 对象</li><li>再次通过 hash 值，定位到 Segment 当中数组的具体位置。</li></ol></li><li><strong>put 方法</strong><ol><li>为输入的 Key 做 Hash 运算，得到 hash 值。</li><li>通过 hash 值，定位到对应的 Segment 对象</li><li>获取可重入锁</li><li>再次通过 hash 值，定位到 Segment 当中数组的具体位置。</li><li>插入或覆盖 HashEntry 对象。</li><li>释放锁。</li></ol></li></ul><p>单一的 Segment 结构如下：</p><p><img src="/p/b8eea230/949955df304a91c4ada2eb936b159b52.png"></p><p>像这样的 Segment 对象，在 ConcurrentHashMap 集合中有多少个呢？有 2 的 N 次方个，共同保存在一个名为 segments 的数组当中。 因此整个 ConcurrentHashMap 的结构如下：</p><p><img src="/p/b8eea230/fd89686ebae9eefe5802127ab0fb8492.png"></p><p>可以说，ConcurrentHashMap 是一个二级哈希表。在一个总的哈希表下面，有若干个子哈希表。</p><ul><li><p>Case1：不同 Segment 的并发写入（可以并发执行）</p><p><img src="/p/b8eea230/3cb852e1ce6418450e45431e9bd88518.png"></p></li><li><p>Case2：同一 Segment 的一写一读（可以并发执行）</p><p><img src="/p/b8eea230/b4bc052347c61260977067e51104a0c2.png"></p></li><li><p>Case3：同一 Segment 的并发写入</p><p><img src="/p/b8eea230/afbf2f115face69c655cc74bb8ed3493.png"></p></li></ul><p><strong>Segment 的写入是需要上锁的，因此对同一 Segment 的并发写入会被阻塞</strong>。由此可见，ConcurrentHashMap 中每个 Segment 各自持有一把锁。在保证线程安全的同时降低了锁的粒度，让并发操作效率更高。</p><h2 id="1-7版本ConcurrentHashMap的核心原理"><a href="#1-7版本ConcurrentHashMap的核心原理" class="headerlink" title="1.7版本ConcurrentHashMap的核心原理"></a>1.7版本ConcurrentHashMap的核心原理</h2><h3 id="ConcurrentHashMap类"><a href="#ConcurrentHashMap类" class="headerlink" title="ConcurrentHashMap类"></a>ConcurrentHashMap类</h3><p>ConcurrentHashMap类的核心源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">ConcurrentMap</span>&lt;K, V&gt;, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希映射表的默认初始容量为16，即初始默认为16个桶</span></span><br><span class="line"><span class="comment">     * 在构造器中没有指定这个参数时，使用本参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希映射表的默认装载因子为0.75，该值是table中包含的</span></span><br><span class="line"><span class="comment">     * HashEntry元素的个数与</span></span><br><span class="line"><span class="comment">     * table数组长度的比值，当table中包含的HashEntry元素的个数超过</span></span><br><span class="line"><span class="comment">     * 了table数组的长度与装载因子的乘积时， 将触发扩容操作</span></span><br><span class="line"><span class="comment">     * 如果哈希在构造函数中没有指定这个参数，就使用本参数的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分段锁的最小数量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_SEGMENT_TABLE_CAPACITY</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分段锁的最大数量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SEGMENTS</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁前的重试次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RETRIES_BEFORE_LOCK</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表的默认并发级别为16，该值表示当前更新线程的估计数</span></span><br><span class="line"><span class="comment">     * 在构造器中没有指定这个参数时，使用本参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * segments 的掩码值</span></span><br><span class="line"><span class="comment">     * key 的哈希码的高位用来选择具体的 segment</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> segmentMask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 偏移量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> segmentShift;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由 Segment 对象组成的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K, V&gt;[] segments;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个带有指定初始容量、加载因子和并发级别的新的空映射</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找最佳匹配参数（不小于给定参数最接近的 2 次幂）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sshift</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ssize</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">            ++sshift;</span><br><span class="line">            ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        segmentShift = <span class="number">32</span> - sshift; <span class="comment">// 偏移量值</span></span><br><span class="line">        segmentMask = ssize - <span class="number">1</span>; <span class="comment">// 掩码值</span></span><br><span class="line">        <span class="built_in">this</span>.segments = Segment.newArray(ssize); <span class="comment">// 创建数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> initialCapacity / ssize;</span><br><span class="line">        <span class="keyword">if</span> (c * ssize &lt; initialCapacity) ++c;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cap &lt; c) cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依次遍历每个数组元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.segments.length; ++i)</span><br><span class="line">            <span class="comment">// 初始化每个数组元素引用的 Segment 对象</span></span><br><span class="line">            <span class="built_in">this</span>.segments[i] = <span class="keyword">new</span> <span class="title class_">Segment</span>&lt;K, V&gt;(cap, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个带有默认初始容量 (16)、默认加载因子 (0.75) 和 默认并</span></span><br><span class="line"><span class="comment">     * 发级别 (16)的</span></span><br><span class="line"><span class="comment">     * 空哈希映射表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用三个默认参数调用上面重载的构造器来创建空哈希映射表</span></span><br><span class="line">        <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Segment类"><a href="#Segment类" class="headerlink" title="Segment类"></a>Segment类</h3><p>每个Segment实例用来守护其内部table成员对象，table是一个由HashEntry实例构成的数组，其每个元素就是哈希映射表的一个桶。</p><p>每个Segment实例都有一个count来表示该分段包含的HashEntry“Key-Value对”总数。具体来说，count变量是一个计数器，它表示每个Segment实例管理的table数组（若干个HashEntry组成的链表）包含的HashEntry实例的个数。之所以在每个Segment实例中包含一个计数器，而不是在ConcurrentHashMap中使用全局的计数器，是为了避免出现“全局热点”而影响并发性。</p><p>Segment类的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在本 segment范围内包含的HashEntry 元素的个数</span></span><br><span class="line"><span class="comment">     * 该变量被声明为 volatile 型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * table 被更新的次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当table中包含的HashEntry元素的个数超过本变量值时，触发table的再哈希</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * table 是由 HashEntry 实例组成的数组</span></span><br><span class="line"><span class="comment">     * 如果HashEntry实例的哈希值发生碰撞，碰撞的HashEntry实例就以</span></span><br><span class="line"><span class="comment">     * 链表的形式链接成一个链表</span></span><br><span class="line"><span class="comment">     * table 数组的数组成员代表哈希映射表的一个桶</span></span><br><span class="line"><span class="comment">     * 每个 table 守护整个 ConcurrentHashMap 包含桶总数的一部分</span></span><br><span class="line"><span class="comment">     * 若并发级别为 16，table 则守护 ConcurrentHashMap 包含的桶</span></span><br><span class="line"><span class="comment">     * 总数的 1/16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K, V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 装载因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    Segment(<span class="type">int</span> initialCapacity, <span class="type">float</span> lf) &#123;</span><br><span class="line">        loadFactor = lf;</span><br><span class="line">        setTable(HashEntry.&lt;K, V&gt;newArray(initialCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置table引用到这个新生成的 HashEntry 数组</span></span><br><span class="line"><span class="comment">     * 只能在持有锁或构造器中调用本方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setTable</span><span class="params">(HashEntry&lt;K, V&gt;[] newTable)</span> &#123;</span><br><span class="line">        <span class="comment">// 计算临界阈值为新数组的长度与装载因子的乘积</span></span><br><span class="line">        threshold = (<span class="type">int</span>) (newTable.length * loadFactor);</span><br><span class="line">        table = newTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key的哈希值找到 table 中对应的那个桶（table 数组的某个</span></span><br><span class="line"><span class="comment">     * 数组成员）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HashEntry&lt;K, V&gt; <span class="title function_">getFirst</span><span class="params">(<span class="type">int</span> hash)</span> &#123;</span><br><span class="line">        HashEntry&lt;K, V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 把哈希值与table数组长度减1的值相“与”得到哈希值对应的table 数组的下标</span></span><br><span class="line">        <span class="comment">// 然后返回 table 数组中此下标对应的 HashEntry 元素</span></span><br><span class="line">        <span class="keyword">return</span> tab[hash &amp; (tab.length - <span class="number">1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashEntry"><a href="#HashEntry" class="headerlink" title="HashEntry"></a>HashEntry</h3><p>HashEntry用来封装哈希映射表中的“Key-Value对”。在HashEntry类中，key、hash和next字段都被声明为final型，value字段被声明为volatile型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HashEntry</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> K key; <span class="comment">// 声明 key 为final 型</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash; <span class="comment">// 声明 hash 为final 型</span></span><br><span class="line">    <span class="keyword">volatile</span> V value; <span class="comment">// 声明 value 为volatile 型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> HashEntry&lt;K, V&gt; next; <span class="comment">// 声明 next 为final 型</span></span><br><span class="line"></span><br><span class="line">    HashEntry(K key, <span class="type">int</span> hash, HashEntry&lt;K, V&gt; next, V value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.hash = hash;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ConcurrentHashMap中，哈希时如果产生“碰撞”，将采用“分离链接法”来处理：把“碰撞”的HashEntry对象链接成一个链表，形成一个桶。由于HashEntry的next字段为final型，因此新节点只能在链表的表头处插入。</p><blockquote><p>注意：由于只能在表头插入，因此链表中节点的顺序和插入的顺序相反。</p></blockquote><h3 id="ConcurrentHashMap的get操作"><a href="#ConcurrentHashMap的get操作" class="headerlink" title="ConcurrentHashMap的get操作"></a>ConcurrentHashMap的get操作</h3><p>从结构上我们可以看到Segment类似于一个小型的HashMap，ConcurrentHashMap就是HashMap集合。接下来就来看一下get操作：</p><h2 id="1-8版本ConcurrentHashMap的结构"><a href="#1-8版本ConcurrentHashMap的结构" class="headerlink" title="1.8版本ConcurrentHashMap的结构"></a>1.8版本ConcurrentHashMap的结构</h2><p>在JDK 1.8中，ConcurrentHashMap已经抛弃了Segment分段锁机制，存储结构采用数组+链表或者红黑树的组合方式，利用CAS+Synchronized来保证并发更新的安全。</p><h3 id="ConcurrentHashMap的内部结构示例"><a href="#ConcurrentHashMap的内部结构示例" class="headerlink" title="ConcurrentHashMap的内部结构示例"></a>ConcurrentHashMap的内部结构示例</h3><p>ConcurrentHashMap实例的内部结构示例如图:</p><p><img src="/p/b8eea230/07593be8bb45e89a9a26ccb70d2dbd5b.png"></p><h3 id="ConcurrentHashMap的成员属性"><a href="#ConcurrentHashMap的成员属性" class="headerlink" title="ConcurrentHashMap的成员属性"></a>ConcurrentHashMap的成员属性</h3><p>JDK 1.8版本ConcurrentHashMap的主要成员属性大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">ConcurrentMap</span>&lt;K,V&gt;, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 常量：表示正在转移</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOVED</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 常量：表示已经转换成树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEBIN</span> <span class="operator">=</span> -<span class="number">2</span>; </span><br><span class="line">    <span class="comment">// 常量：hash for transient reservations</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESERVED</span> <span class="operator">=</span> -<span class="number">3</span>; </span><br><span class="line">    <span class="comment">// 常量：usable bits of normal node hash</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_BITS</span> <span class="operator">=</span> <span class="number">0x7fffffff</span>; </span><br><span class="line">    <span class="comment">//数组，用来保存元素</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="comment">//转移时用的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用来控制表初始化和扩容的控制属性</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对以上清单中的重要属性介绍如下：</p><ul><li><code>table</code> 用于保存添加到哈希表中的桶。</li><li><code>DEFAULT_CAPACITY</code>: table的默认长度。默认初期长度为16，在第一次添加元素时，会将table初始化成16个元素的数组。</li><li><code>MIN_TREEIFY_CAPACITY</code>: 链式桶转成红黑树桶的阈值。在增加“Key-Value对”时，当链表长度大于该值时，将链表转换成红黑树。</li><li><code>UNTREEIFY_THRESHOLD</code>: 红黑树桶还原回链式桶的阈值，也就是红黑树转为链表的阈值，当在容量变动时重新计算存储位置后，当原有的红黑树内节点数量小于6时，将红黑树转换成链表。</li><li><code>MIN_TREEIFY_CAPACITY</code>: 链式桶转换成红黑树桶还有一个要求，table的容量达到最小树形化容量的阈值，只有当哈希表中的table容量大于该值时，才允许树将链表转换成红黑树的操作。否则，尽管单个桶内的元素太多，仍然选择直接扩容，而不是将桶树形化。</li><li><code>sizeCtl</code>: sizeCtl用来控制table的初始化和扩容操作的过程，其值大致如下：<ul><li><code>-1</code>代表table正在初始化，其他线程应该交出CPU时间片。</li><li><code>-N</code>表示有N-1个线程正在进行扩容操作，严格来说，当其为负数时，只用到其低16位，如果其低16位数值为M，此时有M-1个线程进行扩容。</li><li>大于0分两种情况：如果table未初始化，sizeCtl表示table需要初始化的大小；如果table初始化完成，sizeCtl表示table的容量，默认是table大小的0.75倍。</li><li>涉及修改sizeCtl的方法有5个：<ul><li><code>initTable()</code>:  初始化哈希表时，涉及sizeCtl的修改。</li><li><code>addCount()</code>: 增加容量时，涉及sizeCtl的修改。</li><li><code>tryPresize()</code>: ConcurrentHashMap扩容方法之一。</li><li><code>transfer()</code>: table数据转移到nextTable。扩容操作的核心在于数据的转移，把旧数组中的数据迁移到新的数组。ConcurrentHashMap精华的部分是它可以利用多线程来进行协同扩容，简单来说，它把table数组当作多个线程之间共享的任务队列，然后通过维护一个指针来划分每个线程锁负责的区间，每个线程通过区间逆向遍历来实现扩容，一个已经迁移完的Bucket会被替换为一个ForwardingNode节点，标记当前Bucket已经被其他线程迁移完了。</li><li><code>helpTransfer()</code>: ConcurrentHashMap鬼斧神工，并发添加元素时，如果正在扩容，其他线程会帮助扩容，也就是多线程扩容。</li></ul></li></ul></li></ul><h3 id="ConcurrentHashMap的数组扩容"><a href="#ConcurrentHashMap的数组扩容" class="headerlink" title="ConcurrentHashMap的数组扩容"></a>ConcurrentHashMap的数组扩容</h3><p>JDK 1.8版本的ConcurrentHashMap中通过一个<code>Node&lt;K,V&gt;[]</code> 数组 table来保存添加到哈希表中的桶，而在同一个Bucket位置是通过链表和红黑树的形式来保存的。但是数组table是懒加载的，只有在第一次添加元素的时候才会初始化</p><p>第一次添加元素时，默认初期长度为16，当往table中继续添加元素时，通过Hash值跟数组长度取余来决定放在数组的哪个Bucket位置，如果出现放在同一个位置，就优先以链表的形式存放，在同一个位置的个数达到了8个以上，如果数组的长度还小于64，就会扩容数组。如果数组的长度大于等于64，就会将该节点的链表转换成树。</p><p>通过扩容数组的方式来把这些节点分散开。然后将这些元素复制到扩容后的新数组中，同一个Bucket中的元素通过Hash值的数组长度位来重新确定位置，可能还是放在原来的位置，也可能放到新的位置。</p><p>而且，在扩容完成之后，如果之前某个节点是树，但是现在该节点的“Key-Value对”数又小于等于6个，就会将该树转为链表。</p><p>什么时候扩容呢？当前容量超过阈值，也就是链表中的元素个数超过默认设定（8个）时，如果数组table的大小还未超过64，此时就<br>进行数组的扩容，如果超过就将链表转化成红黑树。</p><h3 id="ConcurrentHashMap-的内部类"><a href="#ConcurrentHashMap-的内部类" class="headerlink" title="ConcurrentHashMap 的内部类"></a>ConcurrentHashMap 的内部类</h3><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p>Node 类实现了 Map.Entry 接口，主要存放 key-value 对，并且具有 next 域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外可以看出很多属性都是用 <code>volatile 关键字</code>修饰的，也是为了保证内存可见性。</p><h4 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h4><p>树节点，继承于承载数据的 Node 类。红黑树的操作是针对 TreeBin 类的，从该类的注释也可以看出，TreeBin 是对 TreeNode 的再一次封装，下面会提到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * Nodes <span class="keyword">for</span> use in TreeBins</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="type">boolean</span> red;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TreeBin"><a href="#TreeBin" class="headerlink" title="TreeBin"></a>TreeBin</h4><p>这个类并不负责用户的 key、value 信息，而是封装了很多 TreeNode 节点。实际的 ConcurrentHashMap “数组”中，存放的都是 TreeBin 对象，而不是 TreeNode 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeBin</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; root;</span><br><span class="line">        <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> lockState;</span><br><span class="line">        <span class="comment">// values for lockState</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WRITER</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WAITER</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">READER</span> <span class="operator">=</span> <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a>ForwardingNode</h4><p>在扩容时会出现的特殊节点，其 key、value、hash 全部为 null。并拥有 nextTable 引用的新 table 数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="built_in">super</span>(MOVED, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">   .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put-方法源码"><a href="#put-方法源码" class="headerlink" title="put()方法源码"></a>put()方法源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//自旋：并发情况下，也可以保障安全添加成功</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//第一次添加，先初始化node数组</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//计算出table[i]无节点，创建节点</span></span><br><span class="line"> <span class="comment">//使用Unsafe.compareAndSwapObject 原子操作table[i]位置</span></span><br><span class="line"><span class="comment">//如果为null，就添加新建的node节点，跳出循环</span></span><br><span class="line"> <span class="comment">//反之，再循环进入执行添加操作</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//如果当前处于转移状态，返回新的tab内部表，然后进入循环执行添加操作</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//在链表或红黑树中追加节点</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//使用synchronized 对 f 对象加锁</span></span><br><span class="line">            <span class="comment">// f = tabAt(tab, i = (n - 1) &amp; hash) ：table[i] 的node对象(桶)</span></span><br><span class="line"><span class="comment">//注意：这里没用ReentrantLock，而是使用synchronized 进行同步</span></span><br><span class="line"> <span class="comment">//在争用不激烈的场景中，synchronized 的性能和ReentrantLock不相上下</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//在红黑树上追加节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//节点数大于临界值，转换成红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从put()源码可以看到，JDK 1.8版本在使用CAS自旋完成桶的设置时，使用synchronized内置锁保证桶内并发操作的线程安全。尽管对同一个Map操作的线程争用会非常激烈，但是在同一个桶内的线程争用<br>通常不会很激烈，所以使用CAS自旋（简单轻量级锁）、synchronized偏向锁或轻量级锁不会降低ConcurrentHashMap的性能。为什么不用ReentrantLock显式锁呢？如果为每一个桶都创建一个ReentrantLock<br>实例，就会带来大量的内存消耗，反过来，使用CAS自旋（简单轻量级锁）、synchronized偏向锁或轻量级锁，内存消耗的增加会微乎其微。</p><h2 id="ConcurrentHashMap-的字段"><a href="#ConcurrentHashMap-的字段" class="headerlink" title="ConcurrentHashMap 的字段"></a>ConcurrentHashMap 的字段</h2><p>1、<strong>table</strong>，<code>volatile Node&lt;K,V&gt;[] table</code>:</p><p>装载 Node 的数组，作为 ConcurrentHashMap 的底层容器，采用懒加载的方式，直到第一次插入数据的时候才会进行初始化操作，数组的大小总是为 2 的幂次方，讲 HashMap 的时候讲过。</p><p>2、<strong>nextTable</strong>，<code>volatile Node&lt;K,V&gt;[] nextTable</code></p><p>扩容时使用，平时为 null，只有在扩容的时候才为非 null</p><p>3、<strong>sizeCtl</strong>，<code>volatile int sizeCtl</code></p><p>该属性用来控制 table 数组的大小，根据是否初始化和是否正在扩容有几种情况：</p><ul><li><strong>当值为负数时：</strong> 如果为-1 表示正在初始化，如果为 -N 则表示当前正有 N-1 个线程进行扩容操作；</li><li><strong>当值为正数时：</strong> 如果当前数组为 null 的话表示 table 在初始化过程中，sizeCtl 表示为需要新建数组的长度；若已经初始化了，表示当前数据容器（table 数组）可用容量，也可以理解成临界值（插入节点数超过了该临界值就需要扩容），具体指为数组的长度 n 乘以 加载因子 loadFactor；</li><li>当值为 0 时，即数组长度为默认初始值。</li></ul><p>4、<code>sun.misc.Unsafe U</code></p><p>在 ConcurrentHashMap 的实现中，可以看到用了大量的 <code>U.compareAndSwapXXXX</code> 方法去修改 ConcurrentHashMap 的一些属性。</p><p>这些方法实际上是利用了CAS 算法用于保证线程安全性，这是一种乐观策略：假设每一次操作都不会产生冲突，当且仅当冲突发生的时候再去尝试。</p><p>CAS 操作依赖于现代处理器指令集，通过底层的<strong>CMPXCHG</strong>指令实现。<code>CAS(V,O,N)</code>核心思想为：<strong>若当前变量实际值 V 与期望的旧值 O 相同，则表明该变量没被其他线程进行修改，因此可以安全的将新值 N 赋值给变量；若当前变量实际值 V 与期望的旧值 O 不相同，则表明该变量已经被其他线程做了处理，此时将新值 N 赋给变量操作就是不安全的，在进行重试</strong>。</p><p>在并发容器中，CAS 是通过<code>sun.misc.Unsafe</code>类实现的，该类提供了一些可以直接操控内存和线程的底层操作，可以理解为 Java 中的“指针”。该成员变量的获取是在静态代码块中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">.......</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap-的内部类-1"><a href="#ConcurrentHashMap-的内部类-1" class="headerlink" title="ConcurrentHashMap 的内部类"></a>ConcurrentHashMap 的内部类</h2><h3 id="1、Node"><a href="#1、Node" class="headerlink" title="1、Node"></a>1、Node</h3><p>Node 类实现了 Map.Entry 接口，主要存放 key-value 对，并且具有 next 域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外可以看出很多属性都是用 volatile 关键字</p><h3 id="2、TreeNode"><a href="#2、TreeNode" class="headerlink" title="2、TreeNode"></a>2、TreeNode</h3><p>树节点，继承于承载数据的 Node 类。红黑树的操作是针对 TreeBin 类的，从该类的注释也可以看出，TreeBin 是对 TreeNode 的再一次封装，下面会提到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * Nodes <span class="keyword">for</span> use in TreeBins</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="type">boolean</span> red;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、TreeBin"><a href="#3、TreeBin" class="headerlink" title="3、TreeBin"></a>3、TreeBin</h3><p>这个类并不负责用户的 key、value 信息，而是封装了很多 TreeNode 节点。实际的 ConcurrentHashMap “数组”中，存放的都是 TreeBin 对象，而不是 TreeNode 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeBin</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; root;</span><br><span class="line">        <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> lockState;</span><br><span class="line">        <span class="comment">// values for lockState</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WRITER</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WAITER</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">READER</span> <span class="operator">=</span> <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、ForwardingNode"><a href="#4、ForwardingNode" class="headerlink" title="4、ForwardingNode"></a>4、ForwardingNode</h3><p>在扩容时会出现的特殊节点，其 key、value、hash 全部为 null。并拥有 nextTable 引用的新 table 数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="built_in">super</span>(MOVED, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">   .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap-的-CAS"><a href="#ConcurrentHashMap-的-CAS" class="headerlink" title="ConcurrentHashMap 的 CAS"></a>ConcurrentHashMap 的 CAS</h2><p>ConcurrentHashMap 会大量使用 CAS 来修改它的属性和进行一些操作。因此，在理解 ConcurrentHashMap 的方法前，我们需要了解几个常用的利用 CAS 算法来保障线程安全的操作。</p><h3 id="1、tabAt"><a href="#1、tabAt" class="headerlink" title="1、tabAt"></a>1、tabAt</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="title function_">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法用来获取 table 数组中索引为 i 的 Node 元素。</p><h3 id="2、casTabAt"><a href="#2、casTabAt" class="headerlink" title="2、casTabAt"></a>2、casTabAt</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i,</span></span><br><span class="line"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 CAS 操作设置 table 数组中索引为 i 的元素</p><h3 id="3、setTabAt"><a href="#3、setTabAt" class="headerlink" title="3、setTabAt"></a>3、setTabAt</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title function_">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法用来设置 table 数组中索引为 i 的元素</p><h2 id="ConcurrentHashMap-的方法"><a href="#ConcurrentHashMap-的方法" class="headerlink" title="ConcurrentHashMap 的方法"></a>ConcurrentHashMap 的方法</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>ConcurrentHashMap 一共提供了以下 5 个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 构造一个空的map，即table数组还未初始化，初始化放在第一次插入数据时，默认大小为16</span></span><br><span class="line">ConcurrentHashMap()</span><br><span class="line"><span class="comment">// 2. 给定map的大小</span></span><br><span class="line">ConcurrentHashMap(<span class="type">int</span> initialCapacity)</span><br><span class="line"><span class="comment">// 3. 给定一个map</span></span><br><span class="line">ConcurrentHashMap(Map&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; m)</span><br><span class="line"><span class="comment">// 4. 给定map的大小以及加载因子</span></span><br><span class="line">ConcurrentHashMap(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span><br><span class="line"><span class="comment">// 5. 给定map大小，加载因子以及并发度（预计同时操作数据的线程）</span></span><br><span class="line">ConcurrentHashMap(<span class="type">int</span> initialCapacity,<span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span><br></pre></td></tr></table></figure><p>差别请看注释，我们来看看第 2 种构造方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line"><span class="comment">//1. 小于0直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line"><span class="comment">//2. 判断是否超过了允许的最大值，超过了话则取最大值，否则再对该值进一步处理</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line"><span class="comment">//3. 赋值给sizeCtl</span></span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的逻辑请看注释，很容易理解，如果小于 0 就直接抛异常，如果指定值大于所允许的最大值就取最大值，否则再对指定值做进一步处理。最后将 cap 赋值给 sizeCtl。</p><p><strong>当调用构造方法之后，sizeCtl 的大小就代表了 ConcurrentHashMap 的大小，即 table 数组的长度</strong>。</p><p>tableSizeFor 做了哪些事情呢？源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two table size for the given desired capacity.</span></span><br><span class="line"><span class="comment"> * See Hackers Delight, sec 3.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> c - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释写的很清楚，该方法会将构造方法指定的大小转换成一个 2 的幂次方数，也就是说 ConcurrentHashMap 的大小一定是 2 的幂次方，比如，当指定大小为 18 时，为了满足 2 的幂次方特性，实际上 ConcurrentHashMap 的大小为 2 的 5 次方（32）。</p><p>另外，需要注意的是，<strong>调用构造方法时并初始化 table 数组，而只算出了 table 数组的长度，当第一次向 ConcurrentHashMap 插入数据时才会真正的完成初始化，并创建 table 数组</strong>。</p><h3 id="initTable-方法"><a href="#initTable-方法" class="headerlink" title="initTable 方法"></a>initTable 方法</h3><p>直接上源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 1. 保证只有一个线程正在进行初始化操作</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 2. 得出数组的大小</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="comment">// 3. 这里才真正的初始化数组</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line"><span class="comment">// 4. 计算数组中可用的大小：实际大小n*0.75（加载因子）</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的逻辑请见注释。</p><p>可能存在这样一种情况，多个线程同时进入到这个方法，为了保证能够正确地初始化，第 1 步会先通过 if 进行判断，如果当前已经有一个线程正在初始化，这时候其他线程会调用 <code>Thread.yield()</code> 让出 CPU 时间片。</p><p>正在进行初始化的线程会调用 <code>U.compareAndSwapInt</code> 方法将 sizeCtl 改为 -1，即正在初始化的状态。</p><p>另外还需要注意，在第四步中会进一步计算数组中可用的大小，即数组的实际大小 n 乘以加载因子 0.75，0.75 就是四分之三，这里<code>n - (n &gt;&gt;&gt; 2)</code>刚好是<code>n-(1/4)n=(3/4)n</code>，挺有意思的吧？</p><p>如果选择是无参的构造方法，这里在 new Node 数组的时候会使用默认大小<code>DEFAULT_CAPACITY</code>（16），然后乘以加载因子 0.75，结果为 12，也就是说数组当前的可用大小为 12。</p><h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h3><p>调用 put 方法时会调用 putVal 方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"><span class="comment">//1. 计算key的hash值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line"><span class="comment">//2. 如果当前table还没有初始化先调用initTable方法将tab进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line"><span class="comment">//3. tab中索引为i的位置的元素为null，则直接使用CAS将值插入即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//4. 当前正在扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line"><span class="comment">//5. 当前为链表，在链表中插入新的键值对</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">// 6.当前为红黑树，将新的键值对插入到红黑树中</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 7.插入完键值对后再根据实际大小看是否需要转换成红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//8.对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap 是一个哈希桶数组，如果不出现哈希冲突的时候，每个元素均匀的分布在哈希桶数组中。当出现哈希冲突的时候，采用<strong>拉链法的解决方案</strong>，将 hash 值相同的节点转换成链表的形式，另外，在 JDK 1.8 版本中，为了防止拉链过长，当链表的长度大于 8 的时候会将链表转换成红黑树。</p><p>确定好数组的索引 i 后，可以调用 <code>tabAt()</code> 方法获取该位置上的元素，如果当前 Node 为 null 的话，可以直接用 casTabAt 方法将新值插入。</p><p>拉链法、确定索引 i 的知识在学习 HashMap</p><p>如果当前节点不为 null，且该节点为特殊节点（forwardingNode），就说明当前 concurrentHashMap 正在进行扩容操作。怎么确定当前这个 Node 是特殊节点呢？</p><p>通过判断该节点的 hash 值是不是等于 -1（MOVED）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOVED</span>     <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br></pre></td></tr></table></figure><p>当 <code>table[i]</code> 不为 null 并且不是 forwardingNode 时，以及当前 Node 的 hash 值大于<code>0（fh &gt;= 0）</code>时，说明当前节点为链表的头节点，那么向 ConcurrentHashMap 插入新值就是向这个链表插入新值。通过 <code>synchronized (f)</code> 的方式进行加锁以实现线程安全。</p><p>往链表中插入节点的部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    binCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">        K ek;</span><br><span class="line"><span class="comment">// 找到hash值相同的key,覆盖旧值即可</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((ek = e.key) == key ||</span><br><span class="line">             (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">            oldVal = e.val;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                e.val = value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;K,V&gt; pred = e;</span><br><span class="line">        <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果到链表末尾仍未找到，则直接将新值插入到链表末尾即可</span></span><br><span class="line">            pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                      value, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分代码很好理解，就两种情况：</p><ol><li>如果在链表中找到了与待插入的 key 相同的节点，就直接覆盖；</li><li>如果找到链表的末尾都还没找到的话，直接将待插入的键值对追加到链表的末尾。</li></ol><p>当链表长度超过 8（默认值）时，链表就转换为红黑树，利用红黑树快速增删改查的特点可以提高 ConcurrentHashMap 的性能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    binCount = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                   value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        oldVal = p.val;</span><br><span class="line">        <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">            p.val = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很简单，调用 putTreeVal 方法向红黑树插入新节点，同样的逻辑，<strong>如果在红黑树中存在 Key 相同（hash 值相等并且 equals 方法判断为 true）的节点，就覆盖旧值，否则向红黑树追加新节点</strong>。</p><p>当完成数据新节点插入后，会进一步对当前链表大小进行调整：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">        treeifyBin(tab, i);</span><br><span class="line">    <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，put 方法就分析完了，我们来做个总结：</p><ol><li>对每一个放入的值，先用 spread 方法对 key 的 hashcode 进行 hash 计算，由此来确定这个值在 table 中的位置；</li><li>如果当前 table 数组还未初始化，进行初始化操作；</li><li>如果这个位置是 null，那么使用 CAS 操作直接放入；</li><li>如果这个位置存在节点，说明发生了 hash 碰撞，先判断这个节点的类型，如果该节点 <code>==MOVED</code> 的话，说明正在进行扩容；</li><li>如果是链表节点（<code>fh&gt;0</code>），先获取头节点，再依次向后遍历确定这个新加入节点的位置。如果遇到 key 相同的节点，直接覆盖。否则在链表尾插入；</li><li>如果这个节点的类型是 TreeBin，直接调用红黑树的插入方法插入新的节点；</li><li>插入完节点之后再次检查链表的长度，如果长度大于 8，就把这个链表转换成红黑树；</li><li>对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容。</li></ol><h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h3><p>get 方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line"><span class="comment">// 1. 重hash</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. table[i]桶节点的key与查找的key相同，则直接返回</span></span><br><span class="line"><span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 3. 当前节点hash小于0说明为树节点，在红黑树中查找即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//4. 从链表中查找，查找到则返回该节点的value，否则就返回null即可</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>哈希: 对传入的键的哈希值进行散列，这有助于减少哈希冲突的可能性。使用 spread 方法可以保证不同的键更均匀地分布在桶数组中。</li><li>直接查找: 查找的第一步是检查键的哈希值是否位于表的正确位置。如果在该桶的第一个元素中找到了键，则直接返回该元素的值。这里使用了 &#x3D;&#x3D; 操作符和 equals 方法来比较键，这有助于处理可能的 null 值和确保正确的相等性比较。</li><li>红黑树查找: 如果第一个节点的哈希值小于 0，那么这个桶的数据结构是红黑树（Java 8 引入了树化结构来改进链表在哈希冲突时的性能）。在这种情况下，使用 find 方法在红黑树中查找键。</li><li>链表查找: 如果前两个条件都不满足，那么代码将遍历该桶中的链表。如果在链表中找到了具有相同哈希值和键的元素，则返回其值。如果遍历完整个链表都未找到，则返回 null。</li></ul><h3 id="transfer-方法"><a href="#transfer-方法" class="headerlink" title="transfer 方法"></a>transfer 方法</h3><p>当 ConcurrentHashMap 容量不足的时候，需要对 table 进行扩容。这个方法的基本思想跟 HashMap 很像，但由于支持并发扩容，所以要复杂一些。transfer 方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line"><span class="comment">//1. 新建Node数组，容量为之前的两倍</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextn</span> <span class="operator">=</span> nextTab.length;</span><br><span class="line"><span class="comment">//2. 新建forwardingNode引用，在之后会用到</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">        <span class="comment">// 3. 确定遍历中的索引i</span></span><br><span class="line"><span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//4.将原数组中的元素复制到新数组中去</span></span><br><span class="line"><span class="comment">//4.5 for循环退出，扩容结束修改sizeCtl属性</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="type">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="literal">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="literal">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//4.1 当前数组中第i个元素为null，用CAS设置成特殊节点forwardingNode(可以理解成占位符)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line"><span class="comment">//4.2 如果遍历到ForwardingNode节点  说明这个点已经被处理过了 直接跳过  这里是控制并发扩容的核心</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="literal">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//4.3 处理当前节点为链表的头结点的情况，根据最高位为1还是为0(最高位指数组长度位)，将原链表拆分为两个链表，分别放到新数组的i位置和i+n位置。这里还通过巧妙的处理措施，使得原链表中的一部分能直接平移到新链表(即lastRun及其后面跟着的一串节点)，剩下部分才需要通过new方式克隆移动到新链表中（采用头插法）。</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash; <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln); <span class="comment">//可以看到是逆序插入新节点的（头插）</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                       <span class="comment">//在nextTable的i位置上插入一个链表</span></span><br><span class="line">                         setTabAt(nextTab, i, ln);</span><br><span class="line">                         <span class="comment">//在nextTable的i+n的位置上插入另一个链表</span></span><br><span class="line">                         setTabAt(nextTab, i + n, hn);</span><br><span class="line">                         <span class="comment">//在table的i位置上插入forwardNode节点  表示已经处理过该节点</span></span><br><span class="line">                         setTabAt(tab, i, fwd);</span><br><span class="line">                         <span class="comment">//设置advance为true 返回到上面的while循环中 就可以执行i--操作</span></span><br><span class="line">                         advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//4.4 处理当前节点是TreeBin时的情况，操作和上面的类似</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑请看注释，整个扩容操作分为<strong>两个部分</strong>：</p><p><strong>第一部分</strong>是构建一个 nextTable，它的容量是原来的两倍，这个操作是单线程完成的。</p><p><strong>第二个部分</strong>是将原来 table 中的元素复制到 nextTable 中，主要是遍历复制的过程。 得到当前遍历的数组位置 i，然后利用 tabAt 方法获得 i 位置的元素：</p><ol><li>如果这个位置为空，就在原 table 中的 i 位置放入 forwardNode 节点，这个也是触发并发扩容的关键；</li><li>如果这个位置是 Node 节点（<code>fh&gt;=0</code>），并且是链表的头节点，就把这个链表分裂成两个链表，把它们分别放在 nextTable 的 i 和 i+n 的位置上；</li><li>如果这个位置是 TreeBin 节点（<code>fh&lt;0</code>），也做一个反序处理，并且判断是否需要 untreefi，把处理的结果分别放在 nextTable 的 i 和 i+n 的位置上；</li><li>遍历所有的节点，就完成复制工作，这时让 nextTable 作为新的 table，并且更新 sizeCtl 为新容量的 0.75 倍 ，完成扩容。</li></ol><p><img src="/p/b8eea230/09e027aad8bf5271cb0671700d46a1d3.png" alt="ConcurrentHashMap扩容示意图"></p><h3 id="size-相关的方法"><a href="#size-相关的方法" class="headerlink" title="size 相关的方法"></a>size 相关的方法</h3><p>对于 ConcurrentHashMap 来说，这个 table 里到底装了多少东西是不确定的，因为<strong>不可能在调用 <code>size()</code> 方法的时候“stop the world”让其他线程都停下来去统计</strong>，对于这个不确定的 size，ConcurrentHashMap 仍然花费了大量的力气。</p><p>为了统计元素的个数，ConcurrentHashMap 定义了一些变量和一个内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A padded cell for distributing counts.  Adapted from LongAdder</span></span><br><span class="line"><span class="comment"> * and Striped64.  See their internal docs for explanation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CounterCell</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line">    CounterCell(<span class="type">long</span> x) &#123; value = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实际上保存的是HashMap中的元素个数  利用CAS锁进行更新</span></span><br><span class="line"><span class="comment"> 但它并不用返回当前HashMap的元素个数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> baseCount;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Table of counter cells. When non-null, size is a power of 2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br></pre></td></tr></table></figure><p>再来看如何统计的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="type">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="type">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the number of mappings. This method should be used</span></span><br><span class="line"><span class="comment"> * instead of &#123;<span class="doctag">@link</span> #size&#125; because a ConcurrentHashMap may</span></span><br><span class="line"><span class="comment"> * contain more mappings than can be represented as an int. The</span></span><br><span class="line"><span class="comment"> * value returned is an estimate; the actual count may differ if</span></span><br><span class="line"><span class="comment"> * there are concurrent insertions or removals.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of mappings</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">mappingCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> sumCount();</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0L</span>) ? <span class="number">0L</span> : n; <span class="comment">// ignore transient negative values</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">sumCount</span><span class="params">()</span> &#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.value;<span class="comment">//所有counter的值求和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>size 方法返回 Map 中的元素数量，但结果被限制在 Integer.MAX_VALUE 内。如果计算的大小超过这个值，则返回 Integer.MAX_VALUE。如果计算的大小小于 0，则返回 0。</p><p>mappingCount 方法也返回 Map 中的元素数量，但允许返回一个 long 值，因此可以表示大于 Integer.MAX_VALUE 的数量。与 <code>size()</code> 方法类似，该方法也会忽略负值，返回 0。</p><p>sumCount 方法计算 Map 的实际大小。ConcurrentHashMap 使用一个基础计数 baseCount 和一个 CounterCell 数组 counterCells 来跟踪大小。这种结构有助于减少多线程环境中的争用，因为不同的线程可能会更新不同的 CounterCell。</p><p>在计算总和时，<code>sumCount()</code> 方法将 baseCount 与 counterCells 数组中的所有非空单元的值相加。</p><p>在 put 方法结尾处调用了 addCount 方法，把当前 ConcurrentHashMap 的元素个数 +1，这个方法一共做了两件事，更新 baseCount 的值，检测是否进行扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span> &#123;</span><br><span class="line">    CounterCell[] as; <span class="type">long</span> b, s;</span><br><span class="line">    <span class="comment">//利用CAS方法更新baseCount的值</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="literal">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="type">long</span> v; <span class="type">int</span> m;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果check值大于等于0 则需要检验是否需要进行扩容操作</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="type">int</span> n, sc;</span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                 <span class="comment">//如果已经有其他线程在执行扩容操作</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前线程是唯一的或是第一个发起扩容的线程  此时nextTable=null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap-示例"><a href="#ConcurrentHashMap-示例" class="headerlink" title="ConcurrentHashMap 示例"></a>ConcurrentHashMap 示例</h2><p>假设我们想要构建一个线程安全的高并发统计用户访问次数的功能。在这里，ConcurrentHashMap 是一个很好的选择，因为它提供了高并发性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserVisitCounter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Integer&gt; visitCountMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserVisitCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.visitCountMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户访问时调用的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userVisited</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        visitCountMap.compute(userId, (key, value) -&gt; value == <span class="literal">null</span> ? <span class="number">1</span> : value + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取用户的访问次数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVisitCount</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> visitCountMap.getOrDefault(userId, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserVisitCounter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserVisitCounter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟用户访问</span></span><br><span class="line">        counter.userVisited(<span class="string">&quot;user1&quot;</span>);</span><br><span class="line">        counter.userVisited(<span class="string">&quot;user1&quot;</span>);</span><br><span class="line">        counter.userVisited(<span class="string">&quot;user2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;User1 visit count: &quot;</span> + counter.getVisitCount(<span class="string">&quot;user1&quot;</span>)); <span class="comment">// 输出: User1 visit count: 2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;User2 visit count: &quot;</span> + counter.getVisitCount(<span class="string">&quot;user2&quot;</span>)); <span class="comment">// 输出: User2 visit count: 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中：</p><ul><li>我们使用了 ConcurrentHashMap 来存储用户的访问次数。</li><li>当用户访问时，我们通过 userVisited 方法更新访问次数。</li><li>使用 ConcurrentHashMap 的 compute 方法可以确保原子地更新用户的访问次数。</li><li>可以通过 getVisitCount 方法检索任何用户的访问次数。</li></ul><p>ConcurrentHashMap 使我们能够无需担心并发问题就能构建这样一个高效的统计系统。</p><script>var description="JUC提供了一套高并发容器类解决基础容器会出现线程安全问题。"</script>]]></content>
      
      
      <categories>
          
          <category> 多线程编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC容器类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS抽象同步器的核心原理</title>
      <link href="/p/7aaa01f1.html"/>
      <url>/p/7aaa01f1.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>前面介绍的在争用激烈的场景下，使用基于CAS自旋实现的轻量级锁有两个大的问题：<br>（1）CAS恶性空自旋会浪费大量的CPU资源。<br>（2）在SMP架构的CPU上会导致“总线风暴”。</p><p><strong>解决CAS恶性空自旋的有效方式之一是以空间换时间，较为常见的方案有两种：分散操作热点和使用队列削峰。</strong>JUC并发包使用的是队列削峰的方案解决CAS的性能问题，并提供了一个基于双向队列的削峰基类——抽象基础类AbstractQueuedSynchronizer（抽象同步器类，简称为AQS）。</p><h2 id="锁与队列的关系"><a href="#锁与队列的关系" class="headerlink" title="锁与队列的关系"></a>锁与队列的关系</h2><p>无论是单体服务应用内部的锁，还是分布式环境下多体服务应用所使用的分布式锁，为了减少由于无效争夺导致的资源浪费和性能恶化，一般都基于队列进行排队与削峰。</p><ul><li><p>CLH锁的内部队列</p><ul><li>CLH自旋锁使用的CLH（Craig,Landin,andHagersten Lock Queue）是一个单向队列，也是一个FIFO队列。在独占锁中，竞争资源在一个时间点只能被一个线程锁访问，队列头部的<br>节点表示占有锁的节点，新加入的抢锁线程则需要等待，会插入队列的尾部。</li></ul><p><img src="/p/7aaa01f1/84057b3363a6f88ac15fbdceb5bb6efa.png" alt="CLH 锁的队列结构"></p></li><li><p>分布式锁的内部队列</p><ul><li>在分布式锁的实现中，比较常见的是基于队列的方式进行不同节点中“等锁线程”的统一调度和管理。</li></ul></li><li><p>AQS的内部队列</p><ul><li>AQS是JUC提供的一个用于构建锁和同步容器的基础类。JUC包内许多类都是基于AQS构建的，例如ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock、FutureTask等。AQS解决了在实现同步容器时设计的大量细节问题。AQS是CLH队列的一个变种，主要原理和CLH队列差不多，这也是前面对CLH队列进行长篇大论介绍的原因。</li><li>AQS队列内部维护的是一个FIFO的双向链表，这种结构的特点是每个数据结构都有两个指针，分别指向直接的前驱节点和直接的后继节点。所以双向链表可以从任意一个节点开始很方便地访问前驱节点和后继节点。每个节点其实是由线程封装的，当线程争抢锁失败后会封装成节点加入AQS队列中；当获取锁的线程释放锁以后，会从队列中唤醒一个阻塞的节点（线程）。</li></ul><p><img src="/p/7aaa01f1/07e56587f8335524bded01c420145c51.png" alt="CLH 变体队列结构"></p></li></ul><h2 id="AQS的核心成员"><a href="#AQS的核心成员" class="headerlink" title="AQS的核心成员"></a>AQS的核心成员</h2><p>AQS出于“分离变与不变”的原则，基于模板模式实现。AQS为锁获取、锁释放的排队和出队过程提供了一系列的模板方法。由于JUC的显式锁种类丰富，因此AQS将不同锁的具体操作抽取为钩子方法，供各种锁的子类（或者其内部类）去实现。</p><h3 id="状态标志位"><a href="#状态标志位" class="headerlink" title="状态标志位"></a>状态标志位</h3><p>AQS中维持了一个单一的<code>volatile</code>修饰的状态信息state，AQS使用int类型的state标示锁的状态，可以理解为锁的同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步状态，使用 volatile保证线程可见</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure><p><strong>state因为使用volatile保证了操作的可见性</strong>，所以任何线程通过<code>getState()</code>获得状态都可以得到最新值。AQS提供了<code>getState()</code>、<code>setState()</code>来获取和设置同步状态，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取同步的状态</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置同步的状态</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line"> state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于setState()无法保证原子性，因此AQS给我们提供了<code>compareAndSetState()</code>方法利用底层UnSafe的CAS机制来实现原子性。 <code>compareAndSetState()</code>方法实际上调用的是unsafe成员的<code>compareAndSwapInt()</code>方法。</p><p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程执行该锁的lock()操作时，会调用tryAcquire()独占该锁并将state加1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state&#x3D;0（释放锁）为止，其他线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么<br>次，这样才能保证state能回到零态。</p><p><code>AbstractQueuedSynchronizer</code>继承了<code>AbstractOwnableSynchronizer</code>，这个基类只有一个变量叫<code>exclusiveOwnerThread</code>，表示当前占用该锁的线程，并且提供了相应<br>的get()和set()方法，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//表示当前占用该锁的线程</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line">     <span class="comment">// 省略get/set方法</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列节点Node类"><a href="#队列节点Node类" class="headerlink" title="队列节点Node类"></a>队列节点Node类</h3><p>AQS是一个虚拟队列，不存在队列实例，仅存在节点之间的前后关系。节点类型通过内部类Node定义，其核心的成员如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 标记一个结点（对应的线程）在共享模式下等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="comment">// 标记一个结点（对应的线程）在独占模式下等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// waitStatus的值，表示该结点（对应的线程）已被取消</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// waitStatus的值，表示后继结点（对应的线程）需要被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// waitStatus的值，表示该结点（对应的线程）在等待某一条件</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/*waitStatus的值，表示有资源可用，新head结点需要继续唤醒后继结点（共享模式下，多线程并发释放资源，而head唤醒其后继结点后，需要把多出来的资源留给后面的结点；设置新的head结点时，会继续唤醒其后继结点）*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待状态，取值范围，-3，-2，-1，0，1</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">    <span class="keyword">volatile</span> Node prev; <span class="comment">// 前驱结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next; <span class="comment">// 后继结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread; <span class="comment">// 结点对应的线程</span></span><br><span class="line">    Node nextWaiter; <span class="comment">// 等待队列里下一个等待条件的结点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断共享模式的方法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其它方法忽略，可以参考具体的源码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS里面的addWaiter私有方法</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用了Node的这个构造函数</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 其它代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Node-节点-waitStatus-状态含义"><a href="#Node-节点-waitStatus-状态含义" class="headerlink" title="Node 节点 waitStatus 状态含义"></a>Node 节点 waitStatus 状态含义</h3><table><thead><tr><th>Node 节点状态</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td><code>CANCELLED</code></td><td>1</td><td>表示线程已经取消获取锁。线程在等待获取资源时被中断、等待资源超时会更新为该状态。</td></tr><tr><td><code>SIGNAL</code></td><td>-1</td><td>表示后继节点需要当前节点唤醒。在当前线程节点释放锁之后，需要对后继节点进行唤醒。</td></tr><tr><td><code>CONDITION</code></td><td>-2</td><td>表示节点在等待 Condition。当其他线程调用了 Condition 的 <code>signal()</code> 方法后，节点会从等待队列转移到同步队列中等待获取资源。</td></tr><tr><td><code>PROPAGATE</code></td><td>-3</td><td>用于共享模式，在共享模式下，前继节点不仅会唤醒后继节点，同时也可能会唤醒后继节点的后继节点。</td></tr><tr><td></td><td>0</td><td>加入队列的新节点的初始状态。</td></tr></tbody></table><p>如果 <code>waitStatus &gt; 0</code> ，表明节点的状态已经取消等待获取资源。</p><p>如果 <code>waitStatus &lt; 0</code> ，表明节点的处于有效的等待状态。</p><p>因此在 AQS 的源码中，经常使用 <code>&gt; 0</code> 、 <code>&lt; 0</code> 来对 <code>waitStatus</code> 进行判断。</p><h3 id="FIFO双向同步队列"><a href="#FIFO双向同步队列" class="headerlink" title="FIFO双向同步队列"></a>FIFO双向同步队列</h3><p>AQS的内部队列是CLH队列的变种，每当线程通过AQS获取锁失败时，线程将被封装成一个Node节点，通过CAS原子操作插入队列尾部。<br>当有线程释放锁时，AQS会尝试让队头的后继节点占用锁。AQS通过内置的FIFO双向队列来完成线程的排队工作，内部通过节点head和tail记录队首和队尾元素，元素的节点类型为Node类型，具<br>体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*首节点的引用*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="comment">/*尾节点的引用*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure><p>AQS的首节点和尾节点都是懒加载的。懒加载的意思是在需要的时候才真正创建。只有在线程竞争失败的情况下，有新线程加入同步队列时，AQS才创建一个head节点。head节点只能被setHead()方法修改，并且节点的waitStatus不能为CANCELLED。尾节点只在有新线程阻塞时才被创建。</p><h3 id="AQS-资源共享方式"><a href="#AQS-资源共享方式" class="headerlink" title="AQS 资源共享方式"></a>AQS 资源共享方式</h3><p>AQS 定义两种资源共享方式：<code>Exclusive</code>（独占，只有一个线程能执行，如<code>ReentrantLock</code>）和<code>Share</code>（共享，多个线程可同时执行，如<code>Semaphore</code>&#x2F;<code>CountDownLatch</code>）。</p><p>一般来说，自定义同步器的共享方式要么是独占，要么是共享，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p><h2 id="AQS中的钩子方法"><a href="#AQS中的钩子方法" class="headerlink" title="AQS中的钩子方法"></a>AQS中的钩子方法</h2><p><strong>什么是钩子方法呢？</strong> 钩子方法是一种被声明在抽象类中的方法，一般使用 <code>protected</code> 关键字修饰，它可以是空方法（由子类实现），也可以是默认实现的方法。模板设计模式通过钩子方法控制固定步骤的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>以上钩子方法的默认实现会抛出UnsupportedOperationException异常。除了这些钩子方法外，AQS类中的其他方法都是final类型的方法，所以无法被其他类继承，只有这几个方法可以被其他类继承。</p><h2 id="自定义同步器"><a href="#自定义同步器" class="headerlink" title="自定义同步器"></a>自定义同步器</h2><p>通过AQS实现一把简单的独占锁,如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p><ol><li>自定义的同步器继承 <code>AbstractQueuedSynchronizer</code> 。</li><li>重写 AQS 暴露的模板方法。</li></ol><h3 id="简单的独占锁的实现"><a href="#简单的独占锁的实现" class="headerlink" title="简单的独占锁的实现"></a>简单的独占锁的实现</h3><p>使用SimpleMockLock实现基于AQS的、简单的非公平独占锁，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SimpleMockLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="comment">// 同步器实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义的内部类：同步器</span></span><br><span class="line">    <span class="comment">// 直接使用 AbstractQueuedSynchronizer.state 值表示锁的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.state=1 表示锁没有被占用</span></span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.state=0 表示锁没已经被占用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="comment">// 钩子方法</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="comment">// CAS更新状态值为1</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 钩子方法</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前线程不是占用锁的线程</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="comment">// 抛出非法状态的异常 </span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果锁的状态为没有占用</span></span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 抛出非法状态的异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 接下来不需要使用CAS操作，因为下面的操作不存在并发场景</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 设置状态</span></span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式锁的抢占方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 委托给同步器的acquire()抢占方法</span></span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式锁的释放方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 委托给同步器的release()释放方法</span></span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他未实现的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 每个线程的执行轮数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TURNS</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">// 线程数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREADS</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池，用于多线程模拟测试</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(THREADS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义的独占锁</span></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMockLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 倒数闩</span></span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(THREADS);</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10个线程并发执行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; THREADS; i++) &#123;</span><br><span class="line">        pool.submit(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 调用自定义的独占锁的加锁方法</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; TURNS; j++) &#123;</span><br><span class="line">                    <span class="comment">// 执行一次累加 1000 次</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 调用自定义的独占锁的释放方法</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 线程执行完成，倒数闩减少一次</span></span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    <span class="comment">// 省略等待并发执行完成、结果输出的代码</span></span><br><span class="line">    System.out.println(<span class="string">&quot;count=&quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AQS锁抢占的原理"><a href="#AQS锁抢占的原理" class="headerlink" title="AQS锁抢占的原理"></a>AQS锁抢占的原理</h2><p>AbstractQueuedSynchronizer的实现非常精巧，令人叹为观止，不入细节难以完全领会其精髓。下面基于SimpleMockLock公平独占锁的抢占过程详细说明AQS锁抢占的原理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式锁的抢占方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 委托给同步器的acquire()抢占方法</span></span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AQS模板方法：acquire-arg"><a href="#AQS模板方法：acquire-arg" class="headerlink" title="AQS模板方法：acquire(arg)"></a>AQS模板方法：acquire(arg)</h3><p>AQS 中以独占模式获取资源的入口方法是 <code>acquire()</code> ，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>acquire()</code> 中，线程会先尝试获取共享资源；如果获取失败，会将线程封装为 Node 节点加入到 AQS 的等待队列中；加入队列之后，会让等待队列中的线程尝试获取资源，并且会对线程进行阻塞操作。分别对应以下三个方法：</p><ul><li><code>tryAcquire()</code> ：尝试获取锁（模板方法），<code>AQS</code> 不提供具体实现，由子类实现。</li><li><code>addWaiter()</code> ：如果获取锁失败，会将当前线程封装为 Node 节点加入到 AQS 的 CLH 变体队列中等待获取锁。</li><li><code>acquireQueued()</code> ：对线程进行阻塞、唤醒，并调用 <code>tryAcquire()</code> 方法让队列中的线程尝试获取锁。</li></ul><h3 id="钩子实现：tryAcquire-arg"><a href="#钩子实现：tryAcquire-arg" class="headerlink" title="钩子实现：tryAcquire(arg)"></a>钩子实现：tryAcquire(arg)</h3><p>SimpleMockLock的tryAcquire()流程是：CAS操作state字段，将其值从0改为1，若成功，则表示锁未被占用，可成功占用，并且返回<br>true；若失败，则获取锁失败，返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 钩子方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// CAS更新状态值为1</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SimpleMockLock的实现非常简单，是不可以重入的，仅仅为了学习AQS而编写。如果是可以重入的锁，在重复抢锁时会累计state字段值，表示重入锁的次数，具体可参考ReentrantLock源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 1、获取 AQS 中的 state 状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// 2、如果 state 为 0，证明锁没有被其他线程占用</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.1、通过 CAS 对 state 进行更新</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 2.2、如果 CAS 更新成功，就将锁的持有者设置为当前线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、如果当前线程和锁的持有线程相同，说明发生了「锁的重入」</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.1、将锁的重入次数加 1</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4、如果锁被其他线程占用，就返回 false，表示获取锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 <code>CAS</code> 更新 <code>state</code> 变量。<code>state == 0</code> 表示资源没有被占用。<code>state &gt; 0</code> 表示资源被占用，此时 <code>state</code> 表示重入次数。</li><li>通过 <code>setExclusiveOwnerThread()</code> 设置持有资源的线程。</li></ul><p>如果线程更新 <code>state</code> 变量成功，就表明获取到了资源， 因此将持有资源的线程设置为当前线程即可。</p><h3 id="直接入队：addWaiter"><a href="#直接入队：addWaiter" class="headerlink" title="直接入队：addWaiter"></a>直接入队：addWaiter</h3><p>在acquire模板方法中，如果钩子方法tryAcquire尝试获取同步状态失败的话，就构造同步节点（独占式节点模式为Node.EXCLUSIVE），通过<code>addWaiter(Node node,int args)</code>方法将该节<br>点加入同步队列的队尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、将当前线程封装为 Node 节点。</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="comment">// 2、如果 pred ！= null，则证明 tail 节点已经被初始化，直接将 Node 节点加入队列即可。</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 2.1、通过 CAS 控制并发安全。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、初始化队列，并将新创建的 Node 节点加入队列。</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>addWaiter()</code> 方法中，需要执行 Node 节点 <strong>入队</strong> 的操作。由于是在多线程环境下，因此需要通过 <code>CAS</code> 操作保证并发安全。通过 <code>CAS</code> 操作去更新 <code>tail</code> 指针指向新入队的 Node 节点，<code>CAS</code> 可以保证只有一个线程会成功修改 <code>tail</code> 指针，以此来保证 Node 节点入队时的并发安全。</p><h3 id="自旋入队：enq"><a href="#自旋入队：enq" class="headerlink" title="自旋入队：enq"></a>自旋入队：enq</h3><p>执行 <code>addWaiter()</code> 时，如果发现 <code>pred == null</code> ，即 <code>tail</code> 指针为 null，则证明队列没有初始化，需要调用 <code>enq()</code> 方法初始化队列，并将 <code>Node</code> 节点加入到初始化后的队列中，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 1、通过 CAS 操作保证队列初始化的并发安全,初始化尾节点和头节点为新节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2、与 addWaiter() 方法中节点入队的操作相同,队列不为空，将新节点插入队列尾部</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS 操作head指针，仅仅被enq()调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetHead</span><span class="params">(Node update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="built_in">this</span>, headOffset, <span class="literal">null</span>, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS 操作head指针，仅仅被enq()调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="built_in">this</span>, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/p/7aaa01f1/6433abc9d3f4da3083de27995d765dc0.png"></p><h3 id="自旋抢占：acquireQueued"><a href="#自旋抢占：acquireQueued" class="headerlink" title="自旋抢占：acquireQueued()"></a>自旋抢占：acquireQueued()</h3><p>在 <code>acquire()</code> 方法中，通过 <code>addWaiter()</code> 方法将 <code>Node</code> 节点加入队列之后，就会调用 <code>acquireQueued()</code> 方法。在节点入队之后，启动自旋抢锁的流程。<code>acquireQueued()</code>方法的主要逻辑：<strong>当前Node节点线程在死循环中不断获取同步状态，并且不断在前驱节点上自旋，只有当前驱节点是头节点时才能尝试获取锁</strong>，原因是：</p><ol><li>头节点是成功获取同步状态（锁）的节点，而头节点的线程释放了同步状态以后，将会唤醒其后继节点，后继节点的线程被唤醒后要检查自己的前驱节点是否为头节点。</li><li>维护同步队列的FIFO原则，节点进入同步队列之后，就进入了自旋的过程，每个节点都在不断地执行for死循环。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS：令队列中的节点尝试获取锁，并且对线程进行阻塞。</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="comment">// 自旋检查当前节点的前驱节点是否为头节点，才能获取锁</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 1、尝试获取锁。</span></span><br><span class="line">            <span class="comment">// 获取节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">// 节点中的线程循环地检查自己的前驱节点是否为 head节点</span></span><br><span class="line">            <span class="comment">// 前驱节点是head时，进一步调用子类的tryAcquire（…）实现</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2、判断线程是否可以阻塞，如果可以，则阻塞当前线程。</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 3、如果获取锁失败，就会取消获取锁，将节点状态更新为 CANCELLED。</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">//取消请求，将当前节点从队列中移除</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了不浪费资源，<code>acquireQueued()</code>自旋过程中会阻塞线程，等待被前驱节点唤醒后才启动循环。如果成功就返回，否则执行<code>shouldParkAfterFailedAcquire()</code>、<code>parkAndCheckInterrupt()</code>来达到阻塞的效果。</p><p>调用<code>acquireQueued()</code>方法的线程一定是node所绑定的线程（由它的thread属性所引用），该线程也是最开始调用lock()方法抢锁的那个线程，在<code>acquireQueued()</code>的死循环中，该线程可能重复进行阻塞和被唤醒。</p><p>在 <code>acquireQueued()</code> 方法中，主要做两件事情：</p><ul><li><p><strong>尝试获取资源</strong>: 在 <code>acquireQueued()</code> 方法中，尝试获取资源总共有 2 个步骤：</p><ol><li><code>p == head</code> ：表明当前节点的前继节点为 <code>head</code> 节点。此时当前节点为 AQS 队列中的第一个等待节点。</li><li><code>tryAcquire(arg) == true</code> ：表明当前线程尝试获取资源成功。</li><li>在成功获取资源之后，就需要将当前线程的节点 <strong>从等待队列中移除</strong> 。移除操作为：将当前等待的线程节点设置为 <code>head</code> 节点（<code>head</code> 节点是虚拟节点，并不参与排队获取资源）。</li></ol></li><li><p><strong>阻塞当前线程</strong></p><p>在 <code>AQS</code> 中，当前节点的唤醒需要依赖于上一个节点。如果上一个节点取消获取锁，它的状态就会变为 <code>CANCELLED</code> ，<code>CANCELLED</code> 状态的节点没有获取到锁，也就无法执行解锁操作对当前节点进行唤醒。因此在阻塞当前线程之前，需要跳过 <code>CANCELLED</code> 状态的节点。</p></li></ul><h3 id="挂起预判：shouldParkAfterFailedAcquire"><a href="#挂起预判：shouldParkAfterFailedAcquire" class="headerlink" title="挂起预判：shouldParkAfterFailedAcquire()"></a>挂起预判：shouldParkAfterFailedAcquire()</h3><p><code>acquireQueued()</code>自旋在阻塞自己的线程之前会进行挂起预判。<code>shouldParkAfterFailedAcquire()</code>方法的主要功能是：将当前节点的有效前驱节点（是指有效节点不是CANCELLED类型的节点）找到，并且将有效前驱节点的状态设置为SIGNAL，之后返回true代表当前线程可以马上被阻塞了。具体可以分为三种情况：</p><ul><li>如果发现前继节点的状态是<code>-1 SIGNAL</code> ，则可以阻塞当前线程。<ul><li>说明前驱的等待标志已设好，返回true表示设置完毕。</li></ul></li><li>如果发现前继节点的状态是<code>1 CANCELLED</code> ，则需要跳过 <code>1 CANCELLED</code> 状态的节点<ul><li>说明前驱节点本身不再等待了，需要跨越这些节点，然后找到一个有效节点，再把当前节点和这个有效节点的唤醒关系建立好：调整前驱节点的next指针为自己。</li></ul></li><li>如果发现前继节点的状态不是 <code>SIGNAL</code> 和 <code>CANCELLED</code> ，表明前继节点的状态处于正常等待资源的状态，因此将前继节点的状态设置为 <code>SIGNAL</code> ，表明该前继节点需要对后续节点进行唤醒。<ul><li>如果是其他情况：<code>-3（PROPAGATE，共享锁等待）</code>、<code>-2（CONDITION，条件等待）</code>、<code>0（初始状态）</code>，那么通过CAS尝试设置前驱节点为SIGNAL，表示只要前驱节点释放锁，当前节点就可以抢占锁了。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS：判断当前线程节点是否可以阻塞。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="comment">// 1、前继节点状态正常，直接返回 true 即可。</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 2、ws &gt; 0 表示前继节点的状态异常，即为 CANCELLED 状态，需要跳过异常状态的节点。</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 将pred记录前驱的前驱</span></span><br><span class="line">            <span class="comment">// 调整当前节点的prev指针，保持为前驱的前驱</span></span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 调整前驱节点的next指针</span></span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3、如果前继节点的状态不是 SIGNAL，也不是 CANCELLED，就将状态设置为 SIGNAL。</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        <span class="comment">// 设置前驱状态之后，此方法返回值还是为false，表示线程不可用，被阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在独占锁的场景中，<code>shouldParkAfterFailedAcquire()</code>方法是在<code>acquireQueued()</code>方法的死循环中被调用的，由于此方法返回false时<code>acquireQueued()</code>不会阻塞当前线程，只有此方法返回true时当前线程才阻塞，<strong>因此在一般情况下，此方法至少需要执行两次，当前线程才会被阻塞。</strong></p><h3 id="线程挂起：parkAndCheckInterrupt"><a href="#线程挂起：parkAndCheckInterrupt" class="headerlink" title="线程挂起：parkAndCheckInterrupt()"></a>线程挂起：parkAndCheckInterrupt()</h3><p>当判断当前线程可以阻塞之后，通过调用 <code>parkAndCheckInterrupt()</code> 方法来阻塞当前线程。内部使用了 <code>LockSupport</code> 来实现阻塞。<code>LockSupoprt</code> 底层是基于 <code>Unsafe</code> 类来阻塞线程，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1、线程阻塞到这里 调用park()使线程进入waiting状态</span></span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 2、线程被唤醒之后，返回线程中断状态</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当线程被唤醒之后，需要执行 <code>Thread.interrupted()</code> 来返回线程的中断状态，这是为什么呢？</p></blockquote><p>这个和线程的中断协作机制有关系，线程被唤醒之后，并不确定是被中断唤醒，还是被 <code>LockSupport.unpark()</code> 唤醒，因此需要通过线程的中断状态来判断。</p><p>AbstractQueuedSynchronizer会把所有的等待线程构成一个阻塞等待队列，当一个线程执行完<code>lock.unlock()</code>时，会激活其后继节点，通过调用<code>LockSupport.unpark(postThread)</code>完成后继线程的唤醒。</p><h3 id="selfInterrupt"><a href="#selfInterrupt" class="headerlink" title="selfInterrupt()"></a>selfInterrupt()</h3><p>在 <code>acquire()</code> 方法中，当 <code>if</code> 语句的条件返回 <code>true</code> 后，就会调用 <code>selfInterrupt()</code> ，该方法会中断当前线程，为什么需要中断当前线程呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selfInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 重新设置线程的中断状态。</span></span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当 <code>if</code> 判断为 <code>true</code> 时，需要 <code>tryAcquire()</code> 返回 <code>false</code> ，并且 <code>acquireQueued()</code> 返回 <code>true</code> 。</li><li>其中 <code>acquireQueued()</code> 方法返回的是线程被唤醒之后的 <strong>中断状态</strong> ，通过执行 <code>Thread.interrupted()</code> 来返回。该方法在返回中断状态的同时，会清除线程的中断状态。</li><li>因此如果 <code>if</code> 判断为 <code>true</code> ，表明线程的中断状态为 <code>true</code> ，但是调用 <code>Thread.interrupted()</code> 之后，线程的中断状态被清除为 <code>false</code> ，因此需要重新执行 <code>selfInterrupt()</code> 来重新设置线程的中断状态。</li></ul><h2 id="AQS锁释放的原理"><a href="#AQS锁释放的原理" class="headerlink" title="AQS锁释放的原理"></a>AQS锁释放的原理</h2><p>下面基于SimpleMockLock公平独占锁的释放流程详细说明AQS锁释放的原理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式锁的释放方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 委托给同步器的release()释放方法</span></span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AQS模板方法：release"><a href="#AQS模板方法：release" class="headerlink" title="AQS模板方法：release()"></a>AQS模板方法：release()</h3><p>这段代码逻辑比较简单，如果同步状态的钩子方法执行成功（tryRelease返回true），就会执行if块中的代码，当head指向的头节点不为null，并且该节点的状态值不为0时才会执行<code>unparkSuccessor()</code>方法。钩子方法tryRelease()尝试释放当前线程持有的资源，由子类提供具体的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、尝试释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 2、唤醒后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="钩子实现：tryRelease"><a href="#钩子实现：tryRelease" class="headerlink" title="钩子实现：tryRelease()"></a>钩子实现：tryRelease()</h3><p>tryRelease()方法是需要子类提供实现的一个钩子方法，需要子类根据具体业务进行具体的实现。SimpleMockLock的钩子实现如下：<strong>核心逻辑是设置同步状态state的值为0，方便后继节点执行抢</strong><br><strong>占。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 钩子方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前线程不是占用锁的线程</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 抛出非法状态的异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果锁的状态为没有占用</span></span><br><span class="line">    <span class="keyword">if</span> (getState() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 抛出非法状态的异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接下来不需要使用CAS操作，因为下面的操作不存在并发场景</span></span><br><span class="line">    setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 设置状态</span></span><br><span class="line">    setState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock在 <code>tryRelease()</code> 方法中，会先计算释放锁之后的 <code>state</code> 值，判断 <code>state</code> 值是否为 0。</p><ul><li><p>如果 <code>state == 0</code> ，表明该线程没有重入次数了，更新 <code>free = true</code> ，并修改持有资源的线程为 null，表明该线程完全释放这把锁。</p></li><li><p>如果 <code>state != 0</code> ，表明该线程还存在重入次数，因此不更新 <code>free</code> 值，<code>free</code> 值为 <code>false</code> 表明该线程没有完全释放这把锁。之后更新 <code>state</code> 值，并返回 <code>free</code> 值，<code>free</code> 值表明线程是否完全释放锁。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="comment">// 1、判断持有锁的线程是否为当前线程</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 2、如果 state 为 0，则表明当前线程已经没有重入次数。因此将 free 更新为 true，表明该线程会释放锁。</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 3、更新持有资源的线程为 null</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4、更新 state 值</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="唤醒后继：unparkSuccessor"><a href="#唤醒后继：unparkSuccessor" class="headerlink" title="唤醒后继：unparkSuccessor()"></a>唤醒后继：unparkSuccessor()</h3><p>如果 <code>tryRelease()</code> 返回 <code>true</code> ，表明线程已经没有重入次数了，锁已经被完全释放，因此需要唤醒后继节点。在唤醒后继节点之前，需要判断是否可以唤醒后继节点，判断条件为： <code>h != null &amp;&amp; h.waitStatus != 0</code> 。这里解释一下为什么要这样判断：</p><ul><li><code>h == null</code> ：表明 <code>head</code> 节点还没有被初始化，也就是 AQS 中的队列没有被初始化，因此无法唤醒队列中的线程节点。</li><li><code>h != null &amp;&amp; h.waitStatus == 0</code> ：表明头节点刚刚初始化完毕（节点的初始化状态为 0），后继节点线程还没有成功入队，因此不需要对后续节点进行唤醒。（当后继节点入队之后，会将前继节点的状态修改为 <code>SIGNAL</code> ，表明需要对后继节点进行唤醒）</li><li><code>h != null &amp;&amp; h.waitStatus != 0</code> ：其中 <code>waitStatus</code> 有可能大于 0，也有可能小于 0。其中 <code>&gt; 0</code> 表明节点已经取消等待获取资源，<code>&lt; 0</code> 表明节点处于正常等待状态。</li></ul><p>接下来进入 <code>unparkSuccessor()</code> 方法查看如何唤醒后继节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS：这里的入参 node 为队列的头节点（虚拟头节点）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// // 获得节点状态，释放锁的节点，也就是头节点</span></span><br><span class="line">    <span class="comment">//CANCELLED（1）、SIGNAL（-1）、CONDITION （-2）、PROPAGATE（-3） </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="comment">// 1、将头节点的状态进行清除，为后续的唤醒做准备。</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 若头节点状态小于0，则将其置为0，表示初始状态</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="comment">// 2、如果后继节点异常，则需要从 tail 向前遍历，找到正常状态的节点进行唤醒。</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// // 如果新节点已经被取消CANCELLED（1）</span></span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="comment">// 从队列尾部开始，往前去找最前面的一个 waitStatus 小于等于的节点</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 3、唤醒后继节点</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在 <code>unparkSuccessor()</code> 中，如果头节点的状态 <code>&lt; 0</code> （在正常情况下，只要有后继节点，头节点的状态应该为 <code>SIGNAL</code> ，即 -1），表示需要对后继节点进行唤醒，因此这里提前清除头节点的状态标识，将状态修改为 0，表示已经执行了对后续节点唤醒的操作。</p></li><li><p>如果 <code>s == null</code> 或者 <code>s.waitStatus &gt; 0</code> ，表明后继节点异常，此时不能唤醒异常节点，而是要找到正常状态的节点进行唤醒。</p></li><li><p>因此需要从 <code>tail</code> 指针向前遍历，来找到第一个状态正常（<code>waitStatus &lt;= 0</code>）的节点进行唤醒。</p></li></ul><p><code>unparkSuccessor()</code>唤醒后继节点的线程后，后继节点的线程重新执行方法<code>acquireQueued()</code>中的自旋抢占逻辑。</p><h3 id="tail-指针向前遍历原因"><a href="#tail-指针向前遍历原因" class="headerlink" title="tail 指针向前遍历原因"></a><code>tail</code> 指针向前遍历原因</h3><blockquote><p><strong>为什么要从 <code>tail</code> 指针向前遍历，而不是从 <code>head</code> 指针向后遍历，寻找正常状态的节点呢？</strong></p></blockquote><p>遍历的方向和 <strong>节点的入队操作</strong> 有关。入队方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS：节点入队方法</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 1、先修改 prev 指针。</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">// 2、再修改 next 指针。</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>addWaiter()</code> 方法中，<code>node</code> 节点入队需要修改 <code>node.prev</code> 和 <code>pred.next</code> 两个指针，但是这两个操作并不是 <strong>原子操作</strong> ，先修改了 <code>node.prev</code> 指针，之后才修改 <code>pred.next</code> 指针。在极端情况下，可能会出现 <code>head</code> 节点的下一个节点状态为 <code>CANCELLED</code> ，此时新入队的节点仅更新了 <code>node.prev</code> 指针，还未更新 <code>pred.next</code> 指针，如下图：</p><p><img src="/p/7aaa01f1/3fa5fc494857d136263f7d421874fcb4.png"></p><p>这样如果从 <code>head</code> 指针向后遍历，无法找到新入队的节点，因此需要从 <code>tail</code> 指针向前遍历找到新入队的节点。</p><h2 id="图解-AQS-工作原理"><a href="#图解-AQS-工作原理" class="headerlink" title="图解 AQS 工作原理"></a>图解 AQS 工作原理</h2><p>这里基于 <code>ReentrantLock</code> 来画图进行讲解。</p><ol><li><p>设总共有 3 个线程尝试获取锁，线程分别为 <code>T1</code> 、 <code>T2</code> 和 <code>T3</code> 。</p><ul><li><p>此时，假设线程 <code>T1</code> 先获取到锁，线程 <code>T2</code> 排队等待获取锁。在线程 <code>T2</code> 进入队列之前，需要对 AQS 内部队列进行初始化。<code>head</code> 节点在初始化后状态为 <code>0</code> 。AQS 内部初始化后的队列如下图：</p><p><img src="/p/7aaa01f1/b02b5e65c5d5402664724f8a7b079624.png"></p></li></ul></li><li><p>此时，线程 <code>T2</code> 尝试获取锁。由于线程 <code>T1</code> 持有锁，因此线程 <code>T2</code> 会进入队列中等待获取锁。同时会将前继节点（ <code>head</code> 节点）的状态由 <code>0</code> 更新为 <code>SIGNAL</code> ，表示需要对 <code>head</code> 节点的后继节点进行唤醒。此时，AQS 内部队列如下图所示：</p><p><img src="/p/7aaa01f1/5fe2e2a3932cb6f44927024d5e9c1992.png"></p></li><li><p>此时，线程 <code>T3</code> 尝试获取锁。由于线程 <code>T1</code> 持有锁，因此线程 <code>T3</code> 会进入队列中等待获取锁。同时会将前继节点（线程 <code>T2</code> 节点）的状态由 <code>0</code> 更新为 <code>SIGNAL</code> ，表示线程 <code>T2</code> 节点需要对后继节点进行唤醒。此时，AQS 内部队列如下图所示：</p><p><img src="/p/7aaa01f1/0aeb455ca0106c1dbb8d2841fdef011f.png"></p></li><li><p>此时，假设线程 <code>T1</code> 释放锁，会唤醒后继节点 <code>T2</code> 。线程 <code>T2</code> 被唤醒后获取到锁，并且会从等待队列中退出。</p><ul><li>这里线程 <code>T2</code> 节点退出等待队列并不是直接从队列移除，而是令线程 <code>T2</code> 节点成为新的 <code>head</code> 节点，以此来退出资源获取的等待。此时 AQS 内部队列如下所示：</li></ul><p><img src="/p/7aaa01f1/d8863d88067b9e15ff4e528530dbe03a.png"></p></li><li><p>此时，假设线程 <code>T2</code> 释放锁，会唤醒后继节点 <code>T3</code> 。线程 <code>T3</code> 获取到锁之后，同样也退出等待队列，即将线程 <code>T3</code> 节点变为 <code>head</code> 节点来退出资源获取的等待。此时 AQS 内部队列如下所示：</p><p><img src="/p/7aaa01f1/91dd7d1c354bdf841284e797651eb703.png"></p></li></ol><h2 id="ReentrantLock的抢锁流程"><a href="#ReentrantLock的抢锁流程" class="headerlink" title="ReentrantLock的抢锁流程"></a>ReentrantLock的抢锁流程</h2><h3 id="非公平抢占的钩子方法：tryAcquire-arg"><a href="#非公平抢占的钩子方法：tryAcquire-arg" class="headerlink" title="非公平抢占的钩子方法：tryAcquire(arg)"></a>非公平抢占的钩子方法：tryAcquire(arg)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">//非公平锁抢占的钩子方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 先直接获得锁的状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果内部队列首节点的线程执行完了，它会将锁的state设置为0</span></span><br><span class="line">            <span class="comment">// 当前抢锁线程的下一步就是直接进行抢占，不管不顾</span></span><br><span class="line">            <span class="comment">// 发现state是空的，就直接拿来加锁使用，根本不考虑后面继承者的存在</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">// 1. 利用CAS自旋方式判断当前state确实为0，然后设置成acquire（1）</span></span><br><span class="line">                <span class="comment">// 这是原子性的操作，可以保证线程安全</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="comment">// 设置当前执行的线程，直接返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// 2.当前的线程和执行中的线程是同一个，也就意味着可重入操作 int nextc = c + acquires;</span></span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count</span></span><br><span class="line"><span class="string">                        exceeded&quot;</span>);</span><br><span class="line">                        setState(nextc);</span><br><span class="line">            <span class="comment">// 表示当前锁被1个线程重复获取了nextc次</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则就返回false，表示没有成功获取当前锁，进入排队过程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非公平同步器<code>ReentrantLock.NonfairSync</code>的核心思想<strong>是当前线程尝试获取锁的时候，如果发现锁的状态位是0，就直接尝试将锁拿过来，然后执行<code>setExclusiveOwnerThread()</code>，根本不管同步队列中的排队节点。</strong></p><h3 id="公平抢占的钩子方法：tryAcquire-arg"><a href="#公平抢占的钩子方法：tryAcquire-arg" class="headerlink" title="公平抢占的钩子方法：tryAcquire(arg)"></a>公平抢占的钩子方法：tryAcquire(arg)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// 公平抢占的钩子方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState(); <span class="comment">// 锁状态</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">// 有后继节点就返回，足够讲义气</span></span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平抢占的钩子方法中，首先判断是否有后继节点，如果有后继节点，并且当前线程不是锁的占有线程，钩子方法就返回false，模板方法会进入排队的执行流程，可见公平锁是真正公平的。</p><h4 id="是否有后继节点的判断"><a href="#是否有后继节点的判断" class="headerlink" title="是否有后继节点的判断"></a>是否有后继节点的判断</h4><p>head节点是获取到锁的节点，但是任意时刻head节点可能占用着锁，也可能释放了锁，如果释放了锁，那么此时state&#x3D;0，未被阻塞的<code>head.next</code>节点对应的线程在任意时刻都是在自旋地尝试获取锁。FairSync进行是否有后继节点的判断代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="literal">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hasQueuedPredecessors的执行场景大致如下：</p><ol><li>当<code>h!=t</code>不成立的时候，说明h头节点、t尾节点要么是同一个节点，要么都是null，此时<code>hasQueuedPredecessors()</code>返回false，表示没有后继节点。</li><li>当<code>h!=t</code>成立的时候，进一步检查<code>head.next</code>是否为null，如果为null，就返回true。什么情况下<code>h!=t</code>，同时<code>h.next==null</code>呢？<ul><li>有其他线程第一次正在入队时可能会出现。其他线程执行AQS的<code>enq()</code>方法，<code>compareAndSetHead(node)</code>完成，还没执行<code>tail=head</code>语句时，此时<code>t=null、head=new Node()、head.next=null</code>。</li></ul></li><li>如果<code>h!=t</code>成立，<code>head.next != null</code>，判断<code>head.next</code>是不是当前线程，如果是就返回false，否则返回true。</li></ol><h2 id="AQS条件队列"><a href="#AQS条件队列" class="headerlink" title="AQS条件队列"></a>AQS条件队列</h2><p>Condition是JUC用来替代传统Object的<code>wait()/notify()</code>线程间通信与协作机制的新组件，相比调用Object的<code>wait()/notify()</code>，调用Condition的<code>await()/signal()</code>这种方式实现线程间协作更加高效。</p><ul><li>Condition的await()方法会<strong>将线程包装为等待节点，加入等待队列中，并将AQS同步队列中的节点移除</strong>，接着不断检查<code>isOnSyncQueue(Node node)</code>，如果在等待队列中，就一直等着，如果signal将它移到AQS队列中，则退出循环。</li><li>Condition的signal()方法则是先检查当前线程是否获取了锁，接着将等待队列中的节点通过Node的操作<strong>直接</strong>加入AQS队列。线程并不会立即获取到资源，从while循环退出后，会通过acquireQueued方法加入获取同步状态的竞争中。</li></ul><p><code>AQS，Lock,Condition，ConditionObject</code>之间的关系：<strong>ConditionObject是AQS的内部类，实现了Condition接口</strong>，Lock中提供newCondition()方法，委托给内部AQS的实现Sync来创建ConditionObject对象，享受AQS对Condition的支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock#newCondition</span></span><br><span class="line"><span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Sync#newCondition</span></span><br><span class="line"><span class="keyword">final</span> ConditionObject <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 返回Contition的实现，定义在AQS中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Condition基本原理"><a href="#Condition基本原理" class="headerlink" title="Condition基本原理"></a>Condition基本原理</h3><p>Condition与Object的<code>wait()/notify()</code>作用是相似的，都是使得一个线程等待某个条件，只有当该条件具备<code>signal()</code>或者<code>signalAll()</code>方法被调用时等待线程才会被唤醒，从而重新争夺锁。不同的是，<strong>Object的wait()&#x2F;notify()由JVM底层实现，而Condition接口与实现类完全使用Java代码实现</strong>。当需要进行线程间的通信时，建议结合使用ReetrantLock与Condition，通过Condition的await()和signal()方法进行线程间的阻塞与唤醒。</p><p>ConditionObject类是实现条件队列的关键，每个ConditionObject对象都维护一个单独的条件等待队列。每个ConditionObject对应一个条件队列，它记录该队列的头节点和尾节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS中Node类与Condition相关的字段：</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 记录当前线程的等待状态，</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// node存储的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点在Condition中等待队列上的下一个节点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>,java.io.Serializable &#123;</span><br><span class="line">     <span class="comment">//记录该队列的头节点</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">     <span class="comment">//记录该队列的尾节点</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>条件队列为单向列表，只有指向下一个节点的引用；没有被唤醒的节点全部存储在条件队列上</strong>。下图描述的是一个长度为 5 的条件队列，即有5个线程执行了<code>await()</code>方法；与阻塞队列不同，条件队列没有常驻内存的“head结点”，且一个处于正常状态节点的<code>waitStatus</code>为<code> -2 condition</code> 。当有新节点加入时，将会追加至队列尾部</p><p><img src="/p/7aaa01f1/280f71cbde81a0e0fc7374e55bfbbe2a.png" alt="条件队列数据结构"></p><p>在一个显式锁上，我们可以创建多个等待任务队列，这点和内置锁不同，Java内置锁上只有唯一的一个等待队列。比如，我们可以调用<code>newCondition()</code>创建两个等待队列，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">//创建第一个等待队列 </span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">firstCond</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="comment">//创建第二个等待队列 </span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">secondCond</span> <span class="operator">=</span> lock.newCondition();</span><br></pre></td></tr></table></figure><p>Condition条件队列是单向的，而AQS同步队列是双向的，AQS节点会有前驱指针。一个AQS实例可以有多个条件队列，是聚合关系；但是一个AQS实例只有一个同步队列，是逻辑上的组合关系。</p><p><img src="/p/7aaa01f1/6affcfeefcdc02b59cbe45da30b901c8.png"></p><h3 id="await-等待方法原理"><a href="#await-等待方法原理" class="headerlink" title="await()等待方法原理"></a>await()等待方法原理</h3><p>当线程调用await()方法时，说明当前线程的节点为当前AQS队列的头节点，正好处于占有锁的状态，await()方法需要把该线程从AQS队列挪到Condition等待队列里</p><p><img src="/p/7aaa01f1/94c3c512858025764e756dd5c068d7c3.png"></p><p>在<code>await()</code>方法将当前线程挪动到Condition等待队列后，还会唤醒AQS同步队列中head节点的下一个节点。await()方法的核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 这个方法是响应中断的</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 添加到条件队列中</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放同步资源，也就是释放锁</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果这个节点的线程不在同步队列中，说明该线程还不具备竞争锁的资格</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 挂起线程</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 如果线程中断，退出</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面的循环退出有两种情况：</span></span><br><span class="line">    <span class="comment">// 1. isOnSyncQueue(node) 为true，即当前的node已经转移到阻塞队列了</span></span><br><span class="line">    <span class="comment">// 2. checkInterruptWhileWaiting != 0, 表示线程中断</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出循环，被唤醒之后，进入阻塞队列，等待获取锁 acquireQueued</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="addConditionWaiter"><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter"></a>addConditionWaiter</h4><p>创建一个新节点并放入Condition队列尾部的工作由<code>addConditionWaiter()</code>方法完成，该方法具体如下：</p><ul><li>首先判断条件队列的尾节点是否被取消了，这里用<code>last.ws != CONDITION</code>来判断，如果是的话，就需要从头到尾遍历，消除被不是condition的节点。</li><li>接着将当前线程包装为Node，指定ws为CONDITION。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">    <span class="comment">// 如果lastWaiter被取消了，将其清除</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        <span class="comment">// 遍历整个条件队列，将已取消的所有节点清除出列</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">// t重新赋值一下，因为last可能改变了</span></span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意这里，node在初始化的时候，会指定ws为CONDITION</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="comment">// t == null 表示队列此时为空，初始化firstWaiter</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;<span class="comment">// 入队尾</span></span><br><span class="line">    lastWaiter = node;<span class="comment">// 将尾指针指向新建的node</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="unlinkCancelledWaiters"><a href="#unlinkCancelledWaiters" class="headerlink" title="unlinkCancelledWaiters"></a>unlinkCancelledWaiters</h4><p>unlinkCancelledWaiters用于清除队列中已经取消等待的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlinkCancelledWaiters</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="comment">// trail这里表示取消节点的前驱节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">trail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// t会从头到尾遍历这个单链表</span></span><br><span class="line">    <span class="keyword">while</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// next用于保存下一个</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> t.nextWaiter;</span><br><span class="line">        <span class="comment">// 如果发现当前这个节点 不是 condition了， 那么考虑移除它</span></span><br><span class="line">        <span class="comment">// 下面是单链表的移除节点操作 简单来说就是 trail.next = t.next</span></span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            t.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 说明first就是不是condition了</span></span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="literal">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//trail.next = t.next</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            <span class="comment">// trail后面没东西，自然trail就是lastWaiter了</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前节点是一直跟到不是condition节点的上一个</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;</span><br><span class="line">        <span class="comment">// 向后遍历 t = t.next</span></span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fullyRelease"><a href="#fullyRelease" class="headerlink" title="fullyRelease"></a>fullyRelease</h4><p>将节点加入等待队列中后，就需要完全释放线程拥有的独占锁了，<strong>完全释放</strong>针对重入锁的情况。</p><p>我们看到这个方法返回了一个savedState变量，简单的理解就是保存状态。我们知道重入锁的state由重入的次数，如果一个state为N，我们可以认为它持有N把锁。</p><p><code>await()</code>方法必须将state置0，也就是完全释放锁，后面的线程才能获取到这把锁，置0之后，我们需要用个变量标记一下，也就是这里的savedState。这样它被重新唤醒的时候，我们就知道，他需要获取savedState把锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前的state值，重入次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 释放N = savedState资源</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果获取失败，将会将节点设置为取消状态，并抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="等待进入阻塞队列"><a href="#等待进入阻塞队列" class="headerlink" title="等待进入阻塞队列"></a>等待进入阻塞队列</h4><p>完全释放锁之后，将会来到这几步，如果这个节点的线程不在同步队列中，说明该线程还不具备竞争锁的资格，将被一直挂起，这里的同步队列指的是AQS的阻塞队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 如果这个节点的线程不在同步队列中，说明该线程还不具备竞争锁的资格，会一直挂起</span></span><br><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    <span class="comment">// 挂起线程</span></span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 如果线程中断，退出</span></span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isOnSyncQueue"><a href="#isOnSyncQueue" class="headerlink" title="isOnSyncQueue"></a>isOnSyncQueue</h4><p>判断节点是不是已经到阻塞队列中了，如果是的话，就直接返回true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOnSyncQueue</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 节点的等待状态还是condition表示还在等待队列中</span></span><br><span class="line">    <span class="comment">// 2. node.prev == null 表示还没移到阻塞队列中[prev和next都是阻塞队列中用的]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果node已经有了后继节点，表示已经在阻塞队列中了</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="literal">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * node.prev can be non-null, but not yet on queue because</span></span><br><span class="line"><span class="comment">     * the CAS to place it on queue can fail. So we have to</span></span><br><span class="line"><span class="comment">     * traverse from tail to make sure it actually made it.  It</span></span><br><span class="line"><span class="comment">     * will always be near the tail in calls to this method, and</span></span><br><span class="line"><span class="comment">     * unless the CAS failed (which is unlikely), it will be</span></span><br><span class="line"><span class="comment">     * there, so we hardly ever traverse much.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 来到这里的情况：ws != condition &amp;&amp; node.prev != null &amp;&amp; node.next == null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 想想：为什么node.prev != null不能作为判断不在阻塞队列的依据呢？</span></span><br><span class="line">    <span class="comment">// CAS首先设置node.prev 指向tail，这个时候node.prev 是不为null的，但CAS可能会失败</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="findNodeFromTail"><a href="#findNodeFromTail" class="headerlink" title="findNodeFromTail"></a>findNodeFromTail</h4><p>从阻塞队列的尾部向前遍历，如果找到这个node，表示它已经在了，那就返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">findNodeFromTail</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 已经有了</span></span><br><span class="line">        <span class="keyword">if</span> (t == node)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 尾都没有，找啥呢，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 一直往前找</span></span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="signal-唤醒方法原理"><a href="#signal-唤醒方法原理" class="headerlink" title="signal()唤醒方法原理"></a>signal()唤醒方法原理</h3><p>线程在某个ConditionObject对象上调用<code>signal()</code>方法后，等待队列中的<code>firstWaiter</code>会被加入同步队列中，等待节点被唤醒</p><p><img src="/p/7aaa01f1/22cd093d1bff4564ef62b3acba05f492.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 一样的，必须占有当前这个锁才能用signal方法</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="doSignal"><a href="#doSignal" class="headerlink" title="doSignal"></a>doSignal</h4><p><code>doSignal()</code>方法会从头到尾遍历条件队列，找到需要移到同步队列的节点。</p><ul><li>这里的while循环表示，如果first没有转移成功，就接着判断first后面的节点是不是需要转移。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// firstWaiter 指向first的下一个</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 如果first是最后一个且要被移除了，就将last置null</span></span><br><span class="line">            lastWaiter = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// first断绝与条件队列的连接</span></span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// fisrt转移失败，就看看后面是不是需要的</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="transferForSignal"><a href="#transferForSignal" class="headerlink" title="transferForSignal"></a>transferForSignal</h4><p><code>transferForSignal</code>该方法将节点从条件队列转移到阻塞队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * CAS操作尝试将Condition的节点的ws改为0</span></span><br><span class="line"><span class="comment">     * 如果失败，意味着：节点的ws已经不是CONDITION，说明节点已经被取消了</span></span><br><span class="line"><span class="comment">     * 如果成功，则该节点的状态ws被改为0了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 通过enq方法将node自旋的方式加入同步队列队尾</span></span><br><span class="line"><span class="comment">     * 这里放回的p是node在同步队列的前驱节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">    <span class="comment">// ws大于0 的情况只有 cancenlled，表示node的前驱节点取消了争取锁，那直接唤醒node线程</span></span><br><span class="line">    <span class="comment">// ws &lt;= 0 会使用cas操作将前驱节点的ws置为signal，如果cas失败也会唤醒node</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自旋的方式入队</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="comment">// 返回的是node的前驱节点</span></span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体流程如下：</p><ol><li>通过enq()方法自旋（该方法已经介绍过）将条件队列中的头节点放入AQS同步队列尾部，并获取它在AQS队列中的前驱节点。</li><li>如果前驱节点的状态是取消状态，或者设置前驱节点为Signal状态失败，就唤醒当前节点的线程；否则节点在同步队列的尾部，参与排队。</li><li>同步队列中的线程被唤醒后，表示重新获取了显式锁，然后继续执行condition.await()语句后面的临界区代码。</li></ol><h3 id="唤醒线程"><a href="#唤醒线程" class="headerlink" title="唤醒线程"></a>唤醒线程</h3><p><code>LockSupport.park(this)</code>挂起的线程是什么时候唤醒的：</p><ol><li>signal方法将节点转移到同步队列中，且获取到了锁或者对前驱节点的cas操作失败，调用了<code>LockSupport.unpark(node.thread);</code>方法。</li><li>在park的时候，另外一个线程对挂起的线程进行了中断。</li></ol><p>一旦signal之后，节点被成功转移到同步队列后，这时下面这个循环就会退出了，继续回到这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 如果这个节点的线程不在同步队列中，说明该线程还不具备竞争锁的资格，会一直挂起</span></span><br><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    <span class="comment">// 挂起线程</span></span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 如果线程中断，退出</span></span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="interruptMode"><a href="#interruptMode" class="headerlink" title="interruptMode"></a>interruptMode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** await 返回的时候，需要重新设置中断状态 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REINTERRUPT</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line"><span class="comment">/** await 返回的时候，需要抛出 InterruptedException 异常 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THROW_IE</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">/** interruptMode取0的时候表示在await()期间，没有发生中断 */</span></span><br></pre></td></tr></table></figure><h4 id="checkInterruptWhileWaiting"><a href="#checkInterruptWhileWaiting" class="headerlink" title="checkInterruptWhileWaiting"></a>checkInterruptWhileWaiting</h4><p>该方法用于判断该线程是否在挂起期间发生了中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?<span class="comment">// 如果处于中断状态，返回true，且将重置中断状态</span></span><br><span class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :<span class="comment">// 如果中断了，判断何时中断</span></span><br><span class="line">        <span class="number">0</span>; <span class="comment">// 没有中断， 返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="transferAfterCancelledWait"><a href="#transferAfterCancelledWait" class="headerlink" title="transferAfterCancelledWait"></a>transferAfterCancelledWait</h4><p>该方法判断何时中断，是否在signal之前。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferAfterCancelledWait</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试使用CAS操作将node 的ws设置为0</span></span><br><span class="line">    <span class="comment">// 如果成功，说明在signal方法之前中断就已经发生：</span></span><br><span class="line">    <span class="comment">// 原因在于：signal如果在此之前发生，必然已经cas操作将ws设置为0了，这里不可能设置成功</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// 就算中断了，也将节点入队</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If we lost out to a signal(), then we can&#x27;t proceed</span></span><br><span class="line"><span class="comment">     * until it finishes its enq().  Cancelling during an</span></span><br><span class="line"><span class="comment">     * incomplete transfer is both rare and transient, so just</span></span><br><span class="line"><span class="comment">     * spin.</span></span><br><span class="line"><span class="comment">     * 这里就是signal之后发生的中断</span></span><br><span class="line"><span class="comment">     * 但是signal可能还在进行转移中，这边自旋等一下它完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.<span class="keyword">yield</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理中断状态"><a href="#处理中断状态" class="headerlink" title="处理中断状态"></a>处理中断状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一部分</span></span><br><span class="line"><span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">    interruptMode = REINTERRUPT;</span><br><span class="line"><span class="comment">// 第二部分</span></span><br><span class="line"><span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">    unlinkCancelledWaiters(); <span class="comment">// 清除取消的节点</span></span><br><span class="line"><span class="comment">// 第三部分</span></span><br><span class="line"><span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">    reportInterruptAfterWait(interruptMode);</span><br></pre></td></tr></table></figure><h5 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a><strong>第一部分</strong></h5><p>signal唤醒的线程并不会立即获取到资源，从while循环退出后，会通过acquireQueued方法加入获取同步状态的竞争中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted; <span class="comment">// </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acquireQueued方法返回时，表示已经获取到了锁，且返回的是interrupted值，如果返回true，表示已经被中断。</p><p>接着判断<code>interruptMode != THROW_IE</code>表示是在signal之后发生的中断，需要重新中断当前线程，将interruptMode设置为REINTERRUPT。</p><h5 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二部分</span></span><br><span class="line"><span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">    unlinkCancelledWaiters(); <span class="comment">// 清除取消的节点</span></span><br></pre></td></tr></table></figure><p>前面说了，signal会将节点移到同步队列中，最后一步需要和条件队列断开关系，也就是：<code>node.nextWaiter = null</code>，但这是想象中比较正常的情况，如果在signal之前被中断，节点也会被加入同步队列中，这时其实是没有调用这个断开关系的。</p><p>因此这边做一点处理，<code>unlinkCancelledWaiters()</code>逻辑上面也说过了，可以回过头去看看，主要是清除队列中已经取消等待的节点。</p><h5 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h5><p>最后一个部分，就是对两种interruptMode的情况进行处理，看看代码就知道了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reportInterruptAfterWait</span><span class="params">(<span class="type">int</span> interruptMode)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// signal 之前的中断， 需要抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// signal 之后发生的中断， 需要重新中断</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AQS的实际应用"><a href="#AQS的实际应用" class="headerlink" title="AQS的实际应用"></a>AQS的实际应用</h2><p>AQS建立在CAS原子操作和volatile可见性变量的基础之上，为上层的显式锁、同步工具类、阻塞队列、线程池、并发容器、Future异步工具提供线程之间同步的基础设施。所以，AQS在JUC框架中的使用是非常广泛的。</p><p><img src="/p/7aaa01f1/a36c0ff5720f3d75bb709bfa58cee1ba.png"></p><script>var description="为了减少由于无效争夺导致的资源浪费和性能恶化，一般都基于队列进行排队与削峰。"</script>]]></content>
      
      
      <categories>
          
          <category> 多线程编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AQS抽象同步器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC显式锁的原理与实战</title>
      <link href="/p/de78061e.html"/>
      <url>/p/de78061e.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="显式锁"><a href="#显式锁" class="headerlink" title="显式锁"></a>显式锁</h2><p>使用Java内置锁时，不需要通过Java代码显式地对同步对象的监视器进行抢占和释放，这些工作由JVM底层完成，而且任何一个Java对象都能作为一个内置锁使用，所以Java的对象锁使用起来非常方便。</p><p>但是，Java内置锁的功能相对单一，不具备一些比较高级的锁功能，比如：</p><ol><li>限时抢锁：在抢锁时设置超时时长，如果超时还未获得锁就放弃，不至于无限等下去。</li><li>可中断抢锁：在抢锁时，外部线程给抢锁线程发一个中断信号，就能唤起等待锁的线程，并终止抢占过程。</li><li>多个等待队列：为锁维持多个等待队列，以便提高锁的效率。比如在生产者-消费者模式实现中，生产者和消费者共用一把锁，<br>该锁上维持两个等待队列，即一个生产者队列和一个消费者队列。</li></ol><p>除了以上功能问题之外，Java对象锁还存在性能问题。在竞争稍微激烈的情况下，Java对象锁会膨胀为重量级锁（基于操作系统的<br>Mutex Lock实现），而重量级锁的线程阻塞和唤醒操作需要进程在内核态和用户态之间来回切换，导致其性能非常低。所以，迫切需要提供一种新的锁来提升争用激烈场景下锁的性能。</p><p><strong>Java显式锁就是为了解决这些Java对象锁的功能问题、性能问题而生的</strong>。JDK 5版本引入了Lock接口，Lock是Java代码级别的锁。为了与Java对象锁相区分，Lock接口叫作显式锁接口，其对象实例叫作显式锁对象。</p><h2 id="显式锁Lock接口"><a href="#显式锁Lock接口" class="headerlink" title="显式锁Lock接口"></a>显式锁Lock接口</h2><p>JDK 5版本引入了java.util.concurrent并发包，简称为JUC包，里面提供了各种高并发工具类，通过此JUC工具包可以在Java代码中实现功能非常强大的多线程并发操作。所以，Java显式锁也叫JUC显式锁。</p><blockquote><p>JUC出自并发大师Doug Lea之手，Doug Lea对Java并发性能的提升做出了巨大的贡献。除了实现JUC包外，Doug Lea还提供了高并发IO模式——Reactor模式多个版本的参考实现。</p></blockquote><p>Lock接口位于<code>java.util.concurrent.locks</code>包中，是JUC显式锁的一个抽象，Lock接口的主要抽象方法如表所示。</p><table><thead><tr><th>方法签名</th><th>功能描述</th></tr></thead><tbody><tr><td><code>void lock()</code></td><td>获取锁。若锁不可用，调用线程会阻塞，直至获取到锁</td></tr><tr><td><code>void lockInterruptibly() throws InterruptedException</code></td><td>获取锁，该方法能响应中断，等待锁时若被中断则抛出<code>InterruptedException</code>，同时清除线程中断状态</td></tr><tr><td><code>boolean tryLock()</code></td><td>尝试获取锁，锁可用则获取并返回<code>true</code>；若不可用，立即返回<code>false</code>，线程不阻塞</td></tr><tr><td><code>boolean tryLock(long time, TimeUnit unit) throws InterruptedException</code></td><td>在指定时长内尝试获取锁，若在时长内获取到锁返回<code>true</code>，超时未获取则返回<code>false</code>，期间可响应中断</td></tr><tr><td><code>void unlock()</code></td><td>释放锁，通常需搭配<code>lock</code>系列方法在<code>finally</code>块中调用，确保锁能正常释放</td></tr><tr><td><code>Condition newCondition()</code></td><td>创建一个与该锁绑定的条件对象，用于线程间复杂的同步控制，像实现等待 &#x2F; 通知机制</td></tr></tbody></table><p>JUC包中提供了一系列的显式锁实现类（如ReentrantLock），当然也允许应用程序提供自定义的锁实现类。与synchronized关键字不同，显式锁不再作为Java内置特性来实现，而是作为Java语言可编程特性来实现。这就为多种不同功能的锁实现留下了空间，各种锁实现可能有不同的调度算法、性能特性或者锁定语义。<br>从Lock提供的接口方法可以看出，显式锁至少比Java内置锁多了以下优势：</p><ul><li><strong>可中断获取锁</strong><br>使用synchronized关键字获取锁的时候，如果线程没有获取到被阻塞，阻塞期间该线程是不响应中断信号（interrupt）的；而调用<code>Lock.lockInterruptibly()</code>方法获取锁时，如果线程被中断，线程将抛出中断异常。</li><li><strong>可非阻塞获取锁</strong><br>使用synchronized关键字获取锁时，如果没有成功获取，线程只有被阻塞；而调用<code>Lock.tryLock()</code>方法获取锁时，如果没有获取成功，线程也不会被阻塞，而是直接返回false。</li><li><strong>可限时抢锁</strong><br>调用<code>Lock.tryLock(long time,TimeUnit unit)</code>方法，显式锁可以设置限定抢占锁的超时时间。而在使用synchronized关键字获取锁时，如果不能抢到锁，线程只能无限制阻塞。</li></ul><p>除了以上能通过Lock接口直接观察出来的三点优势之外，显式锁还有不少其他的优势，稍后在介绍显式锁种类繁多的实现类时，大家就能感觉到。</p><h2 id="可重入锁ReentrantLock"><a href="#可重入锁ReentrantLock" class="headerlink" title="可重入锁ReentrantLock"></a>可重入锁ReentrantLock</h2><p>ReentrantLock是JUC包提供的显式锁的一个基础实现类，ReentrantLock类实现了Lock接口，它拥有与synchronized相同的并发性和内存语义，但是<strong>拥有了限时抢占、可中断抢占等一些高级锁特性</strong>。此外，ReentrantLock基于内置的抽象队列同步器（Abstract Queued Synchronized，AQS）实现，在争用激烈的场景下，能表现出表内置锁更佳的性能。</p><p>ReentrantLock是一个可重入的独占（或互斥）锁，其中两个修饰词的含义为：</p><ul><li><p><strong>可重入</strong>的含义：表示该锁能够支持一个线程对资源的重复加锁，也就是说，一个线程可以多次进入同一个锁所同步的临界区代码<br>块。比如，同一线程在外层函数获得锁后，在内层函数能再次获取该锁，甚至多次抢占到同一把锁。<br>下面是一段对可重入锁进行两次抢占和释放的伪代码，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lock.lock(); <span class="comment">// 第一次获取锁</span></span><br><span class="line">lock.lock(); <span class="comment">// 第二次获取锁，重新进入 </span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">// 临界区代码块 </span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">    lock.unlock(); <span class="comment">// 第二次释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>独占</strong>的含义：在同一时刻只能有一个线程获取到锁，而其他获取锁的线程只能等待，只有拥有锁的线程释放了锁后，其他的线程<br>才能够获取锁。</p></li><li><p>一个简单地使用ReentrantLock进行同步累加的演示案例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread1.join();</span><br><span class="line">            thread2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最终累加结果: &quot;</span> + count); <span class="comment">// 最终累加结果: 2000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="使用显式锁的模板代码"><a href="#使用显式锁的模板代码" class="headerlink" title="使用显式锁的模板代码"></a>使用显式锁的模板代码</h2><p>因为JUC中的显式锁都实现了Lock接口，所以不同类型的显式锁对象的使用方法都是模板化的、套路化的.</p><h3 id="使用lock-方法抢锁的模板代码"><a href="#使用lock-方法抢锁的模板代码" class="headerlink" title="使用lock()方法抢锁的模板代码"></a>使用lock()方法抢锁的模板代码</h3><p>通常情况下，大家会调用lock()方法进行<strong>阻塞式</strong>的锁抢占，其模板代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建锁对象，SomeLock为Lock的某个实现类，如ReentrantLock</span></span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SomeLock</span>(); </span><br><span class="line">lock.lock(); <span class="comment">//step1：抢占锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">//step2：抢锁成功，执行临界区代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> lock.unlock(); <span class="comment">//step3：释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上抢锁模板代码有以下几个需要注意的要点：</p><ol><li><strong>释放锁操作<code>lock.unlock()</code>必须在try-catch结构的finally块中执行</strong>，否则，如果临界区代码抛出异常，锁就有可能永远得不到释放。</li><li><strong>抢占锁操作<code>lock.lock()</code>必须在try语句块之外</strong>，而不是放在try语句块之内。为什么呢？<ul><li>原因之一是lock()方法没有申明抛出异常，所以可以不包含到try块中；</li><li>原因之二是lock()方法并不一定能够抢占锁成功，如果没有抢占成功，当然也就不需要释放锁，而且在没有占有锁的情况下去释放锁，可能会导致运行时异常。</li></ul></li><li><strong>在抢占锁操作<code>lock.lock()</code>和try语句之间不要插入任何代码</strong>，避免抛出异常而导致释放锁操作<code>lock.unlock()</code>执行不到，导致锁无法被释放。</li></ol><h3 id="调用tryLock-方法非阻塞抢锁的模板代码"><a href="#调用tryLock-方法非阻塞抢锁的模板代码" class="headerlink" title="调用tryLock()方法非阻塞抢锁的模板代码"></a>调用tryLock()方法非阻塞抢锁的模板代码</h3><p>lock()是阻塞式抢占，在没有抢到锁的情况下，当前线程会阻塞。如果不希望线程阻塞，可以调用tryLock()方法抢占锁。<strong>tryLock()是非阻塞抢占，在没有抢到锁的情况下，当前线程会立即返回，不会被阻塞。</strong></p><p>调用tryLock()方法非阻塞抢占锁，大致的模板代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建锁对象，SomeLock为Lock的某个实现类，如ReentrantLock</span></span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SomeLock</span>();</span><br><span class="line"><span class="keyword">if</span> (lock.tryLock()) &#123; <span class="comment">// step1：尝试抢占锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// step2：抢锁成功，执行临界区代码</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// step3：释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// step4：抢锁失败，执行后备动作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>tryLock()</code>方法时，线程拿不到锁就立即返回，这种处理方式在实际开发中使用不多，但是其重载版本<code>tryLock(long  time,TimeUnit unit)</code>方法在限时阻塞抢锁的场景中非常有用。</p><h3 id="调用tryLock-long-time-TimeUnit-unit-方法"><a href="#调用tryLock-long-time-TimeUnit-unit-方法" class="headerlink" title="调用tryLock(long time,TimeUnit unit)方法"></a>调用tryLock(long time,TimeUnit unit)方法</h3><p>tryLock(long time,TimeUnit unit)方法用于限时抢锁，该方法在抢锁时会进行一段时间的阻塞等待，其中的time参数代表最大的阻塞时长，unit参数为时长的单位（如秒）。</p><p>调用tryLock(long time,TimeUnit unit)方法限时抢锁，其大致的代码模板如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建锁对象，SomeLock为Lock的某个实现类，如ReentrantLock</span></span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SomeLock</span>();</span><br><span class="line"><span class="comment">// 抢锁时阻塞一段时间，如1秒</span></span><br><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123; <span class="comment">// step1：限时阻塞抢占</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// step2：抢锁成功，执行临界区代码</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// step3：释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 限时抢锁失败，执行后备操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="显式锁进行“等待-通知”"><a href="#显式锁进行“等待-通知”" class="headerlink" title="显式锁进行“等待-通知”"></a>显式锁进行“等待-通知”</h2><p>在前面介绍Java的线程间通信机制时，基于Java内置锁实现一种简单的“等待-通知”方式的线程间通信：通过Object对象的<code>wait</code>、<code>notify</code>两类方法作为开关信号，用来完成通知方线程和等待方线程之间的通信。</p><p>“等待-通知”方式的线程间通信机制，具体来说是指一个线程A调用了同步对象的wait()方法进入等待状态，而另一线程B调用了同步<br>对象的<code>notify()</code>或者<code>notifyAll()</code>方法去唤醒等待线程，当线程A收到线程B的唤醒通知后，就可以重新开始执行了。</p><p>需要特别注意的是，在通信过程中，线程需要拥有同步对象的监视器，<strong>在执行Object对象的wait、notify方法之前，线程必须先通过抢占到内置锁而成为其监视器的Owner</strong>。</p><p>与Object对象的wait、notify两类方法相类似，基于Lock显式锁，JUC也为大家提供了一个用于线程间进行“等待-通知”方式通信的接口——<code>java.util.concurrent.locks.Condition</code>。</p><h3 id="Condition接口的主要方法"><a href="#Condition接口的主要方法" class="headerlink" title="Condition接口的主要方法"></a>Condition接口的主要方法</h3><ul><li>Condition类的await方法和Object类的wait方法等效。</li><li>Condition类的signal方法和Object类的notify方法等效。</li><li>Condition类的signalAll方法和Object类的notifyAll方法等效。</li></ul><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>await()</td><td>使当前线程等待，直到被通知（signal）或中断。它会释放当前持有的锁，进入等待状态。</td></tr><tr><td>awaitUninterruptibly()</td><td>和 await () 类似，不过这个方法不会响应中断，线程会一直处于等待状态直到被通知。</td></tr><tr><td>signal()</td><td>唤醒一个等待在这个 Condition 上的线程。</td></tr><tr><td>signalAll()</td><td>唤醒所有等待在这个 Condition 上的线程。</td></tr></tbody></table><p>Condition对象的signal（通知）方法和同一个对象的await（等待）方法是一一配对使用的，也就是说，一个Condition对象的signal（或signalAll）方法不能去唤醒其他Condition对象上的await线程。</p><p>Condition对象是基于显式锁的，所以不能独立创建一个Condition对象，而是需要借助于显式锁实例去获取其绑定的Condition对象。不过，每一个<strong>Lock显式锁实例都可以有任意数量的Condition对象</strong>。具体来说，可以通过<code>lock.newCondition()</code>方法去获取一个与当前显式锁绑定的Condition实例，然后通过该Condition实例进行“等待-通知”方式的线程间通信。</p><h3 id="显式锁Condition演示案例"><a href="#显式锁Condition演示案例" class="headerlink" title="显式锁Condition演示案例"></a>显式锁Condition演示案例</h3><p>基于Condition的“等待-通知”通信机制实现一个更高性能的生产者-消费者程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] buffer = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">putIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">takeIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者往缓冲区放入数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> value)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 当缓冲区已满时，等待</span></span><br><span class="line">            <span class="keyword">while</span> (count == buffer.length) &#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            buffer[putIndex] = value;</span><br><span class="line">            putIndex = (putIndex + <span class="number">1</span>) % buffer.length;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 放入数据后，通知消费者缓冲区有数据了</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者从缓冲区取出数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 当缓冲区为空时，等待</span></span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> buffer[takeIndex];</span><br><span class="line">            takeIndex = (takeIndex + <span class="number">1</span>) % buffer.length;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="comment">// 取出数据后，通知生产者缓冲区有空位了</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Buffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Buffer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.put(i);</span><br><span class="line">                    System.out.println(<span class="string">&quot;生产者生产了: &quot;</span> + i);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> buffer.take();</span><br><span class="line">                    System.out.println(<span class="string">&quot;消费者消费了: &quot;</span> + value);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producerThread.start();</span><br><span class="line">        consumerThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            producerThread.join();</span><br><span class="line">            consumerThread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p>LockSupport是JUC提供的一个线程阻塞与唤醒的工具类，该工具类可以<strong>让线程在任意位置阻塞和唤醒</strong>，其所有的方法都是静态方法。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>LockSupport的方法主要有两类：<code>park</code>和<code>unpark</code>。park的英文意思为停车，如果把Thread看成一辆车的话，<code>park()</code>方法就是让车停下，其作用是将调用<code>park()</code>方法的当前线程阻塞；而<code>unpark()方法</code>是让车启动，然后跑起来，其作用是将指定线程Thread唤醒。</p><table><thead><tr><th>方法名</th><th>描述</th><th>参数说明</th></tr></thead><tbody><tr><td><code>park()</code></td><td>无限期阻塞当前线程，直到被中断或者被<code>unpark</code>方法唤醒。</td><td>无参数</td></tr><tr><td><code>unpark(Thread thread)</code></td><td>唤醒指定的被阻塞线程，使其有机会继续执行。</td><td><code>thread</code>：要唤醒的目标线程对象</td></tr><tr><td><code>parkNanos(long nanos)</code></td><td>阻塞当前线程，不过存在超时时间限制，超时后线程会自动恢复执行，也可提前被中断或<code>unpark</code>唤醒。</td><td><code>nanos</code>：阻塞的最长纳秒时间</td></tr><tr><td><code>parkUntil(long deadline)</code></td><td>阻塞当前线程，直至达到指定时间，也可提前被中断或<code>unpark</code>唤醒。</td><td><code>deadline</code>：表示阻塞截止的绝对时间（通常基于<code>System.currentTimeMillis()</code>等计算得出）</td></tr><tr><td><code>park(Object blocker)</code></td><td>无限期阻塞当前线程，同时关联<code>blocker</code>对象，方便诊断工具确定线程阻塞原因。</td><td><code>blocker</code>：用于标识阻塞原因的对象</td></tr><tr><td><code>parkNanos(Object blocker, long nanos)</code></td><td>限时阻塞当前线程，并关联<code>blocker</code>对象，用于辅助分析阻塞相关情况。</td><td><code>blocker</code>：用于标识阻塞原因的对象 <code>nanos</code>：阻塞的最长纳秒时间</td></tr><tr><td><code>getBlocker(Thread t)</code></td><td>获取指定被阻塞线程关联的<code>blocker</code>对象，便于分析线程阻塞原因。</td><td></td></tr></tbody></table><h3 id="LockSupport的演示实例"><a href="#LockSupport的演示实例" class="headerlink" title="LockSupport的演示实例"></a>LockSupport的演示实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSupportExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程开始执行&quot;</span>);</span><br><span class="line">            <span class="comment">// 阻塞当前线程</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程被唤醒，继续执行&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程准备唤醒子线程&quot;</span>);</span><br><span class="line">        <span class="comment">// 唤醒指定线程</span></span><br><span class="line">        LockSupport.unpark(thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程开始执行</span></span><br><span class="line"><span class="comment">// 主线程准备唤醒子线程</span></span><br><span class="line"><span class="comment">// 子线程被唤醒，继续执行</span></span><br></pre></td></tr></table></figure><h3 id="LockSupport-park-和Thread-sleep-的区别"><a href="#LockSupport-park-和Thread-sleep-的区别" class="headerlink" title="LockSupport.park()和Thread.sleep()的区别"></a>LockSupport.park()和Thread.sleep()的区别</h3><p>从功能上说，LockSupport.park()与Thread.sleep()方法类似，都是让线程阻塞，二者的区别如下：</p><table><thead><tr><th>对比项</th><th>LockSupport.park()</th><th>Thread.sleep()</th></tr></thead><tbody><tr><td>唤醒方式</td><td>可通过LockSupport.unpark()从外部唤醒</td><td>只能等待设定时间结束自行唤醒</td></tr><tr><td>异常处理</td><td>不需要捕获中断异常</td><td>声明了InterruptedException中断异常，调用者需捕获或再抛出</td></tr><tr><td>中断响应</td><td>不会抛出InterruptedException异常，仅设置线程中断标志，需检查Thread.interrupted()</td><td>会抛出InterruptedException异常</td></tr><tr><td>阻塞灵活性</td><td>能更精准、灵活地阻塞、唤醒指定线程</td><td>相对不够灵活，按指定时间阻塞线程</td></tr><tr><td>方法性质</td><td>调用Unsafe类的Native方法实现，本身非Native方法</td><td>本身就是Native方法</td></tr><tr><td>附加功能</td><td>允许设置Blocker对象，供监视诊断工具确定阻塞原因</td><td>无</td></tr><tr><td>使用场景</td><td>适用于需要灵活控制线程阻塞和唤醒的场景，如线程间的复杂协作、实现自定义的锁机制、线程池中的线程管理等</td><td>常用于需要让线程暂停一段时间的场景，如定时任务的间隔控制、模拟网络延迟、控制并发访问的频率等</td></tr></tbody></table><h3 id="LockSupport-park-与Object-wait-的区别"><a href="#LockSupport-park-与Object-wait-的区别" class="headerlink" title="LockSupport.park()与Object.wait()的区别"></a>LockSupport.park()与Object.wait()的区别</h3><p>从功能上说，LockSupport.park()与Object.wait()方法也类似，都是让线程阻塞，二者的区别如下：</p><table><thead><tr><th>对比项</th><th>LockSupport.park()</th><th>Object.wait()</th></tr></thead><tbody><tr><td>阻塞和唤醒机制</td><td>通过<code>LockSupport.unpark(Thread thread)</code>唤醒，可先唤醒再阻塞，唤醒关系灵活</td><td>需搭配<code>Object.notify()</code>或<code>Object.notifyAll()</code>，在同步代码块或方法中，先阻塞后才能被唤醒</td></tr><tr><td>所属类与依赖条件</td><td><code>java.util.concurrent.locks.LockSupport</code>类的方法，不依赖锁机制或同步代码块</td><td><code>java.lang.Object</code>类的方法，必须在<code>synchronized</code>代码块或同步方法中调用</td></tr><tr><td>异常处理</td><td>本身不抛出受检查异常，中断时需通过其他方式处理，如检查<code>Thread.interrupted()</code></td><td>抛出<code>InterruptedException</code>异常，需显式处理</td></tr><tr><td>线程状态与可见性</td><td>线程状态通常为<code>WAITING</code>或<code>TIMED_WAITING</code>，阻塞状态对其他线程可见性更直接</td><td>线程状态变为<code>WAITING</code>或<code>TIMED_WAITING</code>，需通过获取同一对象监视器锁来感知状态变化</td></tr><tr><td>使用场景</td><td>适用于灵活控制线程阻塞和唤醒，如线程间复杂协作、自定义锁机制、线程池管理等</td><td>适用于基于对象监视器锁的简单线程协作，如传统生产者 - 消费者模型</td></tr><tr><td>提前唤醒情况</td><td>在<code>LockSupport.park()</code>执行之前去执行<code>LockSupport.unpark()</code>，不会抛出任何异常，是被允许的</td><td>如果在<code>Object.wait()</code>执行之前去执行<code>Object.notify()</code>唤醒，会抛出<code>IllegalMonitorStateException</code>异常，是不被允许的</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.fulsun._4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSupportDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        testLockSupport2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testLockSupport2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 使当前线程睡眠1秒，模拟一些前置操作</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 即将进入无限时阻塞&quot;</span>);</span><br><span class="line">            <span class="comment">// 使用LockSupport.park()阻塞当前线程</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被重新唤醒了&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;演示线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提前唤醒一次没有使用LockSupport.park()阻塞的线程，这是允许的，不会有异常</span></span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">        <span class="comment">// 再提前唤醒一次没有调用LockSupport.park()阻塞的线程，多次提前唤醒也是允许的</span></span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三次唤醒，此时线程可能已经处于被park阻塞的状态（因为前面线程已经睡了1秒后执行了park）</span></span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 主线程再等待一会儿，确保有足够时间看到子线程的完整执行情况</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleepSeconds</span><span class="params">(<span class="type">int</span> seconds)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(seconds * <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示线程 即将进入无限时阻塞</span></span><br><span class="line"><span class="comment">// 演示线程 被重新唤醒了</span></span><br></pre></td></tr></table></figure><p>通过结果可以看出，前两次LockSupport.unpark(t1)唤醒操作没有发生任何作用，因为线程t1还没有被LockSupport.park()阻塞。<strong>只有在被LockSupport.park()阻塞之后，LockSupport.unpark(t1)唤醒操作才能将线程t1唤醒</strong>。</p><h2 id="显式锁的分类"><a href="#显式锁的分类" class="headerlink" title="显式锁的分类"></a>显式锁的分类</h2><p>显式锁有多种分类方式，以下是从不同角度进行的分类及相关介绍：</p><h3 id="可重入锁和不可重入锁"><a href="#可重入锁和不可重入锁" class="headerlink" title="可重入锁和不可重入锁"></a>可重入锁和不可重入锁</h3><ul><li><strong>可重入锁（递归锁）</strong>：<ul><li><strong>定义</strong>：一个线程可以多次抢占同一个锁。例如线程A进入外层函数抢占Lock显式锁后，进入内层函数遇到抢占同一Lock显式锁的代码时，依然能抢到该锁。</li><li><strong>实现类</strong>：JUC的ReentrantLock类是可重入锁的标准实现类。</li></ul></li><li><strong>不可重入锁</strong>：<ul><li><strong>定义</strong>：一个线程只能抢占一次同一个锁。线程A进入外层函数抢占锁后，进入内层函数再遇抢占同一锁的代码时，不能抢到该锁，除非提前释放锁，才能第二次抢占。</li></ul></li></ul><h3 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h3><ul><li><strong>悲观锁</strong>：<ul><li><strong>思想及操作</strong>：秉持悲观思想，每次进入临界区操作数据时，都认为别的线程会修改，所以读写数据时都会上锁锁住同步资源，其他线程读写该数据时会阻塞等待拿锁。</li><li><strong>适用场景</strong>：适用于写多读少的场景，高并发写时性能高。</li><li><strong>示例</strong>：Java的synchronized重量级锁是一种悲观锁。</li></ul></li><li><strong>乐观锁</strong>：<ul><li><strong>思想及操作</strong>：秉持乐观思想，拿数据时认为别的线程不会修改，所以不上锁，但更新时会判断在此期间别人有无更新数据，采取先读出当前版本号，然后加锁操作（比较跟上一次版本号，一样则更新），若失败需重复读-比较-写操作。</li><li><strong>适用场景</strong>：适用于读多写少的场景，高并发写时性能低。</li><li><strong>实现方式及示例</strong>：基本通过CAS自旋操作实现，如Java的synchronized轻量级锁是一种乐观锁，JUC中基于抽象队列同步器（AQS）实现的显式锁（如ReentrantLock）都是乐观锁。不过在争用激烈场景下，CAS自旋会出现大量空自旋，导致性能大大降低，但因AQS通过队列使用减少锁争用、空的CAS自旋，所以基于AQS的JUC乐观锁在争用激烈场景下也能比悲观锁性能更佳。</li></ul></li></ul><h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><ul><li><strong>公平锁</strong>：<ul><li><strong>定义</strong>：不同线程抢占锁的机会公平、平等，按抢占时间先后，先抢占锁的线程先被满足，抢锁成功次序体现为FIFO（先进先出）顺序，保障各线程按顺序获取锁。</li><li><strong>示例</strong>：线程A、B、C、D依次获取锁，A先获取锁，处理完释放后唤醒B获取锁，依此类推。</li></ul></li><li><strong>非公平锁</strong>：<ul><li><strong>定义</strong>：不同线程抢占锁的机会非公平、不平等，先抢占锁的线程不一定先被满足，抢锁成功次序不体现FIFO顺序。</li><li><strong>示例</strong>：线程A持有锁时，B、C、D尝试获取锁进入等待队列，A释放锁后唤醒B的过程中，若有线程E尝试请求锁，E可能趁机获取锁（插队），原因是CPU唤醒线程B有上下文切换时间，E可利用此空档期在其他内核上获取锁，目的是提高锁利用效率。</li><li><strong>设置方式</strong>：ReentrantLock实例默认是非公平锁，构造时传入参数true可得到公平锁，ReentrantLock的tryLock()方法是特例，一旦有线程释放锁，正在tryLock的线程能优先取到锁，即便有其他线程在等待队列中。</li></ul></li></ul><h3 id="可中断锁和不可中断锁"><a href="#可中断锁和不可中断锁" class="headerlink" title="可中断锁和不可中断锁"></a>可中断锁和不可中断锁</h3><ul><li><strong>可中断锁</strong>：某线程A占有锁执行临界区代码，线程B阻塞式抢占锁时，若等待时间过长，B不想等待想处理其他事，可中断自己的阻塞等待，这种就是可中断锁。</li><li><strong>不可中断锁</strong>：一旦锁被其他线程占有，自己想抢占只能等待或阻塞，若对方永远不释放锁，自己只能永远等下去，没办法终止等待或阻塞。例如Java的synchronized内置锁是不可中断锁，JUC的显式锁（如ReentrantLock）是可中断锁。</li></ul><h3 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h3><ul><li><strong>独占锁</strong>：<ul><li><strong>定义及特点</strong>：每次只有一个线程能持有的锁，是悲观保守加锁策略，限制读&#x2F;读竞争，若某个只读线程获取锁，其他读线程只能等待，限制读操作并发性，不过读操作不影响数据一致性。</li><li><strong>实现类</strong>：JUC的ReentrantLock类是标准的独占锁实现类。</li></ul></li><li><strong>共享锁</strong>：<ul><li><strong>定义及特点</strong>：允许多个线程同时获取锁，容许线程并发进入临界区，是一种乐观锁，放宽加锁策略，不限制读&#x2F;读竞争，<strong>允许多个读操作线程同时访问共享资源</strong>。</li><li><strong>实现类及使用规则</strong>：JUC的ReentrantReadWriteLock（读写锁）类是共享锁实现类，使用时读操作可多线程一起读，但写操作只能一个线程写，且写入时别的线程不能读。用ReentrantLock替代ReentrantReadWriteLock虽能保证线程安全，但会浪费资源，在读的地方用读锁、写的地方用写锁可提高程序执行效率。</li></ul></li></ul><h2 id="悲观锁和乐观锁-1"><a href="#悲观锁和乐观锁-1" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2><p>独占锁其实就是一种悲观锁，Java的synchronized是悲观锁。悲观锁可以确保无论哪个线程持有锁，都能独占式访问临界区。虽然悲观锁的逻辑非常简单，但是存在不少问题。</p><h3 id="悲观锁存在的问题"><a href="#悲观锁存在的问题" class="headerlink" title="悲观锁存在的问题"></a>悲观锁存在的问题</h3><p>悲观锁总是假设会发生最坏的情况，每次线程读取数据时，也会上锁。这样其他线程在读取数据时就会被阻塞，直到它拿到锁。传统的关系型数据库用到了很多悲观锁，比如行锁、表锁、读锁、写锁等。</p><p>悲观锁机制存在以下问题：</p><ol><li>在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</li><li>一个线程持有锁后，会导致其他所有抢占此锁的线程挂起。</li><li>如果一个优先级高的线程等待一个优先级低的线程释放锁，就会导致线程的优先级倒置，从而引发性能风险。</li></ol><p><strong>解决以上悲观锁的这些问题的有效方式是使用乐观锁去替代悲观锁</strong>。与之类似，数据库操作中的带版本号数据更新、JUC包的原子类，都使用了乐观锁的方式提升性能。</p><h3 id="通过CAS实现乐观锁"><a href="#通过CAS实现乐观锁" class="headerlink" title="通过CAS实现乐观锁"></a>通过CAS实现乐观锁</h3><blockquote><p><strong>乐观锁是一种思想，而CAS是这种思想的一种实现。</strong></p></blockquote><p>乐观锁的操作主要就是两个步骤：</p><ol><li>第一步：冲突检测。</li><li>第二步：数据更新。</li></ol><p>乐观锁一种比较典型的就是CAS原子操作，JUC强大的高并发性能是建立在CAS原子之上的。CAS操作中包含三个操作数：需要操作的内存位置（V）、进行比较的预期原值（A）和拟写入的新值（B）。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置的值更新为新值B；否则处理器不做任何操作。</p><p>CAS操作可以非常清晰地分为两个步骤：</p><ol><li>检测位置V的值是否为A。</li><li>如果是，就将位置V更新为B值；否则不要更改该位置。</li></ol><p>CAS操作的两个步骤其实与乐观锁操作的两个步骤是一致的，都是在冲突检测后进行数据更新。实际上，如果需要完成数据的最终更新，仅仅进行一次CAS操作是不够的，一般情况下，需要进行自旋操作，即不断地循环重试CAS操作直到成功，这也叫<strong>CAS自旋</strong>。</p><p>通过CAS自旋，在不使用锁的情况下实现多线程之间的变量同步，也就是说，在没有线程被阻塞的情况下实现变量的同步，这叫作“非阻塞同步”（Non-Blocking Synchronization），或者说“无锁同步”。使用基于CAS自旋的乐观锁进行同步控制，属于无锁编程（Lock Free）的一种实践。</p><h3 id="自定义不可重入的自旋锁"><a href="#自定义不可重入的自旋锁" class="headerlink" title="自定义不可重入的自旋锁"></a>自定义不可重入的自旋锁</h3><p>自旋锁的基本含义为：当一个线程在获取锁的时候，如果锁已经被其他线程获取，调用者就一直在那里循环检查该锁是否已经被释放，一直到获取到锁才会退出循环。</p><p>CAS自旋锁的实现原理为：抢锁线程不断进行CAS自旋操作去更新锁的owner（拥有者），如果更新成功，就表明已经抢锁成功，退出抢锁方法。如果锁已经被其他线程获取（也就是owner为其他线程），调用者就一直在那里循环进行owner的CAS更新操作，一直到成功才会退出循环。</p><p>作为演示，这里先实现一个简单版本的自旋锁——不可重入的自旋锁，具体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NonReentrantSpinLock</span> &#123;</span><br><span class="line">    <span class="comment">// 使用AtomicBoolean来表示锁的状态，true表示锁已被占用，false表示锁可用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用自旋的方式，不断尝试获取锁，直到成功</span></span><br><span class="line">        <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">            <span class="comment">// 可以在这里添加一些等待策略，例如短暂休眠，避免过度占用CPU</span></span><br><span class="line">            <span class="comment">// Thread.yield();  // 或者Thread.sleep(1);等</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();  <span class="comment">//让出当前剩余的CPU时间片</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁，如果锁可用，则获取锁并返回true，否则返回false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用CAS（Compare And Swap）操作来尝试将锁的状态从false设置为true</span></span><br><span class="line">        <span class="comment">// 如果当前锁的状态是false，就将其设置为true，表示获取锁成功</span></span><br><span class="line">        <span class="comment">// 如果当前锁的状态是true，说明锁已被占用，获取锁失败</span></span><br><span class="line">        <span class="keyword">return</span> locked.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 将锁的状态设置为false，表示锁已释放</span></span><br><span class="line">        locked.set(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细分析以上代码就可以看出，上述NonReentrantSpinLock是不支持重入的，即当一个线程第一次已经获取到了该锁，在锁没有被释放之前，如果又一次重新获取该锁，第二次将不能成功获取到。</p><h3 id="自定义可重入的自旋锁"><a href="#自定义可重入的自旋锁" class="headerlink" title="自定义可重入的自旋锁"></a>自定义可重入的自旋锁</h3><p>为了实现可重入锁，主要思路是通过记录当前持有锁的线程以及重入的次数来实现可重入功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantSpinLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用AtomicBoolean来表示锁的状态，true表示锁已被占用，false表示锁可用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 记录当前持有锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread lockedOwner;</span><br><span class="line">    <span class="comment">// 记录重入的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">holdCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 如果当前线程已经持有锁，增加重入次数并直接返回，实现可重入</span></span><br><span class="line">        <span class="keyword">if</span> (currentThread == lockedOwner) &#123;</span><br><span class="line">            holdCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用自旋的方式，不断尝试获取锁，直到成功</span></span><br><span class="line">        <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">            <span class="comment">// 可以在这里添加一些等待策略，例如短暂休眠，避免过度占用CPU</span></span><br><span class="line">            <span class="comment">// Thread.yield();  // 或者Thread.sleep(1);等</span></span><br><span class="line">            LockSupport.parkNanos(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁，如果锁可用，则获取锁并返回true，否则返回false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 使用CAS（Compare And Swap）操作来尝试将锁的状态从false设置为true</span></span><br><span class="line">        <span class="keyword">if</span> (locked.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="comment">// 获取锁成功，设置当前持有锁的线程为当前线程，并将重入次数设置为1</span></span><br><span class="line">            lockedOwner = currentThread;</span><br><span class="line">            holdCount.set(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 只有当前持有锁的线程才能释放锁</span></span><br><span class="line">        <span class="keyword">if</span> (currentThread == lockedOwner) &#123;</span><br><span class="line">            <span class="comment">// 减少重入次数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> holdCount.decrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果重入次数为0，说明彻底释放锁，将锁状态设置为false，并清除持有锁的线程</span></span><br><span class="line">                locked.set(<span class="literal">false</span>);</span><br><span class="line">                lockedOwner = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CAS可能导致“总线风暴”"><a href="#CAS可能导致“总线风暴”" class="headerlink" title="CAS可能导致“总线风暴”"></a>CAS可能导致“总线风暴”</h3><p>“总线风暴” 是指在计算机系统中，多个处理器或设备频繁地对系统总线进行访问和竞争，导致总线上的数据传输量急剧增加，产生大量的冲突和等待，从而使系统性能严重下降的现象。</p><p><strong>CAS 操作引发总线风暴的原因:</strong></p><ul><li><strong>竞争激烈时的高频操作</strong>：CAS 操作是一种硬件级别的原子操作，用于在多线程环境下实现对共享变量的无锁并发访问。当多个线程同时竞争同一个基于 CAS 的可重入锁时，它们会频繁地执行 CAS 操作来尝试获取锁。如果竞争非常激烈，大量的 CAS 操作会在极短的时间内被发送到系统总线上，导致总线上的数据流量瞬间增大。</li><li><strong>缓存一致性协议的开销</strong>：现代多核处理器系统中，为了保证各个处理器缓存之间的数据一致性，通常采用缓存一致性协议（如 MESI 协议）。当一个线程通过 CAS 操作修改共享变量时，会导致其他处理器缓存中该变量的副本失效，其他处理器需要从主内存中重新读取数据。在高并发情况下，大量的 CAS 操作会使得缓存失效和数据同步操作频繁发生，这些操作都需要通过系统总线来完成，进一步增加了总线的负载。</li><li><strong>重试机制的影响</strong>：在基于 CAS 的可重入锁实现中，当线程获取锁失败时，通常会通过自旋的方式不断重试。这意味着线程会持续地发起 CAS 操作，而不会主动让出 CPU。如果有大量线程都在自旋等待获取锁，那么它们会不断地向总线发送 CAS 请求，使得总线的负载持续处于高位，无法得到缓解。</li></ul><p><strong>总线风暴的影响</strong>:</p><ul><li><strong>系统性能下降</strong>：总线风暴会导致系统总线的利用率急剧下降，因为总线上充斥着大量的 CAS 请求和缓存同步等操作，真正用于有效数据传输和其他正常操作的带宽被严重挤压，从而导致整个系统的性能大幅下降。</li><li><strong>响应时间变长</strong>：由于总线被大量无用的 CAS 操作占据，其他重要的操作（如内存读写、I&#x2F;O 操作等）无法及时得到执行，导致程序的响应时间变长，用户会明显感觉到系统变得卡顿。</li><li><strong>能耗增加</strong>：处理器在不断执行 CAS 操作和处理缓存一致性问题时，需要消耗更多的能量，这不仅会增加硬件的发热量，还会降低系统的能源效率。</li></ul><p>前面讲到，在争用激烈的场景下，Java轻量级锁会快速膨胀为重量级锁，其本质上一是为了减少CAS空自旋，二是为了避免同一时间大量CAS操作所导致的总线风暴。</p><p>那么，<strong>JUC基于CAS实现的轻量级锁如何避免总线风暴呢？答案是：使用队列对抢锁线性进行排队，最大程度上减少了CAS操作数量</strong>。</p><h3 id="CLH自旋锁"><a href="#CLH自旋锁" class="headerlink" title="CLH自旋锁"></a>CLH自旋锁</h3><blockquote><p>JUC中显式锁基于AQS抽象队列同步器，<strong>而AQS是CLH锁的一个变种</strong>，为了方便大家理解AQS的原理（此为Java工程师的必备知识），这里详细介绍一下CLH锁的实现和核心原理。</p></blockquote><p>CLH锁其实就是一种基于队列（具体为单向链表）排队的自旋锁，由于是Craig、Landin和Hagersten三人一起发明的，因此被命名为CLH锁，也叫CLH队列锁。</p><p>简单的CLH锁可以基于单向链表实现，申请加锁的线程首先会通过CAS操作在单向链表的尾部增加一个节点，之后该线程只需要在其前驱节点上进行普通自旋，等待前驱节点释放锁即可。由于CLH锁只有在节点入队时进行一下CAS的操作，在节点加入队列之后，抢锁线程不需要进行CAS自旋，只需普通自旋即可。因此，在争用激烈的场景下，CLH锁能大大减少CAS操作的数量，以避免CPU的总线风暴。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CLHSpinLock</span> &#123;</span><br><span class="line">    <span class="comment">// 指向最后一个加入队列的节点</span></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;QNode&gt; tail = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 当前线程对应的节点</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;QNode&gt; myNode = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁节点类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">QNode</span> &#123;</span><br><span class="line">        <span class="comment">// 表示是否已经获得锁</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建当前线程对应的节点</span></span><br><span class="line">        <span class="type">QNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QNode</span>();</span><br><span class="line">        <span class="comment">// 将当前线程的节点设置到ThreadLocal中</span></span><br><span class="line">        myNode.set(node);</span><br><span class="line">        <span class="comment">// 将新节点设置为tail节点，并获取旧的tail节点</span></span><br><span class="line">        <span class="type">QNode</span> <span class="variable">pred</span> <span class="operator">=</span> tail.getAndSet(node);</span><br><span class="line">        <span class="keyword">if</span> (pred!= <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果存在前驱节点，自旋等待前驱节点释放锁</span></span><br><span class="line">            <span class="keyword">while</span> (pred.locked) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前线程对应的节点</span></span><br><span class="line">        <span class="type">QNode</span> <span class="variable">node</span> <span class="operator">=</span> myNode.get();</span><br><span class="line">        <span class="comment">// 如果tail节点是当前线程的节点，说明没有后续节点在等待锁</span></span><br><span class="line">        <span class="keyword">if</span> (tail.compareAndSet(node, <span class="literal">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// 不需要做任何事情，直接返回</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 还有后续节点在等待锁，将当前节点的locked设置为false，让下一个节点获取锁</span></span><br><span class="line">            node.locked = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 以下是简单的测试代码，用于演示CLH自旋锁的使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CLHSpinLock</span> <span class="variable">clhSpinLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CLHSpinLock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多个线程来模拟并发获取锁的情况</span></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                clhSpinLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadIndex + <span class="string">&quot; 获取到锁&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);  <span class="comment">// 模拟线程持有锁执行任务的时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    clhSpinLock.unlock();</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadIndex + <span class="string">&quot; 释放锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动所有线程</span></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有线程执行完毕</span></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong><code>CLHSpinLock</code>类结构</strong>：<ul><li>内部定义了<code>Node</code>类，它代表等待锁的线程节点，节点中有一个<code>volatile</code>修饰的<code>locked</code>字段，用于表示该节点对应的线程是否获取到锁（初始为<code>true</code>，即未获取到锁，处于等待状态）。</li><li>有一个<code>AtomicReference&lt;Node&gt;</code>类型的<code>tail</code>字段，通过原子操作来维护等待锁的队列尾节点，初始值为<code>null</code>。</li><li>还有一个<code>ThreadLocal&lt;Node&gt;</code>类型的<code>myNode</code>，用于为每个线程存储其对应的节点，保证每个线程都有自己独立的等待节点信息。</li></ul></li><li><strong><code>lock</code>方法逻辑</strong>：<ul><li>首先通过<code>myNode.get()</code>获取当前线程对应的节点。</li><li>然后使用<code>tail.getAndSet(node)</code>原子操作将当前节点设置为尾节点，并获取原来的尾节点（也就是当前线程的前驱节点）。</li><li>如果前驱节点不为<code>null</code>，说明有其他线程在等待队列中，当前线程就会通过自旋（<code>while (pred.locked)</code>循环）等待前驱节点释放锁（即前驱节点的<code>locked</code>变为<code>false</code>）。</li></ul></li><li><strong><code>unlock</code>方法逻辑</strong>：<ul><li>获取当前线程对应的节点后，将该节点的<code>locked</code>字段设置为<code>false</code>，表示释放锁，让后续等待的线程有机会获取锁。并且可以选择调用<code>myNode.remove()</code>来清除线程本地变量中存储的节点，避免可能的内存泄漏问题（在实际应用中根据具体需求决定是否执行此操作）。</li></ul></li><li>在争用激烈的场景下，相比于那种完全依赖持续 CAS 操作来获取锁的普通自旋锁，CLH 锁通过将竞争分散到链表节点上，把大量的 CAS 操作限制在了节点入队这个环节，后续等待过程不再有 CAS 自旋，从而大大减少了整体的 CAS 操作数量，也就能够有效避免因过多 CAS 操作引发的 CPU 总线风暴问题。</li></ol><blockquote><p><strong>优缺点</strong></p></blockquote><ul><li>CLH锁是一种队列锁，其优点是空间复杂度低。如果有N个线程、L个锁，每个线程每次只获取一个锁，那么需要的存储空间是O(L+N)，N个线程有N个Node，L个锁有L个Tail。</li><li>CLH队列锁的一个显著缺点是它在NUMA架构的CPU平台上性能很差。线程在 CLH 锁中需要通过前驱节点来判断是否可以获取锁，这种访问方式在某些情况下可能会导致伪共享问题。因为多个线程可能会频繁访问不同节点的同一缓存行，从而导致缓存行的频繁无效化，影响性能。</li><li><strong>CLH 锁</strong>：更适合在单核处理器或者缓存一致性开销较小的环境中使用，能够有效地实现线程同步。</li><li><strong>MCS 锁</strong>：在多核处理器、高并发且对缓存性能要求较高的场景中，MCS 锁能够更好地发挥其优势，提供更高效的同步机制，减少线程之间的竞争和缓存冲突，提高系统的整体性能和并发处理能力。</li></ul><h3 id="MCS队列锁"><a href="#MCS队列锁" class="headerlink" title="MCS队列锁"></a>MCS队列锁</h3><p>高性能、公平的自旋队列锁。MCS在自身节点上自旋，可以理解为当前线程不断访问本地高速缓存中的变量，因此更适合NUMA结构的CPU。</p><blockquote><p><strong>工作原理</strong></p></blockquote><ul><li><strong>入队</strong>：当一个线程请求锁时，它会创建一个新的 MCS 节点，并将自己相关的信息存入节点中。然后，线程通过原子操作将自己的节点加入到队列尾部。在这个过程中，新节点会与当前的尾节点建立连接，同时更新尾节点的引用，使其指向新加入的节点。</li><li><strong>出队</strong>：当持有锁的线程释放锁时，它会检查自己的节点是否有后继节点。如果有后继节点，就将后继节点中的锁状态标记设置为可以获取锁的状态，通知后继线程可以尝试获取锁，然后将自己的节点从队列中移除；如果没有后继节点，说明队列中没有其他等待锁的线程，就直接将尾节点设置为 null，表示队列为空。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MCS锁节点类，代表每个等待锁的线程对应的节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MCSNode</span> &#123;</span><br><span class="line">    <span class="comment">// 标记当前节点对应的线程是否获取到锁，初始化为false表示未获取到锁</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 指向下一个节点的引用，用于构建链表结构</span></span><br><span class="line">    <span class="keyword">volatile</span> MCSNode next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MCSLock</span> &#123;</span><br><span class="line">    <span class="comment">// 原子引用，指向队列的最后一个节点，初始化为null</span></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;MCSNode&gt; tail = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 线程本地变量，用于存储当前线程对应的节点</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;MCSNode&gt; myNode = ThreadLocal.withInitial(MCSNode::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MCSNode</span> <span class="variable">node</span> <span class="operator">=</span> myNode.get();</span><br><span class="line">        <span class="type">MCSNode</span> <span class="variable">pred</span> <span class="operator">=</span> tail.getAndSet(node);</span><br><span class="line">        <span class="keyword">if</span> (pred!= <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前线程不是第一个请求锁的线程，将前驱节点的next指向自己的节点</span></span><br><span class="line">            node.locked = <span class="literal">false</span>;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="comment">// 自旋等待前驱节点释放锁并通知自己</span></span><br><span class="line">            <span class="keyword">while</span> (!node.locked) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前线程是第一个请求锁的线程，直接获取锁</span></span><br><span class="line">            node.locked = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MCSNode</span> <span class="variable">node</span> <span class="operator">=</span> myNode.get();</span><br><span class="line">        <span class="keyword">if</span> (node.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点没有后继节点，说明没有其他线程等待锁，尝试将尾节点设置为null</span></span><br><span class="line">            <span class="keyword">if</span> (tail.compareAndSet(node, <span class="literal">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果设置失败，说明有新线程在入队过程中，自旋等待新线程完成入队</span></span><br><span class="line">            <span class="keyword">while</span> (node.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将后继节点的locked标记设置为true，通知后继线程可以获取锁</span></span><br><span class="line">        node.next.locked = <span class="literal">true</span>;</span><br><span class="line">        node.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MCS和CLH实现细节对比"><a href="#MCS和CLH实现细节对比" class="headerlink" title="MCS和CLH实现细节对比"></a>MCS和CLH实现细节对比</h3><ul><li><p>队列中Node节点组成的链表结构不同。</p><ul><li>CLH使用前驱指针</li><li>MCS使用后继指针。</li></ul></li><li><p>自旋对象不同。</p><ul><li>CLH是在前驱节点上自旋。【查看前驱节点的Lock状态是否为false】</li><li>MCS是在自身节点上自旋。【查看自身节点的Lock状态是否为false】</li></ul></li><li><p>解锁逻辑不同</p><ul><li>CLH解锁方法是，设置自己的Lock状态为false，解除后继节点的自旋状态。</li><li>MCS解锁方法是，当前节点通过next指针将后继节点的Lock状态设置为false，解除其自旋状态。</li></ul></li></ul><h2 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h2><p>synchronized内置锁是一种非公平锁，<strong>默认情况下ReentrantLock锁也是非公平锁</strong>。</p><h3 id="非公平锁实战"><a href="#非公平锁实战" class="headerlink" title="非公平锁实战"></a>非公平锁实战</h3><p>非公平锁是指多个线程获取锁的顺序并不一定是其申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，抢锁成功的次序不一定体现为FIFO（先进先出）顺序。</p><p>非公平锁的<strong>优点在于吞吐量比公平锁大</strong>，它的<strong>缺点是有可能会导致线程优先级反转或者线程饥饿现象</strong>。</p><p>使用ReentrantLock锁作为非公平锁的实战用例，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NonFairLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建可重入锁，默认的非公平锁</span></span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 创建4个线程</span></span><br><span class="line">        Thread[] tArray = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            tArray[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; lockAndIncrease(lock), <span class="string">&quot;线程&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 启动4个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            tArray[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待4个线程执行完毕</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            tArray[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lockAndIncrease</span><span class="params">(Lock lock)</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始抢占锁&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ^-^ 抢到了锁&quot;</span>);</span><br><span class="line">            sum++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线程<span class="number">0</span> 开始抢占锁</span><br><span class="line">线程<span class="number">3</span> 开始抢占锁</span><br><span class="line">线程<span class="number">2</span> 开始抢占锁</span><br><span class="line">线程<span class="number">1</span> 开始抢占锁</span><br><span class="line">线程<span class="number">0</span> ^-^ 抢到了锁</span><br><span class="line">线程<span class="number">2</span> ^-^ 抢到了锁</span><br><span class="line">线程<span class="number">3</span> ^-^ 抢到了锁</span><br><span class="line">线程<span class="number">1</span> ^-^ 抢到了锁</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>从输出的结果可以看出，各个线程的抢锁次序为：线程0→线程3→线程2→线程1，但是抢到锁的次序为：线程0→线程2→线程3→线程1。所以说，非公平锁是不公平的。</p><h3 id="公平锁实战"><a href="#公平锁实战" class="headerlink" title="公平锁实战"></a>公平锁实战</h3><p>公平锁是指多个线程按照申请锁的顺序来获取锁，抢锁成功的次序体现为FIFO（先进先出）顺序。虽然ReentrantLock锁默认是非公平锁，但可以通过构造器指定该锁为公平<br>锁，具体的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//可重入、公平锁对象</span><br><span class="line">Lock lock = new ReentrantLock(true);</span><br></pre></td></tr></table></figure><h3 id="简单的非公平锁的示例代码"><a href="#简单的非公平锁的示例代码" class="headerlink" title="简单的非公平锁的示例代码"></a>简单的非公平锁的示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义非公平锁类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NonFairLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用AtomicBoolean来表示锁的状态，true表示锁已被占用，false表示锁可用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 用于存储当前持有锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread lockedThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 新请求的线程不管是否有其他线程已经在等待，都直接尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (locked.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">            lockedThread = Thread.currentThread();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果获取锁失败，线程进入阻塞等待状态</span></span><br><span class="line">            <span class="keyword">while</span> (locked.get()) &#123;</span><br><span class="line">                LockSupport.park();</span><br><span class="line">            &#125;</span><br><span class="line">            lockedThread = Thread.currentThread();</span><br><span class="line">            locked.set(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() == lockedThread) &#123;</span><br><span class="line">            locked.set(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// 唤醒其他等待的线程</span></span><br><span class="line">            LockSupport.unpark(getNextWaitingThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个等待的线程（这里简单返回null，实际可根据需要维护等待队列来准确获取）</span></span><br><span class="line">    <span class="keyword">private</span> Thread <span class="title function_">getNextWaitingThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="公平锁的代码示例"><a href="#公平锁的代码示例" class="headerlink" title="公平锁的代码示例"></a>公平锁的代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义公平锁类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FairLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用AtomicBoolean来表示锁的状态，true表示锁已被占用，false表示锁可用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 用于存储当前持有锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread lockedThread;</span><br><span class="line">    <span class="comment">// 等待队列，存储等待获取锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;Thread&gt; waitQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前线程加入等待队列</span></span><br><span class="line">        waitQueue.add(Thread.currentThread());</span><br><span class="line">        <span class="comment">// 循环检查是否轮到当前线程获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前线程是队列头部的线程且锁可用，尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (waitQueue.peek() == Thread.currentThread() &amp;&amp; locked.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">                lockedThread = Thread.currentThread();</span><br><span class="line">                waitQueue.poll();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果还没轮到或者锁不可用，阻塞当前线程</span></span><br><span class="line">                LockSupport.park();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() == lockedThread) &#123;</span><br><span class="line">            locked.set(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// 唤醒等待队列中的下一个线程（如果有）</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">nextThread</span> <span class="operator">=</span> waitQueue.peek();</span><br><span class="line">            <span class="keyword">if</span> (nextThread!= <span class="literal">null</span>) &#123;</span><br><span class="line">                LockSupport.unpark(nextThread);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可中断锁与不可中断锁"><a href="#可中断锁与不可中断锁" class="headerlink" title="可中断锁与不可中断锁"></a>可中断锁与不可中断锁</h2><p>可中断锁是指抢占过程可以被中断的锁，JUC的显式锁（如ReentrantLock）是一个可中断锁。不可中断锁是指抢占过程不可以被中断的锁，如Java的synchronized内置锁就是一个不可中断锁。</p><h3 id="锁的可中断抢占"><a href="#锁的可中断抢占" class="headerlink" title="锁的可中断抢占"></a>锁的可中断抢占</h3><p>在JUC的显式锁Lock接口中，有以下两个方法可以用于可中断抢占：</p><ul><li><p><code>lockInterruptibly()</code></p><p>可中断抢占锁抢占过程中会处理Thread.interrupt()中断信号，如果线程被中断，就会终止抢占并抛出InterruptedException异常。</p></li><li><p><code>tryLock(long timeout,TimeUnit unit)</code></p><p>阻塞式“限时抢占”（在timeout时间内）锁抢占过程中会处理Thread.interrupt()中断信号，如果线程被中断，就会终止抢占并抛出InterruptedException异常。</p></li></ul><p>下面是调用lockInterruptibly()方法进行可中断抢锁的一个简单案例，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptibleLockExample</span> &#123;</span><br><span class="line">    <span class="comment">// 创建可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程1</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 尝试获取锁，可被中断</span></span><br><span class="line">                lock.lockInterruptibly();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 模拟线程执行任务，休眠5秒</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获得锁，开始执行任务&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 捕获中断异常</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被中断&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    lock.unlock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 捕获获取锁时的中断异常</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取锁时被中断&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程2</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 尝试获取锁，可被中断</span></span><br><span class="line">                lock.lockInterruptibly();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 模拟线程执行任务，休眠5秒</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获得锁，开始执行任务&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 捕获中断异常</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被中断&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    lock.unlock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 捕获获取锁时的中断异常</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取锁时被中断&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程1</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="comment">// 启动线程2</span></span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程休眠1秒，确保线程1和线程2有足够时间开始竞争锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中断线程2</span></span><br><span class="line">        thread2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread1 获得锁，开始执行任务</span><br><span class="line">Thread2 获取锁时被中断</span><br><span class="line">Thread1 释放锁</span><br></pre></td></tr></table></figure><h2 id="死锁的监测与中断"><a href="#死锁的监测与中断" class="headerlink" title="死锁的监测与中断"></a>死锁的监测与中断</h2><p><strong>死锁是指两个或两个以上线程因抢占锁而造成的相互等待的现象。</strong>多个线程通过AB-BA模式抢占两个锁是造成多线程死锁比较普遍的原因。</p><p>AB-BA模式的死锁具体表现为：线程X按照先后次序去抢占锁A与锁B，线程Y按照先后次序去抢占锁B与锁A，当线程X抢到锁A再去抢占锁B时，发现已经被其他线程拿走，然而线程Y拿到锁B后再去抢占锁A时，发现已经被其他线程拿走，于是线程X等待其他线程释放锁B，线程Y等待其他线程释放锁A，两个线程互相等待从而造成死锁。</p><p>JDK 8中包含的ThreadMXBean接口提供了多种监视线程的方法，其中包括两个死锁监测的方法，具体如下：</p><ol><li><code>findDeadlockedThreads</code><br>用于检测由于抢占JUC显式锁、Java内置锁引起死锁的线程。</li><li><code>findMonitorDeadlockedThreads</code><br>仅仅用于检测由于抢占Java内置锁引起死锁的线程。</li></ol><p>ThreadMXBean的实例可以通过JVM管理工厂ManagementFactory去获取，具体的获取代码如下：</p><p><code> ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadInfo;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadMXBean;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockDetectionExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建两个线程模拟死锁场景</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock1.lock();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                lock2.lock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock1.unlock();</span><br><span class="line">                lock2.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock2.lock();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                lock1.lock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock2.unlock();</span><br><span class="line">                lock1.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread-2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ThreadMXBean实例</span></span><br><span class="line">        <span class="type">ThreadMXBean</span> <span class="variable">threadMXBean</span> <span class="operator">=</span> ManagementFactory.getThreadMXBean();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环检测是否存在死锁</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">long</span>[] deadlockedThreadIds = threadMXBean.findDeadlockedThreads();</span><br><span class="line">            <span class="keyword">if</span> (deadlockedThreadIds!= <span class="literal">null</span>) &#123;</span><br><span class="line">                ThreadInfo[] threadInfos = threadMXBean.getThreadInfo(deadlockedThreadIds);</span><br><span class="line">                System.out.println(<span class="string">&quot;检测到死锁，涉及的线程信息如下：&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程名称: &quot;</span> + threadInfo.getThreadName());</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程ID: &quot;</span> + threadInfo.getThreadId());</span><br><span class="line">                    System.out.println(<span class="string">&quot;阻塞等待的锁: &quot;</span> + threadInfo.getLockName());</span><br><span class="line">                    System.out.println(<span class="string">&quot;阻塞等待的锁的持有者: &quot;</span> + threadInfo.getLockOwnerName());</span><br><span class="line">                    System.out.println(<span class="string">&quot;---------------------------&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">检测到死锁，涉及的线程信息如下：</span><br><span class="line">线程名称: Thread-<span class="number">2</span></span><br><span class="line">线程ID: <span class="number">21</span></span><br><span class="line">阻塞等待的锁: java.util.concurrent.locks.ReentrantLock$NonfairSync@16b98e56</span><br><span class="line">阻塞等待的锁的持有者: Thread-<span class="number">1</span></span><br><span class="line">---------------------------</span><br><span class="line">线程名称: Thread-<span class="number">1</span></span><br><span class="line">线程ID: <span class="number">20</span></span><br><span class="line">阻塞等待的锁: java.util.concurrent.locks.ReentrantLock$NonfairSync@7ef20235</span><br><span class="line">阻塞等待的锁的持有者: Thread-<span class="number">2</span></span><br></pre></td></tr></table></figure><p>JVM管理工厂ManagementFactory类提供静态方法，返回各种获取JVM信息的Bean实例。我们通过这些Bean实例能获取大量的JVM运行时信息，比如JVM堆的使用情况、GC情况、线程信息等。我们通过JVM运行时信息可以了解正在运行的JVM的情况，以便可以做出相应的参数调整。</p><p>如果是可中断抢占锁（如调用lockInterruptibly()方法等），就可以在监测到死锁发生之后，调用Thread.interrupt()去中断死锁线程，不让死锁线程一直等下去。</p><blockquote><p>ManagementFactory位于JDK的核心包<code>java.lang.management</code>中，该包提供了一系列的管理接口，用于监视和管理JVM以及运行JVM的底层操作系统，它同时允许从本地和远程对正在运行的JVM进行监视和管理。</p></blockquote><h2 id="共享锁与独占锁"><a href="#共享锁与独占锁" class="headerlink" title="共享锁与独占锁"></a>共享锁与独占锁</h2><p>在访问共享资源之前进行加锁操作，在访问完成之后进行解锁操作。按照“是否允许在同一时刻被多个线程持有”来区分，锁可以分为<strong>共享锁</strong>与<strong>独占锁</strong>。</p><h3 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h3><p>占锁也叫排他锁、互斥锁、独享锁，是指锁在同一时刻只能被一个线程所持有。一个线程加锁后，任何其他试图再次加锁的线程都会被阻塞，直到持有锁线程解锁。<strong>通俗来说，就是共享资源某一时刻只能有一个线程访问，其余线程阻塞等待</strong>。</p><p>如果是公平地独占锁，在持有锁线程解锁时，如果有一个以上的线程在阻塞等待，那么最先抢锁的线程被唤醒变为就绪状态去执行加锁操作，其他的线程仍然阻塞等待。<strong>Java中的Synchronized内置锁和ReentrantLock显式锁都是独占锁。</strong></p><h3 id="共享锁Semaphore"><a href="#共享锁Semaphore" class="headerlink" title="共享锁Semaphore"></a>共享锁Semaphore</h3><blockquote><p>Semaphore和ReentrantLock类似，Semaphore发放许可时有两种式：公平模式和非公平模式，默认情况下使用非公平模式。</p></blockquote><p>共享锁就是在同一时刻允许多个线程持有的锁。当然，获得共享锁的线程只能读取临界区的数据，不能修改临界区的数据。</p><p>JUC中的共享锁包括<code>Semaphore</code>（信号量）、<code>ReadLock</code>（读写锁）中的读锁、<code>CountDownLatch</code>。</p><p>Semaphore可以用来控制在同一时刻访问共享资源的线程数量，通过协调各个线程以保证共享资源的合理使用。<strong>Semaphore维护了一组虚拟许可，它的数量可以通过构造器的参数指定。线程在访问共享资源前必须调用Semaphore的<code>acquire()方法获得许可</code>，如果许可数量为0，该线程就一直阻塞。线程访问完资源后，必须调用Semaphore的<code>release()方法释放许可</code>。</strong>更形象的说法是：Semaphore是一个许可管理器。</p><h4 id="Semaphore的主要方法"><a href="#Semaphore的主要方法" class="headerlink" title="Semaphore的主要方法"></a>Semaphore的主要方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造一个Semaphore实例，初始化其管理的许可数量为permits参数值。</span></span><br><span class="line">Semaphore(<span class="keyword">permits</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个Semaphore实例，初始化其管理的许可数量为permits参数值，</span></span><br><span class="line"><span class="comment">// 是否以公平模式（fair参数是否为true）进行许可的发放。</span></span><br><span class="line">Semaphore(<span class="keyword">permits</span>,fair)</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>方法分类</th><th>方法名</th><th>方法签名</th><th>描述</th></tr></thead><tbody><tr><td>许可获取</td><td><code>acquire</code></td><td><code>void acquire() throws InterruptedException</code></td><td>从信号量获取一个许可，如果没有可用许可，则线程会被阻塞，直到有许可可用或线程被中断。</td></tr><tr><td>许可获取</td><td><code>acquire(permits)</code></td><td><code>void acquire() throws InterruptedException</code></td><td>当前线程尝试阻塞地获取permits个许可。此过程是阻塞的，线程会一直等待Semaphore发放permits个许可。如果没有足够的许可而当前线程被中断，就会抛出InterruptedException异常并终止阻塞。</td></tr><tr><td>许可获取</td><td><code>acquireUninterruptibly</code></td><td><code>void acquireUninterruptibly()</code></td><td>与<code>acquire</code>方法类似，但该方法不会响应中断，即使线程在等待许可时被中断，也会一直等待直到获取到许可。</td></tr><tr><td>许可获取</td><td><code>tryAcquire</code>（无参）</td><td><code>boolean tryAcquire()</code></td><td>尝试获取一个许可，若有许可可用，则获取许可并返回<code>true</code>；否则，立即返回<code>false</code>，不会阻塞线程。</td></tr><tr><td>许可获取</td><td><code>tryAcquire</code>（有参）</td><td><code>boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException</code></td><td>在指定的时间内尝试获取一个许可。若在超时时间内获取到许可，则返回<code>true</code>；否则，返回<code>false</code>。如果线程在等待期间被中断，会抛出<code>InterruptedException</code>异常。</td></tr><tr><td>许可释放</td><td><code>release</code></td><td><code>void release()</code></td><td>释放一个许可，将信号量的许可数量加1。如果有其他线程正在等待获取许可，则会唤醒其中一个线程使其能够获取许可。</td></tr><tr><td>许可数量查询</td><td><code>availablePermits</code></td><td><code>int availablePermits()</code></td><td>返回当前信号量中可用的许可数量。</td></tr><tr><td>许可数量查询</td><td><code>drainPermits</code></td><td><code>int drainPermits()</code></td><td>获取并返回当前所有可用的许可，并将可用许可数量置为0。</td></tr><tr><td>线程等待情况查询</td><td><code>hasQueuedThreads</code></td><td><code>boolean hasQueuedThreads()</code></td><td>查询是否有线程在等待获取该信号量的许可。</td></tr><tr><td>线程等待情况查询</td><td><code>getQueueLength</code></td><td><code>int getQueueLength()</code></td><td>返回正在等待获取许可的线程估计数。该值是一个估计值，因为在计算过程中线程的状态可能会发生变化。</td></tr></tbody></table><p>假设有10个人在银行办理业务，只有两个工作窗口，使用Semaphore模拟银行排队，同时只有两个线程进入临界区。大致的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankQueueSimulation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建信号量，设置许可数量为2（对应两个工作窗口）</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟10个客户来办理业务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">customerId</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取许可，相当于排队等待窗口有空位</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户 &quot;</span> + customerId + <span class="string">&quot; 开始办理业务&quot;</span>);</span><br><span class="line">                    <span class="comment">// 模拟办理业务的耗时，这里简单用休眠来表示</span></span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户 &quot;</span> + customerId + <span class="string">&quot; 办理业务完成&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放许可，办理完业务，窗口空出来了</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><blockquote><p>门闩（Shuān），横插在门后使门推不开的棍子。</p></blockquote><p>CountDownLatch是一个常用的共享锁，其功能相当于一个多线程环境下的倒数门闩。</p><p><strong>原理</strong>：CountDownLatch 内部也是基于 AQS 实现的，它通过一个计数器来控制线程的等待和放行。计数器初始化为一个给定的值，当线程调用 countDown () 方法时，计数器会减 1，当计数器的值减到 0 时，所有等待在 CountDownLatch 上的线程会被唤醒。</p><p><strong>使用场景</strong>：适用于一个或多个线程等待其他多个线程完成一组任务后再继续执行的场景，如主线程等待多个子线程完成数据加载后进行数据汇总。</p><p>模拟游戏玩家加载的示例代码。在游戏开始前，需要等待多个玩家完成加载操作，当所有玩家都加载完成后，游戏才正式开始具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameLoadingExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 假设一共有5个玩家，CountDownLatch初始值设为5</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">playerCount</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(playerCount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟每个玩家加载的线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= playerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">playerIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 模拟玩家加载耗时，这里简单使用随机时间模拟，单位为毫秒</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">loadingTime</span> <span class="operator">=</span> (<span class="type">long</span>) (Math.random() * <span class="number">3000</span>);</span><br><span class="line">                    Thread.sleep(loadingTime);</span><br><span class="line">                    System.out.println(<span class="string">&quot;玩家&quot;</span> + playerIndex + <span class="string">&quot; 加载完成，耗时 &quot;</span> + loadingTime + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">                    <span class="comment">// 玩家加载完成，计数器减1</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 主线程（可以理解为游戏控制线程）等待所有玩家加载完毕</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;所有玩家加载完毕，游戏开始！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><ul><li><strong>原理</strong>：CyclicBarrier 内部使用 ReentrantLock 和 Condition 来实现线程的同步。它维护了一个计数器，当线程到达屏障点时，会调用 await () 方法，将自己阻塞，并使计数器减 1。当计数器的值为 0 时，说明所有线程都到达了屏障点，此时会唤醒所有阻塞的线程。</li><li><strong>使用场景</strong>:适用于一组线程相互等待，到达某个公共屏障点后再一起继续执行的场景，常用于多线程并发处理数据，每个线程处理一部分，全部处理完后进行合并等操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建CyclicBarrier，参数5表示需要5个线程都到达屏障点后才能继续执行</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;所有运动员都已准备好，比赛开始！&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并启动5个线程模拟运动员</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">athleteNumber</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;运动员&quot;</span> + athleteNumber + <span class="string">&quot; 正在做准备活动...&quot;</span>);</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">3000</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;运动员&quot;</span> + athleteNumber + <span class="string">&quot; 已准备好，等待其他运动员...&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(<span class="string">&quot;运动员&quot;</span> + athleteNumber + <span class="string">&quot; 开始比赛！&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中：</p><ol><li>首先创建了一个<code>CyclicBarrier</code>对象，构造函数传入两个参数，第一个参数<code>5</code>表示需要有<code>5</code>个线程调用<code>await</code>方法（也就是到达屏障点）后，所有线程才能继续往下执行。第二个参数是一个<code>Runnable</code>接口实现（使用了 Java 8 的 Lambda 表达式），它定义了当所有线程都到达屏障点后要执行的操作，在这里就是输出表示比赛开始的语句。</li><li>然后通过循环创建并启动了<code>5</code>个线程，每个线程模拟一个运动员做准备活动，然后调用<code>cyclicBarrier.await()</code>方法，表示自己已经准备好，进入等待状态，直到所有线程（也就是所有运动员）都调用了<code>await</code>方法，此时满足了屏障条件，之前传入<code>CyclicBarrier</code>构造函数中的<code>Runnable</code>会被执行，接着所有被阻塞的线程就会继续往下执行，模拟比赛开始的情况。</li></ol><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>读写锁的内部包含两把锁：一把是读（操作）锁，是一种共享锁；另一把是写（操作）锁，是一种独占锁。</p><p><strong>在没有写锁的时候，读锁可以被多个线程同时持有。写锁是具有排他性的：如果写锁被一个线程持有，其他的线程不能再持有写锁，抢占写锁会阻塞；进一步来说，如果写锁被一个线程持有，其他的线程不能再持有读锁，抢占读锁也会阻塞。</strong></p><p>读写锁的读写操作之间的互斥原则具体如下：</p><ul><li>读操作、读操作能共存，是相容的。</li><li>读操作、写操作不能共存，是互斥的。</li><li>写操作、写操作不能共存，是互斥的。</li></ul><p>与单一的互斥锁相比，组合起来的读写锁允许对于共享数据进行更大程度的并发操作。虽然每次只能有一个写线程，但是同时可以有多个线程并发地读数据。<strong>读写锁适用于读多写少的并发情况</strong>。</p><p>JUC包中的读写锁接口为<code>ReadWriteLock</code>，主要有两个方法，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回读锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     Lock <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     Lock <span class="title function_">writeLock</span><span class="params">()</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>JUC中ReadWriteLock接口的实现类为<code>ReentrantReadWriteLock</code>。</p><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>通过ReentrantReadWriteLock类能获取读锁和写锁，它的读锁是可以多线程共享的共享锁，而它的写锁是排他锁，在被占时不允许其他线程再抢占操作。然而其读锁和写锁之间是有关系的：同一时刻不允许读锁和写锁同时被抢占，二者之间是互斥的。</p><p>代码演示，读锁是共享锁，写锁是排他锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockExample</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个Map，代表共享数据</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;String, String&gt; MAP = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">    <span class="comment">// 创建一个读写锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">// 获取读锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">READ_LOCK</span> <span class="operator">=</span> LOCK.readLock();</span><br><span class="line">    <span class="comment">// 获取写锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">WRITE_LOCK</span> <span class="operator">=</span> LOCK.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对共享数据的写操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">put</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        WRITE_LOCK.lock(); <span class="comment">// 抢写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + LocalTime.now() + <span class="string">&quot; 抢占了WRITE_LOCK，开 始执行write操作&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">put</span> <span class="operator">=</span> MAP.put(key, value); <span class="comment">// 写入共享数据</span></span><br><span class="line">            <span class="keyword">return</span> put;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            WRITE_LOCK.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对共享数据的读操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        READ_LOCK.lock(); <span class="comment">// 抢占读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + LocalTime.now() + <span class="string">&quot; 抢占了 READ_LOCK，开始执行read操作&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> MAP.get(key); <span class="comment">// 读取共享数据</span></span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            READ_LOCK.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入口方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Runnable异步可执行目标实例</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">writeTarget</span> <span class="operator">=</span> () -&gt; put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">readTarget</span> <span class="operator">=</span> () -&gt; get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建4个读线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(readTarget, <span class="string">&quot;读线程&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建2个写线程，并启动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(writeTarget, <span class="string">&quot;写线程&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">读线程<span class="number">0</span> - <span class="number">00</span>:<span class="number">14</span>:<span class="number">11.818</span> 抢占了 READ_LOCK，开始执行read操作</span><br><span class="line">读线程<span class="number">2</span> - <span class="number">00</span>:<span class="number">14</span>:<span class="number">11.819</span> 抢占了 READ_LOCK，开始执行read操作</span><br><span class="line">读线程<span class="number">1</span> - <span class="number">00</span>:<span class="number">14</span>:<span class="number">11.819</span> 抢占了 READ_LOCK，开始执行read操作</span><br><span class="line">写线程<span class="number">0</span> - <span class="number">00</span>:<span class="number">14</span>:<span class="number">12.831</span> 抢占了WRITE_LOCK，开 始执行write操作</span><br><span class="line">写线程<span class="number">1</span> - <span class="number">00</span>:<span class="number">14</span>:<span class="number">13.844</span> 抢占了WRITE_LOCK，开 始执行write操作</span><br><span class="line">读线程<span class="number">3</span> - <span class="number">00</span>:<span class="number">14</span>:<span class="number">14.858</span> 抢占了 READ_LOCK，开始执行read操作</span><br></pre></td></tr></table></figure><p>从输出结果可以看出：</p><ul><li>读线程0、读线程1、读线程2同时获取了读锁，说明可以同时进行共享数据的读操作。</li><li>写线程0、写线程1只能依次获取写锁，说明共享数据的写操作不能同时进行。</li><li>读线程3必须等待写线程1释放写锁后才能获取到读锁，说明读写操作是互斥的。</li></ul><h3 id="锁的升级与降级"><a href="#锁的升级与降级" class="headerlink" title="锁的升级与降级"></a>锁的升级与降级</h3><p><strong>锁升级是指读锁升级为写锁，锁降级指的是写锁降级为读锁。</strong><code>在ReentrantReadWriteLock读写锁中，只支持写锁降级为读锁，而不支持读锁升级为写锁</code>。具体的演示代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockUpgradeAndDowngradeExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">sharedData</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 演示写锁降级为读锁</span></span><br><span class="line">        writeLockDowngradeToReadLock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 演示读锁尝试升级为写锁（会报错）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            readLockUpgradeToWriteLock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读锁升级为写锁失败，出现异常: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写锁降级为读锁示例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeLockDowngradeToReadLock</span><span class="params">()</span> &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 进行写操作</span></span><br><span class="line">            sharedData = <span class="number">10</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;获取写锁，写入数据: &quot;</span> + sharedData);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 降级操作，先获取读锁，再释放写锁，实现写锁降级为读锁</span></span><br><span class="line">            readLock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;已将写锁降级为读锁，当前数据: &quot;</span> + sharedData);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">            System.out.println(<span class="string">&quot;已释放锁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读锁尝试升级为写锁示例（实际不支持，会报错）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readLockUpgradeToWriteLock</span><span class="params">()</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;获取读锁，当前数据: &quot;</span> + sharedData);</span><br><span class="line">            <span class="comment">// 这里尝试获取写锁，在当前持有读锁的情况下，会阻塞，因为不支持读锁升级为写锁</span></span><br><span class="line">            <span class="comment">// 并且如果没有额外处理，会导致死锁情况，这里只是简单演示其不支持会抛出异常</span></span><br><span class="line">            writeLock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;尝试将读锁升级为写锁成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">获取写锁，写入数据: <span class="number">10</span></span><br><span class="line">已将写锁降级为读锁，当前数据: <span class="number">10</span></span><br><span class="line">已释放锁</span><br><span class="line">获取读锁，当前数据: <span class="number">10</span></span><br></pre></td></tr></table></figure><p>先通过<code>readLock.lock()</code>获取读锁，然后尝试通过<code>writeLock.lock()</code>获取写锁，在<code>ReentrantReadWriteLock</code>中这种情况是不被允许的，会导致当前线程阻塞在获取写锁的操作上，并且如果不做额外处理（比如通过超时等机制打破这种等待），很容易就陷入死锁情况（因为获取写锁需要等待所有读锁都释放，而当前线程又不释放自己持有的读锁）</p><p>通过结果可以看出：ReentrantReadWriteLock不支持读锁的升级，主要是避免死锁，例如两个线程A和B都占了读锁并且都需要升级成写锁，A升级要求B释放读锁，B升级要求A释放读锁，二者就会由于相互等待形成死锁。</p><p>总结起来，与ReentrantLock相比，<code>ReentrantReadWriteLock</code>更适合<strong>读多写少</strong>的场景，可以提高并发读的效率；而<code>ReentrantLock</code>更适合<strong>读写比例相差不大或写比读多的场景。</strong></p><h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><p><code>StampedLock</code>是 Java 8 中引入的一种锁机制， StampedLock（印戳锁）是对ReentrantReadWriteLock读写锁的一种改进，主要的改进为：<strong>在没有写只有读的场景下，StampedLock支持不用加读锁而是直接进行读操作，最大程度提升读的效率，只有在发生过写操作之后，再加读锁才能进行读操作。</strong></p><h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><ul><li><strong>写锁（排他锁）</strong>：用于对资源进行独占式的写操作。获取写锁后，其他线程无法获取写锁或读锁，直到写锁被释放。通过<code>writeLock()</code>方法获取写锁，返回的戳记用于后续释放锁操作，使用<code>unlockWrite(stamp)</code>方法释放写锁。</li><li><strong>读锁（共享锁）</strong>：多个线程可以同时获取读锁，用于对资源的只读操作。获取读锁后，其他线程可以继续获取读锁，但不能获取写锁。通过<code>readLock()</code>方法获取读锁，同样返回一个戳记，释放读锁使用<code>unlockRead(stamp)</code>方法。</li><li><strong>乐观读锁</strong>：一种优化的读锁方式，它假设在读取数据的过程中，数据不会被其他线程修改。线程先尝试获取一个乐观读戳记，然后进行数据读取操作。在读取完成后，需要使用<code>validate(stamp)</code>方法验证戳记的有效性，以确保在读取过程中没有其他线程对数据进行了写操作。如果验证失败，说明数据可能已经被修改，需要重新读取或采取其他处理方式。虽然写锁与乐观读锁不会互斥，但是在数据被更新之后，之前通过乐观读锁获得的数据已经变成了脏数据。</li></ul><p>悲观读锁的获取与释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取普通读锁（悲观读锁），返回long类型的印戳值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">readLock</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放普通读锁（悲观读锁），以取锁时的印戳值作为参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlockRead</span><span class="params">(<span class="type">long</span> stamp)</span></span><br></pre></td></tr></table></figure><p>写锁的获取与释放 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取写锁，返回long类型的印戳值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">writeLock</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放写锁，以获取写锁时的印戳值作为参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlockWrite</span><span class="params">(<span class="type">long</span> stamp)</span></span><br></pre></td></tr></table></figure><p>乐观读的印戳获取与有效性判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取乐观读，返回long类型的印戳值，返回0表示当前锁处于写锁模式，不能乐观读</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">tryOptimisticRead</span><span class="params">()</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//判断乐观读的印戳值是否有效，以tryOptimisticRead返回的印戳值作为参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">tryOptimisticRead</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>三种模式锁获取示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StampedLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(<span class="type">int</span> newData)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = newData;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 乐观读操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">optimisticRead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> data;</span><br><span class="line">        <span class="comment">// 验证戳记有效性</span></span><br><span class="line">        <span class="keyword">if</span> (!lock.validate(stamp)) &#123;</span><br><span class="line">            <span class="comment">// 数据已被修改，重新获取读锁读取</span></span><br><span class="line">            stamp = lock.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = data;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stamp值"><a href="#stamp值" class="headerlink" title="stamp值"></a>stamp值</h3><p><code>stamp</code>的不同取值在不同操作和场景下有特定的含义与作用：</p><ul><li><p><strong>写锁相关</strong></p><ul><li><p><strong>写锁获取成功</strong>：当通过<code>writeLock()</code>等方法成功获取写锁时，返回的<code>stamp</code>是一个非零的<code>long</code>型数值。这个数值代表了此次写锁操作的标识，后续可以使用该<code>stamp</code>来释放写锁或者进行相关的验证操作。</p></li><li><p><strong>写锁获取失败</strong>：如果获取写锁失败，通常返回的<code>stamp</code>值为<code>0</code>，这表示此次获取写锁的操作未成功，线程不能进行写操作。</p></li></ul></li><li><p><strong>读锁相关</strong></p><ul><li><strong>悲观读锁获取成功</strong>：使用<code>readLock()</code>方法获取悲观读锁成功时，会返回一个非零的<code>stamp</code>，用于标识该读锁操作。与写锁类似，后续可以用这个<code>stamp</code>来释放读锁。</li></ul></li><li><p><strong>乐观读相关</strong>：在乐观读场景中，首先通过<code>tryOptimisticRead()</code>方法尝试获取乐观读锁，它也会返回一个<code>stamp</code>。</p><ul><li><strong>乐观读有效</strong>：如果返回的<code>stamp</code>不为<code>0</code>，表示当前可能处于一个没有写操作在进行的状态，即乐观读有效。此时可以进行数据读取操作，并且可以通过<code>validate(stamp)</code>方法来验证在读取数据期间是否有写操作发生。</li><li><strong>乐观读无效</strong>：如果<code>tryOptimisticRead()</code>返回的<code>stamp</code>为<code>0</code>，则说明当前可能有写操作正在进行，乐观读无效，不建议直接进行数据读取操作。</li></ul></li></ul><h3 id="StampedLock的演示案例"><a href="#StampedLock的演示案例" class="headerlink" title="StampedLock的演示案例"></a>StampedLock的演示案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.fulsun._5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> pers.fulsun._4.LockSupportDemo.sleepSeconds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StampedLockTest</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个Map，代表共享数据</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;String, String&gt; MAP = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">    <span class="comment">// 创建一个印戳锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">StampedLock</span> <span class="variable">STAMPED_LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对共享数据的写操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">put</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> STAMPED_LOCK.writeLock(); <span class="comment">// 尝试获取写锁的印戳</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + LocalTime.now() + <span class="string">&quot; 抢占了WRITE_LOCK，开始执行write操作&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">put</span> <span class="operator">=</span> MAP.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> put;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + LocalTime.now() + <span class="string">&quot; 释放了WRITE_LOCK&quot;</span>);</span><br><span class="line">            STAMPED_LOCK.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对共享数据的悲观读操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">pessimisticRead</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + LocalTime.now() + <span class="string">&quot; 进入了悲观读模式&quot;</span>);</span><br><span class="line">        <span class="comment">// 进入了写锁模式，只能获取悲观读锁</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> STAMPED_LOCK.readLock(); <span class="comment">// 尝试获取读 锁的印戳</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 成功获取到读锁，并重新获取最新的变量值</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + LocalTime.now() + <span class="string">&quot; 抢占了READ_LOCK，开始执行read操作&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> MAP.get(key);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + LocalTime.now() + <span class="string">&quot; 释放了READ_LOCK&quot;</span>);</span><br><span class="line">            STAMPED_LOCK.unlockRead(stamp); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对共享数据的乐观读操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">optimisticRead</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 尝试进行乐观读</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> STAMPED_LOCK.tryOptimisticRead();</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != stamp) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + LocalTime.now() + <span class="string">&quot; 进入了乐观读模式&quot;</span>);</span><br><span class="line">            sleepSeconds(<span class="number">1</span>); <span class="comment">// 模拟耗费时间1秒</span></span><br><span class="line">            value = MAP.get(key);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">// 0 == stamp 表示当前为写锁模式</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + LocalTime.now() + <span class="string">&quot; 进入了写锁模式，不能进行乐观读&quot;</span>);</span><br><span class="line">            <span class="comment">// LOCK已经进入写模式，使用悲观读方法</span></span><br><span class="line">            <span class="keyword">return</span> pessimisticRead(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 乐观读操作已经间隔了一段时间，期间可能发生写入</span></span><br><span class="line">        <span class="comment">// 所以，需要验证乐观读的印戳值是否有效，即判断LOCK是否进入过写模式</span></span><br><span class="line">        <span class="keyword">if</span> (!STAMPED_LOCK.validate(stamp)) &#123;</span><br><span class="line">            <span class="comment">// 乐观读的印戳值无效，表明写锁被占用过</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + LocalTime.now() + <span class="string">&quot; 乐观读的印戳值，已经过期&quot;</span>);</span><br><span class="line">            <span class="comment">// 写锁已经被抢占，进入了写锁模式，只能通过悲观读锁再一次读取最新值</span></span><br><span class="line">            <span class="keyword">return</span> pessimisticRead(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 乐观读的印戳值有效，表明写锁没有被占用过</span></span><br><span class="line">            <span class="comment">// 不用加悲观读锁而直接读，减少了读锁的开销</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + LocalTime.now() + <span class="string">&quot; 乐观读的印戳值，没有过期&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建Runnable可执行实例</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">writeTarget</span> <span class="operator">=</span> () -&gt; put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">readTarget</span> <span class="operator">=</span> () -&gt; optimisticRead(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建1个写线程，并启动</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(writeTarget, <span class="string">&quot;写线程&quot;</span>).start();</span><br><span class="line">        <span class="comment">// 创建1个读线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(readTarget, <span class="string">&quot;读线程&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">读线程 - 00:33:19.080 进入了写锁模式，不能进行乐观读</span><br><span class="line">写线程 - 00:33:19.080 抢占了WRITE_LOCK，开始执行write操作</span><br><span class="line">读线程 - 00:33:19.081 进入了悲观读模式</span><br><span class="line">写线程 - 00:33:20.095 释放了WRITE_LOCK</span><br><span class="line">读线程 - 00:33:20.095 抢占了READ_LOCK，开始执行<span class="built_in">read</span>操作</span><br><span class="line">读线程 - 00:33:20.095 释放了READ_LOCK</span><br></pre></td></tr></table></figure><h3 id="StampedLock与ReentrantReadWriteLock对比"><a href="#StampedLock与ReentrantReadWriteLock对比" class="headerlink" title="StampedLock与ReentrantReadWriteLock对比"></a>StampedLock与ReentrantReadWriteLock对比</h3><ol><li><p>锁特性</p><ul><li><p>**<code>StampedLock</code>**：具有写锁、读锁和乐观读锁三种模式。乐观读锁是其特色，提供了一种无锁的读方式，适用于大部分读操作不会与写操作冲突的场景。</p></li><li><p>**<code>ReentrantReadWriteLock</code>**：分为读锁和写锁，支持多个线程同时获取读锁，但写锁是排他的，同一时刻只能有一个线程获取写锁。</p></li></ul></li><li><p>锁获取与释放</p><ul><li><p>**<code>StampedLock</code>**：获取锁时会返回一个戳记（<code>stamp</code>），用于后续的锁释放和验证操作。释放锁时需要传入对应的戳记。如<code>long stamp = lock.writeLock();</code>获取写锁，<code>lock.unlockWrite(stamp);</code>释放写锁。</p></li><li><p>**<code>ReentrantReadWriteLock</code>**：通过<code>readLock()</code>获取读锁，<code>writeLock()</code>获取写锁，释放锁时直接调用<code>unlock()</code>方法即可，不需要额外的标识。如<code>ReadLock readLock = readWriteLock.readLock(); readLock.lock();</code>获取读锁，<code>readLock.unlock();</code>释放读锁。</p></li></ul></li><li><p>可重入性</p><ul><li><p>**<code>StampedLock</code>**：支持可重入，但在重入时需要注意戳记的使用和管理。例如，一个线程可以多次获取读锁或写锁，每次获取都会返回一个新的戳记，但释放锁时需要按照获取的顺序和次数进行释放。</p></li><li><p>**<code>ReentrantReadWriteLock</code>**：明确支持可重入，重入时锁的获取和释放相对简单，线程可以多次获取同一类型的锁，不会出现死锁等问题。</p></li></ul></li><li><p>性能</p><ul><li><p>**<code>StampedLock</code>**：在读多写少的场景下，乐观读锁能提高读操作的并发性，性能优势明显。但如果写操作频繁，乐观读锁的验证失败率会增加，可能导致性能下降。</p></li><li><p>**<code>ReentrantReadWriteLock</code>**：读锁和写锁的分离能提高一定的并发性能，但读锁之间存在一定的竞争，在高并发读的情况下性能可能不如<code>StampedLock</code>的乐观读锁。</p></li></ul></li><li><p>公平性</p><ul><li><p>**<code>StampedLock</code>**：默认是非公平锁，但可以通过构造函数或方法调用设置为公平锁，在公平模式下，线程按照请求锁的顺序获取锁。</p></li><li><p>**<code>ReentrantReadWriteLock</code>**：也支持公平和非公平模式，公平模式下，读锁和写锁的获取都遵循先来先服务的原则。</p></li></ul></li><li><p>适用场景</p><ul><li><p>**<code>StampedLock</code>**：适用于读操作频率远高于写操作，且对数据实时性要求较高的场景，如缓存系统、实时数据分析等。在这些场景中，乐观读锁可以在不影响数据一致性的前提下，提高系统的并发性能。</p></li><li><p>**<code>ReentrantReadWriteLock</code>**：适用于读多写少，但写操作对数据一致性要求严格，且读操作之间不需要过于精细的并发控制的场景，如数据库的读写操作、文件的读写等。</p></li></ul></li></ol><script>var description="JUC显式锁是一种非常灵活的、使用纯Java语言实现的锁。"</script>]]></content>
      
      
      <categories>
          
          <category> 多线程编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC显式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可见性与有序性的原理</title>
      <link href="/p/1c8195dc.html"/>
      <url>/p/1c8195dc.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="CPU物理缓存结构"><a href="#CPU物理缓存结构" class="headerlink" title="CPU物理缓存结构"></a>CPU物理缓存结构</h2><p>由于CPU的运算速度比主存（物理内存）的存取速度快很多，为了提高处理速度，现代CPU不直接和主存进行通信，而是在CPU和主存之间设计了多层的Cache（高速缓存），越靠近CPU的高速缓存越快，容量也越小。</p><p>按照数据读取顺序和与CPU内核结合的紧密程度，CPU高速缓存有L1和L2高速缓存（即一级高速缓存和二级缓存高速），部分高端CPU还具有L3高速缓存（即三级高速缓存）。<strong>每一级高速缓存中所存储的数据都是下一级高速缓存的一部分，越靠近CPU的高速缓存读取越快，容量也越小。</strong>所以L1高速缓存容量很小，但存取速度最快，并且紧靠着使用它的CPU内核。L2容量大一些，存取速度也慢一些，并且仍然只能被一个单独的CPU核使用。L3在现代多核CPU中更普遍，容量更大、读取速度更慢些，能被同一个CPU芯片板上的所有CPU内核共享。最后，系统还拥有一块主存（即主内存），由系统中的所有CPU共享。拥有L3高速缓存的CPU，CPU存取数据的命中率可达95%，也就是说只有不到5%的数据需要从主存中去存取</p><p><img src="/p/1c8195dc/72a30598bf53b93af74723edb374e558.png"></p><p>CPU内核读取数据时，先从L1高速缓存中读取，如果没有命中，再到L2、L3高速缓存中读取，假如这些高速缓存都没有命中，它就会到主存中读取所需要的数据。高速缓存大大缩小了高速CPU内核与低速主存之间的速度差距。以三层高速缓存架构为例：</p><ul><li>L1高速缓存最接近CPU，容量最小（如32KB、64KB等）、存取速度最快，每个核上都有一个L1高速缓存。</li><li>L2高速缓存容量更大（如256KB）、速度低些，在一般情况下，每个内核上都有一个独立的L2高速缓存。</li><li>L3高速缓存最接近主存，容量最大（如12MB）、速度最低，由在同一个CPU芯片板上的不同CPU内核共享。</li></ul><p>CPU通过高速缓存进行数据读取有以下优势：</p><ol><li>写缓冲区可以保证指令流水线持续运行，可以避免由于CPU停顿下来等待向内存写入数据而产生的延迟。</li><li>通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，减少对内存总线的占用。</li></ol><h2 id="并发编程的三大问题"><a href="#并发编程的三大问题" class="headerlink" title="并发编程的三大问题"></a>并发编程的三大问题</h2><p>由于需要尽可能释放CPU的能力，因此在CPU上不断增加内核和缓存。内核是越加越多，从之前的单核演变成8核、32核甚至更多。缓存也不止一层，可能是2层、3层甚至更多。<strong>随着CPU内核和缓存的增加，导致了并发编程的可见性和有序性问题</strong>。</p><h3 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h3><p>所谓原子操作，就是“不可中断的一个或一系列操作”，是指不会被线程调度机制打断的操作。这种操作一旦开始，就一直运行到结束，中间不会有任何线程的切换。</p><p>下面来看一小段程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CounterSample</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    sum++; <span class="comment">//①</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>很多读者认为，sum++是单一操作，所以是原子性的。本书前面我们用实验证明了sum++不是原子操作。接下来，我们使用javap命令解析出以上代码的汇编指令信息，从汇编指令的角度来看看++操作的细分操作。<br>说明</p><blockquote><p>javap是JDK提供的一个命令行工具，能对给定的class文件提供的字节代码进行反编译。通过它可以对照源代码和字节码，从而了解很多编译器内部的工作，对更深入地理解如何提高程序执行的效率等问题有极大的帮助。命令选项-c表示对代码进行反汇编。</p></blockquote><p>使用javap命令解析出CounterSample的汇编代码，具体的命令如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javap -c .\CounterSample.class</span></span><br><span class="line">Compiled from <span class="string">&quot;CounterSample.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">pers</span>.fulsun._3.CounterSample &#123;</span><br><span class="line">  <span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> pers.fulsun._3.CounterSample();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: aload_0</span><br><span class="line">       <span class="number">5</span>: iconst_0</span><br><span class="line">       <span class="number">6</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field sum:I</span></span><br><span class="line">       <span class="number">9</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: dup</span><br><span class="line">①        <span class="number">2</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field sum:I</span></span><br><span class="line">②        <span class="number">5</span>: iconst_1</span><br><span class="line">③        <span class="number">6</span>: iadd</span><br><span class="line">④        <span class="number">7</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field sum:I</span></span><br><span class="line">      <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解释一下上面的4个关键性的汇编指令：</p><ul><li>① 获取当前sum变量的值，并且放入栈顶。</li><li>② 将常量1放入栈顶。</li><li>③ 将当前栈顶中的两个值（sum的值和1）相加，并把结果放入栈顶。</li><li>④ 把栈顶的结果再赋值给sum变量。</li></ul><p>通过以上4个关键性的汇编指令可以看出，在汇编代码的层面，++操作实质上是4个操作。这4个操作之间是可以发生线程切换的，或者说是可以被其他线程中断的。所以，++操作不是原子操作，在并行场景会发生原子性问题。</p><h3 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a><strong>可见性问题</strong></h3><p><strong>一个线程对共享变量的修改，另一个线程能够立刻可见，我们称该共享变量具备内存可见性。</strong>谈到内存可见性，要先引出JMM（Java Memory Model，Java内存模型）的概念。<strong>JMM规定，将所有的变量都存放在公共主存中，当线程使用变量时会把主存中的变量复制到自己的工作空间（或者叫私有内存）中，线程对变量的读写操作，是自己工作内存中的变量副本。如果两个线程同时操作一个共享变量，就可能发生可见性问题</strong>。</p><p>举一个例子：</p><ol><li>主存中有变量sum，初始值为0。</li><li>线程A计划将sum加1，先将sum&#x3D;0复制到自己的私有内存中，然后更新sum的值。线程A操作完成之后其私有内存中sum的值为1，然而线程A将更新后的sum值回刷到主存的时间是不固定的。</li><li>在线程A没有回刷sum到主存前，刚好线程B同样从主存中读取sum，此时值为0，和线程A进行同样的操作，最后期盼的sum&#x3D;2目标没有达成，最终sum&#x3D;1。</li></ol><p>线程B没有将sum变成2的原因是：线程A的修改还在其工作内存中，对线程B不可见，因为线程A的修改还没有刷入主存。这就发生了典型的内存可见性问题。</p><p>要想解决多线程的内存可见性问题，所有线程都必须将共享变量刷新到主存，<strong>一种简单的方案是：使用Java提供的关键字volatile修饰共享变量。</strong></p><blockquote><p><strong>为什么Java局部变量、方法参数不存在内存可见性问题？</strong></p><p>在Java中，所有的局部变量、方法定义参数都不会在线程之间共享，所以也就不会有内存可见性问题。所有的Object实例、Class实例和数组元素都存储在JVM堆内存中，<strong>堆内存在线程之间共享，所以存在可见性问题</strong>。</p></blockquote><h3 id="有序性问题"><a href="#有序性问题" class="headerlink" title="有序性问题"></a>有序性问题</h3><p>所谓程序的有序性，是指程序按照代码的先后顺序执行。如果程序执行的顺序与代码的先后顺序不同，并导致了错误的结果，即发生了有序性问题。</p><p>举一个简单的例子，看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstructionReorder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            x = <span class="number">0</span>;</span><br><span class="line">            y = <span class="number">0</span>;</span><br><span class="line">            a = <span class="number">0</span>;</span><br><span class="line">            b = <span class="number">0</span>;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                a = <span class="number">1</span>; <span class="comment">//①</span></span><br><span class="line">                x = b; <span class="comment">//②</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">other</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                b = <span class="number">1</span>; <span class="comment">//③</span></span><br><span class="line">                y = a; <span class="comment">//④</span></span><br><span class="line">            &#125;);</span><br><span class="line">            one.start();</span><br><span class="line">            other.start();</span><br><span class="line">            one.join();</span><br><span class="line">            other.join();</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次 (&quot;</span> + x + <span class="string">&quot;,&quot;</span> + y + <span class="string">&quot;）&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</span><br><span class="line">                System.err.println(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第55577次 (0,0）</span></span><br><span class="line"><span class="comment">// 第136129次 (0,0）</span></span><br></pre></td></tr></table></figure><p>以上程序的代码很简单，两个线程交替给a、b、x、y赋值。由于并发执行的无序性，赋值之后x、y的值可能为(1,0)、(0,1)或(1,1)。为什么呢？</p><p>因为线程one可能在线程two开始之前就执行完了，也可能线程two在线程one开始之前就执行完了，甚至有可能二者的指令是同时或交替执行的。</p><p><img src="/p/1c8195dc/6821ca935b19f75a0de0a2a02a3d81b4.png"></p><p>然而，执行以上代码时，出乎意料的事情发生了：这段代码的执行结果也可能是(0,0)。以上代码特意将结果(0,0)进行过滤和输出，部分结果如下： <code>第55577次 (0,0）</code></p><p>对于以上程序来说，(0,0)结果是错误的，意味着已经发生了并发的有序性问题。为什么会出现(0,0)结果呢？<strong>可能在程序的执行过程中发生了指令重排序（Reordering）。</strong></p><h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>下面解释一下什么是指令重排序。一般来说，CPU为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行顺序同代码中的先后顺序一致，但是它会保证程序最终的执行结果和代码顺序执行的结果是一致的。</p><p>重排序也是单核时代非常优秀的优化手段，有足够多的措施保证其在单核下的正确性。在多核时代，如果工作线程之间不共享数据或仅共享不可变数据，重排序也是性能优化的利器。然而，如果工作线程之间共享了可变数据，由于两种重排序的结果都不是固定的，因此会导致工作线程似乎表现出了随机行为。得到了(0,0)结果的语句执行过程，对于线程one来说，可能a&#x3D;1和x&#x3D;b这两个语句的赋值操作顺序被颠倒了，对于线程two来说，可能b&#x3D;1和y&#x3D;a这两个语句的赋值操作顺序被颠倒了，从而出现了(x,y)值为(0,0)的错误结果。</p><p>线程one和线程two发生错误结果时的执行顺序如图所示。</p><p><img src="/p/1c8195dc/28cb56f203b316d7a024c0939ee3c49b.png"></p><p>从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响多个线程并发执行的正确性。</p><blockquote><p>事实上，<strong>输出了乱序的结果，并不代表一定发生了指令重排序，内存可见性问题也会导致这样的输出。但是，指令重排序也是导致乱序的原因之一</strong>。总之，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有得到保证，就有可能会导致程序运行不正确。</p></blockquote><h2 id="硬件层的MESI协议原理"><a href="#硬件层的MESI协议原理" class="headerlink" title="硬件层的MESI协议原理"></a>硬件层的MESI协议原理</h2><p>为了缓解内存速度和CPU内核速度差的问题，现代计算机会在CPU上增加高速缓存，每个CPU内核都只有自己的一级、二级高速缓存，CPU芯片板上的CPU内核之间共享一个三级高速缓存。</p><p>每个CPU的处理过程为：先将计算需要用到的数据缓存在CPU的高速缓存中，在CPU进行计算时，直接从高速缓存中读取数据并且在计算完成之后写回高速缓存中。在整个运算过程完成后，再把高速缓存中的数据同步到主存。</p><p>由于每个线程可能会运行在不同的CPU内核中，因此每个线程拥有自己的高速缓存。同一份数据可能会被缓存到多个CPU内核中，在不同CPU内核中运行的线程看到同一个变量的缓存值就会不一样，就可能发生内存的可见性问题。</p><p><strong>硬件层的MESI协议是一种用于解决内存的可见性问题的手段</strong>，接下来为大家介绍MESI协议的原理和具体内容。</p><blockquote><p><strong>缓存行是高速缓存操作的基本单位，在Intel的CPU上一般是64字节。</strong></p></blockquote><h3 id="总线锁和缓存锁"><a href="#总线锁和缓存锁" class="headerlink" title="总线锁和缓存锁"></a>总线锁和缓存锁</h3><p>为了解决内存的可见性问题，CPU主要提供了两种解决办法：<code>总线锁</code>和<code>缓存锁</code>。</p><ul><li><p>总线锁</p><ul><li>操作系统提供了总线锁机制。前端总线（也叫CPU总线）是所有CPU与芯片组连接的主干道，负责CPU与外界所有部件的通信，包括高速缓存、内存、北桥，其控制总线向各个部件发送控制信号，通过地<br>址总线发送地址信号指定其要访问的部件，通过数据总线实现双向传输。</li><li><strong>在CPU内核1要执行i++操作的时候，将在总线上发出一个LOCK#信号锁住缓存（具体来说是变量所在的缓存行），这样其他CPU内核就不能操作缓存了，从而阻塞其他CPU内核，使CPU内核1可以独享此共享内存</strong>。</li><li>每当CPU内核访问L3中的数据时，都会通过线程总线来进行读取。总线锁的意思是在线程总线中加入一把锁，当不同的CPU内核访问同一个缓存行时，<strong>只允许一个CPU内核进行读取</strong>。</li><li>在多CPU的系统中，当其中一个CPU要对共享主存进行操作时，在总线上发出一个LOCK#信号，这个信号使得其他CPU无法通过总线来访问共享主存中的数据，总线锁把CPU和主存之间的通信锁住了，这使得锁定期间，其他CPU不能操作其他主存地址的数据，总线锁的开销比较大，这种机制显然是不合适的。</li></ul></li><li><p>总线锁的缺陷是：</p><ul><li>某一个CPU访问主存时，总线锁把CPU和主存的通信给锁住了，其他CPU不能操作其他主存地址的数据，使得效率低下，开销较大。</li><li>总线锁的粒度太大了，会<strong>导致其他CPU核心的访问延迟</strong>。最好的方法就是控制锁的保护粒度，只需要保证被多个CPU缓存的同一份数据一致即可。所以引入了缓存锁（如缓存一致性机制），后来的CPU都提供了缓存一致性机制，Intel 486之后的处理器就提供了这种优化。</li></ul></li><li><p>缓存锁</p><ul><li>比总线锁，缓存锁降低了锁的粒度。为了达到数据访问的一致，需要各个CPU在访问高速缓存时遵循一些协议，在存取数据时根据协议来操作，常见的协议有MSI、MESI、MOSI等。最常见的就是MESI协议。</li><li>就整体而言，缓存一致性机制就是当某CPU对高速缓存中的数据进行操作之后，<strong>通知其他CPU放弃存储在它们内部的缓存数据，或者从主存中重新读取</strong>。</li></ul></li></ul><p>为了提高处理速度，CPU不直接和主存进行通信，而是先将系统主存的数据读到内部高速缓存（L1、L2或其他）后再进行操作，但操作完不知道何时会写入内存。<strong>如果对声明了volatile的变量进行写操作，JVM就会向CPU发送一条带lock前缀的指令，将这个变量所在缓存行的数据写回系统主存。但是，即使写回系统主存，如果其他CPU高速缓存中的值还是旧的，再执行计算操作也会有问题。</strong></p><p>所以，在多CPU的系统中，为了保证各个CPU的高速缓存中数据的一致性，会实现<strong>缓存一致性协议</strong>，<code>每个CPU通过嗅探在总线上传播的数据来检查自己的高速缓存中的值是否过期，当CPU发现自己缓存行对应的主存地址被修改时，就会将当前CPU的缓存行设置成无效状态，当CPU对这个数据执行修改操作时，会重新从系统主存中把数据读到CPU的高速缓存中。因为高速缓存的内容是部分主存内容的副本，所以应该与主存内容保持一致。</code></p><p>而CPU对高速缓存副本如何与主存内容保持一致有几种写入模式供选择，主要的写入模式有以下两种：<br>（1）<code>Write-Through（直写）模式</code>：在数据更新时，同时写入低一级的高速缓存和主存。此模式的优点是操作简单，因为所有的数据都会更新到主存，所以其他CPU读取主存时都是最新值。此模式的缺点是数据写入速度较慢，因为数据修改之后需要同时写入低一级的高速缓存和主存。<br>（2）<code>Write-Back（回写）模式</code>：数据的更新并不会立即反映到主存，而是只写入高速缓存。只在数据被替换出高速缓存或者变成共享（S）状态时，如果发现数据有变动，才会将最新的数据更新到主存。</p><p>Write-Back模式的优点是数据写入速度快，因为发生数据变动时不需要写入主存，所以这种模式占用总线少，大多数CPU的高速缓存采用这种模式。</p><p>此模式的缺点为：实现一致性协议比较复杂，因为最新值可能存放在私有高速缓存中，而不是存放在共享的高速缓存或者主存中。主要的缓存一致性协议有MSI协议、MESI协议等。</p><h3 id="MSI协议"><a href="#MSI协议" class="headerlink" title="MSI协议"></a>MSI协议</h3><p>多核CPU都有自己的专有高速缓存（一般为L1、L2），以及同一个CPU芯片板上不同CPU内核之间共享的高速缓存（一般为L3）。不同CPU内核的高速缓存中难免会加载同样的数据，那么如何保证数据的一致性呢？这就需要用到缓存一致性协议。</p><p>缓存一致性协议的基础版本为MSI协议，也叫作写入失效协议。<strong>如果同时有多个CPU要写入，总线会进行串行化，同一时刻只会有一个CPU获得总线的访问权</strong>。</p><p>MSI协议是一种简化的缓存一致性协议，全称为Modified、Shared、Invalid（修改、共享、无效）。它用于在多处理器系统中维护缓存一致性，确保每个处理器缓存中的数据与主内存中的数据保持一致。MSI协议是MESI协议的一个变种，去掉了Exclusive状态，简化了协议的实现。以下是MSI协议的详细介绍：</p><ol><li><strong>Modified（修改）</strong>：<ul><li>当一个缓存行处于Modified状态时，表示该缓存行的数据已经被修改，并且与主内存中的数据不一致。</li><li>只有一个处理器的缓存可以拥有该缓存行的Modified状态，其他处理器的缓存中该缓存行必须处于Invalid状态。</li><li>当处理器写入数据时，缓存行进入Modified状态，并且不需要立即写回主内存。</li></ul></li><li><strong>Shared（共享）</strong>：<ul><li>当一个缓存行处于Shared状态时，表示该缓存行的数据与主内存中的数据一致，并且多个处理器的缓存可能拥有该缓存行的副本。</li><li>处理器可以读取该缓存行，但写入操作会导致缓存行状态转换为Modified，并通知其他处理器将该缓存行设置为Invalid。</li></ul></li><li><strong>Invalid（无效）</strong>：<ul><li>当一个缓存行处于Invalid状态时，表示该缓存行的数据无效，处理器不能读取或写入该缓存行。</li><li>如果处理器需要访问该缓存行，必须从主内存或其他处理器的缓存中获取最新的数据，并将缓存行状态更新为Shared或Modified。</li></ul></li></ol><p>比如CPU c1、c2对变量m进行读写，采用缓存回写模式，总线操作:</p><blockquote><p>初始状态</p></blockquote><ul><li>变量m在主内存中，初始值为0。</li><li>c1和c2的缓存中都没有变量m的副本，即变量m的缓存行状态为Invalid。</li></ul><blockquote><p>步骤1：c1读取变量m</p></blockquote><ol><li>c1发出读请求，请求变量m的数据。</li><li>总线仲裁器检测到c1的读请求，并从主内存中读取变量m的数据。</li><li>主内存将变量m的数据发送给c1，c1的缓存中变量m的缓存行状态变为Shared。</li></ol><blockquote><p>步骤2：c2读取变量m</p></blockquote><ol><li>c2发出读请求，请求变量m的数据。</li><li>总线仲裁器检测到c2的读请求，并从主内存中读取变量m的数据。</li><li>主内存将变量m的数据发送给c2，c2的缓存中变量m的缓存行状态变为Shared。</li></ol><blockquote><p>步骤3：c1写入变量m</p></blockquote><ol><li>c1发出写请求，准备修改变量m的值。</li><li>c1的缓存中变量m的缓存行状态从Shared变为Modified。</li><li>c1通过总线发出无效化请求（Invalidate），通知其他CPU核心（包括c2）将变量m的缓存行设置为Invalid。</li><li>c2接收到无效化请求，将其缓存中变量m的缓存行状态设置为Invalid。</li><li>c1修改变量m的值，缓存行状态保持为Modified。</li></ol><blockquote><p>步骤4：c2再次读取变量m</p></blockquote><ol><li>c2发出读请求，请求变量m的数据。</li><li>总线仲裁器检测到c2的读请求，并发现c1的缓存中变量m的缓存行状态为Modified。</li><li>c1将修改后的变量m的数据发送给c2，并将其缓存中变量m的缓存行状态变为Shared。</li><li>c2接收到变量m的数据，缓存中变量m的缓存行状态变为Shared。</li></ol><blockquote><p>步骤5：c1回写变量m到主内存</p></blockquote><ol><li>c1决定回写变量m的数据到主内存。</li><li>c1将变量m的数据写回主内存，并将其缓存中变量m的缓存行状态变为Shared。</li><li>主内存更新变量m的值。</li></ol><h3 id="MESI协议及RFO请求"><a href="#MESI协议及RFO请求" class="headerlink" title="MESI协议及RFO请求"></a>MESI协议及RFO请求</h3><p>目前主流的缓存一致性协议为MESI写入失效协议，而MESI是MSI协议的扩展。在MESI协议中，每个缓存行（Cache Line）有4种状态，即M、E、S和I（全名是Modified、Exclusive、Shared和Invalid），可<br>用2 bit表示。</p><p>以下是对每个状态的解释：</p><ol><li>**Modified (M)**：缓存行是脏的，即缓存行的数据已经被修改，但还没有写回到内存中。这个缓存行只存在于一个处理器的缓存中，其他处理器的缓存中没有这个数据的副本。</li><li>**Exclusive (E)**：缓存行是干净的，且只存在于一个处理器的缓存中。数据与内存中的数据一致，但其他处理器的缓存中没有这个数据的副本。</li><li>**Shared (S)**：缓存行是干净的，且可能存在于多个处理器的缓存中。数据与内存中的数据一致，多个处理器可以共享这个数据。</li><li>**Invalid (I)**：缓存行是无效的，即缓存行中的数据不可用。这个缓存行需要从内存中重新加载数据。</li></ol><blockquote><p>MESI协议的工作原理如下：</p></blockquote><ul><li>当一个处理器需要读取数据时，它会首先检查自己的缓存。如果数据在缓存中，并且状态是M、E或S，那么处理器可以直接使用这个数据。</li><li>如果数据不在缓存中，或者状态是I，处理器会向总线发出读请求。其他处理器会监听这个请求，并根据自己缓存中的数据状态做出响应。</li><li>如果其他处理器的缓存中有这个数据，并且状态是M，那么这个处理器会将数据写回到内存，并将自己的缓存行状态改为S。请求数据的处理器会从内存中读取数据，并将自己的缓存行状态设置为S。</li><li>如果其他处理器的缓存中有这个数据，并且状态是E或S，那么这些处理器会将自己的缓存行状态改为S。请求数据的处理器会从内存中读取数据，并将自己的缓存行状态设置为S。</li><li>如果其他处理器的缓存中没有这个数据，请求数据的处理器会从内存中读取数据，并将自己的缓存行状态设置为E。</li></ul><h2 id="volatile的原理"><a href="#volatile的原理" class="headerlink" title="volatile的原理"></a>volatile的原理</h2><p>前面介绍过，为了解决CPU访问主存时主存读写性能的短板，在CPU中增加了高速缓存，但这带来了可见性问题。而Java的<code>volatile关</code>键字可以保证共享变量的主存可见性，也就是将共享变量的改动值立即刷新回主存。</p><p>在正常情况下，系统操作并不会校验共享变量的缓存一致性，只有当共享变量用volatile关键字修饰了，该变量所在的缓存行才被要求进行缓存一致性的校验。</p><p>接下来，从volatile关键字的汇编代码出发分析一下volatile关键字的底层原理，参考如下示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileVar</span> &#123;</span><br><span class="line">    <span class="comment">// 使用volatile保障内存可见性</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">var</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVar</span><span class="params">(<span class="type">int</span> <span class="keyword">var</span>)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;setVar = &quot;</span> + <span class="keyword">var</span>);</span><br><span class="line">        <span class="built_in">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">VolatileVar</span> <span class="variable">var</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileVar</span>();</span><br><span class="line">        <span class="keyword">var</span>.setVar(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出汇编代码的操作命令</p><ul><li>-Xcomp：表示永远以编译模式运行（禁止解释器模式）。</li><li>-XX:-Inline：禁止内联优化。</li><li>-server：设置虚拟机使用何种运行模式，“-server”表示选择server模式JVM，在Windows中默认的JVM类型为client模式。client模式启动比较快，但运行时性能和内存管理效率不如server模式，通常用于客户端应用程序。相反，server模式启动比client模式慢，但可获得更高的运行性能。如果要使用server模式，就需要在启动虚拟机时添加-server参数，以获得更高的性能。对于服务器端应用，推荐采用server模式，尤其是拥有多个CPU的系统。在Linux下，Solaris上默认采用server模式。</li><li>输出汇编代码中可能出现的错误<strong>无法加载hsdis-amd64.dll</strong>,<a href="https://chriswhocodes.com/hsdis/">下载hsdis HotSpot Disassembly Plugin Downloads</a>,放在 $JAVA_HOME&#x2F;jre&#x2F;bin&#x2F;server 目录下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target\classes&gt; java -server -Xcomp -XX:-Inline  -XX:+UnlockDiagnosticVMOptions  -XX:+PrintAssembly <span class="string">&quot;-XX:CompileCommand=compileonly,*VolatileVar.setVar&quot;</span>  .\VolatileVar.java &gt; <span class="keyword">volatile</span>.log</span><br></pre></td></tr></table></figure><ul><li><p>分析volatile关键字对应的汇编指令,运行程序后，volatile.log会有VolatileVar类的汇编指令。<br>volatile.log可能很长，可以根据共享变量的名称进行检索，这里的共享变量为var，所以可以减少到以下两行代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x00000000031fe26a: lock addl <span class="variable">$0x0</span>,(%rsp)     ;*putfield var</span><br><span class="line">                                              ; - pers.fulsun._3.VolatileVar::setVar@27 (line 9)</span><br><span class="line">  </span><br><span class="line">0x00000000031fe26f: add    <span class="variable">$0x50</span>,%rsp</span><br><span class="line">0x00000000031fe273: pop    %rbp</span><br></pre></td></tr></table></figure></li><li><p>由于共享变量var加了volatile关键字，因此在汇编指令中，操作var之前多出一个lock前缀指令<code>lock addl</code>，该lock前缀指令有三个功能。</p><ol><li>将当前CPU缓存行的数据立即写回系统内存<ul><li>在对volatile修饰的共享变量进行写操作时，其汇编指令前用lock前缀修饰。lock前缀指令使得在执行指令期间，CPU可以独占共享内存（即主存）。对共享内存的独占，老的CPU（如Intel 486）通过总线锁方式实现。由于总线锁开销比较大，因此新版CPU（如IA-32、Intel 64）通过缓存锁实现对共享内存的独占性访问，缓存锁（缓存一致性协议）会阻止两个CPU同时修改共享内存的数据。</li></ul></li><li>lock前缀指令会引起在其他CPU中缓存了该内存地址的数据无效<ul><li>写回操作时要经过总线传播数据，而每个CPU通过嗅探在总线上传播的数据来检查自己缓存的值是否过期，当CPU发现自己缓存行对应的内存地址被修改时，就会将当前CPU的缓存行设置为无效状态，当CPU要对这个值进行修改的时候，会强制重新从系统内存中把数据读到CPU缓存。</li></ul></li><li>lock前缀指令禁止指令重排<ul><li>lock前缀指令的最后一个作用是作为内存屏障（Memory Barrier）使用，可以禁止指令重排序，从而避免多线程环境下程序出现乱序执行的现象。</li></ul></li></ol></li></ul><h2 id="有序性与内存屏障"><a href="#有序性与内存屏障" class="headerlink" title="有序性与内存屏障"></a>有序性与内存屏障</h2><p>有序性是与可见性完全不同的概念，虽然二者都是CPU不断迭代升级的产物。由于CPU技术不断发展，为了重复释放硬件的高性能，编译器、CPU会优化待执行的指令序列，包括调整某些指令的顺序执行。优化的结果，指令执行顺序会与代码顺序略有不同，可能会导致代码执行出现有序性问题。</p><p>内存屏障又称内存栅栏（Memory Fences），是一系列的CPU指令，它的作用主要是保证特定操作的执行顺序，保障并发执行的有序性。在编译器和CPU都进行指令的重排优化时，可以通过在指令间插入一个内存屏障指令，告诉编译器和CPU，禁止在内存屏障指令前（或后）执行指令重排序。</p><h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>为了提高性能，编译器和CPU常常会对指令进行重排序。重排序主要分为两类：<code>编译器重排序</code>和<code>CPU重排序</code>，具体如图所示:</p><p><img src="/p/1c8195dc/c21352aaff3d8a9b2076b26f4c72095a.png"></p><ul><li><strong>编译器重排序</strong><ul><li>编译器重排序指的是在代码编译阶段进行指令重排，不改变程序执行结果的情况下，为了提升效率，编译器对指令进行乱序（Out-ofOrder）的编译。例如，在代码中，A操作需要获取其他资源而进入等待的状态，而A操作后面的代码跟A操作没有数据依赖关系，如果编译器一直等待A操作完成再往下执行的话，效率要慢得多，所以可以先编译后面的代码，这样的乱序可以提升编译速度。编译器为什么要重排序（Re-Order）呢？它的目的为：与其等待阻塞指令（如等待缓存刷入）完成，不如先去执行其他指令。与CPU乱序执行相比，编译器重排序能够完成更大范围、效果更好的乱序优化。</li></ul></li><li><strong>CPU重排序</strong><ul><li>流水线（Pipeline）和乱序执行（Out-of-Order Execution）是现代CPU基本都具有的特性。机器指令在流水线中经历取指令、译码、执行、访存、写回等操作。为了CPU的执行效率，流水线都是并行处理的，在不影响语义的情况下。处理次序（Process Ordering，机器指令在CPU实际执行时的顺序）和程序次序（Program Ordering，程序代码的逻辑执行顺序）是允许不一致的，只要满足As-if-Serial规则即可。显然，这里的不影响语义依旧只能保证指令间的显式因果关系，无法保证隐式因果关系，即无法保证语义上不相关但是在程序逻辑上相关的操作序列按序执行。</li></ul></li><li><strong>CPU重排序包括两类</strong>：<code>指令级重排序</code>和<code>内存系统重排序</code>。<ul><li>指令级重排序。在不影响程序执行结果的情况下，CPU内核采用ILP（Instruction-Level Parallelism，指令级并行运算）技术来将多条指令重叠执行，主要是为了提升效率。如果指令之间不存在数据依赖性，CPU就可以改变语句的对应机器指令的执行顺序，叫作指令级重排序。</li><li>内存系统重排序：对于现代的CPU来说，在CPU内核和主存之间都具备一个高速缓存，高速缓存的作用主要是减少CPU内核和主存的交互（CPU内核的处理速度要快得多），在CPU内核进行读操作时，如<br>果缓存没有的话就从主存取，而对于写操作都是先写在缓存中，最后再一次性写入主存，原因是减少跟主存交互时CPU内核的短暂卡顿，从而提升性能。但是，内存系统重排序可能会导致一个问题——数据不一致。</li><li>内存系统重排序和指令级重排序不同，内存系统重排序为伪重排序，也就是说只是看起来像在乱序执行而已。</li></ul></li></ul><blockquote><p>所谓“乱序”，仅仅是被称为“乱序”，实际上也遵循着一定规则：只要两个指令之间不存在“数据依赖”，就可以对这两个指令乱序。</p></blockquote><h3 id="As-if-Serial规则"><a href="#As-if-Serial规则" class="headerlink" title="As-if-Serial规则"></a>As-if-Serial规则</h3><p>在单核CPU的场景下，当指令被重排序之后，如何保障运行的正确性呢？其实很简单，编译器和CPU都需要遵守As-if-Serial规则。<strong>As-if-Serial规则的具体内容为：无论如何重排序，都必须保证代码在单线程下运行正确。</strong></p><p>为了遵守As-if-Serial规则，编译器和CPU不会对存在数据依赖关系的操作进行重排序，因为这种重排序会改变执行结果。但是，如果指令之间不存在数据依赖关系，这些指令可能被编译器和CPU重排序。</p><p>下面是一段非常简单的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReorderDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">1</span>; <span class="comment">//①</span></span><br><span class="line">        <span class="type">int</span> b=<span class="number">2</span>; <span class="comment">//②</span></span><br><span class="line">        <span class="type">int</span> c=a+b; <span class="comment">//③</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在示例代码中，③和①之间存在数据依赖关系，同时③和②之间也存在数据依赖关系。因此，在最终执行的指令序列中，③不能被重排序到①和②的前面，因为③排到①和②的前面，程序的结果将会被改变。但①和②之间没有数据依赖关系，编译器和CPU可以重排序①和②之间的执行顺序。</p><p>为了保证As-if-Serial规则，Java异常处理机制也会为指令重排序做一些特殊处理。下面是一段非常简单的Java异常处理示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReorderDemo2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            x = <span class="number">2</span>; <span class="comment">//①</span></span><br><span class="line">         y = <span class="number">0</span>/<span class="number">0</span>; <span class="comment">//②</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="comment">//③</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;x = &quot;</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的代码中，语句①（x&#x3D;2）和语句②（y&#x3D;0&#x2F;0）之间没有数据依赖关系，语句②可能会被重排序在①之前执行。重排之后，语句①尚未执行，语句②已经抛出异常，因而重排后会导致语句①得不到执行，最终x得到错误结果1。所以，为了保证最终不至于输出x&#x3D;1的错误结果，JIT在重排序时会在catch语句中插入错误补偿代码，补偿执行语句②，将x赋值为2，将程序恢复到发生异常时应有的状态。这种做法的确将异常捕捉的和处理的底层逻辑变得非常复杂，但是JIT的优化原则是，尽力保障正确的运行逻辑，哪怕以catch块逻辑变得复杂为代价。</p><blockquote><p>JIT是Just In Time的缩写，也就是“即时编译器”。JVM读入“.class”文件的字节码后，默认情况下是解释执行的。但是对于运行频率很高（如大于5000次）的字节码，JVM采用了JIT技术，将直接编译为机器指令，以提高性能。</p></blockquote><p>虽然编译器和CPU遵守了As-if-Serial规则，无论如何，也只能在单CPU执行的情况下保证结果正确。在多核CPU并发执行的场景下，由于CPU的一个内核无法清晰分辨其他内核上指令序列中的数据依赖关系，因此可能出现乱序执行，从而导致程序运行结果错误。</p><p>所以，<strong>As-if-Serial规则只能保障单内核指令重排序之后的执行结果正确，不能保障多内核以及跨CPU指令重排序之后的执行结果正确。</strong></p><h3 id="硬件层面的内存屏障"><a href="#硬件层面的内存屏障" class="headerlink" title="硬件层面的内存屏障"></a>硬件层面的内存屏障</h3><p>多核情况下，所有的CPU操作都会涉及缓存一致性协议（MESI协议）校验，该协议用于保障内存可见性。但是，缓存一致性协议仅仅保障内存弱可见（高速缓存失效），没有保障共享变量的强可见，而且缓存一致性协议更不能禁止CPU重排序，也就是不能确保跨CPU指令的有序执行。</p><p>如何保障跨CPU指令重排序之后的程序结果正确呢？需要用到<strong>内存屏障</strong>。</p><p><strong>内存屏障又称内存栅栏，是让一个CPU高速缓存的内存状态对其他CPU内核可见的一项技术，也是一项保障跨CPU内核有序执行指令的技术</strong>。</p><p>硬件层常用的内存屏障分为三种：<code>读屏障（Load Barrier）</code>、<code>写屏障（Store Barrier）</code>和<code>全屏障（Full Barrier）</code>。</p><ol><li>读屏障<ul><li><strong>读屏障让高速缓存中相应的数据失效</strong>。在指令前插入读屏障，可以让高速缓存中的数据失效，强制重新从主存加载数据。并且，读屏障会告诉CPU和编译器，先于这个屏障的指令必须先执行。</li><li>读屏障对应着X86处理器上的lfence指令，将强制所有在该指令之后的读操作都在lfence指令执行之后被执行，并且强制本地高速缓冲区的值全部失效，以便从主存中重新读取共享变量的值。</li><li>读屏障既使得当前CPU内核对共享变量的更改对所有CPU内核可见，又阻止了一些可能导致读取无效数据的指令重排。</li></ul></li><li>写屏障<ul><li>在指令后插入写屏障指令能让高速缓存中的最新数据更新到主存，让其他线程可见。并且，写屏障会告诉CPU和编译器，后于这个屏障的指令必须后执行。</li><li>写屏障对应X86处理器上的sfence指令，sfence指令会保证所有写操作都在该指令执行之前被完成，并<strong>把高速缓冲区的数据都刷新到主存中，使得当前CPU对共享变量的更改对所有CPU可见</strong>。</li></ul></li><li>全屏障<ul><li>全屏障是一种全能型的屏障，具备读屏障和写屏障的能力。Full Barrier又称为StoreLoad Barriers，对应X86处理器上的mfence指令。</li><li>在X86处理器平台上mfence指令综合了sfence指令与lfence指令的作用。X86处理器强制所有在mfence之前的store&#x2F;load指令都在mfence执行之前被执行；所有在mfence之后的store&#x2F;load指令都在该mfence执行之后被执行。简单来说，X86处理器禁止对mfence指令前后的<br>store&#x2F;load指令进行重排序。</li><li>X86处理器上的lock前缀指令也具有内存全屏障的功能。lock前缀后面可以跟ADD、ADC、AND、BTC、BTR、BTS、CMPXCHG、CMPXCH8B、DEC、INC、NEG、NOT、OR、SBB、SUB、XOR、XADD、XCHG等指令。</li></ul></li></ol><h3 id="硬件层的内存屏障的作用"><a href="#硬件层的内存屏障的作用" class="headerlink" title="硬件层的内存屏障的作用"></a>硬件层的内存屏障的作用</h3><ol><li>阻止屏障两侧的指令重排序编译器和CPU可能为了使性能得到优化而对指令重排序，但是插入一个硬件层的内存屏障相当于告诉CPU和编译器先于这个屏障的指令必须先执行，后于这个屏障的指令必须后执行。</li><li>强制让高速缓存的数据失效硬件层的内存屏障强制把高速缓存中的最新数据写回主存，让高速缓存中相应的脏数据失效。一旦完成写入，任何访问这个变量的线程将会得到最新的值。</li></ol><p>内存屏障的使用示例, 下面是一段可能乱序执行的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReorderDemo3</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        x= <span class="number">8</span>; <span class="comment">//①</span></span><br><span class="line">        flag = <span class="literal">true</span>; <span class="comment">//②</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123; <span class="comment">//③</span></span><br><span class="line">            <span class="comment">// x是多少？</span></span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReorderDemo3并发运行之后，控制台所输出的x值可能是0或8。为什么x可能会输出0呢？</p><p>主要原因是：update()和show()方法可能在两个CPU内核并发执行，语句①和语句②如果发生了重排序，那么show()方法输出的x就可能为0。如果输出的x结果是0，显然不是程序的正常结果。</p><p>如何确保ReorderDemo3的并发运行结果正确呢？可以通过内存屏障进行保障。Java语言没有办法直接使用硬件层的内存屏障，只能使用含有JMM内存屏障语义的Java关键字，这类关键字的典型为<code>volatile</code>。使用volatile关键字对实例中的x进行修饰，修改后的ReorderDemo3代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReorderDemo3</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> x= <span class="number">0</span>; <span class="comment">//使用volatile 关键字对x进行修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        x= <span class="number">8</span>; <span class="comment">//① //volatile 要求编译器在这里插入Store Barrier写屏障</span></span><br><span class="line">        flag = <span class="literal">true</span>; <span class="comment">//② </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123; <span class="comment">//③</span></span><br><span class="line">            <span class="comment">// x是多少</span></span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的ReorderDemo3代码使用volatile关键字对成员变量x进行修饰，<strong>volatile含有JMM全屏障的语义，要求JVM编译器在语句①的后面插入全屏障指令。该全屏障确保x的最新值对所有的后序操作是可见</strong><br><strong>的（含跨CPU场景），并且禁止编译器和处理器对语句①和语句②进行重排序</strong>。</p><p>前面介绍volatile关键字的原理时介绍过，volatile在X86处理器上被JVM编译之后，它的汇编代码中会被插入一条lock前缀指令（lock ADD），从而实现全屏障目的。</p><p>由于不同的物理CPU硬件所提供的内存屏障指令的差异非常大，因此JMM定义了自己的一套相对独立的内存屏障指令，用于屏蔽不同硬件的差异性。很多Java关键字（如volatile）在语义中包含JMM内存屏障指令，在不同的硬件平台上，这些JMM内存屏障指令会要求JVM为不同的平台生成相应的硬件层的内存屏障指令。</p><h2 id="JMM详解"><a href="#JMM详解" class="headerlink" title="JMM详解"></a>JMM详解</h2><p>JMM（Java Memory Model，Java内存模型）并不像JVM内存结构一样是真实存在的运行实体，<strong>更多体现为一种规范和规则</strong>。</p><h3 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h3><p>JMM最初由JSR-133（Java Memory Model and Thread Specification）文档描述，JMM定义了一组规则或规范，该规范定义了一个线程对共享变量写入时，如何确保对另一个线程是可见的。实际上，<strong>JMM提供了合理的禁用缓存以及禁止重排序的方法，所以其核心的价值在于解决可见性和有序性。</strong></p><p>JMM的另一大价值在于能<strong>屏蔽各种硬件和操作系统的访问差异，保证Java程序在各种平台下对内存的访问最终都是一致的</strong>。</p><p>Java内存模型规定所有的变量都存储在主存中，JMM的主存类似于物理内存，但有区别，还能包含部分共享缓存。每个Java线程都有自己的工作内存（类似于CPU高速缓存，但也有区别）。</p><p>Java内存模型定义的两个概念：</p><ul><li><strong>主存</strong>：主要存储的是Java实例对象，所有线程创建的实例对象都存放在主存中，无论该实例对象是成员变量还是方法中的本地变量（也称局部变量），当然也包括共享的类信息、常量、静态变量。由于是共享数据区域，因此多条线程对同一个变量进行访问可能会发现线程安全问题。</li><li><strong>工作内存</strong>：主要存储当前方法的所有本地变量信息（工作内存中存储着主存中的变量副本），<strong>每个线程只能访问自己的工作内存，即线程中的本地变量对其他线程是不可见的</strong>，即使两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括字节码行号指示器、相关Native方法的信息。注意，由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。</li></ul><p>Java内存模型的规定如下：<br>（1）所有变量存储在主存中。<br>（2）每个线程都有自己的工作内存，且对变量的操作都是在工作内存中进行的。<br>（3）不同线程之间无法直接访问彼此工作内存中的变量，要想访问只能通过主存来传递。</p><p>在JMM中，Java线程、工作内存、主存之间的关系大致如图所示。</p><p><img src="/p/1c8195dc/44c4aed7c29e0bd5b809ced36297e775.png"></p><p>JMM将所有的变量都存放在公共主存中，当线程使用变量时，会把公共主存中的变量复制到自己的工作内存（或者叫作私有内存)中，线程对变量的读写操作是自己的工作内存中的变量副本。因此，JMM模型也需要解决代码重排序和缓存可见性问题。<strong>JMM提供了一套自己的方案去禁用缓存以及禁止重排序来解决这些可见性和有序性问题</strong>。JMM提供的方案包括大家都很熟悉的<code>volatile</code>、<code>synchronized</code>、<code>fina</code>等。</p><p>JMM定义了一些内存操作的抽象指令集，然后将这些抽象指令包含到Java的<code>volatile</code>、<code>synchronized</code>等关键字的语义中，并要求JVM在实现这些关键字时必须具备其包含的JMM抽象指令的能力。</p><h3 id="JMM与JVM物理内存的区别"><a href="#JMM与JVM物理内存的区别" class="headerlink" title="JMM与JVM物理内存的区别"></a>JMM与JVM物理内存的区别</h3><ol><li>JMM（Java 内存模型）</li></ol><ul><li>定义：Java 内存模型（JMM）是一个规范，定义了 Java 线程如何通过内存进行交互，以及在并发编程中允许哪些行为。它指定了在多线程环境下变量的可见性、顺序性和原子性等规则。</li><li>内存管理：JMM 并不直接涉及物理内存，它关注的是线程如何访问和共享内存。它确保不同线程对内存有一致的视图，这是编写安全高效的多线程程序的关键。</li><li>JMM 的关键方面：<ul><li>可见性：确保一个线程对共享变量的修改对其他线程可见。</li><li>原子性：规定某些变量（如 volatile 变量）的操作是原子的，即操作不会被中断。</li><li>顺序性：指定内存访问的顺序，如跨线程读取和写入操作的允许顺序。</li></ul></li><li>抽象概念：<strong>JMM 更多的是关于内存操作的规则和语义，而不是物理内存的布局。</strong></li></ul><ol start="2"><li>JVM（Java 虚拟机）物理内存</li></ol><ul><li>定义：JVM 是运行 Java 程序的虚拟机，通过解释字节码（编译后的 Java 代码）来执行 Java 程序。JVM 提供了一个环境，在其中 Java 程序可以运行，并抽象化了底层的硬件和操作系统。JVM 使用物理内存来存储数据和执行 Java 程序的上下文。</li><li>内存管理：JVM 的内存模型包括多个物理内存区域，如：<ul><li>堆：用于动态内存分配（如对象、数组）。</li><li>栈：存储方法调用的栈帧和局部变量。</li><li>方法区：存储类、方法、常量等的元数据。</li><li>程序计数器（PC 寄存器）：存储当前执行指令的地址。</li><li>本地方法栈：用于本地方法调用（如果有）。</li></ul></li><li>物理内存：JVM 实际上运行在主机机器的物理内存（RAM）上。JVM 会在物理内存中分配堆、栈等内存区域来运行 Java 程序。</li></ul><blockquote><p><strong>关键区别</strong>: 总结来说，JMM 关注的是 线程间如何共享和访问内存，而 JVM 的物理内存则是 JVM 在运行时实际使用的内存资源。</p></blockquote><ol><li>概念层次：<ol><li>JMM 是一个高层的抽象，定义了 Java 程序在多线程下如何通过内存进行交互与一致性。</li><li>JVM 物理内存 指的是 Java 虚拟机在实际机器上用于运行 Java 程序的物理内存资源。</li></ol></li><li>关注点：<ol><li>JMM 关注的是 多线程和内存一致性，即如何确保不同线程对内存的访问是一致的。</li><li>JVM 物理内存 关注的是 内存的分配和管理，如堆、栈等在物理内存中的分配和使用。</li></ol></li></ol><h3 id="JMM的8个操作"><a href="#JMM的8个操作" class="headerlink" title="JMM的8个操作"></a>JMM的8个操作</h3><p>Java内存模型规定所有的变量都存储在主存中（类似于前面讲的主存或者物理内存），每个线程都有自己的工作内存（类似于CPU中的高速缓存）。工作内存保存了线程使用到的变量的拷贝副本，线程对变量的所有操作（读取、赋值等）必须在该线程的工作内存中进行。</p><p><strong>JMM定义了一套自己的主存与工作内存之间的交互协议，即一个变量如何从主存拷贝到工作内存，又如何从工作内存写入主存，该协议包含8种操作，并且要求JVM具体实现必须保证其中每一种操作都是原子的、不可再分的。</strong></p><p>JMM主存与工作内存之间的交互协议的8种操作:</p><ol><li>lock(锁定)：作用于主内存，它把一个变量标记为一条线程独占状态；</li><li>read(读取)：作用于主内存，它把变量值从主内存传送到线程的工作内存中，以便随后的load动作使用；</li><li>load(载入)：作用于工作内存，它把read操作的值放入工作内存中的变量副本中；</li><li>use(使用)：作用于工作内存，它把工作内存中的值传递给执行引擎，每当虚拟机遇到一个需要使用这个变量的指令时候，将会执行这个动作；</li><li>assign(赋值)：作用于工作内存，它把从执行引擎获取的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的指令时候，执行该操作；</li><li>store(存储)：作用于工作内存，它把工作内存中的一个变量传送给主内存中，以备随后的write操作使用；</li><li>write(写入)：作用于主内存，它把store传送值放到主内存中的变量中。</li><li>unlock(解锁)：作用于主内存，它将一个处于锁定状态的变量释放出来，释放后的变量才能够被其他线程锁定；</li></ol><p><img src="/p/1c8195dc/f325e487a99000388e35ca3404eee6e5.png"></p><p>Java内存模型还规定了执行上述8种基本操作时必须满足如下规则：</p><ol><li>不允许read和load、store和write操作之一单独出现，以上两个操作必须按顺序执行，但没有保证必须连续执行，也就是说，read与load之间、store与write之间是可插入其他指令的。<strong>不允许read和load、store和write操作之一单独出现，意味着有read就有load，不能读取了变量值而不予加载到工作内存中；有store就有write，也不能存储了变量值而不写到主存中</strong>。</li><li>不允许一个线程丢弃它最近的assign操作，也就是说当线程使用assign操作对私有内存的变量副本进行变更时，它必须使用write操作将其同步到主存中。<strong>assign操作不允许丢弃，即，工作内存中变量改变必须同步给主内存</strong>。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主存中。</li><li>一个新的变量只能从主存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use和store操作之前，必须先执行assign和load操作。<strong>use前必须有load，store前必须有assign。</strong></li><li>一个变量在同一个时刻只允许一个线程对其执行lock操作，但lock操作可以被同一个个线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li><li>如果一个变量实现没有被lock操作锁定，就不允许对它执行unlock操作，也不允许unlock一个被其他线程锁定的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步回主存（执行store和write操作）。</li></ol><p>以上JMM的8大操作规范定义相当严谨，也极为烦琐，JVM实现起来也非常复杂。Java设计团队大概也意识到了这个问题，新的JMM版本不断地对这些操作进行简化，比如将8个操作简化为Read、Write、Lock和Unlock四个操作。虽然进行了简化，但是JMM的基础设计并未改变。</p><blockquote><p>JMM的规范细节是JVM开发人员需要掌握的内容，对于普通的Java应用工程师、应用架构师来说，只需要了解其基本的原理即可。</p></blockquote><h3 id="JMM内存屏障"><a href="#JMM内存屏障" class="headerlink" title="JMM内存屏障"></a>JMM内存屏障</h3><p>JMM如何解决顺序一致性问题？JMM提供了自己的内存屏障指令，要求JVM编译器实现这些指令，禁止特定类型的编译器和CPU重排序（不是所有的编译器重排序都要禁止）。</p><p>由于不同CPU硬件实现内存屏障的方式不同，JMM屏蔽了这种底层CPU硬件平台的差异，定义了不对应任何CPU的JMM逻辑层内存屏障，由JVM在不同的硬件平台生成对应的内存屏障机器码。</p><p>JMM内存屏障主要有Load和Store两类，具体如下：</p><ol><li><code>Load Barrier</code>（读屏障）<br>在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主存加载数据。</li><li><code>Store Barrier</code>（写屏障）<br>在写指令之后插入写屏障，能让写入缓存的最新数据写回主存。</li></ol><p>在实际使用时，会对以上JMM的Load Barrier和Store Barrier两类屏障进行组合，组合成<code>LoadLoad（LL）</code>、<code>StoreStore（SS）</code>、<code>LoadStore（LS）</code>、<code>StoreLoad（SL）</code>四个屏障，用于禁止特定类型的CPU重排序。</p><ul><li><p><code>LoadLoad（LL）</code>屏障<br>在执行预加载（或支持乱序处理）的指令序列中，通常需要显式地声明LoadLoad屏障，因为这些Load指令可能会依赖其他CPU执行的Load指令的结果。<br>一段使用LoadLoad（LL）屏障的伪代码示例如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Load1; LoadLoad; Load2;</span><br><span class="line"><span class="comment">// 该示例的含义为：在Load2要读取的数据被访问前，使用LoadLoad屏障保证Load1要读取的数据被读取完毕。</span></span><br></pre></td></tr></table></figure></li><li><p><code>StoreStore（SS）</code>屏障<br>通常情况下，如果CPU不能保证从高速缓冲向主存（或其他CPU）按顺序刷新数据，那么它需要使用StoreStore屏障。<br>一段使用StoreStore（SS）屏障的伪代码示例如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Store1; StoreStore; Store2;</span><br><span class="line"><span class="comment">// 该示例的含义为：在Store2及后续写入操作执行前，使StoreStore屏障保证Store1的写入结果对其他CPU可见。</span></span><br></pre></td></tr></table></figure></li><li><p><code>LoadStore（LS）</code>屏障<br>该屏障用于在数据写入操作执行前确保完成数据的读取。</p><p>一段使用LoadStore（LS）屏障的伪代码示例如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Load1; LoadStore; Store2;</span><br><span class="line"><span class="comment">// 该示例的含义为：在Store2及后续写入操作执行前，使LoadStore屏障保证Load1要读取的数据被读取完毕。</span></span><br></pre></td></tr></table></figure></li><li><p><code>StoreLoad（SL）</code></p><p>屏障该屏障用于在数据读取操作执行前，确保完成数据的写入。</p><p>StoreLoad（SL）屏障的开销是4种屏障中最大的，但是此屏障是一个“全能型”的屏障，兼具其他3个屏障的效果，现代的多核CPU大多支持该屏障。</p><p>使用LoadStore（LS）屏障的伪代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Store1; StoreLoad; Load2;</span><br><span class="line"><span class="comment">// 该示例的含义为：在Load2及后续所有读取操作执行前，使StoreLoad屏障保证Store1的写入对所有CPU可见。</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="volatile语义中的内存屏障"><a href="#volatile语义中的内存屏障" class="headerlink" title="volatile语义中的内存屏障"></a>volatile语义中的内存屏障</h2><p>在Java代码中，volatile关键字主要有两层语义：</p><ol><li>不同线程对volatile变量的值具有内存可见性，即一个线程修改了某个volatile变量的值，该值对其他线程立即可见。</li><li>禁止进行指令重排序。</li></ol><p>总之，<strong>volatile关键字除了保障内存可见性外，还能确保执行的有序性</strong>。volatile语义中的<strong>有序性是通过内存屏障指令来确保的</strong>。为了实现volatile关键字语义的有序性，JVM编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。JMM建议JVM采取保守策略对重排序进行严格禁止。下面是基于保守策略的volatile操作的内存屏障插入策略。</p><ul><li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadStore屏障。</li><li>在每个volatile写操作的前面插入一个StoreStore屏障。</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li></ul><p>volatile<strong>写操作的内存屏障插入策略</strong>为：在每个volatile写操作前插入StoreStore（SS）屏障，在写操作后面插入StoreLoad屏障，具体如图所示。</p><p><img src="/p/1c8195dc/b3d79e517a7bd11bc874e67e9520adfe.png"></p><p>volatile<strong>读操作的内存屏障插入策略</strong>为：在每个volatile写操作后插入LoadLoad（LL）屏障和LoadStore屏障，禁止后面的普通读、普通写和前面的volatile读操作发生重排序</p><p><img src="/p/1c8195dc/5549182a4e943ef7603a93364ac0b856.png"></p><p>上述JMM建议的volatile写和volatile读的内存屏障插入策略是针对任意处理器平台的，所以非常保守。不同的处理器有不同“松紧<br>度”的处理器内存模型，只要不改变volatile读写操作的内存语义，不同JVM编译器可以根据具体情况省略不必要的JMM屏障。以X86处理器为例，该平台的JVM实现仅仅在volatile写操作后面插入一个StoreLoad屏障，其他的JMM屏障都会被省略。由于StoreLoad屏障的开销大，因此在X86处理器中，volatile写操作比volatile读操作的开销会大很多。</p><h2 id="volatile不具备原子性"><a href="#volatile不具备原子性" class="headerlink" title="volatile不具备原子性"></a>volatile不具备原子性</h2><p>volatile能保证数据的可见性，但volatile不能完全保证数据的原子性，对于volatile类型的变量进行复合操作（如++），其仍存在线程不安全的问题。</p><p>下面的例子使用10个线程，每个线程进行1000次自增操作（复合操作），看看最终的结果是否正确，具体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAtomicLong</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 并发任务数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TASK_AMOUNT</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池，获取CPU密集型任务线程池</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> ThreadUtil.getCpuIntensiveThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个线程的执行轮数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TURNS</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">    <span class="comment">// 线程同步倒数闩</span></span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(TASK_AMOUNT);</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TASK_AMOUNT; i++) &#123;</span><br><span class="line">        pool.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; TURNS; j++) &#123;</span><br><span class="line">                    value++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 倒数闩，倒数一次 countDownLatch.countDown();</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略，等待倒数闩完成所有的倒数操作</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="variable">time</span> <span class="operator">=</span> (System.currentTimeMillis() - start) / <span class="number">1000F</span>;</span><br><span class="line">    <span class="comment">// 输出统计结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;运行的时长为：&quot;</span> + time);</span><br><span class="line">    System.out.println(<span class="string">&quot;累加结果为：&quot;</span> + value);</span><br><span class="line">    System.out.println(<span class="string">&quot;与预期相差：&quot;</span> + (TURNS * TASK_AMOUNT - value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行的时长为：<span class="number">0.034</span></span><br><span class="line">累加结果为：<span class="number">8701</span></span><br><span class="line">与预期相差：<span class="number">91186</span></span><br></pre></td></tr></table></figure><p>通过实验可以看出：volatile变量的复合操作不具备原子性。</p><h3 id="不具备原子性的原理"><a href="#不具备原子性的原理" class="headerlink" title="不具备原子性的原理"></a>不具备原子性的原理</h3><p>首先回顾一下JMM对变量进行读取和写入的操作流程</p><p><img src="/p/1c8195dc/3524c7ee69c1c10e8218366d25b071a7.png" alt="image-20250110210451232"></p><ul><li><p>对于<strong>非volatile修饰的普通变量</strong>而言，在读取变量时，<strong>JMM要求保持read、load有相对顺序即可</strong>。例如，若从主存读取i、j两个变量，可能的操作是<code>read i=&gt;read j=&gt;load j=&gt;load i</code>，并不要求read、load操作是连续的。</p></li><li><p>对于关键字volatile修饰的内存可见变量而言，具有两个重要的语义：</p><ol><li>使用volatile修饰的变量在变量值发生改变时，会立刻同步到主存，并使其他线程的变量副本失效。</li><li>禁止指令重排序：用volatile修饰的变量在硬件层面上会通过在指令前后加入内存屏障来实现，编译器级别是通过下面的规则实现的。</li></ol></li></ul><blockquote><p>为了实现这些volatile内存语义，<strong>JMM对于volatile变量会有特殊的约束：</strong></p></blockquote><ol><li>使用volatile修饰的变量其<strong>read、load、use都是连续出现的</strong>，所以每次使用变量的时候都要从主存读取最新的变量值，替换私有内存的变量副本值（如果不同的话）。</li><li>其对同一变量的<strong>assign、store、write操作都是连续出现的</strong>，所以每次对变量的改变都会立马同步到主存中。</li></ol><p>稍加思考就可以理解，虽然volatile修饰的变量可以强制刷新内存，但是其并不具备原子性。虽然其要求对变量的（read、load、<br>use）、（assign、store、write）必须是连续出现，但是在不同CPU内核上并发执行的线程还是有可能出现读取脏数据的时候。</p><p>以前面的VolatileDemo为例，假设有两个线程A、B分别运行在Core1、Core2上，并假设此时的value为0，线程A、B也都读取了value值到自己的工作内存。</p><ul><li>现在线程A将value变成1之后，完成了assign、store的操作，假设在执行write指令之前，线程A的CPU时间片用完，线程A被空闲，但是线程A的write操作没有到达主存。</li><li>由于线程A的store指令触发了写的信号，线程B缓存过期，重新从主存读取到value值，但是线程A的写入没有最终完成，线程B读到的value值还是0。</li><li>线程B执行完成所有的操作之后，将value变成1写入主存。线程A的时间片重新拿到，重新执行store操作，将过期了的1写入主存。</li></ul><p><img src="/p/1c8195dc/7751bfe7a083fcd76aa87177ff692bb0.png"></p><p>对于复合操作，volatile变量无法保障其原子性，如果要保证复合操作的原子性，就需要使用锁。并且，<strong>在高并发场景下，volatile变量一定需要使用Java的显式锁结合使用</strong>。</p><h2 id="Happens-Before规则"><a href="#Happens-Before规则" class="headerlink" title="Happens-Before规则"></a>Happens-Before规则</h2><p>JMM的内存屏障指令对Java工程师是透明的，是JMM对JVM实现的一种规范和要求。那么，作为Java工程师，如何确保自己设计和开发的Java代码不存在内存可见性问题或者有序性问题？</p><p>JMM定义了一套自己的规则：Happens-Before（先行发生）规则，并且确保只要两个Java语句之间必须存在Happens-Before关系，JMM尽量确保这两个Java语句之间的内存可见性和指令有序性。</p><h3 id="规则介绍"><a href="#规则介绍" class="headerlink" title="规则介绍"></a>规则介绍</h3><p>Happens-Before规则的主要内容包括以下几个方面：</p><ol><li><p><code>程序顺序执行规则</code>（as-if-serial规则）</p><p>在同一个线程中，有依赖关系的操作按照先后顺序，前一个操作必须先行发生于后一个操作（Happens-Before）。换句话说，单个线程中的代码顺序无论怎么重排序，对于结果来说是不变的。</p></li><li><p><code>volatile变量规则</code><br>对volatile（修饰的）变量的写操作必须先行发生于对volatile变量的读操作。</p></li><li><p><code>传递性规则</code><br>如果A操作先于B操作，而B操作又先行发生于C操作，那么A操作先行发生于C操作。</p></li><li><p><code>监视锁规则</code>（Monitor Lock Rule）<br>对一个监视锁的解锁操作先行发生于后续对这个监视锁的加锁操作。</p></li><li><p><code>start规则</code><br>对线程的start操作先行于这个线程内部的其他任何操作。具体来说，如果线程A执行B.start()启动线程B，那么线程A的B.start()操作先行发生于线程B中的任意操作。</p></li><li><p><code>join规则</code><br>如果线程A执行了B.join()操作并成功返回，那么线程B中的任意操作先行发生于线程A所执行的ThreadB.join()操作。</p></li></ol><h3 id="规则1：顺序性规则"><a href="#规则1：顺序性规则" class="headerlink" title="规则1：顺序性规则"></a>规则1：顺序性规则</h3><p>顺序性规则的具体内容：一个线程内，按照代码顺序，书写在前面的操作先行发生（Happens-Before）于书写在后面的操作。<br>一段程序的执行，在单个线程中看起来是有序的。程序次序规则看起来是按顺序执行的，因为虚拟机可能会对程序指令进行重排序。<br>虽然进行了重排序，但是最终执行的结果与程序顺序执行的结果是一致的。它只会对不存在数据依赖行的指令进行重排序。<br>该规则就是前面介绍的As-if-Serial规则，仅仅用来保证程序在单线程执行结果的正确性，但是无法保证程序在多线程执行结果的正<br>确性。</p><h3 id="规则2：volatile规则"><a href="#规则2：volatile规则" class="headerlink" title="规则2：volatile规则"></a>规则2：volatile规则</h3><p>volatile规则的具体内容：对一个volatile变量的写先行发生（Happens-Before）于任意后续对这个volatile变量的读。<br>基于volatile变量的Happens-Before规则，罗列一下volatile操作与前后指令之间可否重排序的清单，</p><table><thead><tr><th>第一个操作</th><th>第二个操作：普通读写</th><th>第二个操作：volatile读</th><th>第二个操作：volatile写</th></tr></thead><tbody><tr><td>普通读写</td><td>可以重排</td><td>可以重排</td><td>不可以重排</td></tr><tr><td>volatile读</td><td>不可以重排</td><td>不可以重排</td><td>不可以重排</td></tr><tr><td>volatile写</td><td>可以重排</td><td>不可以重排</td><td>不可以重排</td></tr></tbody></table><ul><li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li><li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li><li>当第一个操作是volatile写，第二个操作是volatile读或写时，不能重排序。</li></ul><h3 id="规则3：传递性规则"><a href="#规则3：传递性规则" class="headerlink" title="规则3：传递性规则"></a>规则3：传递性规则</h3><p>传递性规则的具体内容：如果A操作先行发生于B操作，且B操作先行发生于C操作，那么A操作先行发生于C操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileReorderDemo2</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">doubleValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        value = <span class="number">100</span>; <span class="comment">//①</span></span><br><span class="line">        flag = <span class="literal">true</span>; <span class="comment">//②</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doubleX</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="comment">//③        &#123;</span></span><br><span class="line">            doubleValue = x + x; <span class="comment">//④</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果线程B读到了flag是true，那么value&#x3D;100对线程B就一定可见了。</p><h3 id="规则4：监视锁规则"><a href="#规则4：监视锁规则" class="headerlink" title="规则4：监视锁规则"></a>规则4：监视锁规则</h3><p>监视锁规则的具体内容：对一个锁的unlock操作先行发生于后面对同一个锁的lock操作，即无论在单线程还是多线程中，同一个锁如<br>果处于被锁定状态，那么必须先对锁进行释放操作，后面才能继续执行lock操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileReorderDemo2</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">doubleValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        value = <span class="number">100</span>; <span class="comment">//①</span></span><br><span class="line">        flag = <span class="literal">true</span>; <span class="comment">//②</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doubleX</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="comment">//③        &#123;</span></span><br><span class="line">            doubleValue = x + x; <span class="comment">//④</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先获取锁的线程，对x赋值之后释放锁，另一个再获取锁，一定能看到对x赋值的改动，就是这么简单。请读者用如图4-19所示的命令查看上面的程序，看同步块和同步方法被转换成汇编指令有什么不同。</p><p>监视锁规则不会对临界区内的代码进行约束，临界区内的代码可以重排序（但JMM不允许临界区内的代码“逸出”到临界区之外，那样<br>会破坏监视器的语义）。JMM会在退出临界区和进入临界区这两个关键时间点做一些特别处理，虽然线程A在临界区内进行了重排序，但由于监视器互斥执行的特性，这里的线程B根本无法“观察”到线程A在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</p><h3 id="规则5：start-规则"><a href="#规则5：start-规则" class="headerlink" title="规则5：start()规则"></a>规则5：start()规则</h3><p>start()规则的具体内容：如果线程A执行ThreadB.start()操作启动线程B，那么线程A的ThreadB.start()操作先行发生于线程B中的任意操作。反过来说，<strong>如果主线程A启动子线程B后，线程B能看到线程A在启动操作前的任何操作。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">startExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;线程A&quot;</span>);</span><br><span class="line">        <span class="type">startExample</span> <span class="variable">startExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">startExample</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(startExample::writer, <span class="string">&quot;线程B&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动线程B前，线程A进行了多个内存操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;开始赋值操作&quot;</span>);</span><br><span class="line">        startExample.x = <span class="number">10</span>;</span><br><span class="line">        startExample.y = <span class="number">20</span>;</span><br><span class="line">        startExample.flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        threadB.start(); <span class="comment">// 启动线程B</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;x:&quot;</span> + x);</span><br><span class="line">        System.out.println(<span class="string">&quot;y:&quot;</span> + y);</span><br><span class="line">        System.out.println(<span class="string">&quot;flag:&quot;</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[线程A|StartExample.main]：开始赋值操作</span><br><span class="line">[线程A|StartExample.main]：线程结束</span><br><span class="line">[线程B|StartExample.writer]：x:<span class="number">10</span></span><br><span class="line">[线程B|StartExample.writer]：y:<span class="number">20</span></span><br><span class="line">[线程B|StartExample.writer]：flag:<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>通过结果可以看出：线程B看到了线程A调用threadB.start()之前的所有赋值结果。</p><h3 id="规则6：join-规则"><a href="#规则6：join-规则" class="headerlink" title="规则6：join()规则"></a>规则6：join()规则</h3><p>join()规则的具体内容：如果线程A执行threadB.join()操作并成功返回，那么线程B中的任意操作先行发生于线程A的ThreadB.join()操作。join()规则和start()规则刚好相反，线程A等待子线程B完成后，当前线程B的赋值操作，线程A都能够看到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;线程A&quot;</span>);</span><br><span class="line">        <span class="type">JoinExample</span> <span class="variable">joinExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JoinExample</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(joinExample::writer, <span class="string">&quot;线程B&quot;</span>);</span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        threadB.join();<span class="comment">// 线程A join线程B</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;x:&quot;</span> + joinExample.x);</span><br><span class="line">        System.out.println(<span class="string">&quot;y:&quot;</span> + joinExample.y);</span><br><span class="line">        System.out.println(<span class="string">&quot;flag:&quot;</span> + joinExample.flag);</span><br><span class="line">        System.out.println(<span class="string">&quot;本线程结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始赋值操作&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.x = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">this</span>.y = <span class="number">200</span>;</span><br><span class="line">        <span class="built_in">this</span>.flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[线程B|JoinExample.writer]：开始赋值操作</span><br><span class="line">[线程A|JoinExample.main]：x:<span class="number">100</span></span><br><span class="line">[线程A|JoinExample.main]：y:<span class="number">200</span></span><br><span class="line">[线程A|JoinExample.main]：flag:<span class="literal">true</span></span><br><span class="line">[线程A|JoinExample.main]：本线程结束</span><br></pre></td></tr></table></figure><p>通过结果可以看出：线程A在调用了threadB.join()之后，看到了线程B所有的赋值结果</p><script>var description="介绍Java如何解决并发编程中的可见性和有序性问题。"</script>]]></content>
      
      
      <categories>
          
          <category> 多线程编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAS原理 </tag>
            
            <tag> JUC原子类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS原理与JUC原子类</title>
      <link href="/p/4793d884.html"/>
      <url>/p/4793d884.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>由于JVM的Synchronized重量级锁涉及操作系统（如Linux）内核态下互斥锁的使用，因此其线程阻塞和唤醒都涉及进程在用户态到内核态的频繁切换，导致重量级锁开销大、性能低。而JVM的Synchronized轻量级锁使用CAS（Compare And Swap，比较并交换）进行自旋抢锁，<strong>CAS是CPU指令级的原子操作，并处于用户态下，所以JVM轻量级锁的开销较小</strong>。</p><h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p>JDK 5所增加的JUC（java.util.concurrent）并发包对操作系统的底层CAS原子操作进行了封装，为上层Java程序提供了CAS操作的API。</p><h2 id="Unsafe类中的CAS方法"><a href="#Unsafe类中的CAS方法" class="headerlink" title="Unsafe类中的CAS方法"></a>Unsafe类中的CAS方法</h2><p>Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全的底层操作，如直接访问系统内存资源、自主管理内存资源等。Unsafe大量的方法都是native方法，基于C++语言实现，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。</p><p>Unsafe类的全限定名为<strong>sun.misc.Unsafe</strong>，从名字中可以看出这个类对普通程序员来说是“危险”的，一般的应用开发都不会涉及此类，<strong>Java官方也不建议直接在应用程序中使用这些类</strong>。</p><p>为什么此类取名为Unsafe呢？由于使用Unsafe类可以像C语言一样使用指针操作内存空间，这无疑增加了指针相关问题、内存泄漏问题出现的概率。总之，在程序中过度使用Unsafe类会使得程序出错的概率变大，使得安全的语言Java变得不再安全，因此对Unsafe的使用一定要慎重。</p><p><strong>操作系统层面的CAS是一条CPU的原子指令（cmpxchg指令），正是由于该指令具备原子性，因此使用CAS操作数据时不会造成数据不一致的问题</strong>，Unsafe提供的CAS方法直接通过native方式（封装C++代码）调用了底层的CPU指令cmpxchg。</p><p>完成Java应用层的CAS操作主要涉及Unsafe方法的调用，具体如下：</p><ol><li>获取Unsafe实例。</li><li>调用Unsafe提供的CAS方法，这些方法主要封装了底层CPU的CAS原子操作。</li><li>调用Unsafe提供的字段偏移量方法，这些方法用于获取对象中的字段（属性）偏移量，此偏移量值需要作为参数提供给CAS操作。</li></ol><h3 id="获取Unsafe实例"><a href="#获取Unsafe实例" class="headerlink" title="获取Unsafe实例"></a>获取Unsafe实例</h3><p>Unsafe类是一个final修饰的不允许继承的最终类，而且其构造函数是private类型的方法，具体的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Unsafe</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INVALID_FIELD_OFFSET</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">registerNatives</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 构造函数是private的，不允许外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Unsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们无法在外部对Unsafe进行实例化，那么怎么获取Unsafe的实例呢？可以通过反射的方式自定义地获取Unsafe实例的辅助方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略import</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JvmUtil</span> &#123; </span><br><span class="line">    <span class="comment">//自定义地获取Unsafe实例的辅助方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> (Unsafe) theUnsafe.get(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 省略不相干代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用Unsafe提供的CAS方法"><a href="#调用Unsafe提供的CAS方法" class="headerlink" title="调用Unsafe提供的CAS方法"></a>调用Unsafe提供的CAS方法</h3><p>Unsafe提供的CAS方法包含4个操作数——字段所在的对象、字段内存位置、预期原值及新值。<strong>在执行Unsafe的CAS方法时，这些方法首先将内存位置的值与预期值（旧的值）比较，如果相匹配，那么CPU会</strong><br><strong>自动将该内存位置的值更新为新值，并返回true；如果不匹配，CPU不做任何操作，并返回false</strong>。</p><p>Unsafe的CAS操作会将第一个参数（对象的指针、地址）与第二个参数（字段偏移量）组合在一起，计算出最终的内存操作地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义在Unsafe类中的三个“比较并交换”原子方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 需要操作的字段所在的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset 需要操作的字段的偏移量（相对的，相对于对象头）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expected 期望值（旧的值）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update 更新值（新的值）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 更新成功 | false 更新失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(</span></span><br><span class="line"><span class="params">    Object o, <span class="type">long</span> offset, Object expected, Object update)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(</span></span><br><span class="line"><span class="params">    Object o, <span class="type">long</span> offset, <span class="type">int</span> expected, <span class="type">int</span> update)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(</span></span><br><span class="line"><span class="params">    Object o, <span class="type">long</span> offset, <span class="type">long</span> expected, <span class="type">long</span> update)</span>;</span><br></pre></td></tr></table></figure><h3 id="调用Unsafe提供的偏移量相关"><a href="#调用Unsafe提供的偏移量相关" class="headerlink" title="调用Unsafe提供的偏移量相关"></a>调用Unsafe提供的偏移量相关</h3><p>Unsafe提供的获取字段（属性）偏移量的相关操作主要如下：</p><ul><li>staticFieldOffset()方法用于<strong>获取静态属性Field在Class对象中的偏移量</strong>，在CAS中操作静态属性时会用到这个偏移量。</li><li>objectFieldOffset()方法用于<strong>获取非静态Field（非静态属性）在Object实例中的偏移量</strong>，在CAS中操作对象的非静态属性时会用到这个偏移量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义在Unsafe类中的几个获取字段偏移量的方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> o 需要操作字段的反射</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 字段的偏移量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">staticFieldOffset</span><span class="params">(Field field)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">objectFieldOffset</span><span class="params">(Field field)</span>;</span><br></pre></td></tr></table></figure><p>一个获取非静态Field（非静态属性）在Object实例中的偏移量的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取反射的Field对象</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> OptimisticLockingPlus.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 取得内存偏移</span></span><br><span class="line">        valueOffset = unsafe.objectFieldOffset(field);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用CAS进行无锁编程"><a href="#使用CAS进行无锁编程" class="headerlink" title="使用CAS进行无锁编程"></a>使用CAS进行无锁编程</h2><p>CAS是一种无锁算法，该算法关键依赖两个值——期望值（旧值）和新值，底层CPU利用原子操作判断内存原值与期望值是否相等，如果相等就给内存地址赋新值，否则不做任何操作。</p><p>使用CAS进行无锁编程的步骤大致如下：</p><ol><li>获得字段的期望值（oldValue）。</li><li>计算出需要替换的新值（newValue）。</li><li>通过CAS将新值（newValue）放在字段的内存地址上，如果CAS失败就重复第（1）步到第（2）步，一直到CAS成功，这种重复俗称<strong>CAS自旋</strong>。</li></ol><p>使用CAS进行无锁编程的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    获得字段的期望值（oldValue）;</span><br><span class="line">    计算出需要替换的新值（newValue）;</span><br><span class="line">&#125; <span class="keyword">while</span> (!CAS(内存地址，oldValue，newValue))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假如某个内存地址（某对象的属性）的值为100，现在有两个线程（线程A和线程B）使用CAS无锁编程对该内存地址进行更新，线程A欲将其值更新为200，线程B欲将其值更新为300，线程是并发执行的，谁都有可能先执行。但是CAS是原子操作，对同一个内存地址的CAS操作在同一时刻只能执行一个。因此，在这个例<br>子中，要么线程A先执行，要么线程B先执行。</p><ul><li>假设线程A的CAS(100,200)执行在前，由于内存地址的旧值100与该CAS的期望值100相等，因此线程A会操作成功，内存地址的值被更新为200。</li><li>接下来执行线程B的CAS(100,300)操作，此时内存地址的值为200，不等于CAS的期望值100，线程B操作失败。线程B只能自旋，开始新的循环，这一轮循环首先获取到内存地址的值200，然后进行CAS(200,300)操作，这一次内存地址的值与CAS的预期值（oldValue）相等，线程B操作成功。</li></ul><p>当CAS将内存地址的值与预期值进行比较时，如果相等，就证明内存地址的值没有被修改，可以替换成新值，然后继续往下运行；如果不相等，就说明内存地址的值已经被修改，放弃替换操作，然后重新自旋。当并发修改的线程少，冲突出现的机会少时，自旋的次数也会很少，CAS的性能会很高；当并发修改的线程多，冲突出现的机会多时，自旋的次数也会很多，CAS的性能会大大降低。所以，<strong>提升CAS无</strong><br><strong>锁编程效率的关键在于减少冲突的机会</strong>。</p><h3 id="无锁编程实现轻量级安全自增"><a href="#无锁编程实现轻量级安全自增" class="headerlink" title="无锁编程实现轻量级安全自增"></a>无锁编程实现轻量级安全自增</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">// 统计失败的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">failure</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ++value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自增</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">synchronincrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ++value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cas自增</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">casincrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">expected</span> <span class="operator">=</span> value;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newvalue</span> <span class="operator">=</span> expected + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!compareAndSwap(expected, newvalue)) &#123;</span><br><span class="line">            expected = value;</span><br><span class="line">            newvalue = expected + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newvalue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compareAndSwap</span><span class="params">(<span class="type">int</span> expected, <span class="type">int</span> newvalue)</span> &#123;</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            unsafe = (Unsafe) theUnsafe.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> unsafe.objectFieldOffset(Test.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;offset:&quot;</span> + offset);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, offset, expected, newvalue);</span><br><span class="line">            <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                failure.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 对value进行CAS操作</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    obj.casincrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i] = thread;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待所有线程执行完毕</span></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(obj.value);</span><br><span class="line">        System.out.println(<span class="string">&quot;失败次数：&quot;</span> + failure.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// offset:12</span></span><br><span class="line"><span class="comment">// 10000</span></span><br><span class="line"><span class="comment">// 失败次数：49430</span></span><br></pre></td></tr></table></figure><h3 id="字段偏移量的计算"><a href="#字段偏移量的计算" class="headerlink" title="字段偏移量的计算"></a>字段偏移量的计算</h3><p>调用Unsafe.objectFieldOffset(…)方法获取到的Object字段（也叫Object成员属性）的偏移量值是字段相<strong>对于Object头部的偏移</strong><br><strong>量，是一个相对的内存地址值，不是绝对的内存地址值</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">// 统计失败的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">failure</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然Test类有2个字段，但是其中有1个是静态字段，属于类的成员而不是对象的成员，真正属于对象的字段只有其中的value字段。所以类的对象结构<br>如图所示:</p><p><img src="/p/4793d884/0122f5b891aacc36aceff1fdd33307e0.png"></p><p>在64位的JVM堆区中一个Test对象的Object Header（头部）占用了12字节，其中Mark Word占用了8字节（64位），压缩过的Class Pointer占用了4字节。接在Object Header之后的就是成员属性value的内存区域<strong>，所以value属性相对于Object Header的偏移量为12</strong>。</p><h2 id="JUC原子类"><a href="#JUC原子类" class="headerlink" title="JUC原子类"></a>JUC原子类</h2><p>在多线程并发执行时，诸如“++”或“–”类的运算不具备原子性，不是线程安全的操作。通常情况下，大家会使用synchronized将这些线程不安全的操作变成同步操作，但是这样会降低并发程序的性能。所以，JDK为这些类型不安全的操作提供了一些原子类，与synchronized同步机制相比，JDK原子类是基于CAS轻量级原子操作的实现，使得程序运行效率变得更高。</p><h3 id="Atomic原子操作包"><a href="#Atomic原子操作包" class="headerlink" title="Atomic原子操作包"></a>Atomic原子操作包</h3><p>Atomic操作翻译成中文是指一个不可中断的操作，即使在多个线程一起执行Atomic类型操作的时候，一个操作一旦开始，就不会被其<br>他线程中断。所谓Atomic类，指的是具有原子操作特征的类。JUC并发包中原子类的位置JUC并发包中的原子类都存放在<code>java.util.concurrent.atomic</code>类路径下.</p><p>根据操作的目标数据类型，可以将JUC包中的原子类分为4类：<code>基本原子类</code>、<code>数组原子类</code>、<code>原子引用类</code>和<code>字段更新原子类</code>。</p><h3 id="基本原子类"><a href="#基本原子类" class="headerlink" title="基本原子类"></a>基本原子类</h3><ul><li>基本原子类的功能是通过原子方式更新Java基础类型变量的值。</li><li>基本原子类主要包括以下三个：<ul><li><code>AtomicInteger</code>：整型原子类。</li><li><code>AtomicLong</code>：长整型原子类。</li><li><code>AtomicBoolean</code>：布尔型原子类。</li></ul></li></ul><h3 id="数组原子类"><a href="#数组原子类" class="headerlink" title="数组原子类"></a>数组原子类</h3><ul><li>数组原子类的功能是通过原子方式更数组中的某个元素的值。数</li><li>组原子类主要包括以下三个：<ul><li><code>AtomicIntegerArray</code>：整型数组原子类。</li><li><code>AtomicLongArray</code>：长整型数组原子类。</li><li><code>AtomicReferenceArray</code>：引用类型数组原子类。</li></ul></li></ul><h3 id="引用原子类"><a href="#引用原子类" class="headerlink" title="引用原子类"></a>引用原子类</h3><ul><li>引用原子类主要包括以下三个：<ul><li><code>AtomicReference</code>：引用类型原子类。</li><li><code>AtomicMarkableReference</code>：带有更新标记位的原子引用类型。</li><li><code>AtomicStampedReference</code>：带有更新版本号的原子引用类型。</li></ul></li><li><code>AtomicMarkableReference</code>类将boolean标记与引用关联起来，可以解决使用AtomicBoolean进行原子更新时可能出现的ABA问题。</li><li><code>AtomicStampedReference</code>类将整数值与引用关联起来，可以解决使用AtomicInteger进行原子更新时可能出现的ABA问题。</li></ul><h3 id="字段更新原子类"><a href="#字段更新原子类" class="headerlink" title="字段更新原子类"></a>字段更新原子类</h3><ul><li><strong>字段更新</strong>原子类主要包括以下三个：<ul><li><code>AtomicIntegerFieldUpdater</code>：原子更新整型字段的更新器。</li><li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器。</li><li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型中的字段</li></ul></li></ul><h3 id="基础原子类AtomicInteger"><a href="#基础原子类AtomicInteger" class="headerlink" title="基础原子类AtomicInteger"></a>基础原子类AtomicInteger</h3><p>基础原子类AtomicInteger常用的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span> <span class="comment">//获取当前的值，然后设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> <span class="comment">//获取当前的值，然后自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，然后自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//通过CAS方式设置整数值</span></span><br></pre></td></tr></table></figure><p>下面是一个基础原子类AtomicInteger的使用示例，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerExample</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个 Atomic Integer 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建并启动多个线程来更新计数器</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; updateCounter(<span class="number">5</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; updateCounter(<span class="number">3</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; updateCounter(<span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有线程执行完毕</span></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        thread3.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final counter value: &quot;</span> + counter.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateCounter</span><span class="params">(<span class="type">int</span> increment)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; increment; i++) &#123;</span><br><span class="line">            <span class="comment">// 使用原子操作方法安全地增加计数值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">newValue</span> <span class="operator">=</span> counter.addAndGet(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; updated the counter to: &quot;</span> + newValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组原子类AtomicIntegerArray"><a href="#数组原子类AtomicIntegerArray" class="headerlink" title="数组原子类AtomicIntegerArray"></a>数组原子类AtomicIntegerArray</h3><p>AtomicIntegerArray.AtomicLongArray,AtomicReferenceArray三个类提供的方法几乎相同，所以我们这里以AtomicIntegerArray为例来介绍。</p><p>AtomicIntegerArray类的常用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取 index=i 位置元素的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回 index=i 位置当前的值，并将其设置为新值：newValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> newValue)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">(<span class="type">int</span> i)</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 index=i 位置元素的值，并加上预期的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//如果输入的数值等于预期值，就以原子方式将位置i的元素值设置为输入值（update）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//最终将位置i的元素设置为newValue</span></span><br><span class="line"><span class="comment">//lazySet()方法可能导致其他线程在之后的一小段时间内还是可以读到旧的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> newValue)</span>下</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAtomicIntegerArray</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tempvalue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 原始的数组</span></span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包装为原子数组</span></span><br><span class="line">    <span class="type">AtomicIntegerArray</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(array);</span><br><span class="line">    <span class="comment">// 获取第0个元素，然后设置为2</span></span><br><span class="line">    tempvalue = i.getAndSet(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 输出tempvalue:1; i:[2, 2, 3, 4, 5, 6]</span></span><br><span class="line">    Print.fo(<span class="string">&quot;tempvalue:&quot;</span> + tempvalue + <span class="string">&quot;; i:&quot;</span> + i);</span><br><span class="line">    <span class="comment">// 获取第0个元素，然后自增</span></span><br><span class="line">    tempvalue = i.getAndIncrement(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 输出tempvalue:2; i:[3, 2, 3, 4, 5, 6]</span></span><br><span class="line">    Print.fo(<span class="string">&quot;tempvalue:&quot;</span> + tempvalue + <span class="string">&quot;; i:&quot;</span> + i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第0个元素，然后增加一个delta 5</span></span><br><span class="line">    tempvalue = i.getAndAdd(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 输出tempvalue:3; i:[8, 2, 3, 4, 5, 6]</span></span><br><span class="line">    Print.fo(<span class="string">&quot;tempvalue:&quot;</span> + tempvalue + <span class="string">&quot;; i:&quot;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AtomicInteger线程安全原理"><a href="#AtomicInteger线程安全原理" class="headerlink" title="AtomicInteger线程安全原理"></a>AtomicInteger线程安全原理</h3><p>基础原子类（以AtomicInteger为例）<strong>主要通过CAS自旋+volatile的方案实现</strong>，既保障了变量操作的线程安全性，又避免了synchronized重量级锁的高开销，使得Java程序的执行效率大为提升。</p><p>AtomicInteger源码中的主要方法都是通过CAS自旋实现的。CAS自旋的主要操作为：<strong>如果一次CAS操作失败，获取最新的value值后，再</strong><br><strong>次进行CAS操作，直到成功</strong>。</p><p>另外，AtomicInteger所包装的内部value成员是一个使用关键字volatile修饰的内部成员。关键字volatile的原理比较复杂，简单地<br>说，该关键字可以保证任何线程在任何时刻总能拿到该变量的最新值，其目的在于保障变量值的线程可见性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicInteger</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe类实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部value值，使用volatile保证线程可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// value属性值的地址偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 计算value 属性值的地址偏移量</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset(</span><br><span class="line"></span><br><span class="line">                    AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">(<span class="type">int</span> initialValue)</span> &#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前value值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法：返回旧值并赋新值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;<span class="comment">// 自旋</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();<span class="comment">// 获取旧值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 以CAS方式赋值，直到成功返回</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, newValue)) <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法：封装底层的CAS操作，对比expect(期望值)与value，若不同则返回false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若expect与value相同，则将新值赋给value，并返回true</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法：安全自增 i++</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123; <span class="comment">// 自旋</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next)) <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法：自定义增量数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123; <span class="comment">// 自旋</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + delta;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next)) <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法：类似++i，返回自增后的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123; <span class="comment">// 自旋</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next)) <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法：返回加上delta后的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">addAndGet</span><span class="params">(<span class="type">int</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123; <span class="comment">// 自旋</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + delta;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next)) <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他源码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用类型原子类"><a href="#引用类型原子类" class="headerlink" title="引用类型原子类"></a>引用类型原子类</h3><ul><li>引用类型原子类包括以下种：<ul><li>AtomicReference：基础的引用原子类。</li><li>AtomicStampedReference：带印戳的引用原子类。</li><li>AtomicMarkableReference：带修改标志的引用原子类。</li></ul></li><li>上面三个类提供的方法几乎相同，所以这里以AtomicReference为例来介绍。</li></ul><p>下面为大家介绍一个简单的AtomicReference类的使用示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">qwen2<span class="number">.5</span>:7b</span><br><span class="line">在Java中，AtomicReference 是一个可以支持原子操作的类。它允许你以线程安全的方式更新对象的引用，而不必担心同步问题。这在多线程环境中非常有用。</span><br><span class="line"></span><br><span class="line">下面是一个使用 AtomicReference 对 User 引用进行原子性修改的例子：</span><br><span class="line"></span><br><span class="line">java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 其他属性和方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个User对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用AtomicReference包装user引用</span></span><br><span class="line">        AtomicReference&lt;User&gt; atomicUserRef = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个线程尝试更新用户的名字</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);  <span class="comment">// 模拟一些延迟</span></span><br><span class="line">                <span class="type">User</span> <span class="variable">newUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jane&quot;</span>);</span><br><span class="line">                atomicUserRef.set(newUser);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程尝试读取用户的名字</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);  <span class="comment">// 模拟一些延迟</span></span><br><span class="line">                <span class="type">User</span> <span class="variable">readUser</span> <span class="operator">=</span> atomicUserRef.get();</span><br><span class="line">                System.out.println(<span class="string">&quot;Name after update: &quot;</span> + readUser.getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待所有线程完成</span></span><br><span class="line">            thread1.join();</span><br><span class="line">            thread2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性更新原子类"><a href="#属性更新原子类" class="headerlink" title="属性更新原子类"></a>属性更新原子类</h3><p>此这里以<code>AtomicIntegerFieldUpdater</code>为例来介绍。使用属性更新原子类保障属性安全更新的流程大致需要两步：</p><ol><li>第一步，更新的对象属性必须使用<code>public volatile</code>修饰符。</li><li>第二步，因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须调用静态方法newUpdater()创建一个更新器，并且需要设<br>置想要更新的类和属性。</li></ol><p>下面为大家介绍一个简单的AtomicIntegerFieldUpdater类的使用示例，原子性地更新User对象的age属性，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAtomicIntegerFieldUpdater</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用静态方法newUpdater()创建一个更新器updater</span></span><br><span class="line">    AtomicIntegerFieldUpdater&lt;User&gt; updater = AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用属性更新器的getAndIncrement、getAndAdd增加user的age值</span></span><br><span class="line"></span><br><span class="line">    Print.tco(updater.getAndIncrement(user));<span class="comment">// 1</span></span><br><span class="line">    Print.tco(updater.getAndAdd(user, <span class="number">100</span>));<span class="comment">// 101</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用属性更新器的get获取user的age值</span></span><br><span class="line">    Print.tco(updater.get(user));<span class="comment">// 101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>由于CAS原子操作性能高，因此其在JUC包中被广泛应用，只不过如果使用得不合理，CAS原子操作就会存在ABA问题。</p><h3 id="了解ABA问题"><a href="#了解ABA问题" class="headerlink" title="了解ABA问题"></a>了解ABA问题</h3><p>什么是ABA问题？举一个例子来说明。比如一个线程A从内存位置M中取出V1，另一个线程B也取出V1。现在假设线程B进行了一些操作之<br>后将M位置的数据V1变成了V2，然后又在一些操作之后将V2变成了V1。之后，线程A进行CAS操作，但是线程A发现M位置的数据仍然是V1，然<br>后线程A操作成功。<strong>尽管线程A的CAS操作成功，但是不代表这个过程是没有问题的，线程A操作的数据V1可能已经不是之前的V1，而是被线程</strong><br><strong>B替换过的V1，这就是ABA问题</strong>。</p><p>并发业务场景下,两个并发的查询库存操作，同时从数据库都得到了库存是5。用户1购买了3个库存，于是库存要设置为2, 用户2购买了2个库存，于是库存要设置为3,这两个设置库存的接口并发执行，库存会先变成2，再变成3，导致数据不一致（实际卖出了5件商品，但库存只扣减了2，最后一次设置库存会覆盖和掩盖前一次并发操作）</p><h3 id="ABA问题解决方案"><a href="#ABA问题解决方案" class="headerlink" title="ABA问题解决方案"></a>ABA问题解决方案</h3><p>很多乐观锁的实现版本都是使用版本号（Version）方式来解决ABA问题。<strong>乐观锁每次在执行数据的修改操作时都会带上一个版本号，版本号和数据的版本号一致就可以执行修改操作并对版本号执行加1操作，否则执行失败。</strong>因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加，不会减少。</p><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><p>参考乐观锁的版本号，JDK提供了一个AtomicStampedReference类来解决ABA问题。AtomicStampReference在CAS的基础上增加了一个<br>Stamp（印戳或标记），使用这个印戳可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验。</p><p>AtomicStampReference的compareAndSet()方法首先检查当前的对象引用值是否等于预期引用，并且当前印戳（Stamp）标志是否等于预<br>期标志，如果全部相等，就以原子方式将引用值和印戳（Stamp）标志的值更新为给定的更新值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器，V表示要引用的原始数据，initialStamp表示最初的版本印戳（版本号）</span></span><br><span class="line">AtomicStampedReference(V initialRef, <span class="type">int</span> initialStamp)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取被封装的数据</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">getRerference</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取被封装的数据的版本印戳</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStamp</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(</span></span><br><span class="line"><span class="params"> V expectedReference, //预期引用值</span></span><br><span class="line"><span class="params"> V newReference, //更新后的引用值</span></span><br><span class="line"><span class="params"> <span class="type">int</span> expectedStamp, //预期印戳（Stamp）标志值</span></span><br><span class="line"><span class="params"> <span class="type">int</span> newStamp)</span> <span class="comment">//更新后的印戳（Stamp）标志值</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>compareAndSet()方法的第一个参数是原来的CAS中的参数，第二个参数是替换后的新参数，第三个参数是原来CAS数据旧的版本号，第<br>四个参数表示替换后的新参数版本号。进行CAS操作时，若当前引用值等于预期引用值，并且当前印戳值等于预期印戳值，则以原子方式将引用值和印戳值更新为给定的更新值。<br>下面是一个简单的AtomicStampedReference使用示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 AtomicStampedReference 存储当前的库存值和版本号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicStampedReference&lt;Integer&gt; stock = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateInventory</span><span class="params">(<span class="type">int</span> quantity)</span> &#123;</span><br><span class="line">        <span class="type">int</span> currentValue, newStamp;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            currentValue = stock.getReference(); <span class="comment">// 获取当前库存值</span></span><br><span class="line">            newStamp = stock.getStamp() + <span class="number">1</span>; <span class="comment">// 获取并增加版本号</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currentValue &gt;= quantity) &#123; <span class="comment">// 检查是否足够库存</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">newValue</span> <span class="operator">=</span> currentValue - quantity;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">updated</span> <span class="operator">=</span> stock.compareAndSet(currentValue, newValue, newStamp, newStamp + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (!updated) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Failed to update inventory in thread &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Insufficient stock for update by thread &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>); <span class="comment">// 重试循环，直到更新成功</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><p>AtomicMarkableReference是AtomicStampedReference的简化版，<strong>不关心修改过几次，只关心是否修改</strong>过。因此，其标记属性mark是boolean类型，而不是数字类型，标记属性mark仅记录值是否修改过。<strong>AtomicMarkableReference适用于只要知道对象是否被修改过，而不适用于对象被反复修改的场景</strong>。</p><p>下面是一个简单的AtomicMarkableReference使用示例，通过两个线程分别更新同一个stock 的值，第一个线程会更新成功，而第二个线程会更新失败，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 AtomicMarkableReference 存储当前的库存值和标记（表示是否有效）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicMarkableReference&lt;Integer&gt; stock = <span class="keyword">new</span> <span class="title class_">AtomicMarkableReference</span>&lt;&gt;(<span class="number">10</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateInventory</span><span class="params">(<span class="type">int</span> quantity)</span> &#123;</span><br><span class="line">        <span class="type">int</span> currentValue, currentMark;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 获取当前的库存值和标记</span></span><br><span class="line">            currentValue = stock.getReference();</span><br><span class="line">            currentMark = stock.getMark();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!currentMark &amp;&amp; currentValue &gt;= quantity) &#123; <span class="comment">// 检查是否足够库存且标记未被更改</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">updated</span> <span class="operator">=</span> stock.compareAndSet(currentValue, currentValue - quantity, currentMark, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (updated) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Inventory updated by thread &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + currentValue - quantity);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Failed to update inventory in thread &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Insufficient stock for update by thread &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!updated); <span class="comment">// 重试循环，直到更新成功</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="提升高并发场景下CAS操作的性能"><a href="#提升高并发场景下CAS操作的性能" class="headerlink" title="提升高并发场景下CAS操作的性能"></a>提升高并发场景下CAS操作的性能</h2><p>在争用激烈的场景下，会导致大量的CAS空自旋。比如，在大量线程同时并发修改一个AtomicInteger时，可能有很多线程会不停地自旋，甚至有的线程会进入一个无限重复的循环中。大量的CAS空自旋会浪费大量的CPU资源，大大降低了程序的性能。</p><p><img src="/p/4793d884/c68e12d7533c2c50690ff886b5e60704.webp"></p><blockquote><p><strong>除了存在CAS空自旋之外，在SMP架构的CPU平台上，大量的CAS操作还可能导致“总线风暴”</strong></p></blockquote><blockquote><p>在高并发场景下如何提升CAS操作的性能呢？<strong>可以使用LongAdder替代AtomicInteger</strong>。</p></blockquote><h3 id="以空间换时间：LongAdder"><a href="#以空间换时间：LongAdder" class="headerlink" title="以空间换时间：LongAdder"></a>以空间换时间：LongAdder</h3><p>Java 8提供了一个新的类<code>LongAdder</code>，以空间换时间的方式提升高并发场景下CAS操作的性能。LongAdder的核心思想是热点分离，与ConcurrentHashMap的设计思想类似<strong>：将value值分离成一个数组，当多线程访问时，通过Hash算法将线程映射到数组的一个元素进行操作；而获取最终的value结果时，则将数组的元素求和</strong>。最终，通过LongAdder将内部操作对象<strong>从单个value值“演变”成一系列的数组元素，从而减小了内部竞争的粒度。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicLongAdderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        testAtomicLongAdder(<span class="number">1</span>, <span class="number">10000000</span>);</span><br><span class="line">        testAtomicLongAdder(<span class="number">10</span>, <span class="number">10000000</span>);</span><br><span class="line">        testAtomicLongAdder(<span class="number">100</span>, <span class="number">10000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAtomicLongAdder</span><span class="params">(<span class="type">int</span> threadCount, <span class="type">int</span> times)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;threadCount: &quot;</span> + threadCount + <span class="string">&quot;, times: &quot;</span> + times);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        testLongAdder(threadCount, times);</span><br><span class="line">        System.out.println(<span class="string">&quot;LongAdder 耗时：&quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;threadCount: &quot;</span> + threadCount + <span class="string">&quot;, times: &quot;</span> + times);</span><br><span class="line">        <span class="type">long</span> <span class="variable">atomicStart</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        testAtomicLong(threadCount, times);</span><br><span class="line">        System.out.println(<span class="string">&quot;AtomicLong 耗时：&quot;</span> + (System.currentTimeMillis() - atomicStart) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAtomicLong</span><span class="params">(<span class="type">int</span> threadCount, <span class="type">int</span> times)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">AtomicLong</span> <span class="variable">atomicLong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line">        List&lt;Thread&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; times; j++) &#123;</span><br><span class="line">                    atomicLong.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : list) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : list) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;AtomicLong value is : &quot;</span> + atomicLong.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testLongAdder</span><span class="params">(<span class="type">int</span> threadCount, <span class="type">int</span> times)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">LongAdder</span> <span class="variable">longAdder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">        List&lt;Thread&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; times; j++) &#123;</span><br><span class="line">                    longAdder.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : list) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : list) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;LongAdder value is : &quot;</span> + longAdder.longValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">threadCount: <span class="number">1</span>, times: <span class="number">10000000</span></span><br><span class="line">LongAdder value is : <span class="number">10000000</span></span><br><span class="line">LongAdder 耗时：75ms</span><br><span class="line">threadCount: <span class="number">1</span>, times: <span class="number">10000000</span></span><br><span class="line">AtomicLong value is : <span class="number">10000000</span></span><br><span class="line">AtomicLong 耗时：23ms</span><br><span class="line">----------------------------------------</span><br><span class="line">threadCount: <span class="number">10</span>, times: <span class="number">10000000</span></span><br><span class="line">LongAdder value is : <span class="number">100000000</span></span><br><span class="line">LongAdder 耗时：52ms</span><br><span class="line">threadCount: <span class="number">10</span>, times: <span class="number">10000000</span></span><br><span class="line">AtomicLong value is : <span class="number">100000000</span></span><br><span class="line">AtomicLong 耗时：958ms</span><br><span class="line">----------------------------------------</span><br><span class="line">threadCount: <span class="number">100</span>, times: <span class="number">10000000</span></span><br><span class="line">LongAdder value is : <span class="number">1000000000</span></span><br><span class="line">LongAdder 耗时：266ms</span><br><span class="line">threadCount: <span class="number">100</span>, times: <span class="number">10000000</span></span><br><span class="line">AtomicLong value is : <span class="number">1000000000</span></span><br><span class="line">AtomicLong 耗时：12221ms</span><br><span class="line">----------------------------------------</span><br></pre></td></tr></table></figure><p>这里可以看到<strong>随着并发的增加</strong>，<code>AtomicLong</code>性能是急剧下降的，耗时是<code>LongAdder</code>的数倍。至于原因我们还是接着往后看。</p><h3 id="AtomicLong可以弃用了吗？"><a href="#AtomicLong可以弃用了吗？" class="headerlink" title="AtomicLong可以弃用了吗？"></a>AtomicLong可以弃用了吗？</h3><p>看上去<code>LongAdder</code>的性能全面超越了<code>AtomicLong</code>，而且阿里巴巴开发手册也提及到 <strong>推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观<br>锁的重试次数）</strong>，但是我们真的就可以舍弃掉<code>LongAdder</code>了吗？</p><p>当然不是，我们需要看场景来使用，如果是并发不太高的系统，使用<code>AtomicLong</code>可能会更好一些，而且内存需求也会小一些。</p><p>我们通过分析源码<code>sum()</code>方法后可以知道<code>LongAdder</code>在统计的时候如果有并发更新，可能导致统计的数据有误差。而在<strong>高并发统计计数</strong>的场景下，才更适合使用<code>LongAdder</code>。</p><h2 id="LongAdder的原理"><a href="#LongAdder的原理" class="headerlink" title="LongAdder的原理"></a>LongAdder的原理</h2><h3 id="操作原理图"><a href="#操作原理图" class="headerlink" title="操作原理图"></a>操作原理图</h3><p>先看下<code>LongAdder</code>的操作原理图：</p><p><img src="/p/4793d884/e98ecf700241547c45fca7b722731752.webp"></p><p>既然说到<code>LongAdder</code>可以显著提升高并发环境下的性能，那么它是如何做到的？</p><h3 id="分段加锁思路"><a href="#分段加锁思路" class="headerlink" title="分段加锁思路"></a>分段加锁思路</h3><blockquote><p><strong>设计思想上，<code>LongAdder</code>采用”分段”的方式降低<code>CAS</code>失败的频次</strong></p></blockquote><p>我们知道，<code>AtomicLong</code>中有个内部变量<code>value</code>保存着实际的<code>long</code>值，所有的操作都是针对该变量进行。也就是说，高并发环境下，<code>value</code>变量其实是一个<strong>热点数据</strong>，也就是<strong>N个线程竞争一个热点。</strong></p><p><code>LongAdder</code>的基本思路就是<strong>分散热点</strong>，将<code>value</code>值的新增操作分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个<code>value</code>值进行<code>CAS</code>操作，这样热点就被分散了，冲突的概率就小很多。</p><p><code>LongAdder</code>有一个全局变量<code>volatile long base</code>值，当并发不高的情况下都是通过<code>CAS</code>来直接操作<code>base</code>值，如果<code>CAS</code>失败，则针对<code>LongAdder</code>中的<code>Cell[]</code>数组中的<code>Cell</code>进行<code>CA</code>S操作，减少失败的概率。</p><p>例如当前类中<code>base = 10</code>，有三个线程进行<code>CAS</code>原子性的**+1操作<strong>，</strong>线程一执行成功，此时base&#x3D;11<strong>，</strong>线程二、线程三执行失败后<strong>开始针对于<code>Cell[]</code>数组中的<code>Cell</code>元素进行</strong>+1操作**，同样也是<code>CAS</code>操作，此时数组<code>index=1</code>和<code>index=2</code>中<code>Cell</code>的<code>value</code>都被设置为了1.</p><p>执行完成后，统计累加数据：<code>sum = 11 + 1 + 1 = 13</code>，利用<code>LongAdder</code>进行累加的操作就执行完了，流程图如下：</p><p><img src="/p/4793d884/b4dd2afb58703348ca052a7c60f69c28.webp" alt="img"></p><p>如果要获取真正的<code>long</code>值，只要将各个槽中的变量值累加返回。这种分段的做法类似于<code>JDK7</code>中<code>ConcurrentHashMap</code>的分段锁。</p><h3 id="消除伪共享"><a href="#消除伪共享" class="headerlink" title="消除伪共享"></a>消除伪共享</h3><p>在 <code>LongAdder</code> 的父类 <code>Striped64</code> 中存在一个 <code>volatile Cell[] cells;</code> 数组，其长度是<strong>2 的幂次方</strong>，每个<code>Cell</code>都使用 <code>@Contended</code> 注解进行修饰，而<code>@Contended</code>注解可以进行<strong>缓存行填充</strong>，从而解决<strong>伪共享问题</strong>。伪共享会导致缓存行失效，缓存一致性开销变大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>伪共享</strong>指的是多个线程同时读写同一个缓存行的不同变量时导致的 <code>CPU缓存失效</code>。尽管这些变量之间没有任何关系，但由于在主内存中邻近，存在于同一个缓存行之中，它们的相互覆盖会导致频繁的缓存未命中，引发性能下降。这里对于伪共享我只是提一下概念，并不会深入去讲解，大家可以自行查阅一些资料。</p><p>解决伪共享的方法一般都是使用<strong>直接填充</strong>，我们只需要保证不同线程的变量存在于不同的 <code>CacheLine</code> 即可，使用多余的字节来填充可以做点这一点，这样就不会出现伪共享问题。</p><p><img src="/p/4793d884/ce27aa2be39adda70bf145511c97db76.webp" alt="缓存行填充代码"></p><p><img src="/p/4793d884/8fde5d0fa2f94996d4777c0ccbd37b5c.webp" alt="缓存行填充"></p><p>在<code>Striped64</code>类中我们可以看看<code>Doug Lea</code>在<code>Cell</code>上加的注释也有说明这一点：</p><p><img src="/p/4793d884/11fdd9afd2b4d9ebcd6a057231a8946c.webp" alt="Cell注释"></p><blockquote><p>红框中的翻译如下：</p></blockquote><p><code>Cell</code>类是<code>AtomicLong</code>添加了<code>padded（via@sun.misc.compended)</code>来消除<strong>伪共享</strong>的变种版本。缓存行填充对于大多数原子来说是繁琐的，因为它们通常不规则地分散在内存中，因此彼此之间不会有太大的干扰。但是，驻留在数组中的原子对象往往彼此相邻，因此在没有这种预防措施的情况下，通常会共享缓存行数据（对性能有巨大的负面影响）。</p><h3 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h3><p><code>LongAdder</code>只有在使用<code>longValue()</code>获取当前累加值时才会真正的去结算计数的数据，<code>longValue()</code>方法底层就是调用<code>sum()</code>方法，对<code>base</code>和<code>Cell数组</code>的数据累加然后返回，做到数据写入和读取分离。</p><p>而<code>AtomicLong</code>使用<code>incrementAndGet()</code>每次都会返回<code>long</code>类型的计数值，每次递增后还会伴随着数据返回，增加了额外的开销。</p><h3 id="LongAdder实现原理"><a href="#LongAdder实现原理" class="headerlink" title="LongAdder实现原理"></a>LongAdder实现原理</h3><p>之前说了，<code>AtomicLong</code>是多个线程针对单个<strong>热点值value进行原子操作</strong>。而<code>LongAdder</code>是每个线程拥有自己的槽，各个线程一般只对自己槽中的那个值进行<code>CAS操作</code>。</p><p>比如有三个线程同时对value增加1，那么value &#x3D; 1 + 1 + 1 &#x3D; 3</p><p>但是对于LongAdder来说，内部有一个base变量，一个Cell[]数组。</p><ul><li>base变量：非竞态条件下，直接累加到该变量上</li><li>Cell[]数组：竞态条件下，累加个各个线程自己的槽Cell[i]中</li><li>最终结果的计算是下面这个形式：<img src="/p/4793d884/29aef632bff858ae987efb979152a631.png"></li></ul><h2 id="LongAdder源码剖析"><a href="#LongAdder源码剖析" class="headerlink" title="LongAdder源码剖析"></a>LongAdder源码剖析</h2><p>前面已经用图分析了<code>LongAdder</code>高性能的原理，我们继续看下<code>LongAdder</code>实现的源码：</p><h3 id="add-方法"><a href="#add-方法" class="headerlink" title="add()方法"></a><code>add()</code>方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongAdder</span> <span class="keyword">extends</span> <span class="title class_">Striped64</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        add(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">        Cell[] as; <span class="type">long</span> b, v; <span class="type">int</span> m; Cell a;</span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                (a = as[getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">                !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">                longAccumulate(x, <span class="literal">null</span>, uncontended);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">casBase</span><span class="params">(<span class="type">long</span> cmp, <span class="type">long</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="built_in">this</span>, BASE, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般我们进行计数时都会使用<code>increment()</code>方法，每次进行**+1操作**，<code>increment()</code>会直接调用<code>add()</code>方法。</p><p><strong>变量说明：</strong></p><ul><li>as 表示cells引用</li><li>b 表示获取的base值</li><li>v 表示 期望值,</li><li>m 表示 cells 数组的长度</li><li>a 表示当前线程命中的cell单元格</li></ul><blockquote><p><strong>条件一：as &#x3D;&#x3D; null || (m &#x3D; as.length - 1) &lt; 0</strong><br>此条件成立说明cells数组未初始化。如果不成立则说明cells数组已经完成初始化，对应的线程需要找到Cell数组中的元素去写值。</p></blockquote><p><img src="/p/4793d884/aed52a589a2825d1c38318fc9bf31a7f.webp" alt="条件一"></p><blockquote><p><strong>条件二：(a &#x3D; as[getProbe() &amp; m]) &#x3D;&#x3D; null</strong></p></blockquote><p>getProbe()获取当前线程的hash值，m表示cells长度-1，cells长度是2的幂次方数，原因之前也讲到过，与数组长度取模可以转化为按位与运算，提升计算性能。</p><p>当条件成立时说明当前线程通过hash计算出来数组位置处的cell为空，进一步去执行longAccumulate()方法。如果不成立则说明对应的cell不为空，下一步将要将x值通过CAS操作添加到cell中。</p><blockquote><p><strong>条件三：!(uncontended &#x3D; a.cas(v &#x3D; a.value, v + x)</strong></p></blockquote><p>主要看a.cas(v &#x3D; a.value, v + x)，接着条件二，说明当前线程hash与数组长度取模计算出的位置的cell有值，此时直接尝试一次CAS操作，如果成功则退出if条件，失败则继续往下执行longAccumulate()方法。</p><p><img src="/p/4793d884/c6ef3eb9446da4a3daea08bf7c71a1d2.webp" alt="条件二/条件三"></p><h3 id="longAccumulate-方法"><a href="#longAccumulate-方法" class="headerlink" title="longAccumulate()方法"></a>longAccumulate()方法</h3><p>接着往下看核心的<code>longAccumulate()</code>方法，代码很长，后面会一步步分析，先上代码：<code>java.util.concurrent.atomic.Striped64.</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">longAccumulate</span><span class="params">(<span class="type">long</span> x, LongBinaryOperator fn, <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.current();</span><br><span class="line">        h = getProbe();</span><br><span class="line">        wasUncontended = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Cell[] as; Cell a; <span class="type">int</span> n; <span class="type">long</span> v;</span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">Cell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(x);</span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Cell[] rs; <span class="type">int</span> m, j;</span><br><span class="line">                            <span class="keyword">if</span> ((rs = cells) != <span class="literal">null</span> &amp;&amp; (m = rs.length) &gt; <span class="number">0</span> &amp;&amp; rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)</span><br><span class="line">                wasUncontended = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        cells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            h = advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                    Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[<span class="number">2</span>];</span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cell</span>(x);</span><br><span class="line">                    cells = rs;</span><br><span class="line">                    init = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">            <span class="keyword">break</span>;                          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很长，<code>if else</code>分支很多，除此看肯定会很头疼。这里一点点分析，然后结合画图一步步了解其中实现原理。</p><p><strong>我们首先要清楚执行这个方法的前置条件，它们是或的关系，如上面条件一、二、三</strong></p><ol><li>cells数组没有初始化</li><li>cells数组已经初始化，但是当前线程对应的cell数据为空</li><li>cells数组已经初始化， 当前线程对应的cell数据为空，且CAS操作+1失败</li></ol><p><strong>longAccumulate()方法的入参：</strong></p><ul><li>long x 需要增加的值，一般默认都是1</li><li>LongBinaryOperator fn 默认传递的是null</li><li>wasUncontended竞争标识，如果是false则代表有竞争。只有cells初始化之后，并且当前线程CAS竞争修改失败，才会是false</li></ul><p><strong>然后再看下Striped64中一些变量或者方法的定义：</strong></p><ul><li>base: 类似于AtomicLong中全局的value值。在没有竞争情况下数据直接累加到base上，或者cells扩容时，也需要将数据写入到base上</li><li>collide：表示扩容意向，false 一定不会扩容，true可能会扩容。</li><li>cellsBusy：初始化cells或者扩容cells需要获取锁, 0:表示无锁状态 1:表示其他线程已经持有了锁</li><li>casCellsBusy(): 通过CAS操作修改cellsBusy的值，CAS成功代表获取锁，返回true</li><li>NCPU：当前计算机CPU数量，Cell数组扩容时会使用到</li><li>getProbe(): 获取当前线程的hash值</li><li>advanceProbe(): 重置当前线程的hash值</li></ul><p><strong>接着开始正式解析longAccumulate()源码：</strong></p><h4 id="获取当前线程的hash值"><a href="#获取当前线程的hash值" class="headerlink" title="获取当前线程的hash值"></a>获取当前线程的hash值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> PROBE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">    ThreadLocalRandom.current();</span><br><span class="line">    h = getProbe();</span><br><span class="line">    wasUncontended = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getProbe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.getInt(Thread.currentThread(), PROBE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们上面说过<code>getProbe()</code>方法是为了获取当前线程的<code>hash值</code>，具体实现是通过<code>UNSAFE.getInt()</code>实现的，<code>PROBE</code>是在初始化时候获取当前线程<code>threadLocalRandomProbe</code>的值。</p><blockquote><p>注：Unsafe.getInt()有三个重载方法getInt(Object o, long offset)、getInt(long address) 和getIntVolatile(long address)，都是从指定的位置获取变量的值，只不过第一个的offset是相对于对象o的相对偏移量，第二个address是绝对地址偏移量。如果第一个方法中o为null是，offset也会被作为绝对偏移量。第三个则是带有volatile语义的load读操作。</p></blockquote><p>如果当前线程的<strong>hash值h&#x3D;getProbe()为0，0与任何数取模都是0，会固定到数组第一个位置</strong>，所以这里做了优化，使用<code>ThreadLocalRandom</code>为当前线程重新计算一个<code>hash</code>值。最后设置<code>wasUncontended = true</code>，这里含义是重新计算了当前线程的<code>hash</code>后认为此次不算是一次竞争。<code>hash</code>值被重置就好比一个全新的线程一样，所以设置了竞争状态为<code>true</code>。</p><p>可以画图理解为：</p><p><img src="/p/4793d884/186462a13495f6f110241fdbcbcca51a.webp" alt="wasUncontended设置说明"></p><p>接着执行<code>for循环</code>，我们可以把<code>for循环</code>代码拆分一下，每个<code>if条件</code>算作一个<code>CASE</code>来分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">longAccumulate</span><span class="params">(<span class="type">long</span> x, LongBinaryOperator fn, <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Cell[] as; Cell a; <span class="type">int</span> n; <span class="type">long</span> v;</span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">                                   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，第一个<code>if语句代表CASE1</code>，里面再有<code>if判断</code>会以<code>CASE1.1</code>这种形式来讲解，下面接着的<code>else if</code>为<code>CASE2</code>， 最后一个为<code>CASE3</code></p><h4 id="CASE1执行条件："><a href="#CASE1执行条件：" class="headerlink" title="CASE1执行条件："></a><strong>CASE1执行条件</strong>：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cells数组</code>不为空，且数组长度大于0的情况会执行<code>CASE1</code>，<code>CASE1</code>的实现细节代码较多，放到最后面讲解。</p><h4 id="CASE2执行条件和实现原理："><a href="#CASE2执行条件和实现原理：" class="headerlink" title="CASE2执行条件和实现原理："></a><strong>CASE2执行条件和实现原理</strong>：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[<span class="number">2</span>];</span><br><span class="line">                rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cell</span>(x);</span><br><span class="line">                cells = rs;</span><br><span class="line">                init = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            cellsBusy = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (init)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CASE2</code> 标识<code>cells数组</code>还未初始化，因为判断<code>cells == as</code>，这个代表当前线程到了这里获取的<code>cells</code>还是之前的一致。我们可以先看这个<code>case</code>，最后再回头看最为麻烦的<code>CASE1</code>实现逻辑。</p><p><code>cellsBusy</code>上面说了是加锁的状态，初始化<code>cells数组</code>和扩容的时候都要获取加锁的状态，这个是通过<code>CAS</code>来实现的，为0代表无锁状态，为1代表其他线程已经持有锁了。<code>cells==as</code>代表当前线程持有的数组未进行修改过，<code>casCellsBusy()</code>通过<code>CAS操作</code>去获取锁。但是里面的<code>if条件</code>又再次判断了<code>cell==as</code>，这一点是不是很奇怪？通过画图来说明下问题：</p><p><img src="/p/4793d884/273e36a3302c5dfc8bf2f377874698b0.webp" alt="cells==as双重判断说明"></p><p>如果上面条件都执行成功就会执行数组的初始化及赋值操作， <code>Cell[] rs = new Cell[2]</code>表示数组的长度为2，<code>rs[h &amp; 1] = new Cell(x)</code> 表示创建一个新的<code>Cell元素</code>，<strong>value是x值，默认为1。</strong></p><p><code>h &amp; 1</code>类似于我们之前<code>HashMap</code>或者<code>ThreadLocal</code>里面经常用到的计算散列桶<code>index</code>的算法，通常都是<code>hash &amp; (table.len - 1)</code>，这里就不做过多解释了。 执行完成后直接退出<code>for循环</code>。</p><h4 id="CASE3执行条件和实现原理："><a href="#CASE3执行条件和实现原理：" class="headerlink" title="CASE3执行条件和实现原理："></a><strong>CASE3执行条件和实现原理</strong>：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>进入到这里说明<code>cells</code>正在或者已经初始化过了，执行<code>caseBase()</code>方法，通过<code>CAS操作</code>来修改<code>base</code>的值，如果修改成功则跳出循环，这个<code>CAS</code>E只有在初始化<code>Cell数组</code>的时候，多个线程尝试<code>CAS</code>修改<code>cellsBusy</code>加锁的时候，失败的线程会走到这个分支，然后直接<code>CAS</code>修改<code>base</code>数据。</p><h4 id="CASE1-实现原理："><a href="#CASE1-实现原理：" class="headerlink" title="CASE1 实现原理："></a><strong>CASE1 实现原理</strong>：</h4><p>分析完了<code>CASE2和CASE3</code>，我们再折头回看一下<code>CASE1</code>，进入<code>CASE1</code>的前提是：<code>cells数组</code>不为空，已经完成了初始化赋值操作。</p><p>接着还是一点点往下拆分代码，首先看第一个判断分支<code>CASE1.1</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Cell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Cell[] rs; <span class="type">int</span> m, j;</span><br><span class="line">                <span class="keyword">if</span> ((rs = cells) != <span class="literal">null</span> &amp;&amp; (m = rs.length) &gt; <span class="number">0</span> &amp;&amp; rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    rs[j] = r;</span><br><span class="line">                    created = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (created)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    collide = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个if条件中<code>(a = as[(n - 1) &amp; h]) == null</code>代表当前线程对应的数组下标位置的<code>cell</code>数据为<code>null</code>，代表没有线程在此处创建<code>Cell</code>对象。</p><p>接着判断<code>cellsBusy==0</code>，代表当前锁未被占用。然后新创建<code>Cell对象</code>，接着又判断了一遍<code>cellsBusy == 0</code>，然后执行<code>casCellsBusy()</code>尝试通过CAS操作修改<code>cellsBusy=1</code>，加锁成功后修改扩容意向<code>collide = false;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((rs = cells) != <span class="literal">null</span> &amp;&amp; (m = rs.length) &gt; <span class="number">0</span> &amp;&amp; rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">        rs[j] = r;</span><br><span class="line">        created = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (created)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码判断当前线程<code>hash</code>后指向的数据位置元素是否为空，如果为空则将<code>cell</code>数据放入数组中，跳出循环。如果不为空则继续循环。</p><p><img src="/p/4793d884/832cea35b7087f97d7436e2a43d3ce6c.webp" alt="CASE1.1"></p><p>继续往下看代码，<strong>CASE1.2</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)</span><br><span class="line">    wasUncontended = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">h = advanceProbe(h);</span><br></pre></td></tr></table></figure><p><code>wasUncontended</code>表示<code>cells</code>初始化后，当前线程竞争修改失败<code>wasUncontended =false</code>，这里只是重新设置了这个值为<code>true</code>，紧接着执行<code>advanceProbe(h)</code>重置当前线程的<code>hash</code>，重新循环。</p><p>接着看<strong>CASE1.3</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>进入<code>CASE1.3</code>说明当前线程对应的数组中有了数据，也重置过<code>hash值</code>，这时通过CAS操作尝试对当前数中的<code>value值</code>进行累加x操作，x默认为1，如果<code>CAS</code>成功则直接跳出循环。</p><p><img src="/p/4793d884/eadaba5e49615bb61782925ea51f9f41.webp"></p><p>接着看<strong>CASE1.4：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">    collide = <span class="literal">false</span>;    </span><br></pre></td></tr></table></figure><p>如果<code>cells数组</code>的长度达到了<code>CPU核心数</code>，或者<code>cells</code>扩容了，设置扩容意向<code>collide为false</code>并通过下面的<code>h = advanceProbe(h)</code>方法修改线程的<code>probe</code>再重新尝试</p><p>至于这里为什么要提出和<code>CPU数量</code>做判断的问题：每个线程会通过线程对<code>cells[threadHash%cells.length]</code>位置的<code>Cell</code>对象中的<code>value</code>做累加，这样相当于将线程绑定到了<code>cells</code>中的某个<code>cell</code>对象上，如果超过<code>CPU数量</code>的时候就不再扩容是因为<code>CPU</code>的数量代表了机器处理能力，当超过<code>CPU</code>数量时，多出来的<code>cells</code>数组元素没有太大作用。</p><p><img src="/p/4793d884/5b3daf38f674ba23d23b9d1b397c7e85.webp" alt="多线程更新Cell"></p><p>接着看<strong>CASE1.5</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">  collide = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>如果扩容意向<code>collide</code>是<code>false</code>则修改它为<code>true</code>，然后重新计算当前线程的<code>hash</code>值继续循环，在<code>CASE1.4</code>中，如果当前数组的长度已经大于了<code>CPU</code>的核数，就会再次设置扩容意向<code>collide=false</code>，这里的意义是保证扩容意向为<code>false</code>后不再继续往后执行<code>CASE1.6</code>的扩容操作。</p><p><strong>接着看CASE1.6分支：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">            Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                rs[i] = as[i];</span><br><span class="line">            cells = rs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        cellsBusy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    collide = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面执行的其实是扩容逻辑，首先是判断通过<code>CAS</code>改变<code>cellsBusy</code>来尝试加锁，如果<code>CAS</code>成功则代表获取锁成功，继续向下执行，判断当前的<code>cells</code>数组和最先赋值的<code>as</code>是同一个，代表没有被其他线程扩容过，然后进行扩容，扩容大小为之前的容量的两倍，这里用的按位左移1位来操作的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[n &lt;&lt; <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>扩容后再将之前数组的元素拷贝到新数组中，释放锁设置<code>cellsBusy = 0</code>，设置扩容状态，然后继续循环执行。</p><p>到了这里，我们已经分析完了<code>longAccumulate()</code>所有的逻辑，逻辑分支挺多，仔细分析看看其实还是挺清晰的，流程图如下：</p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/p/4793d884/04c5a16508f70601000b53f8e19045e5.webp" alt="流程图"></p><p>我们再举一些线程执行的例子里面场景覆盖不全，大家可以按照这种模式自己模拟场景分析代码流程：</p><p><img src="/p/4793d884/38b5b0eee12d2b7b5d6ecaabbdae7ffd.webp" alt="多线程执行示例"></p><p>如有问题也请及时指出，我会第一时间更正，不胜感激！</p><h3 id="LongAdder的sum方法"><a href="#LongAdder的sum方法" class="headerlink" title="LongAdder的sum方法"></a>LongAdder的sum方法</h3><p>当我们最终获取计数器值时，我们可以使用<code>LongAdder.longValue()</code>方法，其内部就是使用<code>sum</code>方法来汇总数据的。</p><p><code>java.util.concurrent.atomic.LongAdder.sum()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现很简单，base + 遍历<code>cells</code>数组中的值，然后累加。</p><h2 id="CAS在JDK中的广泛应用"><a href="#CAS在JDK中的广泛应用" class="headerlink" title="CAS在JDK中的广泛应用"></a>CAS在JDK中的广泛应用</h2><h3 id="CAS操作的弊端和规避措施"><a href="#CAS操作的弊端和规避措施" class="headerlink" title="CAS操作的弊端和规避措施"></a>CAS操作的弊端和规避措施</h3><p>CAS操作的弊端主要有以下三点：</p><ol><li>ABA问题<ul><li>使用CAS操作内存数据时，数据发生过变化也能更新成功，如操作序列A&#x3D;&#x3D;&gt;B&#x3D;&#x3D;&gt;A时，最后一个CAS的预期数据A实际已经发生过更改，但也能更新成功，这就产生了ABA问题。</li><li>ABA问题的解决思路是使用版本号。在变量前面追加上版本号，每次变量更新的时候将版本号加1，那么操作序列A&#x3D;&#x3D;&gt;B&#x3D;&#x3D;&gt;A就会变成A1&#x3D;&#x3D;&gt;B2&#x3D;&#x3D;&gt;A3，如果将A1当作A3的预期数据，就会操作失败。</li><li>JDK提供了两个类<code>AtomicStampedReference</code>和<code>AtomicMarkableReference</code>来解决ABA问题。比较常用的是AtomicStampedReference类，该类的compareAndSet()方法的作用是首先检查当前引用是否等于预期引用，以及当前印戳是否等于预期印戳，如果全部相等，就以原子方式将引用和印戳的值一同设置为新的值。</li></ul></li><li>只能保证一个共享变量之间的原子性操作<ul><li>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，CAS就无法保证操作的原子<br>性。</li><li>一个比较简单的规避方法为：把多个共享变量合并成一个共享变量来操作。</li><li>JDK提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，可以把多个变量放在一个AtomicReference实例后再进行CAS操作。比如有两个共享变量i＝1、j&#x3D;2，可以将二者合并成一个对象，然后用CAS来操作该合并对象的AtomicReference引用。</li></ul></li><li>开销问题自旋CAS如果长时间不成功（不成功就一直循环执行，直到成功），就会给CPU带来非常大的执行开销。<strong>解决CAS恶性空自旋的有效方式之一是以空间换时间</strong>，较为常见的方案为：<ul><li>分散操作热点，使用LongAdder替代基础原子类AtomicLong，LongAdder将单个CAS热点（value值）分散到一个cells数组中。</li><li>使用队列削峰，将发生CAS争用的线程加入一个队列中排队，降低CAS争用的激烈程度。JUC中非常重要的基础类AQS（抽象队列同步器）就是这么做的。</li></ul></li></ol><h3 id="CAS操作在JDK中的应用"><a href="#CAS操作在JDK中的应用" class="headerlink" title="CAS操作在JDK中的应用"></a>CAS操作在JDK中的应用</h3><ul><li>CAS在java.util.concurrent.atomic包中的原子类、Java AQS以及显式锁、CurrentHashMap等重要并发容器类的实现都有非常广泛的应用。</li><li>在java.util.concurrent.atomic包的原子类（如AtomicXXX）中都使用了CAS来保障对数字成员进行操作的原子性。</li><li>java.util.concurrent的大多数类（包括显式锁、并发容器）都是基于AQS和AtomicXXX来实现的，其中AQS通过CAS保障它内部双向队列头部、尾部操作的原子性。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><p><a href="https://www.cnblogs.com/r1-12king/p/17406220.html">longadder原理 - r1-12king - 博客园</a></p><script>var description="介绍CAS的原理和弊端，然后介绍基于CAS实现的JUC原子类。"</script>]]></content>
      
      
      <categories>
          
          <category> 多线程编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAS原理 </tag>
            
            <tag> JUC原子类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内置锁的核心原理</title>
      <link href="/p/6feba110.html"/>
      <url>/p/6feba110.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>什么是线程安全呢？当多个线程并发访问某个Java对象（Object）时，无论系统如何调度这些线程，也无论这些线程将如何交替操作，这个对象都能表现出一致的、正确的行为，那么对这个对象的操作是线程安全的。如果这个对象表现出不一致的、错误的行为，那么对这个对象的操作不是线程安全的，发生了线程的安全问题。</p><h3 id="自增运算不是线程安全的"><a href="#自增运算不是线程安全的" class="headerlink" title="自增运算不是线程安全的"></a>自增运算不是线程安全的</h3><p>粗看上去，感觉这是一件不可思议的事情：对一个整数进行自增运算（++），怎么可能不是线程安全的呢？这可是只有一个完整的操作，看上去是那么的不可分割。<br>使用10个线程，对一个共享的变量，每个线程自增1000次，看看最终的结果是不是1万。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotSafePlus</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的自增运算不是原子操作</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 线程数量</span></span><br><span class="line"></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[threadCount];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有线程完成</span></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Final count: 9164</span></span><br></pre></td></tr></table></figure><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>为什么自增运算符不是线程安全的呢？实际上，一个自增运算符是一个复合操作，至少包括三个JVM指令：“内存取值”“寄存器增加1”和“存值到内存”。这三个指令在JVM内部是独立进行的，中间完<br>全可能会出现多个线程并发进行。</p><p>比如在amount&#x3D;100时，假设有三个线程同一时间读取amount值，读到的都是100，增加1后结果为101，三个线程都将结果存入amount的内存，amount的结果是101，而不是103。</p><p>“内存取值”“寄存器增加1”和“存值到内存”这三个JVM指令本身是不可再分的，它们都具备原子性，是线程安全的，也叫原子操作。但是，两个或者两个以上的原子操作合在一起进行操作就不再具<br>备原子性了。比如先读后写，就有可能在读之后，其实这个变量被修改了，出现读和写数据不一致的情况。</p><h3 id="临界区资源与临界区代码段"><a href="#临界区资源与临界区代码段" class="headerlink" title="临界区资源与临界区代码段"></a>临界区资源与临界区代码段</h3><p>Java工程师在进行代码开发时，常常倾向于认为代码会以线性的、串行的方式执行，容易忽视多个线程并行执行，从而导致意想不到的结果。</p><p>前面的线程安全小实验展示了在多个线程操作相同资源（如变量、数组或者对象）时就可能出现线程安全问题。一般来说，只在多个线程对这个资源进行写操作的时候才会出现问题，如果是简单的读操作，不改变资源的话，显然是不会出现问题的。</p><p><strong>临界区资源表示一种可以被多个线程使用的公共资源或共享数据</strong>，但是每一次只能有一个线程使用它。一旦临界区资源被占用，想使用该资源的其他线程则必须等待。</p><p>在并发情况下，临界区资源是受保护的对象。临界区代码段（Critical Section）是每个线程中访问临界资源的那段代码，多个线程必须互斥地对临界区资源进行访问。<strong>线程进入临界区代码段之前，必须在进入区申请资源，申请成功之后执行临界区代码段，执行完成之后释放资源</strong>。</p><p><code>竞态条件（Race Conditions</code>）可能是由于在访问临界区代码段时没有互斥地访问而导致的特殊情况。如果多个线程在临界区代码段的并发执行结果可能因为代码的执行顺序不同而不同，我们就说这时在临界区出现了竞态条件问题。在前面的线程安全小实验的代码中，amount为临界区资源，selfPlus()可以理解为临界区代码段，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//临界区资源</span></span><br><span class="line"><span class="comment">//临界区代码段</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selfPlus</span><span class="params">()</span> &#123;</span><br><span class="line"> amount++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当多个线程访问临界区的selfPlus()方法时，就会出现竞态条件的问题。更标准地说，当两个或多个线程竞争同一个资源时，对资源的访问顺序就变得非常关键。</p><p>为了避免竞态条件的问题，我们必须保证临界区代码段操作具备排他性。这就意味着当一个线程进入临界区代码段执行时，其他线程不能进入临界区代码段执行。</p><p>在Java中，我们可以使用<code>synchronized</code>关键字同步代码块，对临界区代码段进行排他性保护，示意代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(syncObject) &#123; </span><br><span class="line"><span class="comment">//critical section</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java中，使用<code>synchronized</code>关键字还可以使用<code>Lock显式锁</code>实例，或者使用原子变量（Atomic Variables）对临界区代码段进行排他性保护。Lock显式锁、原子变量将在后续章节中介绍，接下来将介<br>绍synchronized关键字。</p><h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><p>在Java中，线程同步使用最多的方法是使用<code>synchronized</code>关键字。每个Java对象都隐含有一把锁，这里称为Java内置锁（或者对象锁、隐式锁）。使用synchronized（syncObject）调用相当于获取syncObject的内置锁，所以可以使用内置锁对临界区代码段进行排他性保护。</p><p><strong>任何时间只允许一个线程进入同步方法（临界区代码段），如果其他线程需要执行同一个方法，那么只能等待和排队。</strong></p><h3 id="synchronized同步方法"><a href="#synchronized同步方法" class="headerlink" title="synchronized同步方法"></a>synchronized同步方法</h3><p>synchronized关键字是Java的保留字，<strong>当使用synchronized关键字修饰一个方法的时候，该方法被声明为同步方法</strong>，具体的例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">selfPlus</span><span class="params">()</span>&#123;</span><br><span class="line">amount++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键字synchronized的位置处于同步方法的返回类型之前</strong>。回到前面的线程安全小实验，现在使用synchronized关键字对临界区代码段进行保护，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//临界区代码段使用synchronized进行保护</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">selfPlus</span><span class="params">()</span>&#123;</span><br><span class="line">amount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行测试用例程序，累加10000次之后，最终的结果不再有偏差，与预期的结果（10000）是相同的。</p><h3 id="synchronized同步块"><a href="#synchronized同步块" class="headerlink" title="synchronized同步块"></a>synchronized同步块</h3><p>对于小的临界区，我们直接在方法声明中设置synchronized同步关键字，可以避免竞态条件的问题。但是对于较大的临界区代码段，为了执行效率，最好将同步方法分为小的临界区代码段。通过下面这个例子来具体讲述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoPlus</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sum2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//同步方法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">plus</span><span class="params">(<span class="type">int</span> val1, <span class="type">int</span> val2)</span>&#123;</span><br><span class="line">         <span class="comment">//临界区代码段</span></span><br><span class="line">         <span class="built_in">this</span>.sum1 += val1;</span><br><span class="line">         <span class="built_in">this</span>.sum2 += val2;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>两个临界区资源分别为sum1和sum2。使用synchronized对plus(int val1,int val2)进行同步保护之后，进入临界区代码段的线程拥有sum1和sum2的操作权，并且是全部占用。一旦线程进入，当线程在操<br>作sum1而没有操作sum2时，也将sum2的操作权白白占用，其他的线程由于没有进入临界区，只能看着sum2被闲置而不能去执行操作。所以，将synchronized加在方法上，如果其保护的临界区代码段<br>包含的临界区资源（要求是相互独立的）多于一个，就会<strong>造成临界区资源的闲置等待，进而会影响临界区代码段的吞吐量</strong>。为了提升吞吐量，<strong>可以将synchronized关键字放在函数体内，同步一个代码块</strong>。synchronized同步块的写法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(syncObject) <span class="comment">//同步块而不是方法</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">//临界区代码段的代码块</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在synchronized同步块后边的括号中是一个syncObject对象，代表着进入临界区代码段需要获取syncObject对象的监视锁，或者说将syncObject对象监视锁作为临界区代码段的同步锁。</p><p>由于<strong>每一个Java对象都有一把监视锁，因此任何Java对象都能作为synchronized的同步锁。</strong><br>单个线程在synchronized同步块后面的同步锁后，才能进入临界区代码段；反过来说，当一个线程获得syncObject对象的监视锁后，其他线程就只能等待。</p><blockquote><p><strong>synchronized方法和synchronized同步块有什么区别呢？</strong></p></blockquote><p>总体来说，synchronized方法是一种粗粒度的并发控制，某一时刻只能有一个线程执行该synchronized方法；而synchronized代码块是一种细粒度的并发控制，处于synchronized块之外的其他代码是可以被多个线程并发访问的。在一个方法中，并不一定所有代码都是临界区代码段，可能只有几行代码会涉及线程同步问题。所以synchronized代码块比synchronized方法更加细粒度地控制了多个线程的同步访问。</p><blockquote><p>synchronized方法和synchronized代码块有什么联系呢？</p></blockquote><p>在Java的内部实现上，synchronized方法实际上等同于用一个synchronized代码块，这个代码块包含同步方法中的所有语句，然后在synchronized代码块的括号中传入this关键字，使用this对象锁作为<br>进入临界区的同步锁。<strong>synchronized方法的同步锁实质上使用了this对象锁，这样就免去了手工设置同步锁的工作。而使用synchronized代码块需要手工设置同步锁。</strong></p><h3 id="静态的同步方法"><a href="#静态的同步方法" class="headerlink" title="静态的同步方法"></a>静态的同步方法</h3><p>在Java世界里一切皆对象。Java有两种对象：Object实例对象和Class对象。每个类运行时的类型信息用Class对象表示，它包含与类名称、继承关系、字段、方法有关的信息。JVM将一个类加载入自己的方法区内存时，会为其创建一个Class对象，对于一个类来说其Class对象是唯一的。</p><p>Class类没有公共的构造方法，Class对象是在类加载的时候由Java虚拟机调用类加载器中的defineClass方法自动构造的，因此不能显式地声明一个Class对象。</p><p>所有的类都是在第一次使用时被动态加载到JVM中的（懒加载），其各个类都是在必需时才加载的。这一点与许多传统语言（如C++）都不同，JVM为动态加载机制配套了一个判定一个类是否已经被加载的检查动作，使得类加载器首先检查这个类的Class对象是否已经被加载。如果尚未加载，类加载器就会根据类的全限定名查找.class文件，验证后加载到JVM的方法区内存，并构造其对应的Class对象。</p><p>普通的synchronized实例方法，其同步锁是当前对象this的监视锁。如果<strong>某个synchronized方法是static（静态）方法，而不是普通的对象实例方法</strong>，其同步锁又是什么呢？<br>下面展示一个使用synchronized关键字修饰static方法的例子，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.crazymakercircle.plus;</span><br><span class="line"><span class="comment">// 省略import</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeStaticMethodPlus</span> &#123; <span class="comment">//静态的临界区资源</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//使用synchronized关键字修饰 static方法</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">selfPlus</span><span class="params">()</span>&#123;</span><br><span class="line">     amount++;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>大家都知道，静态方法属于Class实例而不是单个Object实例，在静态方法内部是不可以访问Object实例的this引用（也叫指针、句柄）的。所以，修饰static方法的synchronized关键字就没有办法获<br>得Object实例的this对象的监视锁。</p><p>实际上，<strong>使用synchronized关键字修饰static方法时，synchronized的同步锁并不是普通Object对象的监视锁，而是类所对应的Class对象的监视锁</strong>。为了以示区分，这里将Object对象的监视锁叫作对象锁，将Class对象的监视锁叫作类锁。<strong>当synchronized关键字修饰static方法时，同步锁为类锁；当synchronized关键字修饰普通的成员方法（非静态方法）时，同步锁为类锁</strong>。由于类的对象实例可以有很多，但是每个类只有一个Class实例，因此使用类锁作为synchronized的同步锁时会造成同一个JVM内的所有线程只能互斥地进入临界区段。</p><p>所以，<strong>使用synchronized关键字修饰static方法是非常粗粒度的同步机制</strong>。</p><blockquote><p>通过synchronized关键字所抢占的同步锁什么时候释放呢？</p></blockquote><p>一种场景是synchronized块（代码块或者方法）正确执行完毕，监视锁自动释放；另一种场景是程序出现异常，非正常退出synchronized块，监视锁也会自动释放。所以，使用synchronized块时不必担心监视锁的释放问题。</p><h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p>生产者-消费者问题（Producer-Consumer Problem）也称有限缓冲问题（Bounded-Buffer Problem），是一个多线程同步问题的经典案例。</p><p>生产者-消费者问题描述了两类访问共享缓冲区的线程（所谓的“生产者”和“消费者”）在实际运行时会发生的问题。生产者线程的主要功能是生成一定量的数据放到缓冲区中，然后重复此过程。消<br>费者线程的主要功能是从缓冲区提取（或消耗）数据。</p><p>生产者-消费者问题的关键是：</p><ol><li>保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区空时消耗数据。</li><li>保证在生产者加入过程、消费者消耗过程中，不会产生错误的数据和行为。</li></ol><p>生产者-消费者问题不仅仅是一个多线程同步问题的经典案例，而且业内已经将解决该问题的方案抽象成了一种设计模式——“生产者消费者”模式。“生产者-消费者”模式是一个经典的多线程设计模<br>式，它为多线程间的协作提供了良好的解决方案。</p><h3 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者-消费者模式"></a>生产者-消费者模式</h3><p>在生产者-消费者模式中，通常有两类线程，即生产者线程（若干个）和消费者线程（若干个）。生产者线程向数据缓冲区（DataBuffer）加入数据，消费者线程则从数据缓冲区消耗数据。</p><p>在生产者-消费者模式中，至少有以下关键点：</p><ol><li>生产者与生产者之间、消费者与消费者之间，对数据缓冲区的操作是并发进行的。</li><li>数据缓冲区是有容量上限的。数据缓冲区满后，生产者不能再加入数据；数据缓冲区空时，消费者不能再取出数据。</li><li>数据缓冲区是线程安全的。在并发操作数据缓冲区的过程中，不能出现数据不一致的情况；或者在多个线程并发更改共享数据后，不会造成出现脏数据的情况。</li><li>生产者或者消费者线程在空闲时需要尽可能阻塞而不是执行无效的空操作，尽量节约CPU资源。</li></ol><h3 id="线程不安全的实现版本"><a href="#线程不安全的实现版本" class="headerlink" title="线程不安全的实现版本"></a>线程不安全的实现版本</h3><p>根据上面对生产者-消费者问题的描述先来实现一个非线程安全版本，包含数据缓冲区（DataBuffer）类、生产者（Producer）类和消费者（Consumer）类。</p><blockquote><p>通用生产者类的代码具体如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 生产的时间间隔，生产一次等待的时间默认为200毫秒</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PRODUCE_GAP</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">TURN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者对象编号</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">PRODUCER_NO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产的动作</span></span><br><span class="line">    <span class="type">Callable</span> <span class="variable">action</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> PRODUCE_GAP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Callable action, <span class="type">int</span> gap)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.action = action;</span><br><span class="line">        <span class="built_in">this</span>.gap = gap;</span><br><span class="line">        name = <span class="string">&quot;生产者-&quot;</span> + PRODUCER_NO.incrementAndGet();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行生产动作</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">out</span> <span class="operator">=</span> action.call();</span><br><span class="line">                <span class="comment">// 输出生产的结果</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != out) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;第&quot;</span> + TURN.get() + <span class="string">&quot;轮生产：&quot;</span> + out);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 每一轮生产之后，稍微等待一下</span></span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(gap);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 增加生产轮次</span></span><br><span class="line">                TURN.incrementAndGet();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>通用Consumer类的代码具体如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 消费的时间间隔，默认等待100毫秒</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONSUME_GAP</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 消费总次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">TURN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 消费者对象编号</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">CONSUMER_NO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 消费者名称</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">// 消费的动作</span></span><br><span class="line">    <span class="type">Callable</span> <span class="variable">action</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费一次等待的时间，默认为100毫秒</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> CONSUME_GAP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Callable action, <span class="type">int</span> gap)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.action = action;</span><br><span class="line">        <span class="built_in">this</span>.gap = gap;</span><br><span class="line">        name = <span class="string">&quot;消费者-&quot;</span> + CONSUMER_NO.incrementAndGet();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 增加消费次数</span></span><br><span class="line">            TURN.incrementAndGet();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行消费动作</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">out</span> <span class="operator">=</span> action.call();</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != out) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;第&quot;</span> + TURN.get() + <span class="string">&quot;轮消费：&quot;</span> + out);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 每一轮消费之后，稍微等待一下</span></span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(gap);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>数据区缓冲区实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotSafeDataBuffer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_AMOUNT</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; dataList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 保存数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向数据区增加一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T element)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (amount.get() &gt; MAX_AMOUNT) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列已经满了！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dataList.add(element);</span><br><span class="line">        amount.incrementAndGet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果数据不一致，就抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (amount.get() != dataList.size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(amount + <span class="string">&quot;!=&quot;</span> + dataList.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">fetch</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (amount.get() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列已经空了！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">T</span> <span class="variable">element</span> <span class="operator">=</span> dataList.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;取出的元素是:&quot;</span> + element);</span><br><span class="line">        amount.decrementAndGet();</span><br><span class="line">        <span class="comment">// 如果数据不一致，就抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (amount.get() != dataList.size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(amount + <span class="string">&quot;!=&quot;</span> + dataList.size());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>生产动作、消费动作的定义</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotSafePetStore</span> &#123;</span><br><span class="line">    <span class="comment">// 数据缓冲区静态实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> NotSafeDataBuffer&lt;String&gt; notSafeDataBuffer = <span class="keyword">new</span> <span class="title class_">NotSafeDataBuffer</span>();</span><br><span class="line">    <span class="comment">// 生产者执行的动作</span></span><br><span class="line">    <span class="keyword">static</span> Callable&lt;String&gt; produceAction = () -&gt; &#123;</span><br><span class="line">        <span class="comment">// 首先生成一个随机的商品</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">goods</span> <span class="operator">=</span> <span class="string">&quot;商品&quot;</span> + <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 将商品加上共享数据区</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            notSafeDataBuffer.add(goods);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> goods;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者执行的动作</span></span><br><span class="line">    <span class="keyword">static</span> Callable&lt;String&gt; consumerAction = () -&gt; &#123;</span><br><span class="line">        <span class="comment">// 从PetStore获取商品</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">goods</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            goods = notSafeDataBuffer.fetch();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> goods;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        <span class="comment">// 启动三个生产者线程和一个消费者线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> <span class="title class_">Producer</span>(produceAction, <span class="number">500</span>));</span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> <span class="title class_">Consumer</span>(consumerAction, <span class="number">1500</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>启动main()方法，程序开始并发执行，稍微等待一段时间，问题<br>就出来了，部分结果截取如下：</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IndexOutOfBoundsException: Index: 0, Size: 1</span><br><span class="line">at java.base/java.util.LinkedList.checkElementIndex(LinkedList.java:566)</span><br><span class="line">at java.base/java.util.LinkedList.remove(LinkedList.java:536)</span><br><span class="line">at pers.fulsun.producerandcomsumer.NotSafeDataBuffer.fetch(NotSafeDataBuffer.java:35)</span><br><span class="line">at pers.fulsun.producerandcomsumer.NotSafePetStore.lambda$static<span class="variable">$1</span>(NotSafePetStore.java:29)</span><br><span class="line">at pers.fulsun.producerandcomsumer.Consumer.run(Consumer.java:36)</span><br><span class="line">at java.base/java.util.concurrent.Executors<span class="variable">$RunnableAdapter</span>.call(Executors.java:572)</span><br><span class="line">at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)</span><br><span class="line">at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)</span><br><span class="line">at java.base/java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:642)</span><br><span class="line">at java.base/java.lang.Thread.run(Thread.java:1583)</span><br><span class="line">java.lang.Exception: 5!=2</span><br><span class="line">at pers.fulsun.producerandcomsumer.NotSafeDataBuffe</span><br></pre></td></tr></table></figure><p>从以上异常可以看出，在向数据缓冲区进行元素的增加或者提取时，多个线程在并发执行对amount、dataList两个成员操作时次序已经混乱，导致出现数据不一致和线程安全问题。</p><h3 id="线程安全的实现版本"><a href="#线程安全的实现版本" class="headerlink" title="线程安全的实现版本"></a>线程安全的实现版本</h3><p>解决线程安全问题很简单，为临界区代码加上synchronized关键字即可，主要修改的是涉及操作两个临界区资源amount和dataList的代码，具体为DataBuffer的add(…)和fetch()方法。</p><p>创建一个安全的数据缓存区类SafeDataBuffer，在其add(…)和fetch()两个实例方法的public声明后面加上<code>synchronized</code>关键字即可。其他的代码一行不动，与NotSafeDataBuffer的代码相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向数据区增加一个元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T element)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (amount.get() &gt; MAX_AMOUNT) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;队列已经满了！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dataList.add(element);</span><br><span class="line">    amount.incrementAndGet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果数据不一致，就抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (amount.get() != dataList.size()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(amount + <span class="string">&quot;!=&quot;</span> + dataList.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title function_">fetch</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (amount.get() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;队列已经空了！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">T</span> <span class="variable">element</span> <span class="operator">=</span> dataList.remove(<span class="number">0</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;取出的元素是:&quot;</span> + element);</span><br><span class="line">    amount.decrementAndGet();</span><br><span class="line">    <span class="comment">// 如果数据不一致，就抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (amount.get() != dataList.size()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(amount + <span class="string">&quot;!=&quot;</span> + dataList.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然线程安全问题顺利解决了，但是以上解决方式使用了SafeDataBuffer实例的对象锁作为同步锁，这样一来，所有的生产、消费动作在执行过程中都需要抢占同一个同步锁，最终的结果是所有<br>的生产、消费动作都被串行化了。</p><p>高效率的生产者-消费者模式，生产、消费动作肯定不能串行执行，而是需要并行执行，而且并行化程度越高越好。如何既保障没有线程安全问题，又能提高生产、消费动作的并行化程度呢？这就是后续的实现版本需要解决的问题。</p><p>如果需要开发出并行化程度更高的生产者-消费者模式实现版本，需要彻底地掌握和理解对象锁、synchronized等机制的内部原理，这就需要从Java对象的头部结构等基础知识学起。</p><h2 id="Java对象结构"><a href="#Java对象结构" class="headerlink" title="Java对象结构"></a>Java对象结构</h2><p>Java内置锁的很多重要信息都存放在对象结构中。作为铺垫，在介绍Java内置锁之前，先为大家介绍一下Java对象结构。</p><ul><li>Java对象（Object实例）结构包括三部分：<code>对象头</code>、<code>对象体</code>和<code>对齐字节</code></li></ul><p><img src="/p/6feba110/413e4daa801949a3715a99994ef169fd.png"></p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><ul><li><p>对象头包括三个字段，第一个字段叫作<code>Mark Word</code>（标记字），用于存储自身运行时的数据，例如GC标志位、哈希码、锁状态等信息。<strong>32位JVM的Mark Word为32位，64位JVM的Mark Word为64位。</strong></p><p><img src="/p/6feba110/446df403efce132113a8e2f944b0dc80.png"></p></li><li><p>第二个字段叫作<code>Class Pointer</code>（类对象指针），用于存放方法区Class对象的地址，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p></li><li><p>第三个字段叫作<code>Array Length</code>（数组长度）。如果对象是一个Java数组，那么此字段必须有，用于记录数组长度的数据；如果对象不是一个Java数组，那么此字段不存在，所以这是一个可选字段。</p></li></ul><h3 id="对象体"><a href="#对象体" class="headerlink" title="对象体"></a>对象体</h3><p>对象体包含对象的实例变量（成员变量），用于成员属性值，包括父类的成员属性值。这部分内存按4字节对齐。</p><h3 id="对齐字节"><a href="#对齐字节" class="headerlink" title="对齐字节"></a>对齐字节</h3><p>对齐字节也叫作填充对齐，其作用是用来保证Java对象所占内存字节数为8的倍数, HotSpot VM的内存管理要求对象起始地址必须是8字节的整数倍。对象头本身是8的倍数，当对象的实例变量数据不是8的倍数时，便需要填充数据来保证8字节的对齐。</p><h3 id="UseCompressedOops"><a href="#UseCompressedOops" class="headerlink" title="UseCompressedOops"></a>UseCompressedOops</h3><p>对于对象指针而言，如果JVM中的对象数量过多，使用64位的指针将浪费大量内存，通过简单统计，64位JVM将会比32位JVM多耗费50%的内存。为了节约内存可以使用选项<code>+UseCompressedOops</code><strong>开启指针压缩</strong>。UseCompressedOops中的Oop为Ordinary object pointer（普通对象指针）的缩写。, </p><p>在堆内存小于32GB的情况下，64位虚拟机的UseCompressedOops选项是默认开启的，该选项表示开启Oop对象的指针压缩会将原来64位的Oop对象指针压缩为32位。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 手动开启Oop对象指针压缩的Java指令为：</span><br><span class="line"> java -XX:+UseCompressedOops mainclass</span><br><span class="line">// 手动关闭Oop对象指针压缩的Java指令为：</span><br><span class="line"> java -XX:-UseCompressedOops mainclass</span><br></pre></td></tr></table></figure><p><strong>如果开启UseCompressedOops选项，以下类型的指针将从64位压缩至32位</strong>：</p><ul><li>Class对象的属性指针（静态变量）。</li><li>Object对象的属性指针（成员变量）。</li><li>普通对象数组的元素指针。</li></ul><p>当然，也不是所有的指针都会压缩，一些特殊类型的指针不会压缩，比如指向PermGen（永久代）的Class对象指针（JDK 8中指向元空间的Class对象指针）、本地变量、堆栈元素、入参、返回值和NULL指针等。</p><p>如果对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度（Array Length字段）。Array Length字段的长度也随着JVM架构的不同而不同：在32位JVM上，长度为32位；在64位JVM上，长度为64位。64位JVM如果开启了Oop对象的指针压缩，Array Length字段的长度也将由64位压缩至32位。</p><h2 id="Mark-Word的结构信息"><a href="#Mark-Word的结构信息" class="headerlink" title="Mark Word的结构信息"></a>Mark Word的结构信息</h2><p>Java内置锁涉及很多重要信息，这些都存放在对象结构中，并且存放于对象头的Mark Word字段中。Mark Word的位长度为JVM的一个Word大小，也就是说32位JVM的Mark Word为32位，64位JVM为64位。<strong>Mark Word的位长度不会受到Oop对象指针压缩选项的影响</strong>。</p><p>Java内置锁的状态总共有4种，级别由低到高依次为：<code>无锁、偏向锁、轻量级锁和重量级锁</code>。其实在JDK 1.6之前，Java内置锁还是一个重量级锁，是一个效率比较低下的锁，<strong>在JDK 1.6之后，JVM为了提高锁的获取与释放效率，对synchronized的实现进行了优化，引入了偏向锁和轻量级锁</strong>，从此以后Java内置锁的状态就有了4种（无锁、偏向锁、轻量级锁和重量级锁），并且<strong>4种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级，也就是说只能进行锁升级</strong>（从低级别到高级别）。</p><p>不同锁状态下的Mark Word字段结构Mark Word字段的结构与Java内置锁的状态强相关。为了让Mark<br>Word字段存储更多的信息，JVM将Mark Word<strong>最低两个位设置为Java内置锁状态位</strong>，不同锁状态下的32位Mark Word结构如表所示。</p><p><img src="/p/6feba110/446df403efce132113a8e2f944b0dc80.png" alt="64位Mark Word的结构信息"></p><ul><li>lock：锁状态标记位，占两个二进制位，由于希望用尽可能少的二进制位表示尽可能多的信息，因此设置了lock标记。该标记的值不同，整个Mark Word表示的含义就不同。</li><li>biased_lock：对象是否启用偏向锁标记，只占1个二进制位。为1时表示对象启用偏向锁，为0时表示对象没有偏向锁。lock和biased_lock两个标记位组合在一起共同表示Object实例处于什么样的锁状态。</li><li>age：4位的Java对象分代年龄。在GC中，对象在Survivor区复制一次，年龄就增加1。当对象达到设定的阈值时，将会晋升到老年代。默认情况下，并行GC的年龄阈值为15，并发GC的年龄阈值为6。由<br>于age只有4位，因此最大值为15，这就是-XX:MaxTenuringThreshold选项最大值为15的原因。</li><li>identity_hashcode：31位的对象标识HashCode（哈希码）采用延迟加载技术，当调用Object.hashCode()方法或者System.identityHashCode()方法计算对象的HashCode后，其结果将被写到该对象头中。当对象被锁定时，该值会移动到Monitor（监视器）中。</li><li>thread：54位的线程ID值为持有偏向锁的线程ID。</li><li>epoch：偏向时间戳。</li><li>ptr_to_lock_record：占62位，在轻量级锁的状态下指向栈帧中锁记录的指针。</li><li>ptr_to_heavyweight_monitor：占62位，在重量级锁的状态下指向对象监视器的指针。</li></ul><h2 id="使用JOL工具查看对象的布局"><a href="#使用JOL工具查看对象的布局" class="headerlink" title="使用JOL工具查看对象的布局"></a>使用JOL工具查看对象的布局</h2><p>JOL工具是一个jar包，使用它提供的工具类可以轻松解析出运行时java对象在内存中的结构，使用时首先需要引入maven GAV信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Java Object Layout --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.vm.VM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    log.info(VM.current().details());</span><br><span class="line">    <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">    log.info(<span class="string">&quot;hello obj status:&#123;&#125;&quot;</span>, ClassLayout.parseInstance(hello).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># VM mode: 64 bits</span></span><br><span class="line"><span class="comment"># Compressed references (oops): disabled</span></span><br><span class="line"><span class="comment"># Compressed class pointers: 0-bit shift</span></span><br><span class="line"><span class="comment"># Object alignment: 8 bytes</span></span><br><span class="line"><span class="comment">#                       ref, bool, byte, char, shrt,  int,  flt,  lng,  dbl</span></span><br><span class="line"><span class="comment"># Field sizes:            8,    1,    1,    2,    2,    4,    4,    8,    8</span></span><br><span class="line"><span class="comment"># Array element sizes:    8,    1,    1,    2,    2,    4,    4,    8,    8</span></span><br><span class="line"><span class="comment"># Array base offsets:    16,   16,   16,   16,   16,   16,   16,   16,   16</span></span><br><span class="line"></span><br><span class="line">===============</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line">  8   4        (object header: class)    0x80041170</span><br><span class="line"> 12   4        (object alignment gap)    </span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>VM mode: 64 bits - 表示当前虚拟机是64位虚拟机</li><li>Compressed references (oops): 3-bit shift - 开启了对象指针压缩，在64位的Java虚拟机上，对象指针通常需要占用8字节（64位），但通过使用压缩指针技术，可以减少对象指针的占用空间，提高内存利用率。”3-bit shift” 意味着使用3位的位移操作来对对象指针进行压缩。通过将对象指针右移3位，可以消除指针中的一些无用位，从而减少对象指针的实际大小，使其占用更少的内存。</li><li>Compressed class pointers: 3-bit shift - 开启了类指针压缩，其余同上。</li><li>Object alignment: 8 bytes - 字节对齐使用8字节</li><li>接下来这部分输出表示引用类型、boolean、byte、char、short、int、float、long、double类型的数据所占的字节数大小以及在数组中的大小和偏移量。需要注意的是数组偏移量的概念，数组偏移量的数值其实就是对象头的大小，<strong>在上图中的16字节表示如果当前对象是数组，那对象头就是16字节，不要忘了，对象头中还有数组长度，在未开启对象指针压缩的情况下，它要占据4字节大小</strong>。</li><li>对象结构输出结果<ul><li><strong>OFF</strong>：偏移量，单位字节</li><li><strong>SZ</strong>：大小，单位字节</li><li><strong>TYPE DESCRIPTION</strong>：类型描述，这里显示的比较直观，甚至可以看到是对象头的哪一部分</li><li><strong>VALUE</strong>：值，使用十六进制字符串表示，注意一个字节是8bit，占据两个16进制字符串，JOL0.15版本之前是小端序展示，0.15（包含0.15）版本之后使用大端序展示。</li></ul></li></ul><h3 id="大小端问题"><a href="#大小端问题" class="headerlink" title="大小端问题"></a>大小端问题</h3><p>有关字节序列的存放格式目前有两大阵营：第一大阵营是PowerPC系列CPU，采用大端模式存放数据；第二大阵营是X86系列CPU，采用小端模式存放数据。那么究竟什么是大端模式，什么又是小端模式呢？</p><ul><li><code>大端模式</code>是指数据的<strong>高字节保存在内存的低地址中</strong>，而数据的低字节保存在内存的高地址中。大端存放模式有点类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放。</li><li><code>小端模式</code>是指数据的<strong>高字节保存在内存的高地址中</strong>，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，此模式和日常的数字计算在方向上是一致的。</li></ul><blockquote><p>在处理器（即CPU）的计算过程中，因为使用小端模式在数据类型转换的时候（尤其是指针转换）不用考虑地址问题，所以小端模式是处理器的主流字节存放模式。<code>JVM所采用的字节存放模式是小端模式</code>。</p></blockquote><blockquote><p>由于所有网络协议都是采用大端模式来传输数据的，因此有时也会把大端模式称为“网络字节序”。当两台采用不同字节存放模式的主机通信时，在发送数据之前，都必须经过字节次序转换，转成“网<br>络字节序”（大端模式）后再进行传输。</p></blockquote><p>例如，假设你有一个32位的整数 <code>0x12345678</code>。在大端序下，这个整数会被存储为：</p><ul><li>地址 0: 0x12</li><li>地址 1: 0x34</li><li>地址 2: 0x56</li><li>地址 3: 0x78</li></ul><p>而在小端序（Little-endian）下，同样的整数会被存储为：</p><ul><li>地址 0: 0x78</li><li>地址 1: 0x56</li><li>地址 2: 0x34</li><li>地址 3: 0x12</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigEndianExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个整数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 ByteBuffer 来以大端序将整数转换为字节数组</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">        byteBuffer.order(java.nio.ByteOrder.BIG_ENDIAN); <span class="comment">// 设置为大端序</span></span><br><span class="line">        byteBuffer.putInt(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取大端序下的字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = byteBuffer.array();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印字节数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%02X &quot;</span>, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">在这个示例中，我们使用了ByteBuffer类来实现大端序的转换。ByteBuffer可以方便地将整数以指定的字节顺序存储到字节数组中。</span><br><span class="line"></span><br><span class="line">输出结果将是：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">12</span> <span class="number">34</span> <span class="number">56</span> <span class="number">78</span> </span><br><span class="line">这表示 <span class="number">0x12345678</span> 在大端序下被正确地转换为了 [<span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x56</span>, <span class="number">0x78</span>]。</span><br><span class="line"></span><br><span class="line">You</span><br><span class="line">大小端转换的工具类</span><br><span class="line"></span><br><span class="line">qwen2<span class="number">.5</span>:7b</span><br><span class="line">好的，你可以创建一个工具类来处理大小端转换。以下是一个示例代码，展示了如何在Java中实现大小端转换的功能：</span><br><span class="line"></span><br><span class="line">java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteOrder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EndianUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字节数组从小端序转换为大端序。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> littleEndianBytes 要转换的字节数组（小端序）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 大端序的字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] littleToBigEndian(<span class="type">byte</span>[] littleEndianBytes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (littleEndianBytes == <span class="literal">null</span> || littleEndianBytes.length % <span class="number">4</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid input bytes length&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numInts</span> <span class="operator">=</span> littleEndianBytes.length / <span class="number">4</span>;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(littleEndianBytes);</span><br><span class="line">        buffer.order(ByteOrder.LITTLE_ENDIAN); <span class="comment">// 设置为小端序</span></span><br><span class="line">        <span class="type">byte</span>[] bigEndianBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[littleEndianBytes.length];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numInts; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> buffer.getInt(i * <span class="number">4</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">intBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">            intBuffer.order(ByteOrder.BIG_ENDIAN); <span class="comment">// 设置为大端序</span></span><br><span class="line">            intBuffer.putInt(intValue);</span><br><span class="line">            bigEndianBytes[i * <span class="number">4</span> + <span class="number">0</span>] = intBuffer.get(<span class="number">3</span>); <span class="comment">// 高字节在低位</span></span><br><span class="line">            bigEndianBytes[i * <span class="number">4</span> + <span class="number">1</span>] = intBuffer.get(<span class="number">2</span>);</span><br><span class="line">            bigEndianBytes[i * <span class="number">4</span> + <span class="number">2</span>] = intBuffer.get(<span class="number">1</span>);</span><br><span class="line">            bigEndianBytes[i * <span class="number">4</span> + <span class="number">3</span>] = intBuffer.get(<span class="number">0</span>); <span class="comment">// 低字节在高位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bigEndianBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字节数组从大端序转换为小端序。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bigEndianBytes 要转换的字节数组（大端序）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 小端序的字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] bigToLittleEndian(<span class="type">byte</span>[] bigEndianBytes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bigEndianBytes == <span class="literal">null</span> || bigEndianBytes.length % <span class="number">4</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid input bytes length&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numInts</span> <span class="operator">=</span> bigEndianBytes.length / <span class="number">4</span>;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(bigEndianBytes);</span><br><span class="line">        buffer.order(ByteOrder.BIG_ENDIAN); <span class="comment">// 设置为大端序</span></span><br><span class="line">        <span class="type">byte</span>[] littleEndianBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[bigEndianBytes.length];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numInts; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> buffer.getInt(i * <span class="number">4</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">intBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">            intBuffer.order(ByteOrder.LITTLE_ENDIAN); <span class="comment">// 设置为小端序</span></span><br><span class="line">            intBuffer.putInt(intValue);</span><br><span class="line">            littleEndianBytes[i * <span class="number">4</span> + <span class="number">0</span>] = intBuffer.get(<span class="number">3</span>); <span class="comment">// 高字节在低位</span></span><br><span class="line">            littleEndianBytes[i * <span class="number">4</span> + <span class="number">1</span>] = intBuffer.get(<span class="number">2</span>);</span><br><span class="line">            littleEndianBytes[i * <span class="number">4</span> + <span class="number">2</span>] = intBuffer.get(<span class="number">1</span>);</span><br><span class="line">            littleEndianBytes[i * <span class="number">4</span> + <span class="number">3</span>] = intBuffer.get(<span class="number">0</span>); <span class="comment">// 低字节在高位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> littleEndianBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 测试数据：大端序的整数序列</span></span><br><span class="line">        <span class="type">byte</span>[] bigEndianData = <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x56</span>, <span class="number">0x78</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转换为小端序</span></span><br><span class="line">        <span class="type">byte</span>[] littleEndianData = bigToLittleEndian(bigEndianData);</span><br><span class="line">        System.out.println(<span class="string">&quot;大端序数据: &quot;</span> + bytesToHex(bigEndianData));</span><br><span class="line">        System.out.println(<span class="string">&quot;转换后的小端序数据: &quot;</span> + bytesToHex(littleEndianData));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试数据：小端序的整数序列</span></span><br><span class="line">        <span class="type">byte</span>[] littleEndianTestData = <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0x78</span>, <span class="number">0x56</span>, <span class="number">0x34</span>, <span class="number">0x12</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转换为大端序</span></span><br><span class="line">        <span class="type">byte</span>[] bigEndianTestData = littleToBigEndian(littleEndianTestData);</span><br><span class="line">        System.out.println(<span class="string">&quot;小端序数据: &quot;</span> + bytesToHex(littleEndianTestData));</span><br><span class="line">        System.out.println(<span class="string">&quot;转换后的大端序数据: &quot;</span> + bytesToHex(bigEndianData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字节数组转换为十六进制字符串。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 十六进制表示的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">bytesToHex</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">hexString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">hex</span> <span class="operator">=</span> Integer.toHexString(<span class="number">0xff</span> &amp; b);</span><br><span class="line">            <span class="keyword">if</span> (hex.length() == <span class="number">1</span>) &#123;</span><br><span class="line">                hexString.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            hexString.append(hex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hexString.toString().toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无锁、偏向锁、轻量级锁和重量级锁"><a href="#无锁、偏向锁、轻量级锁和重量级锁" class="headerlink" title="无锁、偏向锁、轻量级锁和重量级锁"></a>无锁、偏向锁、轻量级锁和重量级锁</h2><p>在JDK 1.6版本之前，所有的Java内置锁都是重量级锁。重量级锁会造成CPU在用户态和核心态之间频繁切换，所以代价高、效率低。JDK 1.6版本为了减少获得锁和释放锁所带来的性能消耗，引入了偏向锁和轻量级锁的实现。所以，在JDK 1.6版本中内置锁一共有4种状态：<strong>无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态</strong>，这些状态随着竞争情况逐渐升级。内置锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能再降级成偏向锁。这种能升级却不能降级的策略，其目的是提高获得锁和释放锁的效率。</p><p><img src="/p/6feba110/71e02105740de18d1ca2cad9cc4b2c25.png"></p><h3 id="无锁状态"><a href="#无锁状态" class="headerlink" title="无锁状态"></a>无锁状态</h3><p>Java对象刚创建时还没有任何线程来竞争，说明该对象处于无锁状态（无线程竞争它），这时偏向锁标识位是0，锁状态是01。</p><h3 id="偏向锁状态"><a href="#偏向锁状态" class="headerlink" title="偏向锁状态"></a>偏向锁状态</h3><p><strong>偏向锁是指一段同步代码一直被同一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</strong>如果内置锁处于偏向状态，当有一个线程来竞争锁时，先用偏向锁，表示内置锁偏爱这个线程，这个线程要执行该锁关联的同步代码时，不需要再做任何检查和切换。偏向锁在竞争不激烈的情况下效率非常高。</p><p>偏向锁状态的Mark Word会记录内置锁自己偏爱的线程ID，内置锁会将该线程当作自己的熟人。</p><h3 id="轻量级锁状态"><a href="#轻量级锁状态" class="headerlink" title="轻量级锁状态"></a>轻量级锁状态</h3><p>当有两个线程开始竞争这个锁对象时，情况就发生变化了，不再是偏向（独占）锁了，锁会升级为轻量级锁，两个线程公平竞争，哪个线程先占有锁对象，锁对象的Mark Word就指向哪个线程的栈帧中的锁记录。</p><p>当锁处于偏向锁，又被另一个线程企图抢占时，偏向锁就会升级为轻量级锁。<strong>企图抢占的线程会通过自旋的形式尝试获取锁</strong>，不会阻塞抢锁线程，以便提高性能。</p><p>自旋原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要进行内核态和用户态之间的切换来进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免了用户线程和内核切换的消耗。</p><p>但是，线程自旋是需要消耗CPU的，如果一直获取不到锁，那么线程也不能一直占用CPU自旋做无用功，所以需要设定一个自旋等待的最大时间。JVM对于自旋周期的选择，<strong>JDK 1.6之后引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不是固定的，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定的</strong>。线程如果自旋成功了，下次自旋的次数就会更多，如果自旋失败了，自旋的次数就会减少。</p><p>如果持有锁的线程执行的时间超过自旋等待的最大时间仍没有释放锁，就会导致其他争用锁的线程在最大等待时间内还是获取不到锁，<strong>自旋不会一直持续下去，这时争用线程会停止自旋进入阻塞状态，该锁膨胀为重量级锁</strong>。</p><h3 id="重量级锁状态"><a href="#重量级锁状态" class="headerlink" title="重量级锁状态"></a>重量级锁状态</h3><p>重量级锁会让其他申请的线程之间进入阻塞，性能降低。重量级锁也叫同步锁，这个锁对象Mark Word再次发生变化，会指向一个监视器对象，该监视器对象用集合的形式来登记和管理排队的线程。</p><h2 id="偏向锁的原理与实战"><a href="#偏向锁的原理与实战" class="headerlink" title="偏向锁的原理与实战"></a>偏向锁的原理与实战</h2><p>偏向锁主要解决无竞争下的锁性能问题，所谓的偏向就是偏心，即锁会偏向于当前已经占有锁的线程。</p><p>JDK 15 之前，偏向锁默认是 enabled，从 JDK 15 开始，默认就是 disabled，除非显示的通过 <code>UseBiasedLocking 开启</code>。</p><h3 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h3><p>在实际场景中，如果一个同步块（或方法）没有多个线程竞争，而且总是由同一个线程多次重入获取锁，如果每次还有阻塞线程，唤醒CPU从用户态转为核心态，那么对于CPU是一种资源的浪费，为了解决这类问题，就引入了偏向锁的概念。</p><p>偏向锁的核心原理是：<strong>如果不存在线程竞争的一个线程获得了锁，那么锁就进入偏向状态，此时Mark Word的结构变为偏向锁结构，锁对象的锁标志位（lock）被改为01，偏向标志位（biased_lock）被改为1，然后线程的ID记录在锁对象的Mark Word中（使用CAS操作完成</strong>）。以后该线程获取锁时判断一下线程ID和标志位，就可以直接进入同步块，连CAS操作都不需要，这样就省去了大量有关锁申请的操作，从而也就提升了程序的性能。</p><p>偏向锁的主要作用是消除无竞争情况下的同步原语，进一步提升程序性能，所以，在没有锁竞争的场合，偏向锁有很好的优化效果。但是，一旦有第二条线程需要竞争锁，那么偏向模式立即结束，进入轻量级锁的状态。假如在大部分情况下同步块是没有竞争的，那么可以通过偏向来提高性能。<strong>即在无竞争时，之前获得锁的线程再次获得锁时会判断偏向锁的线程ID是否指向自己，如果是，那么该线程将不用再次获得锁，直接就可以进入同步块；如果未指向当前线程，当前线程就会采用CAS操作将Mark Word中的线程ID设置为当前线程ID，如果CAS操作成功，那么获取偏向锁成功，执行同步代码块，如果CAS操作失败，那么表示有竞争，抢锁线程被挂起，撤销占锁线程的偏向锁，然后将偏向锁膨胀为轻量级锁</strong>。</p><p>偏向锁的缺点：如果锁对象时常被多个线程竞争，偏向锁就是多余的，并且其撤销的过程会带来一些性能开销。</p><h3 id="演示案例"><a href="#演示案例" class="headerlink" title="演示案例"></a>演示案例</h3><p><code>-XX:-UseCompressedOops -XX:+UseBiasedLocking </code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 睡眠 5s</span></span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;未进入同步块，MarkWord 为：&quot;</span>);</span><br><span class="line">    System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">        System.out.println((<span class="string">&quot;进入同步块，MarkWord 为：&quot;</span>));</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要等待5秒呢？因为JVM在启动的时候会延迟启用偏向锁机制。JVM默认把偏向锁延迟了4000毫秒，这就解释了为什么演示案例要等待5秒才能看到对象锁的偏向状态。</p><p>为什么偏向锁会延迟？因为JVM在启动的时候需要加载资源，这些对象加上偏向锁没有任何意义，不启用偏向锁能减少大量偏向锁撤销的成本。如果不想等待（在代码中让线程睡眠），可以直接通过修改JVM的<br>启动选项来禁止偏向锁延迟，其具体的启动选项如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0</span><br></pre></td></tr></table></figure><ul><li>non-biasable; age: 0 表示无锁</li><li>thin lock: 0x0000004164dff358 ,为轻量级锁</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 未睡眠时结果:</span></span><br><span class="line">未进入同步块，MarkWord 为：</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line">  8   8        (object header: class)    0x00000179124d1c00</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br><span class="line"></span><br><span class="line">进入同步块，MarkWord 为：</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x0000004164dff358 (thin lock: 0x0000004164dff358)</span><br><span class="line">  8   8        (object header: class)    0x00000179124d1c00</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>0x000001a430882005 (biased: 0x00000000690c2208; epoch: 0; age: 0),后3位101,打印了偏量锁的信息</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">未进入同步块，MarkWord 为：</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x0000000000000005 (biasable; age: 0)</span><br><span class="line">  8   8        (object header: class)    0x000001a412431c00</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br><span class="line"></span><br><span class="line">进入同步块，MarkWord 为：</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x000001a430882005 (biased: 0x00000000690c2208; epoch: 0; age: 0)</span><br><span class="line">  8   8        (object header: class)    0x000001a412431c00</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure><h3 id="偏向锁的膨胀和撤销"><a href="#偏向锁的膨胀和撤销" class="headerlink" title="偏向锁的膨胀和撤销"></a>偏向锁的膨胀和撤销</h3><p>假如有多个线程来竞争偏向锁，此对象锁已经有所偏向，其他的线程发现偏向锁并不是偏向自己，就说明存在了竞争，尝试撤销偏向锁（很可能引入安全点），然后膨胀到轻量级锁。</p><blockquote><p><strong>偏向锁的撤销</strong>: </p><p>从偏向状态撤回到原来的状态，也就是将 MarkWord 的第 3 位（是否偏向撤销）的值，<code>从 1 变回 0</code></p></blockquote><p>偏向锁撤销的开销花费还是挺大的，其大概过程如下：<br>（1）在一个安全点停止拥有锁的线程。<br>（2）遍历线程的栈帧，检查是否存在锁记录。如果存在锁记录，就需要清空锁记录，使其变成无锁状态，并修复锁记录指向的MarkWord，清除其线程ID。<br>（3）将当前锁升级成轻量级锁。<br>（4）唤醒当前线程。</p><p><strong>撤销偏向锁的条件</strong>：<br>（1）多个线程竞争偏向锁。<br>（2）调用偏向锁对象的hashcode()方法或者System.identityHashCode()方法计算对象的HashCode之后，将哈希码放置到Mark Word中，内置锁变成无锁状态，偏向锁将被撤销。</p><blockquote><p>偏向锁是特定场景下提升程序效率的方案，可并不代表所有程序都满足这些特定场景，比如这些场景（在开启偏向锁的前提下）：</p></blockquote><ol><li>一个线程创建了大量对象并执行了初始的同步操作，之后在另一个线程中将这些对象作为锁进行之后的操作。这种 case 下，会导致大量的偏向锁撤销操作</li><li>明知有多线程竞争（生产者&#x2F;消费者队列），还要使用偏向锁，也会导致各种撤销</li></ol><blockquote><p>很显然，这两种场景肯定会导致偏向撤销的，一个偏向撤销的成本无所谓，大量偏向撤销的成本是不能忽视的。那怎么办？</p></blockquote><ol><li>某些临界区存在两个及两个以上的线程竞争，那么偏向锁反而会降低性能，可以在启动JVM时就把偏向锁的默认功能关闭。</li><li>既不想禁用偏向锁，还不想忍受大量撤销偏向增加的成本，这种方案就是设计一个有阶梯的底线。</li></ol><h3 id="批量重偏向（Bulk-Rebiasing）"><a href="#批量重偏向（Bulk-Rebiasing）" class="headerlink" title="批量重偏向（Bulk Rebiasing）"></a>批量重偏向（Bulk Rebiasing）</h3><ul><li><p>这是第一种场景的快速解决方案，以 class 为单位，为每个 class 维护一个偏向锁撤销计数器，只要 class 的对象发生偏向撤销，该计数器 +1，当这个值达到重偏向阈值（默认 20）时：<code>BiasedLockingBulkRebiasThreshold = 20</code>, JVM 就认为该 class 的偏向锁有问题，因此会进行批量重偏向, 它的实现方式就用到了我们上面说的 epoch。</p></li><li><p>Epoch，如其含义「纪元」一样，就是一个时间戳。每个 class 对象会有一个对应的epoch字段，每个处于偏向锁状态对象的mark word 中也有该字段，其初始值为创建该对象时 class 中的epoch的值（此时二者是相等的）。</p></li><li><p>每次发生批量重偏向时，就将该值加 1，同时遍历 JVM 中所有线程的栈：找到该 class 所有正处于加锁状态的偏向锁对象，将其epoch字段改为新值, class 中不处于加锁状态的偏向锁对象（没被任何线程持有，但之前是被线程持有过的，这种锁对象的 markword 肯定也是有偏向的），保持 epoch 字段值不变<br>这样下次获得锁时，发现当前对象的epoch值和 class 的epoch，本着今朝不问前朝事 的原则（上一个纪元），就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过 CAS 操作将其mark word的线程 ID 改成当前线程 ID，这也算是一定程度的优化，毕竟没升级锁；</p></li><li><p>如果 epoch 都一样，说明没有发生过批量重偏向, 如果 markword 有线程 ID，还有其他锁来竞争，那锁自然是要升级的(如同前面举的例子 epoch&#x3D;0)。</p></li><li><p>批量重偏向是第一阶梯底线，还有第二阶梯底线</p></li></ul><h3 id="批量撤销（bulk-revoke）"><a href="#批量撤销（bulk-revoke）" class="headerlink" title="批量撤销（bulk revoke）"></a>批量撤销（bulk revoke）</h3><p>当达到重偏向阈值后，假设该 class 计数器继续增长，当其达到批量撤销的阈值后（默认 40）时，</p><p>BiasedLockingBulkRevokeThreshold &#x3D; 40<br>JVM 就认为该 class 的使用场景存在多线程竞争，会标记该 class 为不可偏向。之后对于该 class 的锁，直接走轻量级锁的逻辑。</p><p>这就是第二阶梯底线，但是在第一阶梯到第二阶梯的过渡过程中，也就是在彻底禁用偏向锁之前，还会给一次改过自新的机会，那就是另外一个计时器：</p><p>BiasedLockingDecayTime &#x3D; 25000<br>如果在距离上次批量重偏向发生的 25 秒之内，并且累计撤销计数达到 40，就会发生批量撤销（偏向锁彻底 game over）<br>如果在距离上次批量重偏向发生超过 25 秒之外，就会重置在 [20, 40) 内的计数, 再给次机会<br>大家有兴趣可以写代码测试一下临界点，观察锁对象 markword 的变化。至此，整个偏向锁的工作流程可以用一张图表示：</p><blockquote><p><strong>偏向锁的膨胀</strong></p></blockquote><p>如果偏向锁被占据，一旦有第二个线程争抢这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到内置锁偏向状态，这时表明在这个对象锁上已经存在竞争了。JVM检查原来持有该对象锁的占有线程是否依然存活，如果挂了，就可以将对象变为无锁状态，然后进行重新偏向，偏向为抢锁线程。</p><p>如果JVM检查到原来的线程依然存活，就进一步检查占有线程的调用堆栈是否通过锁记录持有偏向锁。如果存在锁记录，就表明原来的线程还在使用偏向锁，发生锁竞争，撤销原来的偏向锁，将偏向锁膨<br>胀（INFLATING）为轻量级锁。</p><blockquote><p><strong>偏向锁的好处</strong></p></blockquote><p>经验表明，其实大部分情况下进入一个同步代码块的线程都是同一个线程。这也是JDK会引入偏向锁的原因。所以，总体来说，使用偏向锁带来的好处还是大于偏向锁撤销和膨胀所带来的代价。</p><h2 id="轻量级锁的原理与实战"><a href="#轻量级锁的原理与实战" class="headerlink" title="轻量级锁的原理与实战"></a>轻量级锁的原理与实战</h2><p>引入轻量级锁的主要目的是<strong>在多线程竞争不激烈的情况下，通过CAS机制竞争锁减少重量级锁产生的性能损耗</strong>。重量级锁使用了操作系统底层的互斥锁（Mutex Lock），会导致线程在用户态和核心态之间频繁切换，从而带来较大的性能损耗。<strong>轻量级锁也被称为非阻塞同步、乐观锁，因为这个过程并没有把线程阻塞挂起，而是让线程空循环等待。</strong></p><h3 id="核心原理-1"><a href="#核心原理-1" class="headerlink" title="核心原理"></a>核心原理</h3><p>轻量锁存在的目的是尽可能不动用操作系统层面的互斥锁，因为其性能比较差。线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁地阻塞和唤醒对CPU来说是一件负担很重的工作。同时我们可以发现，很多对象锁的锁定状态只会持续很短的一段时间，例如整数的自加操作，在很短的时间内阻塞并唤醒线程显然不值得，为此引入了轻量级锁。<strong>轻量级锁是一种自旋锁</strong>，因为JVM本身就是一个应用，所以希望在应用层面上通过自旋解决线程同步问题。</p><p>轻量级锁的执行过程：在抢锁线程进入临界区之前，如果内置锁（临界区的同步对象）没有被锁定，JVM首先将在抢锁线程的栈帧中建立一个锁记录（Lock Record），用于存储对象目前Mark Word的拷贝,这时的线程堆栈与内置锁对象头大致如图:</p><p><img src="/p/6feba110/ef2f04ef0ba47f3c8f82d8f798db08d3.png"></p><p>然后抢锁线程将使用CAS自旋操作，尝试将内置锁对象头的MarkWord的ptr_to_lock_record（锁记录指针）更新为抢锁线程栈帧中锁记录的地址，如果这个更新执行成功了，这个线程就拥有了这个对象锁。然后JVM将Mark Word中的lock标记位改为00（轻量级锁标志），即表示该对象处于轻量级锁状态。抢锁成功之后，<strong>JVM会将Mark Word中原来的锁对象信息（如哈希码等）保存在抢锁线程锁记录的Displaced Mark Word（可以理解为放错地方的Mark Word）字段中，再将抢锁线程中锁记录的owner指针指向锁对象</strong>。在轻量级锁抢占成功之后，锁记录和对象头的状态如图所示。</p><p><img src="/p/6feba110/a5cc31fdc713311c590dc5b7e4f31063.png"></p><blockquote><p>锁记录是线程私有的，每个线程都有自己的一份锁记录，在创建完锁记录后，会将内置锁对象的Mark Word复制到锁记录的DisplacedMark Word字段。这是为什么呢？</p></blockquote><ol><li><strong>避免频繁的内存屏障（Memory Barrier）</strong>：在某些情况下，直接修改Mark Word可能会触发内存屏障，这会影响性能。通过将内置锁对象的Mark Word复制到锁记录中的Displaced Mark Word字段中，可以减少这些不必要的屏障。</li><li><strong>提供临时状态信息</strong>：线程私有的锁记录可以在不立即执行完整锁定操作的情况下保存某些临时状态信息（如锁的对象引用），这有助于后续快速决定是否需要真正进入同步代码块。</li><li><strong>简化实现和优化</strong>：使用锁记录可以减少直接对对象头的访问，避免复杂的内存模型约束。通过复制Mark Word到锁记录中，可以在一定程度上保持原有状态，同时简化了逻辑处理流程。</li><li><strong>支持自旋（Spin）机制</strong>：在轻量级锁中，线程会在获取锁前先尝试自旋一段时间，如果发现锁已经被其他线程持有，则可以基于Displaced Mark Word更快地判断出当前线程是否继续等待或放弃。</li></ol><h3 id="演示案例-1"><a href="#演示案例-1" class="headerlink" title="演示案例"></a>演示案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 睡眠 5s</span></span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;未进入同步块，MarkWord 为：&quot;</span>);</span><br><span class="line">    System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">        System.out.println((<span class="string">&quot;进入同步块，MarkWord 为：&quot;</span>));</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + (<span class="string">&quot;进入同步块，MarkWord 为：&quot;</span>));</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">未进入同步块，MarkWord 为：</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x0000000000000005 (biasable; age: 0)</span><br><span class="line">  8   8        (object header: class)    0x000001ca26411c00</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br><span class="line"></span><br><span class="line">进入同步块，MarkWord 为：</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x000001c80ffa2805 (biased: 0x000000007203fe8a; epoch: 0; age: 0)</span><br><span class="line">  8   8        (object header: class)    0x000001ca26411c00</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br><span class="line"></span><br><span class="line">Thread-0进入同步块，MarkWord 为：</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x00000061744ff620 (thin lock: 0x00000061744ff620)</span><br><span class="line">  8   8        (object header: class)    0x000001ca26411c00</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在执行第一个同步代码块后，在抢占完成之后，o实例的锁状态还是为偏向锁，只不过o实例的Mark Word记录了第一个抢占线程的ID。这一步的输出与前面偏向锁演示实例的输出相同，这里不再赘述。接着开始第二个抢锁线程，在第二个线程抢锁成功之后，o实例的锁状态为轻量级锁, lock标记位改为00（轻量级锁标志），其ptr_to_lock_record（锁记录指针）更新为抢锁线程栈帧中锁记录的地址，此时的锁为轻量级锁。轻量级锁被释放之后，o实例变成无锁状态.</p><h3 id="轻量级锁的分类"><a href="#轻量级锁的分类" class="headerlink" title="轻量级锁的分类"></a>轻量级锁的分类</h3><p>轻量级锁主要有两种：普通自旋锁和自适应自旋锁。</p><h3 id="普通自旋锁"><a href="#普通自旋锁" class="headerlink" title="普通自旋锁"></a>普通自旋锁</h3><p>所谓普通自旋锁，就是指当有线程来竞争锁时，抢锁线程会在原地循环等待，而不是被阻塞，直到那个占有锁的线程释放锁之后，这个抢锁线程才可以获得锁。</p><blockquote><p>锁在原地循环等待的时候是会消耗CPU的，就相当于在执行一个什么也不干的空循环。所以<strong>轻量级锁适用于临界区代码耗时很短的场景</strong>，这样线程在原地等待很短的时间就能够获得锁了。</p></blockquote><p>默认情况下，自旋的次数为10次，用户可以通过<code>XX:PreBlockSpin</code>选项来进行更改。</p><h3 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h3><p>所谓自适应自旋锁，就是等待线程空循环的自旋次数并非是固定的，而是会动态地根据实际情况来改变自旋等待的次数，自旋次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。自适应自旋锁的大概原理是：</p><ol><li>如果抢锁线程在同一个锁对象上之前成功获得过锁，JVM就会认为这次自旋很有可能再次成功，因此允许自旋等待持续相对更长的时间。</li><li>如果对于某个锁，抢锁线程很少成功获得过，那么JVM将可能减少自旋时间甚至省略自旋过程，以避免浪费处理器资源。</li></ol><p>自适应自旋解决的是“锁竞争时间不确定”的问题。自适应自旋假定不同线程持有同一个锁对象的时间基本相当，竞争程度趋于稳定。总的思想是：<strong>根据上一次自旋的时间与结果调整下一次自旋的时间</strong>。</p><blockquote><p>JDK 1.6的轻量级锁使用的是普通自旋锁，且需要使用XX:+UseSpinning选项手工开启。JDK 1.7后，轻量级锁使用自适应自旋锁，JVM启动时自动开启，且自旋时间由JVM自动控制。</p></blockquote><h3 id="轻量级锁的膨胀"><a href="#轻量级锁的膨胀" class="headerlink" title="轻量级锁的膨胀"></a>轻量级锁的膨胀</h3><p>轻量级锁的问题在哪里呢？虽然大部分临界区代码的执行时间都是很短的，但是也会存在执行得很慢的临界区代码。临界区代码执行耗时较长，在其执行期间，其他线程都在原地自旋等待，会空消耗CPU。因此，如果竞争这个同步锁的线程很多，就会有多个线程在原地等待继续空循环消耗CPU（空自旋），这会带来很大的性能损耗。</p><p>轻量级锁的本意是为了减少多线程进入操作系统底层的互斥锁（Mutex Lock）的概率，并不是要替代操作系统互斥锁。所以，<strong>在争用激烈的场景下，轻量级锁会膨胀为基于操作系统内核互斥锁实现的重量级锁</strong>。</p><h2 id="重量级锁的原理与实战"><a href="#重量级锁的原理与实战" class="headerlink" title="重量级锁的原理与实战"></a>重量级锁的原理与实战</h2><p>在JVM中，每个对象都关联一个监视器，这里的对象包含Object实例和Class实例。监视器是一个同步工具，相当于一个许可证，拿到许可证的线程即可进入临界区进行操作，没有拿到则需要阻塞等待。<strong>重量级锁通过监视器的方式保障了任何时间只允许一个线程通过受到监视器保护的临界区代码</strong>。</p><h3 id="核心原理-2"><a href="#核心原理-2" class="headerlink" title="核心原理"></a>核心原理</h3><p>JVM中每个对象都会有一个监视器，监视器和对象一起创建、销毁。监视器相当于一个用来监视这些线程进入的特殊房间，其义务是保证（同一时间）只有一个线程可以访问被保护的临界区代码块。</p><p>本质上，监视器是一种同步工具，也可以说是一种同步机制，主要特点是：</p><ol><li>同步。监视器所保护的临界区代码是互斥地执行的。一个监视器是一个运行许可，任一线程进入临界区代码都需要获得这个许可，离开时把许可归还。</li><li>协作。监视器提供Signal机制，允许正持有许可的线程暂时放弃许可进入阻塞等待状态，等待其他线程发送Signal去唤醒；其他拥有许可的线程可以发送Signal，唤醒正在阻塞等待的线程，让它可以重新获得许可并启动执行。</li></ol><p>在Hotspot虚拟机中，监视器是由C++类ObjectMonitor实现的，ObjectMonitor类定义在ObjectMonitor.hpp文件中，其构造器代码大致如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Monitor结构体</span></span><br><span class="line"> ObjectMonitor::<span class="built_in">ObjectMonitor</span>() &#123; </span><br><span class="line"> _header = <span class="literal">NULL</span>; </span><br><span class="line"> _count = <span class="number">0</span>; </span><br><span class="line"> _waiters = <span class="number">0</span>, </span><br><span class="line"> <span class="comment">//线程的重入次数</span></span><br><span class="line"> _recursions = <span class="number">0</span>; </span><br><span class="line"> _object = <span class="literal">NULL</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//标识拥有该Monitor的线程</span></span><br><span class="line"> _owner = <span class="literal">NULL</span>; </span><br><span class="line"> <span class="comment">//等待线程组成的双向循环链表</span></span><br><span class="line"> _WaitSet = <span class="literal">NULL</span>; </span><br><span class="line"> _WaitSetLock = <span class="number">0</span> ; </span><br><span class="line"> _Responsible = <span class="literal">NULL</span> ;  _succ = <span class="literal">NULL</span> ; </span><br><span class="line"> <span class="comment">//多线程竞争锁进入时的单向链表</span></span><br><span class="line"> cxq = <span class="literal">NULL</span> ; </span><br><span class="line"> FreeNext = <span class="literal">NULL</span> ; </span><br><span class="line"> <span class="comment">//_owner从该双向循环链表中唤醒线程节点</span></span><br><span class="line"> _EntryList = <span class="literal">NULL</span> ; </span><br><span class="line"> _SpinFreq = <span class="number">0</span> ; </span><br><span class="line"> _SpinClock = <span class="number">0</span> ; </span><br><span class="line"> OwnerIsThread = <span class="number">0</span> ; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>ObjectMonitor的<code>Owner（_owner）</code>、<code>WaitSet（_WaitSet</code>、<code>Cxq（_cxq）</code>、<code>EntryList（_EntryList）</code>这几个属性比较关键。<br>ObjectMonitor的WaitSet、Cxq、EntryList这三个队列存放抢夺重量级锁的线程，而ObjectMonitor的Owner所指向的线程即为获得锁的线程。</p><ul><li>Cxq：竞争队列（Contention Queue），所有请求锁的线程首先被放在这个竞争队列中。</li><li>EntryList：Cxq中那些有资格成为候选资源的线程被移动到EntryList中。</li><li>WaitSet：某个拥有ObjectMonitor的线程在调用Object.wait()方法之后将被阻塞，然后该线程将被放置在WaitSet链表中。</li></ul><blockquote><p><strong>Cxq</strong></p></blockquote><p>Cxq并不是一个真正的队列，只是一个虚拟队列，原因在于Cxq是由Node及其next指针逻辑构成的，并不存在一个队列的数据结构。每次新加入Node会在Cxq的队头进行，通过CAS改变第一个节点的指针为<br>新增节点，同时设置新增节点的next指向后续节点；从Cxq取得元素时，会从队尾获取。显然，Cxq结构是一个无锁结构。</p><p>因为只有Owner线程才能从队尾取元素，即线程出列操作无争用，当然也就避免了CAS的ABA问题。</p><p>在线程进入Cxq前，抢锁线程会先尝试通过CAS自旋获取锁，如果获取不到，就进入Cxq队列，这明显对于已经进入Cxq队列的线程是不公平的。所以，<strong>synchronized同步块所使用的重量级锁是不公平锁</strong></p><blockquote><p><strong>EntryList</strong></p></blockquote><p>EntryList与Cxq在逻辑上都属于等待队列。Cxq会被线程并发访问，为了降低对Cxq队尾的争用，而建立EntryList。在Owner线程释放锁时，JVM会从Cxq中迁移线程到EntryList，并会指定EntryList中的某个线程（一般为Head）为OnDeck Thread（Ready Thread）。EntryList中的线程作为候选竞争线程而存在。</p><blockquote><p>OnDeck Thread与Owner Thread</p></blockquote><p>JVM不直接把锁传递给Owner Thread，而是把锁竞争的权利交给OnDeck Thread，OnDeck需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大地提升系统的吞吐量，在JVM中，也把这种选择行为称为“竞争切换”。</p><p>OnDeck Thread获取到锁资源后会变为Owner Thread。无法获得锁的OnDeck Thread则会依然留在EntryList中，考虑到公平性，OnDeckThread在EntryList中的位置不发生变化（依然在队头）。</p><p>在OnDeck Thread成为Owner的过程中，还有一个不公平的事情，就是后来的新抢锁线程可能直接通过CAS自旋成为Owner而抢到锁。</p><blockquote><p><strong>WaitSet</strong></p></blockquote><p>如果Owner线程被<code>bject.wait()</code>方法阻塞，就转移到WaitSet队列中，直到某个时刻通过<code>Object.notify()</code>或者<code>Object.notifyAll()</code>唤醒，该线程就会重新进入EntryList中。</p><h3 id="重量级锁的开销"><a href="#重量级锁的开销" class="headerlink" title="重量级锁的开销"></a>重量级锁的开销</h3><p>处于ContentionList、EntryList、WaitSet中的线程都处于阻塞状态，线程的阻塞或者唤醒都需要操作系统来帮忙，Linux内核下采用pthread_mutex_lock系统调用实现，进程需要从用户态切换到内核态。</p><p>Linux系统的体系架构分为用户态（或者用户空间）和内核态（或者内核空间）,Linux系统的内核是一组特殊的软件程序，负责控制计算机的硬件资源，例如协调CPU资源、分配内存资源，并且提供稳定的环境供应用<br>程序运行。应用程序的活动空间为用户空间，应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I&#x2F;O资源等。</p><p>用户态与内核态有各自专用的内存空间、专用的寄存器等，进程从用户态切换至内核态需要传递许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。</p><p>用户态的进程能够访问的资源受到了极大的控制，而运行在内核态的进程可以“为所欲为”。一个进程可以运行在用户态，也可以运行在内核态，那么肯定存在用户态和内核态切换的过程。进程从用户态到内核态切换主要包括以下三种方式：</p><ul><li>硬件中断。硬件中断也称为外设中断，当外设完成用户的请求时会向CPU发送中断信号。</li><li>系统调用。其实系统调用本身就是中断，只不过是软件中断，跟硬件中断不同。</li><li>异常。如果当前进程运行在用户态，这个时候发生了异常事件（例如缺页异常），就会触发切换。</li></ul><p><strong>用户态是应用程序运行的空间，为了能访问到内核管理的资源（例如CPU、内存、I&#x2F;O），可以通过内核态所提供的访问接口实现，这些接口就叫系统调用</strong>。pthread_mutex_lock系统调用是内核态为用户态进程提供的Linux内核态下互斥锁的访问机制，所以使用pthread_mutex_lock系统调用时，进程需要从用户态切换到内核态，而这种切换是需要消耗很多时间的，有可能比用户执行代码的时间还要长。</p><p>由于JVM轻量级锁使用CAS进行自旋抢锁，这些CAS操作都处于用户态下，进程不存在用户态和内核态之间的运行切换，因此JVM轻量级锁开销较小。而JVM重量级锁使用了Linux内核态下的互斥锁，这是重量级锁开销很大的原因。</p><h3 id="演示案例-2"><a href="#演示案例-2" class="headerlink" title="演示案例"></a>演示案例</h3><blockquote><p>wait 方法是互斥量（重量级锁）独有的，一旦调用该方法，就会升级成重量级锁</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 睡眠 5s</span></span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    log.info(<span class="string">&quot;未生成 hashcode，MarkWord 为：&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">        log.info((<span class="string">&quot;进入同步块，MarkWord 为：&quot;</span>));</span><br><span class="line">        log.info(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;wait 2s&quot;</span>);</span><br><span class="line">        o.wait(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        log.info((<span class="string">&quot;调用 wait 后，MarkWord 为：&quot;</span>));</span><br><span class="line">        log.info(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上输出可以看出<code>0x000001ee12fc0caa (fat lock: 0x000001ee12fc0caa)</code>，此时锁状态已经从轻量级锁膨胀为重量级锁，其lock标记为10，说明此时存在激烈的锁争用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">未进入同步块，MarkWord 为：</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x0000000000000005 (biasable; age: 0)</span><br><span class="line">  8   8        (object header: class)    0x000001ee124d1c00</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br><span class="line"></span><br><span class="line">进入同步块，MarkWord 为：</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x000001ee41141805 (biased: 0x000000007b904506; epoch: 0; age: 0)</span><br><span class="line">  8   8        (object header: class)    0x000001ee124d1c00</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br><span class="line"></span><br><span class="line"><span class="built_in">wait</span> 2s</span><br><span class="line">调用 <span class="built_in">wait</span> 后，MarkWord 为：</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x000001ee12fc0caa (fat lock: 0x000001ee12fc0caa)</span><br><span class="line">  8   8        (object header: class)    0x000001ee124d1c00</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure><h3 id="偏向锁、轻量级锁与重量级锁的对比"><a href="#偏向锁、轻量级锁与重量级锁的对比" class="headerlink" title="偏向锁、轻量级锁与重量级锁的对比"></a>偏向锁、轻量级锁与重量级锁的对比</h3><p>总结一下synchronized的执行过程，大致如下：</p><ol><li>线程抢锁时，JVM首先检测内置锁对象Mark Word中的biased_lock（偏向锁标识）是否设置成1，lock（锁标志位）是否为01，如果都满足，确认内置锁对象为可偏向状态。</li><li>在内置锁对象确认为可偏向状态之后，JVM检查Mark Word中的线程ID是否为抢锁线程ID，如果是，就表示抢锁线程处于偏向锁状态，抢锁线程快速获得锁，开始执行临界区代码。</li><li>如果Mark Word中的线程ID并未指向抢锁线程，就通过CAS操作竞争锁。如果竞争成功，就将Mark Word中的线程ID设置为抢锁线程，偏向标志位设置为1，锁标志位设置为01，然后执行临界区代码，此时内置锁对象处于偏向锁状态。</li><li>如果CAS操作竞争失败，就说明发生了竞争，撤销偏向锁，进而升级为轻量级锁。</li><li>JVM使用CAS将锁对象的Mark Word替换为抢锁线程的锁记录指针，如果成功，抢锁线程就获得锁。如果替换失败，就表示其他线程竞争锁，JVM尝试使用CAS自旋替换抢锁线程的锁记录指针，如果自旋成功（抢锁成功），那么锁对象依然处于轻量级锁状态。</li><li>如果JVM的CAS替换锁记录指针自旋失败，轻量级锁就膨胀为重量级锁，后面等待锁的线程也要进入阻塞状态。</li></ol><p>总体来说，偏向锁是在没有发生锁争用的情况下使用的；一旦有了第二个线程争用锁，偏向锁就会升级为轻量级锁；如果锁争用很激烈，轻量级锁的CAS自旋到达阈值后，轻量级锁就会升级为重量级锁。</p><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>线程是操作系统调度的最小单位，有自己的栈空间，可以按照既定的代码逐步执行，但是如果每个线程间都孤立地运行，就会造资源浪费。</p><p>所以在现实中，如果<strong>需要多个线程按照指定的规则共同完成一个任务，那么这些线程之间就需要互相协调，这个过程被称为线程的通信</strong>。</p><h3 id="线程间通信的定义"><a href="#线程间通信的定义" class="headerlink" title="线程间通信的定义"></a>线程间通信的定义</h3><p>线程的通信可以被定义为：当多个线程共同操作共享的资源时，线程间通过某种方式互相告知自己的状态，以避免无效的资源争夺。</p><p>线程间通信的方式可以有很多种：<strong>等待-通知、共享内存、管道流</strong>。每种方式用不同的方法来实现，这里首先介绍等待-通知的通信方式。</p><p>“等待-通知”通信方式是Java中使用普遍的线程间通信方式，其经典的案例是“生产者-消费者”模式。</p><h3 id="低效的线程轮询"><a href="#低效的线程轮询" class="headerlink" title="低效的线程轮询"></a>低效的线程轮询</h3><p>首先回到前面的生产者-消费者安全版本的数据缓冲区类 SafeDataBuffer。其存在一个隐蔽但又很耗性能的问题：消费者每一轮消费，无论数据区是否为空，都需要进行数据区的询问和判断。其轮询代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title function_">fetch</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (amount.get() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;队列已经空了！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">T</span> <span class="variable">element</span> <span class="operator">=</span> dataList.remove(<span class="number">0</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;取出的元素是:&quot;</span> + element);</span><br><span class="line">    amount.decrementAndGet();</span><br><span class="line">    <span class="comment">// 如果数据不一致，就抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (amount.get() != dataList.size()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(amount + <span class="string">&quot;!=&quot;</span> + dataList.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数据区空时（amount &lt;&#x3D; 0），消费者无法取出数据，但是仍然做无用的数据区询问工作，白白耗费了CPU的时间片。对于生产者来说，也存在类似的无效轮询问题。当数据区满时，生产者无法加入数据，这时生产者执行add(T element)方法也白白耗费了CPU的时间片。</p><blockquote><p>如何在生产者或者消费者空闲时节约CPU时间片，免去巨大的CPU资源浪费呢？</p></blockquote><p>一个非常有效的办法是：使用“等待-通知”方式进行生产者与消费者之间的线程通信。<br>具体来说，在数据区满（amount.get() &gt; MAX_AMOUNT）时，可以让生产者等待，等到下次数据区中可以加入数据时，给生产者发通知，让生产者唤醒。同样，在数据区为空（amount &lt;&#x3D; 0）时，可以让消费者等待，等到下次数据区中可以取出数据时，消费者才能被唤醒。那么，由谁去唤醒等待状态的生产者呢？可以在消费者取出一个数据后，由消费者去唤醒等待的生产者。同样，由谁去唤醒等待状态的消费者呢？可以在生产者加入一个数据后，由生产者去唤醒等待的消费者。</p><p><strong>Java语言中“等待-通知”方式的线程间通信使用对象的wait()、notify()两类方法来实</strong>现。每个Java对象都有wait()、notify()两类实例方法，并且wait()、notify()方法和对象的监视器是紧密相关的。</p><h3 id="wait方法和notify方法的原理"><a href="#wait方法和notify方法的原理" class="headerlink" title="wait方法和notify方法的原理"></a>wait方法和notify方法的原理</h3><p>Java对象中的wait()、notify()两类方法就如同信号开关，用于等待方和通知方之间的交互。</p><h4 id="对象的wait-方法"><a href="#对象的wait-方法" class="headerlink" title="对象的wait()方法"></a>对象的wait()方法</h4><ul><li><p>对象的<code>wait()</code>方法的主要作用是让当前线程阻塞并等待被唤醒。wait()方法与对象监视器紧密相关，<strong>使用<code>wait()</code>方法时一定要放在同步块中</strong>。<code>Wait()</code>方法的调用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(locko)&#123; </span><br><span class="line">    <span class="comment">//同步保护的代码块</span></span><br><span class="line">    locko.wait();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Object类中的wait()方法有三个版本：</p><ul><li><code>void wait()</code>  这是一个基础版本，当前线程调用了同步对象locko的wait()实例方法后，将导致当前的线程等待，当前线程进入locko的监视器WaitSet，等待被其他线程唤醒。</li></ul></li><li><p><code>void wait(long timeout)</code> 这是一个限时等待版本，导致当前的线程等待，等待被其他线程唤醒，或者指定的时间timeout用完，线程不再等待。</p></li><li><p><code>void wait(long timeout,int nanos)</code> 这是一个高精度限时等待版本，其主要作用是更精确地控制等待时间。参数nanos是一个附加的纳秒级别的等待时间，从而实现更加高精度的等待时间控制。<code>1秒=1000毫秒=1000 000微秒=1000 000 000纳秒</code>。</p></li></ul><h4 id="wait-方法的核心原理"><a href="#wait-方法的核心原理" class="headerlink" title="wait()方法的核心原理"></a>wait()方法的核心原理</h4><p>对象的wait()方法的核心原理大致如下：</p><ol><li>当线程调用了locko（某个同步锁对象）的wait()方法后，JVM会将当前线程加入locko监视器的WaitSet（等待集），等待被其他线程唤醒。</li><li>当前线程会释放locko对象监视器的Owner权利，让其他线程可以抢夺locko对象的监视器。</li><li>让当前线程等待，其状态变成WAITING。</li></ol><h4 id="对象的notify-方法"><a href="#对象的notify-方法" class="headerlink" title="对象的notify()方法"></a>对象的notify()方法</h4><p>对象的notify()方法的主要作用是唤醒在等待的线程。notify()方法与对象监视器紧密相关，调用notify()方法时也需要放在同步块中。notify()方法的调用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(locko)&#123; </span><br><span class="line"> <span class="comment">//同步保护的代码块</span></span><br><span class="line"> locko.notify();</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>notify()方法有两个版本：</p><ul><li>版本一：<code>void notify()</code><ul><li><code>notify()</code>方法的主要作用为：<code>locko.notify()</code>调用后，唤醒locko监视器等待集中的第一条等待线程；被唤醒的线程进入EntryList，其状态从WAITING变成BLOCKED。</li></ul></li><li>版本二：void notifyAll()<ul><li><code>locko.notifyAll()</code>被调用后，唤醒locko监视器等待集中的全部等待线程，所有被唤醒的线程进入EntryList，线程状态从WAITING变成BLOCKED。</li></ul></li></ul><h4 id="notify-方法的核心原理"><a href="#notify-方法的核心原理" class="headerlink" title="notify()方法的核心原理"></a>notify()方法的核心原理</h4><p>对象的notify()或者notifyAll()方法的核心原理大致如下：</p><ul><li>当线程调用了locko（某个同步锁对象）的notify()方法后，JVM会唤醒locko监视器WaitSet中的第一条等待线程。</li><li>当线程调用了locko的notifyAll()方法后，JVM会唤醒locko监视器WaitSet中的所有等待线程。</li><li>等待线程被唤醒后，会从监视器的WaitSet移动到EntryList，线程具备了排队抢夺监视器Owner权利的资格，其状态从WAITING变成BLOCKED。</li><li>EntryList中的线程抢夺到监视器的Owner权利之后，线程的状态从BLOCKED变成Runnable，具备重新执行的资格。</li></ul><h3 id="“等待-通知”通信模式演示案例"><a href="#“等待-通知”通信模式演示案例" class="headerlink" title="“等待-通知”通信模式演示案例"></a>“等待-通知”通信模式演示案例</h3><p>Java的“等待-通知”机制是指：一个线程A调用了同步对象的wait()方法进入等待状态，而另一线程B调用了同步对象的notify()或者notifyAll()方法通知等待线程，当线程A收到通知后，重新进入就绪状态，准备开始执行。线程间的通信需要借助同步对象（Object）的监视器来完成，Object对象的wait()、notify()方法就如开关信号，用于完成等待方和通知方之间的通信。</p><p>下面的演示示例定义了一个独立的同步对象locko，然后借助其wait()、notify()方法完成两个线程aitThread、NotifyThread之间的通信，具体代码如下：</p><ul><li>LOCK_OBJECT：用于临界区同步，临界区资源为数据缓冲区的dataList变量和amount变量。</li><li>NOT_FULL：用于数据缓冲区的未满条件等待和通知。生产者在添加元素前需要判断数据区是否已满，如果是，生产者就进入NOT_FULL的同步区等待被通知，只要消费者消耗一个元素，数据区就是未满的，进入NOT_FULL的同步区发送通知。</li><li>NOT_EMPTY：用于数据缓冲区的非空条件等待和通知。消费者在消耗元素前需要判断数据区是否已空，如果是，消费者就进入NOT_EMPTY的同步区等待被通知，只要生产者添加一个元素，数据区就是非空的，生产者会进入NOT_EMPTY的同步区发送通知。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK_OBJECT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">NOT_FULL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">NOT_EMPTY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向数据区增加一个元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T element)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">while</span> (amount.get() &gt; MAX_AMOUNT) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (NOT_FULL) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列已经满了！&quot;</span>);</span><br><span class="line">            <span class="comment">// 等待未满通知</span></span><br><span class="line">            NOT_FULL.wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (LOCK_OBJECT) &#123;</span><br><span class="line">        dataList.add(element);</span><br><span class="line">        amount.incrementAndGet();</span><br><span class="line">        <span class="comment">// 如果数据不一致，就抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (amount.get() != dataList.size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(amount + <span class="string">&quot;!=&quot;</span> + dataList.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (NOT_EMPTY) &#123;</span><br><span class="line">        NOT_EMPTY.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">fetch</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">while</span> (amount.get() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (NOT_EMPTY) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列已经空了！&quot;</span>);</span><br><span class="line">            NOT_EMPTY.wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">T</span> <span class="variable">element</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (LOCK_OBJECT) &#123;</span><br><span class="line">        element = dataList.remove(<span class="number">0</span>);</span><br><span class="line">        amount.decrementAndGet();</span><br><span class="line">        <span class="comment">// 如果数据不一致，就抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (amount.get() != dataList.size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(amount + <span class="string">&quot;!=&quot;</span> + dataList.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (NOT_FULL) &#123;</span><br><span class="line">        NOT_FULL.notify();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="synchronized同步块的内部使用wait和notify"><a href="#synchronized同步块的内部使用wait和notify" class="headerlink" title="synchronized同步块的内部使用wait和notify"></a>synchronized同步块的内部使用wait和notify</h3><p><strong>在调用同步对象的wait()和notify()系列方法时，“当前线程”必须拥有该对象的同步锁，也就是说，wait()和notify()系列方法需要在同步块中使用</strong>，否则JVM会抛出类似如下的异常<code>IllegalMonitorStateException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalMonitorStateException</span><br><span class="line"> at java.lang.Object.notify(Native Method)</span><br></pre></td></tr></table></figure><p>为什么wait和notify不在synchronized同步块的内部使用会抛出异常呢？这需要从wait()和notify()方法的原理说起。<br><strong>wait()方法的原理</strong>：首先，JVM会释放当前线程的对象锁监视器的Owner资格；其次，JVM会将当前线程移入监视器的WaitSet队列，而这些操作都和对象锁监视器是相关的。所以，wait()方法必须在synchronized同步块的内部调用。<strong>在当前线程执行wait()方法前，必须通过synchronized()方法成为对象锁的监视器的Owner</strong>。</p><p><strong>notify()方法的原理</strong>：JVM从对象锁的监视器的WaitSet队列移动一个线程到其EntryList队列，这些操作都与对象锁的监视器有关。所以，notify()方法也必须在synchronized同步块的内部调用。<strong>在执行notify()方法前，当前线程也必须通过synchronized()方法成为对象锁的监视器的Owner</strong>。</p><blockquote><p>调用wait()和notify()系列方法进行线程通信的要点如下：</p></blockquote><ol><li>调用某个同步对象locko的wait()和notify()类型方法前，必须要取得这个锁对象的监视锁，所以wait()和notify()类型方法必须放在synchronized(locko)同步块中，如果没有获得监视锁，JVM就会报IllegalMonitorStateException异常。</li><li>调用wait()方法时使用while进行条件判断，如果是在某种条件下进行等待，对条件的判断就不能使用if语句做一次性判断，而是<strong>使用while循环进行反复判断。只有这样才能在线程被唤醒后继续检查wait的条件，并在条件没有满足的情况下继续等待</strong>。</li></ol><script>var description="从线程安全问题开始讲起，为大家揭秘Java内置锁的核心原理。"</script>]]></content>
      
      
      <categories>
          
          <category> 多线程编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal原理与实战</title>
      <link href="/p/38186d5e.html"/>
      <url>/p/38186d5e.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>在Java的多线程并发执行过程中，为了保证多个线程对变量的安全访问，可以将变量放到ThreadLocal类型的对象中，使变量在每个线程中都有独立值，不会出现一个线程读取变量时被另一个线程修改的<br>现象。ThreadLocal类通常被翻译为“线程本地变量”类或者“线程局部变量”类。</p><h2 id="ThreadLocal的基本使用"><a href="#ThreadLocal的基本使用" class="headerlink" title="ThreadLocal的基本使用"></a>ThreadLocal的基本使用</h2><p>ThreadLocal位于JDK的java.lang核心包中。如果程序创建了一个ThreadLocal实例，那么在访问这个变量的值时，每个线程都会拥有一个独立的、自己的本地值。<strong>“线程本地变量”可以看成专属于线程的变量，不受其他线程干扰，保存着线程的专属数据。</strong>当线程结束后，每个线程所拥有的那个本地值会被释放。在多线程并发操作“线程本地变量”的时候，线程各自操作的是自己的本地值，从而规避了线程安全问题。ThreadLocal的英文字面意思为“本地线程”，实际上ThreadLocal代表的是线程的本地变量，可能将其命名为ThreadLocalVariable更加容易让人理解。</p><blockquote><p>ThreadLocal如何做到为每个线程存有一份独立的本地值呢？</p></blockquote><p>一个ThreadLocal实例可以形象地理解为一个Map（早期版本的ThreadLocal是这样设计的）。当工作线程Thread实例向本地变量保持某个值时，会以“Key-Value对”（即键-值对）的形式保存在ThreadLocal内部的Map中，其中Key为线程Thread实例，Value为待保存的值。当工作线程Thread实例从ThreadLocal本地变量取值时，会以Thread实例为Key，获取其绑定的Value。一个ThreadLocal实例内部结构的形象展示大致如图所示:</p><p><img src="/p/38186d5e/8f1ae778fd4159cc5e2287c3fd5144b4.png" alt="image-20250107123445094"></p><p>Java程序可以调用ThreadLocal的成员方法进行本地值的操作，具体的成员方法如表所示:</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>ThreadLocal()</code></td><td>创建一个新的ThreadLocal对象。</td></tr><tr><td><code>set(T value)</code></td><td>为当前线程设置值。如果您调用该方法，它将将给定的值存储在当前线程的ThreadLocal对象中。</td></tr><tr><td><code>get()</code></td><td>返回为当前线程存储的值。这是一个返回最后一次使用<code>set()</code>或<code>inheritedValue()</code>方法时存储的值。</td></tr><tr><td><code>initialValue()</code></td><td>返回ThreadLocal的初始值。如果没有设置值，这个方法将返回与ThreadLocal对象相关联的初始值。</td></tr><tr><td><code>inheritedValue()</code></td><td>返回ThreadLocal的继承值，如果没有设置值，该方法将返回从父线程继承的值或ThreadLocal对象的初始值。</td></tr><tr><td><code>remove()</code></td><td>移除为当前线程存储的值。如果您调用该方法，它将清除与当前线程相关联的ThreadLocal对象中的值。</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.fulsun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RejectedExecutionHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        <span class="comment">// 实例总数</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">AMOUNT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 对象的编号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 对象的内容</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bar</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBar</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> bar;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBar</span><span class="params">(<span class="type">int</span> bar)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.bar = bar;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造器</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Foo</span><span class="params">()</span> &#123;</span><br><span class="line">            index = AMOUNT.incrementAndGet(); <span class="comment">// 总数增加，并且给对象编号</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index + <span class="string">&quot;@Foo&#123;bar=&quot;</span> + bar + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义线程本地变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Foo&gt; LOCAL_FOO = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Foo&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 获取自定义的混合型线程池</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> (ThreadPoolExecutor) ThreadUtil.getMixedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交5个任务，将会用到5个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取“线程本地变量”中当前线程所绑定的值</span></span><br><span class="line">                    <span class="keyword">if</span> (LOCAL_FOO.get() == <span class="literal">null</span>) &#123; <span class="comment">// 设置“线程本地变量”中当前线程所绑定的值</span></span><br><span class="line">                        LOCAL_FOO.set(<span class="keyword">new</span> <span class="title class_">Foo</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;初始的本地值：：&quot;</span> + LOCAL_FOO.get());</span><br><span class="line">                    <span class="comment">// 每个线程执行10次</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                        <span class="type">Foo</span> <span class="variable">foo</span> <span class="operator">=</span> LOCAL_FOO.get();</span><br><span class="line">                        foo.setBar(foo.getBar() + <span class="number">1</span>); <span class="comment">// 值增1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;累加10次之后的本地值：&quot;</span> + LOCAL_FOO.get());</span><br><span class="line">                    <span class="comment">// 删除“线程本地变量”中当前线程所绑定的值</span></span><br><span class="line">                    LOCAL_FOO.remove(); <span class="comment">// 这点对于线程池中的线程尤其重要</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行以上示例，其结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-2初始的本地值：：2@Foo&#123;bar=10&#125;</span><br><span class="line">pool-1-thread-4初始的本地值：：3@Foo&#123;bar=10&#125;</span><br><span class="line">pool-1-thread-5初始的本地值：：5@Foo&#123;bar=10&#125;</span><br><span class="line">pool-1-thread-1初始的本地值：：1@Foo&#123;bar=10&#125;</span><br><span class="line">pool-1-thread-3初始的本地值：：4@Foo&#123;bar=10&#125;</span><br><span class="line">pool-1-thread-5累加10次之后的本地值：5@Foo&#123;bar=20&#125;</span><br><span class="line">pool-1-thread-3累加10次之后的本地值：4@Foo&#123;bar=20&#125;</span><br><span class="line">pool-1-thread-2累加10次之后的本地值：2@Foo&#123;bar=20&#125;</span><br><span class="line">pool-1-thread-4累加10次之后的本地值：3@Foo&#123;bar=20&#125;</span><br><span class="line">pool-1-thread-1累加10次之后的本地值：1@Foo&#123;bar=20&#125;</span><br></pre></td></tr></table></figure><p>通过输出的结果可以看出，在“线程本地变量”（LOCAL_FOO）中，每一个线程都绑定了一个独立的值（Foo对象），这些值对象是线程的私有财产，可以理解为线程的本地值，线程的每一次操作都是在自己的同一个本地值上进行的，从例子中线程本地值的index始终一致可以看出，每个线程操作的是同一个Foo对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取“线程本地变量”中当前线程所绑定的值</span></span><br><span class="line"> <span class="keyword">if</span> (LOCAL_FOO.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="comment">//设置“线程本地变量”中当前线程所绑定的初始值</span></span><br><span class="line">     LOCAL_FOO.set(<span class="keyword">new</span> <span class="title class_">Foo</span>());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不想采用以上的“判空后设值”这种相对烦琐的方式，可以调用ThreadLocal.withInitial(…)静态工厂方法</span></span><br><span class="line">ThreadLocal&lt;Foo&gt; LOCAL_FOO = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">Foo</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ThreadLocal的使用场景"><a href="#ThreadLocal的使用场景" class="headerlink" title="ThreadLocal的使用场景"></a>ThreadLocal的使用场景</h2><p>ThreadLocal是解决线程安全问题的一个较好的方案，它通过为每个线程提供一个独立的本地值去解决并发访问的冲突问题。在很多情况下，使用ThreadLocal比直接使用同步机制（如synchronized）解决线程安全问题更简单、更方便，且结果程序拥有更高的并发性。</p><p>ThreadLocal的使用场景大致可以分为以下两类：</p><ol><li><code>线程隔离</code>: ThreadLocal的主要价值在于线程隔离，ThreadLocal中的数据只属于当前线程，其本地值对别的线程是不可见的，在多线程环境下，可以防止自己的变量被其他线程篡改。另外，由于各个线程之间的数据相互隔离，避免了同步加锁带来的性能损失，大大提升了并发性的性能。ThreadLocal在线程隔离的常用案例为：可以为每个线程绑定一个用户会话信息、数据库连接、HTTP请求等，这样一个线程所有调用到的处理函数都可以非常方便地访问这些资源。常见的ThreadLocal使用场景为数据库连接独享、Session数据管理等。在“线程隔离”场景中，使用ThreadLocal的典型案例为：可以为每个线程绑定一个数据库连接，使得这个数据库连接为线程所独享，从而避免数据库连接被混用而导致操作异常问题。</li><li><code>跨函数传递数据</code>: 通常用于同一个线程内，跨类、跨方法传递数据时，如果不用ThreadLocal，那么相互之间的数据传递势必要靠返回值和参数，这样无形之中增加了这些类或者方法之间的耦合度。由于ThreadLocal的特性，同一线程在某些地方进行设置，在随后的任意地方都可以获取到。线程执行过程中所执行到的函数都能读写ThreadLocal变量的线程本地值，从而可以方便地实现跨函数的数据传递。使用ThreadLocal保存函数之间需要传递的数据，在需要的地方直接获取，也能避免通过参数传递数据带来的高耦合。在“跨函数传递数据”场景中使用ThreadLocal的典型案例为：可以为每个线程绑定一个Session（用户会话）信息，这样一个线程所有调用到的代码都可以非常方便地访问这个本地会话，而不需要通过参数传递。</li></ol><h3 id="使用ThreadLocal进行线程隔离"><a href="#使用ThreadLocal进行线程隔离" class="headerlink" title="使用ThreadLocal进行线程隔离"></a>使用ThreadLocal进行线程隔离</h3><p>ThreadLocal在“线程隔离”应用场景的典型应用为“数据库连接独享”。下面的代码来自Hibernate，代码中通过ThreadLocal进行数据库连接（Session）的“线程本地化”存储，主要的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadLocal</span> <span class="variable">threadSession</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title function_">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException &#123;</span><br><span class="line">    <span class="type">Session</span> <span class="variable">s</span> <span class="operator">=</span> (Session) threadSession.get();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            s = getSessionFactory().openSession();</span><br><span class="line">            threadSession.set(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InfrastructureException</span>(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hibernate对数据库连接进行了封装，一个Session代表一个数据库连接。通过以上代码可以看到，在Hibernate的getSession()方法中，首先判断当前线程中有没有放进去Session，如果还没有，那么通过sessionFactory().openSession()来创建一个Session，再将Session设置到ThreadLocal变量中，这个Session相当于线程的私有变量，而不是所有线程共用的，显然其他线程中是取不到这个Session的。</p><h3 id="使用ThreadLocal进行跨函数数据传递"><a href="#使用ThreadLocal进行跨函数数据传递" class="headerlink" title="使用ThreadLocal进行跨函数数据传递"></a>使用ThreadLocal进行跨函数数据传递</h3><p>ThreadLocal在“跨函数数据传递”场景的典型应用有很多：</p><ol><li>用来传递请求过程中的用户ID。</li><li>用来传递请求过程中的用户会话（Session）。</li><li>用来传递HTTP的用户请求实例HttpRequest。</li><li>其他需要在函数之间频繁传递的数据。</li></ol><p>通过ThreadLocal在函数之间传递用户信息、会话信息等，并且封装成了一个独立的SessionHolder类，具体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionHolder</span> &#123;</span><br><span class="line">    <span class="comment">// session id，线程本地变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; sidLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;(<span class="string">&quot;sidLocal&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户信息，线程本地变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; sessionUserLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;(<span class="string">&quot;sessionUserLocal&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// session，线程本地变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;HttpSession&gt; sessionLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;(<span class="string">&quot;sessionLocal&quot;</span>);</span><br><span class="line">    <span class="comment">// 省略其他 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存session在线程本地变量中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setSession</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">        sessionLocal.set(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得绑定在线程本地变量中的session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HttpSession <span class="title function_">getSession</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> sessionLocal.get();</span><br><span class="line">        Assert.notNull(session, <span class="string">&quot;session未设置&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> session;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal内部结构演进"><a href="#ThreadLocal内部结构演进" class="headerlink" title="ThreadLocal内部结构演进"></a>ThreadLocal内部结构演进</h2><p>在早期的JDK版本中，<strong>每个ThreadLocal都创建一个Map，然后用线程作为Map的key，要存储的局部变量作为Map的value，这样就能达到各个线程的局部变量隔离的效果。</strong></p><p><img src="/p/38186d5e/ead7201b5aadea8e40d14aec8b7d5e84.png"></p><p>在JDK 8版本中，ThreadLocal的内部结构发生了演进，虽然还是使用了Map结构，但是Map结构的拥有者已经发生了变化, <strong>每个Thread维护一个ThreadLocalMap，这个Map的key是ThreadLocal实例本身，value才是真正要存储的值object。</strong></p><ol><li>每个Thread线程内部都有一个Map（ThreadLocalMap）。</li><li>Map里面存储ThreadLocal对象（key）和线程的变量副本（value）。</li><li>Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。</li><li>对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。</li></ol><p><img src="/p/38186d5e/7d8acf46b9195798e5e52ee63d134f2c.png"></p><blockquote><p>与早期版本的ThreadLocalMap实现相比，新版本的主要变化为：</p></blockquote><ol><li>拥有者发生了变化：新版本的ThreadLocalMap拥有者为Thread，早期版本的ThreadLocalMap拥有者为ThreadLocal。</li><li>Key发生了变化：新版本的Key为ThreadLocal实例，早期版本的Key为Thread实例。</li></ol><blockquote><p><strong>从上面变成JDK8的设计有什么好处？</strong></p></blockquote><ol><li>每个Map存储的Entry数量变少，因为原来的Entry数量是由Thread决定，而现在是由ThreadLocal决定的。(真实开发中，Thread的数量远远大于ThreadLocal的数量。)</li><li>当Thread销毁的时候，ThreadLocalMap也会随之销毁，因为ThreadLocal是存放在Thread中的，随着Thread销毁而消失，能降低开销。</li></ol><h2 id="ThreadLocal源码分析"><a href="#ThreadLocal源码分析" class="headerlink" title="ThreadLocal源码分析"></a>ThreadLocal源码分析</h2><p>ThreadLocal源码提供的方法不多，主要有：<code>set(T value)</code>方法、<code>get()</code>方法、<code>remove()</code>方法和<code>initialValue()</code>方法。</p><h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value: 将要保存在当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取此线程对象中维护的ThreadLoca1Map对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 判断map是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 存在则调用map.set设置此实体entry</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1、当前线程Thread不存在ThreadLocalMap对象</span></span><br><span class="line">        <span class="comment">// 2、则调用createMap进行ThreadLocalMap对象的初始化</span></span><br><span class="line">        <span class="comment">// 3、并将t(当前线程)和va1ue(t对应的值)作为第一个entry存放至ThreadLocalMap中</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程Thread对应维护的ThreadLocalMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t: 当前线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>   对应维护的ThreadLocalMap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建当前线程Thread对应维护的ThreadLocalMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t: 当前线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstValue: 存放到map中第一个entry的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的this是调用此方法的threadLocal</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>set()方法执行流程：</strong></p><ol><li>获得当前线程，然后获得当前线程的ThreadLocalMap成员，暂存于map变量。</li><li>如果map不为空，就将Value设置到map中，当前的ThreadLocal作为Key。</li><li>如果map为空，为该线程创建map，然后设置第一个“KeyValue对”，Key为当前的ThreadLocal实例，Value为set()方法的参数value值。</li></ol><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前线程对应此ThreadLocal的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 如果此map存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 以当前的ThreadLocal为key,调用getEntry获取对应的存储实体e</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 对e进行判空</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">// 获取存储实体e对应的 value值,即为我们想要的当前线程对应此ThreadLoca1的值</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化: 有两种情况要执行当前代码</span></span><br><span class="line">    <span class="comment">// 第一种情况: map不存在，表示此线程没有维护的ThreadLocalMap对象</span></span><br><span class="line">    <span class="comment">// 第二种情况: map存在，但是没有与当前ThreadLocal关联的entry</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 初始化后的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用initialValue获取初始化的值</span></span><br><span class="line">    <span class="comment">// 此方法可以被子类重写，如果不重写默认返回nu11</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 判断map是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 存在,则调用map.set设置此实体entry</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1、当前线程Thread不存在ThreadLocalMap对象</span></span><br><span class="line">        <span class="comment">// 2、则调用createMap进行ThreadLocalmap对象的初始化</span></span><br><span class="line">        <span class="comment">// 3、并将t(当前线程)和value(t对应的值)作为第一个entry存放至ThreadLocalMap中</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断this的类型是否属于TerminatingThreadLocal</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> TerminatingThreadLocal) &#123;</span><br><span class="line">        <span class="comment">// 将this进行注册到TerminatingThreadLocal类中</span></span><br><span class="line">        TerminatingThreadLocal.register((TerminatingThreadLocal&lt;?&gt;) <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回设置的值value</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>get()方法执行流程：</strong></p><p>  　　1. 先尝试获得当前线程，然后获得当前线程的ThreadLocalMap成员，暂存于map变量。<br>        　　2. 如果获得的map不为空，那么以当前ThreadLocal实例为Key尝试获得map中的Entry（条目）。<br>            　　3. 如果获取的Map不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应的Entrye，否则转到第4步。<br>                    　　4. 如果Entry为空，就通过调用initialValue初始化钩子函数获取ThreadLocal初始值，并设置在map中。如果map不存在，还会给当前线程创建新ThreadLocalMap成员，然后用ThreadLocal的引用和value作为firstKey和firstValue创建一个新的Map。</p><p><strong>setInitialValue()方法的执行逻辑为：</strong></p><p>  　　1. 获取到value值（这里使用的initialValue默认返回null）。</p><pre><code>    　　2. 获取到当前线程，根据当前线程查询是否有对应的map。        　　3. 如果当前线程有对应的map，那么就更新值，否则的话就进行创建。                　　4. 最后instance of关键字用来判断this的类型是否属于TerminatingThreadLocal。如果this属于是TerminatingThreadLocal类型的，那么就调用register方法将this进行注册到TerminatingThreadLocal类中。      　　5. 最后的这段代码用于将终止类型的ThreadLocal实例注册到TerminatingThreadLocal类的静态列表中。这样，在线程退出时，终止类型的ThreadLocal实例会自动从ThreadLocalMap中移除，避免内存泄漏。</code></pre><h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除当前线程中保存的ThreadLocal对应的实体entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">    <span class="comment">// 如果此map存在</span></span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 存在则调用map.remove,以当前ThreadLocal为key删除对应的实体entry</span></span><br><span class="line">        m.remove(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>remove()方法执行流程：</strong></p><p>　　1. 首先获取当前线程，并根据当前线程获取一个Map。</p><p>　　2. 如果获取的Map不为空，则移除当前ThreadLocal对象对应的Entry。</p><h3 id="initialValue方法"><a href="#initialValue方法" class="headerlink" title="initialValue方法"></a>initialValue方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前线程对应的ThreadLocal的初始值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 此方法的第一次调用发生在，当线程通过get方法访问此线程的ThreadLoca1值时</span></span><br><span class="line"><span class="comment"> * 除非线程先调用了set方法，在这种情况下，initia1Value才不会被这个线程调用。</span></span><br><span class="line"><span class="comment"> * 通常情况下，每个线程最多调用一次这个方法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;这个方法仅仅简单的返回nu1l &#123;<span class="doctag">@code</span> nu11&#125;;</span></span><br><span class="line"><span class="comment"> * 如果程序员想ThreadLoca1线程局部变量有一个除nu11以外的初始值</span></span><br><span class="line"><span class="comment"> * 必须通过子类继承&#123;<span class="doctag">@code</span> ThreadLoca1&#125; 的方式去重写此方法</span></span><br><span class="line"><span class="comment"> * 通常，可以通过匿名内部类的方式实现</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前ThreadLocal的初始值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>initialValue()方法的作用是返回该线程局部变量的初始值：</strong>如果没有调用set()直接调用get()，就会调用该方法，但是该方法只会被调用一次。默认情况下，initialValue()方法返回null，如果不想返回null，可以继承ThreadLocal以覆盖此方法。</p><p>真的需要继承ThreadLocal去重写initialValue()方法吗？其实没有必要。JDK已经为大家定义了一个ThreadLocal的内部SuppliedThreadLocal静态子类，并且提供了ThreadLocal.withInitial(…)静态工厂方法，方便大家在定义ThreadLocal实例时设置初始值回调函数。使用工厂方法构造ThreadLocal实例的代码如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;Foo&gt; LOCAL_FOO = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">Foo</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ThreadLocal&lt;S&gt; <span class="title function_">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SuppliedThreadLocal</span>&lt;&gt;(supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承了ThreadLocal，重写了initialValue()方法，返回钩子函数的值作为初始值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SuppliedThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; supplier;</span><br><span class="line"></span><br><span class="line">    SuppliedThreadLocal(Supplier&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; supplier) &#123;</span><br><span class="line">        <span class="built_in">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocalMap源码分析"><a href="#ThreadLocalMap源码分析" class="headerlink" title="ThreadLocalMap源码分析"></a>ThreadLocalMap源码分析</h2><p>ThreadLocal的操作都是基于ThreadLocalMap展开的，而ThreadLocalMap是ThreadLocal的一个静态内部类，其实现了一套简单的Map结构（比HashMap简单）。</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也是独立实现。</p><p><img src="/p/38186d5e/88eb45fcff99700281d92c49e341f8e7.png"></p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>跟HashMap类似， <strong>INITIAL_CAPACITY</strong> 代表这个Map的初始容量； <strong>table</strong> 是一个Entry类型的数组，用于存储数据； <strong>size</strong> 代表表中的存储数目； <strong>threshold</strong> 代表需要扩容时对应的size的阈值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始容量 - 必须是2的整次幂</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*存放数据的table ，Entry类的定义在下面分析，同样，数组的长度必须是2的整次幂</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*数组里面entrys的个数，可以用于判断table当前使用量是否超过阈值</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*进行扩容的阈值，表使用量大于它的时候进行扩容</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> threshold; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><h3 id="存储结构-Entry"><a href="#存储结构-Entry" class="headerlink" title="存储结构 - Entry"></a>存储结构 - Entry</h3><p>在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。不过Entry中的key只能是ThreadLocal对象，这点在构造方法中已经限定死了。</p><p>另外，Entry继承WeakReference，也就是key（ThreadLocal）是弱引用，其目的是将ThreadLocal对象的生命周期和线程生命周期解绑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Entry继承WeakRefefence，并且用ThreadLocal作为key。</span></span><br><span class="line"><span class="comment">* 如果key为nu11（entry.get（）==nu11），意味着key不再被引用，</span></span><br><span class="line"><span class="comment">* 因此这时候entry也可以从table中清除。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">weakReference</span>&lt;ThreadLocal&lt;?&gt;&gt;&#123;</span><br><span class="line">　　object value；</span><br><span class="line"></span><br><span class="line">　　Entry（ThreadLocal&lt;?&gt;k，object v）&#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>ThreadLocal源码中的get()、set()、remove()方法都涉及ThreadLocalMap的方法调用，主要调用了ThreadLocalMap的如下几个方法：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>find(int hash, ThreadLocal&lt;?&gt; firstKey)</code></td><td>根据给定哈希值和第一个键查找对应的记录</td></tr><tr><td><code>createThreadLocalRegistry(Thread thread, int initialCapacity)</code></td><td>创建一个新的 <code>ThreadLocalMap</code> 对象并初始化其容量</td></tr><tr><td><code>findSlotForNewValue(ThreadLocal&lt;?&gt; firstKey, int hash)</code></td><td>找到可以放置新线程局部变量记录的位置</td></tr><tr><td><code>get(ThreadLocal&lt;?&gt; key)</code></td><td>根据给定的 <code>ThreadLocal</code> 键获取对应的值</td></tr><tr><td><code>remove(ThreadLocal&lt;?&gt; key)</code></td><td>从映射中移除指定的线程局部变量记录</td></tr><tr><td><code>set(ThreadLocal&lt;?&gt; key, Object value)</code></td><td>将给定键和值添加到 <code>ThreadLocalMap</code> 中</td></tr><tr><td><code>withLock(Runnable runner)</code></td><td>获取当前线程的锁，执行给定的操作后释放锁</td></tr></tbody></table><p>对<code>ThreadLocalMap的set(ThreadLocal&lt;?&gt;key,Object value)</code>方法的代码以注释的形式做一个简单的分析:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据key的HashCode，找到key在数组上的槽点i</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从槽点i开始向后循环搜索，找空余槽点（空余位置）或者找现有槽点</span></span><br><span class="line">    <span class="comment">// 若没有现有槽点，则必定有空余槽点，因为没有空间时会扩容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; e != <span class="literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 找到现有槽点：Key值为ThreadLocal实例</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到异常槽点：槽点被GC掉，重设Key值和Value值</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有找到现有的槽点，增加新的Entry</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="comment">// 设置ThreadLocal数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">    <span class="comment">// 清理Key为null的无效Entry</span></span><br><span class="line">    <span class="comment">// 没有可清理的Entry，并且现有条目数量大于扩容因子值，进行扩容 </span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) </span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Entry的Key需要使用弱引用"><a href="#Entry的Key需要使用弱引用" class="headerlink" title="Entry的Key需要使用弱引用"></a>Entry的Key需要使用弱引用</h3><blockquote><p>什么是弱引用呢？仅有弱引用（Weak Reference）指向的对象只能生存到下一次垃圾回收之前。换句话说，当GC发生时，无论内存够不够，仅有弱引用所指向的对象都会被回收。而拥有强引用指向的对象则不会被直接回收。</p><p>什么是内存泄漏？不再用到的内存没有及时释放（归还给系统），就叫作内存泄漏。对于持续运行的服务进程必须及时释放内存，否则内存占用率越来越高，轻则影响系统性能，重则导致进程崩溃甚至系统崩溃。</p></blockquote><p>为什么Entry需要使用弱引用对Key进行包装，而不是直接使用ThreadLocal实例作为Key呢？这个问题有点复杂，要分析清楚还有点难度。</p><p>这里从一个简单的例子入手，假设有一个方法funcA()创建了一个“线程本地变量”，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funcA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个线程本地变量</span></span><br><span class="line">    <span class="type">ThreadLocal</span> <span class="variable">local</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">// 设置值</span></span><br><span class="line">    local.set(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 获取值</span></span><br><span class="line">    local.get();</span><br><span class="line">    <span class="comment">// 函数末尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程tn调用funcA()方法新建了一个ThreadLocal实例，使用local局部变量指向这个实例，并且此local是强引用；在调用local.set(100)之后，线程tn的ThreadLocalMap成员内部会新建一个Entry实例，其Key以弱引用包装的方式指向ThreadLocal实例。</p><p>当线程tn执行完funcA()方法后，funcA()的方法栈帧将被销毁，强引用local的值也就没有了，但此时线程的ThreadLocalMap中对应的Entry的Key引用还指向ThreadLocal实例。<strong>如果Entry的Key引用是强引用，就会导致Key引用指向的ThreadLocal实例及其Value值都不能被GC回收，这将造成严重的内存泄漏问题</strong>, 因此在没有手动删除这个Entry以及CurrentThread依然运行的前提下，始终有强引用链<strong>CurrentThread Ref-&gt;CurrentThread-&gt;ThreadLocalMap-&gt;Entry</strong> ，Entry就不会被回收（Entry中包括了ThreadLocal实例和value），导致Entry内存泄漏。</p><p><strong><img src="/p/38186d5e/90cb6845bec3042354566d76b7e3c1d0.png"></strong></p><p>同样假设在业务代码中使用完了ThreadLocal，ThreadLocal Ref被回收了。由于ThreadLocalMap只持有ThreadLocal的弱引用，没有任何强引用指向threadlocal实例，所以Threadlocal就可以顺利被GC回收，此时Entry中的key&#x3D;null。</p><p>但是，在没有手动删除这个Entry以及CurrentThread依然运行的前提下，也存在有强引用链 <strong>CurrentThread Ref-&gt;CurrentThread-&gt;ThreadLocalMap-&gt;Entry-&gt;value</strong> ，value不会被回收，而这块value永远不会被访问到了，导致value内存泄漏。<strong>也就是说，ThreadLocalMap中的key使用了弱引用，也有可能内存泄漏。</strong></p><h3 id="出现内存泄漏的真实原因"><a href="#出现内存泄漏的真实原因" class="headerlink" title="出现内存泄漏的真实原因"></a>出现内存泄漏的真实原因</h3><p>由于ThreadLocalMap中Entry的Key使用了弱引用，在下次GC发生时，就可以使那些没有被其他强引用指向、仅被Entry的Key所指向的ThreadLocal实例能被顺利回收。并且，在Entry的Key引用被回收之后，其Entry的Key值变为null。后续当ThreadLocal的get()、set()或remove()被调用时，ThreadLocalMap的内部代码会清除这些Key为null的Entry，从而完成相应的内存释放。</p><p>总结一下，使用ThreadLocal会发生内存泄漏的前提条件如下：</p><ol><li>线程长时间运行而没有被销毁。线程池中的Thread实例很容易满足此条件。</li><li>ThreadLocal引用被设置为null，且后续在同一Thread实例执行期间，没有发生对其他ThreadLocal实例的get()、set()或remove()操作。</li></ol><ul><li>第一点稍微复杂一点，由于ThreadLocalMap是Thread的一个属性，被当前线程所引用，所以它的生命周期跟Thread一样长。那么在使用完ThreadLocal的使用，如果当前Thread也随之执行结束，ThreadLocalMap自然也会被GC回收，从根源上避免了内存泄漏。</li><li>第二点很好理解，只要在使用完ThreadLocal，调用其remove方法删除对应的Entry，就能避免内存泄漏。</li><li><strong>综上，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread-样长，如果没有手动删除对应key就会导致内存泄漏。</strong></li></ul><h2 id="ThreadLocal编程规范推荐"><a href="#ThreadLocal编程规范推荐" class="headerlink" title="ThreadLocal编程规范推荐"></a>ThreadLocal编程规范推荐</h2><p>编程规范有云：ThreadLocal实例作为ThreadLocalMap的Key，针对一个线程内的所有操作是共享的，所以建议设置static修饰符，以便被所有的对象共享。由于静态变量会在类第一次被使用时装载，只会分配一次存储空间，此类的所有实例都会共享这个存储空间，所以使用static修饰ThreadLocal就会节约内存空间。另外，为了确保ThreadLocal实例的唯一性，除了使用static修饰之外，还会使用<br>final进行加强修饰，以防止其在使用过程中发生动态变更。参考的实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐使用static final线程本地变量</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Foo&gt; LOCAL_FOO = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Foo&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码中，为什么ThreadLocal实例除了添加static final修饰外，还常常添加private修饰呢？</span></span><br><span class="line"><span class="comment">// 主要目的是缩小使用的范围，尽可能不让他人引用。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>凡事都有两面性，使用static、final修饰ThreadLocal实例也会带来副作用，使得Thread实例内部的ThreadLocalMap中Entry的Key在thread实例的生命期内将始终保持为非null，从而导致Key所在的<br>Entry不会被自动清空，这就会让Entry中的Value指向的对象一直存在强引用，于是Value指向的对象在线程生命期内不会被释放，最终导致内存泄漏。所以，在使用完static、final修饰的ThreadLocal实例之后，必须调用remove()来进行显式的释放操作。</p><p>如果使用线程池，可以定制线程池的afterExecute()方法（任务执行完成之后的钩子方法），在任务执行完成之后，调用ThreadLocal实例的remove()方法对其进行释放，从而使得其线程内部的Entry得以释放，参考的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程本地变量，用于记录线程异步任务的开始执行时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; START_TIME = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">2</span>)) &#123;</span><br><span class="line">    <span class="comment">// 省略其他 </span></span><br><span class="line">    <span class="comment">// 异步任务执行完成之后的钩子方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterExecute</span><span class="params">(Runnable target, Throwable t)</span> &#123;</span><br><span class="line">        <span class="comment">// 省略其他 </span></span><br><span class="line">        <span class="comment">// 清空ThreadLocal实例的本地值</span></span><br><span class="line">        START_TIME.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal综合使用案例"><a href="#ThreadLocal综合使用案例" class="headerlink" title="ThreadLocal综合使用案例"></a>ThreadLocal综合使用案例</h2><p>由于ThreadLocal使用不当会导致严重的内存泄漏问题，所以为了更好地避免内存泄漏问题的发生，我们使用ThreadLocal时遵守以下两个原则：</p><ol><li>尽量使用private static final修饰ThreadLocal实例。<ul><li>使用private与final修饰符主要是为了尽可能不让他人修改、变更ThreadLocal变量的引用</li><li>使用static修饰符主要是为了确保ThreadLocal实例的全局唯一。</li></ul></li><li>ThreadLocal使用完成之后务必调用remove()方法。这是简单、有效地避免ThreadLocal引发内存泄漏问题的方法。</li></ol><p>下面用一个综合案例演示一下ThreadLocal的使用。此案例的功能为：记录执行过程中所调用的函数所需的执行时间（即执行耗时）。<br>比如在实际Web开发过程中，一次客户端请求往往会涉及DB、缓存、RPC等多个调用，一旦出现性能问题，就需要记录一下各个点耗时，从而判断性能的瓶颈所在。下面的代码定义了三个方法：serviceMethod()、daoMethod()和rpcMethod()，用于模拟实际的DB、RPC等调用，具体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟业务方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serviceMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 睡眠500毫秒，模拟执行所需的时间（耗时）</span></span><br><span class="line">    sleepMilliSeconds(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录从开始调用到当前这个点（ &quot;point-1&quot;）的耗时</span></span><br><span class="line">    SpeedLog.logPoint(<span class="string">&quot;point-1 service&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用DAO()方法：模拟DAO业务方法</span></span><br><span class="line">    daoMethod();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用RPC()方法：模拟RPC远程业务方法</span></span><br><span class="line">    rpcMethod();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟DAO业务方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">daoMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 睡眠400毫秒，模拟执行所需的时间</span></span><br><span class="line">    sleepMilliSeconds(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录上一个点（&quot;point-1&quot;）到这里（&quot;point-2&quot;）的耗时</span></span><br><span class="line">    SpeedLog.logPoint(<span class="string">&quot;point-2 dao&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟RPC远程业务方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rpcMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 睡眠400毫秒，模拟执行所需的时间</span></span><br><span class="line">    sleepMilliSeconds(<span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录上一个点（&quot;point-2&quot;）到这里（&quot;point-3&quot;）的耗时</span></span><br><span class="line">    SpeedLog.logPoint(<span class="string">&quot;point-3 rpc&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sleepMilliSeconds</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(i);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能灵活地记录各个执行埋点的耗时，这里定义了一个SpeedLog类。该类含有一个ThreadLocal类型的、初始值为一个Map&lt;String,Long&gt;实例的“线程本地变量”，名字叫作<br>TIME_RECORD_LOCAL。</p><p>如果要记录某个函数的调用耗时，就需要进行耗时埋点，具体的方法为logPoint(String point)。该方法会操作TIME_RECORD_LOCAL本地变量，在其中增加一次耗时记录：Key为耗时埋点的名称，值为当前时间和上一次记录时间的差值，也就是上一次埋点到本次埋点之间的调用耗时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpeedLog</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录调用耗时的本地Map变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;String, Long&gt;&gt; TIME_RECORD_LOCAL = ThreadLocal.withInitial(SpeedLog::initialStartTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录调用耗时的本地Map变量的初始化方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Long&gt; <span class="title function_">initialStartTime</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Long&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;start&quot;</span>, System.currentTimeMillis());</span><br><span class="line">        map.put(<span class="string">&quot;last&quot;</span>, System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始耗时记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">beginSpeedLog</span><span class="params">()</span> &#123;</span><br><span class="line">        Print.fo(<span class="string">&quot;开始耗时记录&quot;</span>);</span><br><span class="line">        TIME_RECORD_LOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结束耗时记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">endSpeedLog</span><span class="params">()</span> &#123;</span><br><span class="line">        TIME_RECORD_LOCAL.remove();</span><br><span class="line">        Print.fo(<span class="string">&quot;结束耗时记录&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 耗时埋点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">logPoint</span><span class="params">(String point)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取上一次的时间</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">last</span> <span class="operator">=</span> TIME_RECORD_LOCAL.get().get(<span class="string">&quot;last&quot;</span>);</span><br><span class="line">        <span class="comment">// 计算上一次埋点到当前埋点的耗时</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">cost</span> <span class="operator">=</span> System.currentTimeMillis() - last;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存上一次埋点到当前埋点的耗时</span></span><br><span class="line">        TIME_RECORD_LOCAL.get().put(point + <span class="string">&quot; cost:&quot;</span>, cost);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存当前时间，供下一次埋点使用</span></span><br><span class="line">        TIME_RECORD_LOCAL.get().put(<span class="string">&quot;last&quot;</span>, System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printCost</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Long&gt; map = TIME_RECORD_LOCAL.get();</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.endsWith(<span class="string">&quot; cost:&quot;</span>)) &#123;</span><br><span class="line">                Print.fo(key + <span class="string">&quot; : &quot;</span> + map.get(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 开始耗时记录，保存当前时间</span></span><br><span class="line">        SpeedLog.beginSpeedLog();</span><br><span class="line">        <span class="comment">// 调用模拟业务方法</span></span><br><span class="line">        <span class="type">ThreadLocalTest2</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalTest2</span>();</span><br><span class="line">        test.serviceMethod();</span><br><span class="line">        <span class="comment">// 打印耗时</span></span><br><span class="line">        SpeedLog.printCost();</span><br><span class="line">        <span class="comment">// 结束耗时记录</span></span><br><span class="line">        SpeedLog.endSpeedLog();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable).start();</span><br><span class="line">    sleepSeconds(<span class="number">10</span>);<span class="comment">// 等待10秒看结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script>var description="在Java中使用ThreadLocal时，为了防止内存泄漏并确保资源的有效管理，应遵循的最佳实践。"</script>]]></content>
      
      
      <categories>
          
          <category> 多线程编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池原理与实战</title>
      <link href="/p/38186d5e.html"/>
      <url>/p/38186d5e.html</url>
      
        <content type="html"><![CDATA[<ul><li>Java线程的创建非常昂贵，需要JVM和OS（操作系统）配合完成大量的工作：<ul><li>必须为线程堆栈分配和初始化大量内存块，其中包含至少1MB的栈内存。</li><li>需要进行系统调用，以便在OS（操作系统）中创建和注册本地线程。</li></ul></li><li>Java高并发应用频繁创建和销毁线程的操作是非常低效的，而且是不被编程规范所允许的。<strong>如何降低Java线程的创建成本？必须使用到线程池</strong>。线程池主要解决了以下两个问题：<ul><li>提升性能：线程池能独立负责线程的创建、维护和分配。在执行大量异步任务时，可以不需要自己创建线程，而是将任务交给线程池去调度。线程池能尽可能使用空闲的线程去执行异步任务，最大限度地对已经创建的线程进行复用，使得性能提升明显。</li><li>线程管理：每个Java线程池会保持一些基本的线程统计信息，例如完成的任务数量、空闲时间等，以便对线程进行有效管理，使得能对所接收到的异步任务进行高效调度。</li></ul></li></ul><h2 id="JUC的线程池架构"><a href="#JUC的线程池架构" class="headerlink" title="JUC的线程池架构"></a>JUC的线程池架构</h2><p>JUC就是java.util.concurrent工具包的简称，该工具包是从JDK 1.5开始加入JDK的，是用于完成高并发、处理多线程的一个工具包。</p><p><img src="/p/38186d5e/c41cd3b6d9866a26e4fb537fadf110f2.png"></p><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>Executor是Java异步目标任务的“执行者”接口，其目标是执行目标任务。“执行者”Executor提供了execute()接口来执行已提交的Runnable执行目标实例。Executor作为执行者的角色，其目的是提供一种将“任务提交者”与“任务执行者”分离开来的机制。它只包含一个函数式方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br></pre></td></tr></table></figure><h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><p>ExecutorService继承于Executor。它是Java异步目标任务的“执行者服务接”口，对外提供异步任务的接收服务。ExecutorService提供了“接收异步任务并转交给执行者”的方法，如submit系列方法、invoke系列方法等，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向线程池提交单个异步任务</span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"><span class="comment">//向线程池提交批量异步任务</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure><h3 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h3><p>AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。AbstractExecutorService存在的目的是为ExecutorService中的接口提供默认实现。</p><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>ThreadPoolExecutor就是大名鼎鼎的“线程池”实现类，它继承于AbstractExecutorService抽象类。</p><p>ThreadPoolExecutor是JUC线程池的核心实现类。线程的创建和终止需要很大的开销，线程池中预先提供了指定数量的可重用线程，所以使用线程池会节省系统资源，并且每个线程池都维护了一些基础的数据统计，方便线程的管理和监控。</p><h3 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h3><p>ScheduledExecutorService是一个接口，它继承于ExecutorService。它是一个可以完成“延时”和“周期性”任务的调度线程池接口，其功能和Timer&#x2F;TimerTask类似。</p><h3 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h3><p>ScheduledThreadPoolExecutor继承于ThreadPoolExecutor，它提供了ScheduledExecutorService线程池接口中“延时执行”和“周期执行”等抽象调度方法的具体实现。</p><p>ScheduledThreadPoolExecutor类似于Timer，但是在高并发程序中，<strong>ScheduledThreadPoolExecutor的性能要优于Timer</strong>。</p><h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p>Executors是一个静态工厂类，它通过静态工厂方法返回ExecutorService、ScheduledExecutorService等线程池示例对象，这些静态工厂方法可以理解为一些快捷的创建线程池的方法。</p><h2 id="Executors快捷创建线程池"><a href="#Executors快捷创建线程池" class="headerlink" title="Executors快捷创建线程池"></a>Executors快捷创建线程池</h2><p>尽管Executors的工厂方法使用方便，但是在生产场景中被很多企业（尤其是大厂）的开发规范所禁用。</p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>该方法用于创建一个“单线程化线程池”，也就是只有一个线程的线程池，所创建的线程池用唯一的工作线程来执行任务，使用此方法创建的线程池能保证所有任务按照指定顺序（如FIFO）执行。</p><p>调用<code>Executors.newSingleThreadExecutor()</code>快捷工厂方法创建一个“单线程化线程池”的测试用例，其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试用例：只有一个线程的线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pool.execute(<span class="keyword">new</span> <span class="title class_">TargetTask</span>());</span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">TargetTask</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    sleepSeconds(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 关闭线程池</span></span><br><span class="line">    pool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该线程池有以下特点：</p><ol><li>单线程化的线程池中的任务是按照提交的次序顺序执行的。</li><li>池中的唯一线程的存活时间是无限的。</li><li>当池中的唯一线程正繁忙时，新提交的任务实例会进入内部的阻塞队列中，并且其阻塞队列是无界的。</li></ol><p>总体来说，单线程化的线程池所适用的场景是：</p><ol><li><p>任务按照提交次序，一个任务一个任务地逐个执行的场景。</p></li><li><p>以上用例在最后调用shutdown()方法来关闭线程池。执行shutdown()方法后，线程池状态变为SHUTDOWN，此时线程池将拒绝新任务，不能再往线程池中添加新任务，否则会抛出RejectedExecutionException异常。此时，线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成才会退出。还有一个与shutdown()类似的方法，叫作shutdownNow()，执行shutdownNow()方法后，线程池状态会立刻变成STOP，并试图停止所有正在执行的线程，并且不再处理还在阻塞队列中等待的任务，会返回那些未执行的任务。</p></li></ol><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>该方法用于创建一个“固定数量的线程池”，其唯一的参数用于设置池中线程的“固定数量”。调用Executors.newFixedThreadPool(int threads)快捷工厂方法创建“固<br>定数量的线程池”</p><p>“固定数量的线程池”的特点大致如下：</p><ol><li>如果线程数没有达到“固定数量”，每次提交一个任务线程池内就创建一个新线程，直到线程达到线程池固定的数量。</li><li>线程池的大小一旦达到“固定数量”就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li><li>在接收异步任务的执行目标实例时，如果池中的所有线程均在繁忙状态，新任务会进入阻塞队列中（无界的阻塞队列）。</li></ol><p>“固定数量的线程池”的适用场景：需要任务长期执行的场景。“固定数量的线程池”的线程数能够比较稳定地保证一个数，能够避免频繁回收线程和创建线程，故适用于处理CPU密集型的任务，在CPU被工作线程长时间占用的情况下，能确保尽可能少地分配线程。</p><p>“固定数量的线程池”的弊端：内部使用无界队列来存放排队任务，当大量任务超过线程池最大容量需要处理时，队列无限增大，使服务器资源迅速耗尽。</p><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>该方法用于创建一个“可缓存线程池”，如果线程池内的某些线程无事可干成为空闲线程，“可缓存线程池”可灵活回收这些空闲线程。</p><p>“可缓存线程池”的特点大致如下：</p><ol><li>在接收新的异步任务target执行目标实例时，如果池内所有线程繁忙，此线程池就会添加新线程来处理任务。</li><li>此线程池不会对线程池大小进行限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</li><li>如果部分线程空闲，也就是存量线程的数量超过了处理任务数量，就会回收空闲（60秒不执行任务）线程。<br>“</li></ol><p>可缓存线程池”的适用场景：</p><ol><li>需要快速处理突发性强、耗时较短的任务场景，如Netty的NIO处理场景、REST API接口的瞬时削峰场景。</li><li>“可缓存线程池”的线程数量不固定，只要有空闲线程就会被回收；接收到的新异步任务执行目标，查看是否有线程处于空闲状态，如果没有就直接创建新的线程。</li></ol><p>“可缓存线程池”的弊端：线程池没有最大线程数量限制，如果大量的异步任务执行目标实例同时提交，可能会因创建线程过多而导致资源耗尽。</p><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>该方法用于创建一个“可调度线程池”，即一个提供“延时”和“周期性”任务调度功能的ScheduledExecutorService类型的线程池。ScheduleExecutorService接口中有多个重要的接收被调目标任务的方法，其中<code>scheduleAtFixedRate</code>和<code>scheduleWithFixedDelay</code>使用得比较多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：创建一个可调度线程池，池内仅含有一个线程</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newSingleThreadScheduledExecutor</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//方法二：创建一个可调度线程池，池内含有N个线程，N的值为输入参数corePoolSize</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> ;</span><br><span class="line"></span><br><span class="line">scheduled.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">TargetTask</span>(), <span class="number">0</span>, <span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"> <span class="comment">// 以上参数中：0表示首次执行任务的延迟时间，500表示每次执行任务的间隔时间</span></span><br><span class="line"> <span class="comment">// TimeUnit.MILLISECONDS是执行的时间间隔数值，单位为毫秒</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(</span><br><span class="line">     Runnable command, <span class="comment">//异步任务target执行目标实例</span></span><br><span class="line">     <span class="type">long</span> initialDelay, <span class="comment">//首次执行延时</span></span><br><span class="line">     <span class="type">long</span> period, <span class="comment">//两次开始执行最小间隔时间</span></span><br><span class="line">     TimeUnit unit <span class="comment">//所设置的时间的计时单位，如TimeUnit.SECONDS常量</span></span><br><span class="line"> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(</span><br><span class="line">     Runnable command, <span class="comment">//异步任务target执行目标实例</span></span><br><span class="line">     <span class="type">long</span> initialDelay, <span class="comment">//首次执行延时</span></span><br><span class="line">     <span class="type">long</span> delay, <span class="comment">//前一次执行结束到下一次执行开始的间隔时间（间隔执行延迟时间）</span></span><br><span class="line">     TimeUnit unit <span class="comment">//所设置的时间的计时单位，如TimeUnit.SECONDS常量</span></span><br><span class="line"> );</span><br></pre></td></tr></table></figure><p>当被调任务的执行时间大于指定的间隔时间时，ScheduleExecutorService并不会创建一个新的线程去并发执行这个任务，而是等待前一次调度执行完毕。</p><p>“可调度线程池”的适用场景：周期性地执行任务的场景。Spring Boot中的任务调度器，底层借助了JUC的ScheduleExecutorService“可调度线程池”实现，并且可以通过<code>@Configuration</code>配置类型的Bean。</p><h2 id="线程池的标准创建方式"><a href="#线程池的标准创建方式" class="headerlink" title="线程池的标准创建方式"></a>线程池的标准创建方式</h2><p>大部分企业的开发规范都会禁止使用快捷线程池（具体原因稍后介绍），要求通过标准构造器ThreadPoolExecutor去构造工作线程池。Executors工厂类中创建线程池的快捷工厂方法实际上是调用<br>ThreadPoolExecutor（定时任务使用ScheduledThreadPoolExecutor）线程池的构造方法完成的。<code>ThreadPoolExecuutor</code>构造方法有多个重载版本，其中一个比较重要的构造器如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用标准构造器构造一个普通的线程池</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">     <span class="type">int</span> corePoolSize, // 核心线程数，即使线程空闲（Idle），也不会回收</span></span><br><span class="line"><span class="params">     <span class="type">int</span> maximumPoolSize, // 线程数的上限</span></span><br><span class="line"><span class="params">     <span class="type">long</span> keepAliveTime, TimeUnit unit, // 线程最大空闲（Idle）时长</span></span><br><span class="line"><span class="params">     BlockingQueue&lt;Runnable&gt; workQueue, // 任务的排队队列</span></span><br><span class="line"><span class="params">     ThreadFactory threadFactory, // 新线程的产生方式</span></span><br><span class="line"><span class="params">     RejectedExecutionHandler handler // 拒绝策略</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><h3 id="核心和最大线程数量"><a href="#核心和最大线程数量" class="headerlink" title="核心和最大线程数量"></a>核心和最大线程数量</h3><p>参数<code>corePoolSize</code>用于设置核心（Core）线程池数量，参数<code>maximumPoolSiz</code>e用于设置最大线程数量。线程池执行器将会根据<code>corePoolSize</code>和<code>maximumPoolSize</code>自动维护线程池中的工作线程，大致<br>规则为：</p><ol><li>当在线程池接收到新任务，并且当前工作线程数少于<code>corePoolSize</code>时，即使其他工作线程处于空闲状态，也会创建一个新线程来处理该请求，直到线程数达到corePoolSize。（</li><li>如果当前工作线程数多于<code>corePoolSize</code>数量，但小于<code>maximumPoolSize</code>数量，那么<strong>仅当任务排队队列已满时才会创建新线程</strong>。通过设置<code>corePoolSize</code>和<code>maximumPoolSize</code>相同，可以创建一个固<br>定大小的线程池。</li><li>当<code>maximumPoolSize</code>被设置为无界值（如<code>Integer.MAX_VALUE</code>）时，线程池可以接收任意数量的并发任务。</li><li><code>corePoolSize</code>和<code>maximumPoolSize</code>不仅能在线程池构造时设置，也可以调用<code>setCorePoolSize()</code>和<code>setMaximumPoolSize()</code>两个方法进行动态更改。</li></ol><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>BlockingQueue（阻塞队列）的实例用于暂时接收到的异步任务，如果线程池的核心线程都在忙，那么所接收到的目标任务缓存在阻塞队列中。</p><h3 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h3><p>线程构造器的keepAliveTime（空闲线程存活时间）参数用于设置池内线程最大Idle（空闲）时长（或者说保活时长），如果超过这个时间，默认情况下Idle、非Core线程会被回收。</p><p>如果池在使用过程中提交任务的频率变高，也可以调用方法setKeepAliveTime(long，TimeUnit)进行线程存活时间的动态调整，可以将时长延长。如果需要防止Idle线程被终止，可以将Idle时间设<br>置为无限大，具体如下：<code>setKeepAliveTime(Long.MAX_VALUE，TimeUnit.NANOSECONDS);</code></p><p>默认情况下，Idle超时策略仅适用于存在超过corePoolSize线程的情况。但若调用了<code>allowCoreThreadTimeOut(boolean)</code>方法，并且传入了参数true，则keepAliveTime参数所设置的Idle超时策略也将被应用于核心线程。</p><p><code>keepAliveTime</code> 的设定与线程的实际执行时间是两个独立的概念。<code>keepAliveTime</code> 是<strong>用于控制当线程数量已经小于核心线程数时，在无新任务提交的情况下空闲线程的存活时间</strong>。</p><h2 id="线程池提交任务的两种方式"><a href="#线程池提交任务的两种方式" class="headerlink" title="线程池提交任务的两种方式"></a>线程池提交任务的两种方式</h2><blockquote><p>在ThreadPoolExecutor类的实现中，内部核心的任务提交方法是execute()方法，虽然用户程序通过submit()也可以提交任务，但是实际上submit()方法中最终调用的还是execute()方法。</p></blockquote><p>向线程池提交任务的两种方式大致如下：</p><ul><li><p>方式一：调用execute()方法，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br></pre></td></tr></table></figure></li><li><p>方式二：调用submit()方法，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ExecutorService 接口中的方法</span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>; </span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure></li></ul><p>以上的submit()和execute()两类方法的区别在哪里呢？大致有以下三点：</p><ol><li>二者所接收的参数不一样<br><strong>Execute()方法只能接收Runnable类型的参数，而submit()方法可以接收Callable、Runnable两种类型的参数。</strong><ul><li>Callable类型的任务是可以返回执行结果的，而Runnable类型的任务不可以返回执行结果。</li><li>Callable是JDK 1.5加入的执行目标接口，作为Runnable的一种补充，允许有返回值，允许抛出异常。</li><li>Runnable和Callable的主要区别为：Callable允许有返回值，Runnable不允许有返回值；Runnable不允许抛出异常，Callable允许抛出异常。</li></ul></li><li><strong>submit()提交任务后会有返回值</strong>，而execute()没有<ul><li>execute()方法主要用于启动任务的执行，而任务的执行结果和可能的异常调用者并不关心。</li><li>submit()方法也用于启动任务的执行，但是启动之后会返回Future对象，代表一个异步执行实例，可以通过该异步执行实例去获取结果。</li></ul></li><li><strong>submit()方便Exception处理</strong><ul><li>execute()方法在启动任务执行后，任务执行过程中可能发生的异常调用者并不关心。</li><li>而通过submit()方法返回的Future对象（异步执行实例），可以进行异步执行过程中的异常捕获。</li></ul></li></ol><h3 id="submit-获取结果"><a href="#submit-获取结果" class="headerlink" title="submit()获取结果"></a>submit()获取结果</h3><p>submit()方法自身并不会传递结果，而是返回一个Future异步执行实例，处理过程的结果被包装到Future实例中，调用者可以通过Future.get()方法获取异步执行的结果。通过submit()返回的Future<br>对象获取异步执行结果，演示代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.fulsun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 提交任务并获取 Future 对象</span></span><br><span class="line">            Future&lt;Integer&gt; future = executorService.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查任务是否完成</span></span><br><span class="line">            <span class="keyword">if</span> (future.isDone()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task is already done.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取任务的结果，阻塞直到结果可用</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;Result of the task: &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭线程池</span></span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">42</span>;   <span class="comment">// 模拟任务结果</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Task completed with result: &quot;</span> + result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="submit-捕获异常"><a href="#submit-捕获异常" class="headerlink" title="submit()捕获异常"></a>submit()捕获异常</h3><p>submit()方法自身并不会传递结果，而是返回一个Future异步执行实例，处理过程的结果被包装到Future实例中，调用者可以通过Future.get()方法获取异步执行的结果。<strong>如果异常抛出，就会在调用Future.get()时传递给调用者</strong>, 通过submit()返回的Future对象获取异步执行结果，演示代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 提交任务并获取 Future 对象</span></span><br><span class="line">            Future&lt;Integer&gt; future = executorService.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查任务是否完成</span></span><br><span class="line">            <span class="keyword">if</span> (future.isDone()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task is already done.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取任务的结果，阻塞直到结果可用</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">                System.out.println(<span class="string">&quot;Result of the task: &quot;</span> + result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Exception while getting the result: &quot;</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭线程池</span></span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">42</span>;   <span class="comment">// 模拟任务结果</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Task completed with result: &quot;</span> + result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池的任务调度流程"><a href="#线程池的任务调度流程" class="headerlink" title="线程池的任务调度流程"></a>线程池的任务调度流程</h2><p>线程池的任务调度流程（包含接收新任务和执行下一个任务）大致如下：</p><ol><li>如果当前工作线程数量小于核心线程数量，执行器总是优先创建一个任务线程，而不是从线程队列中获取一个空闲线程。</li><li>如果线程池中总的任务数量大于核心线程池数量，新接收的任务将被加入阻塞队列中，一直到阻塞队列已满。在核心线程池数量已经用完、阻塞队列没有满的场景下，线程池不会为新任务创建一个新线程。</li><li>当完成一个任务的执行时，执行器总是优先从阻塞队列中获取下一个任务，并开始执行，一直到阻塞队列为空，其中所有的缓存任务被取光。</li><li>在核心线程池数量已经用完、阻塞队列也已经满了的场景下，如果线程池接收到新的任务，将会为新任务创建一个线程（非核心线程），并且立即开始执行新任务。</li><li>在核心线程都用完、阻塞队列已满的情况下，一直会创建新线程去执行新任务，直到池内的线程总数超出maximumPoolSize。如果线程池的线程总数超过maximumPoolSize，线程池就会拒绝接收任务，当新任务过来时，会为新任务执行拒绝策略。</li></ol><p><img src="/p/38186d5e/48a3e28afdd9886fa4f5b8f49912300b.png"></p><h2 id="ThreadFactory（线程工厂）"><a href="#ThreadFactory（线程工厂）" class="headerlink" title="ThreadFactory（线程工厂）"></a>ThreadFactory（线程工厂）</h2><p><code>ThreadFactory</code>是一个接口，它提供了创建线程的工厂方法。<code>ThreadFactory</code>接口有一个单一的方法 <code>newThread(Runnable r)</code>，该方法用于创建一个新的<code>Thread</code>对象，这个线程将要执行给定的<code>Runnable</code>任务。<code>ThreadFactory</code>的主要目的是提供一种统一的方式来创建线程，这样可以更容易地控制和管理这些线程，尤其是在线程池（如<code>ExecutorService</code>或<code>Executors</code>工具类中的线程池实现）中使用时。具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new unstarted &#123;<span class="doctag">@code</span> Thread&#125; to run the given runnable.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r a runnable to be executed by new thread instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> constructed thread, or &#123;<span class="doctag">@code</span> null&#125; if the request to</span></span><br><span class="line"><span class="comment">     *         create a thread is rejected</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> &lt;a href=&quot;../../lang/Thread.html#inheritance&quot;&gt;Inheritance when</span></span><br><span class="line"><span class="comment">     * creating threads&lt;/a&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用ThreadFactory的唯一方法<code>newThread()</code>创建新线程时，可以更改所创建的新线程的名称、线程组、优先级、守护进程状态等。<br>如果newThread()的返回值为null，表示线程工厂未能成功创建线程，线程池可能无法执行任何任务。</p><p>使用Executors创建新的线程池时，也可以基于<code>ThreadFactory</code>（线程工厂）创建，在创建新线程池时可以指定将要使用的ThreadFactory实例。只不过，如果没有指定的话，就会使用<br><code>Executors.defaultThreadFactory()</code>默认实例。使用默认的线程工厂实例所创建的线程全部位于同一个ThreadGroup（线程组）中，具有相同的NORM_PRIORITY（优先级为5）</p><h3 id="自定义ThreadFactory实例"><a href="#自定义ThreadFactory实例" class="headerlink" title="自定义ThreadFactory实例"></a>自定义ThreadFactory实例</h3><p>基于自定义的ThreadFactory实例创建线程池，首先需要实现一个<code>ThreadFactory</code>类，实现其唯一的抽象方法<code>newThread(Runnable)</code>。下面的例子首先实现一个简单的线程工厂，然后基于该线程工厂快捷创建线程池，具体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup threadGroup;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> priority;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> daemon;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThreadFactory</span><span class="params">(String prefix, ThreadGroup group, <span class="type">int</span> priority, <span class="type">boolean</span> isDaemon)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.namePrefix = prefix + <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.threadGroup = group;</span><br><span class="line">        <span class="built_in">this</span>.priority = priority;</span><br><span class="line">        <span class="built_in">this</span>.daemon = isDaemon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(threadGroup, r, namePrefix + threadNumber.getAndIncrement(), priority, daemon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义线程池核心和最大线程数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numCores</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">        <span class="type">MyThreadFactory</span> <span class="variable">myThreadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThreadFactory</span>(</span><br><span class="line">                <span class="string">&quot;MyPool-&quot;</span>,</span><br><span class="line">                Thread.currentThread().getThreadGroup(),  <span class="comment">// 使用当前线程组</span></span><br><span class="line">                Thread.MAX_PRIORITY,                      <span class="comment">// 设置优先级为最高</span></span><br><span class="line">                <span class="literal">false</span>                                     <span class="comment">// 不设置守护线程</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 ExecutorService 实例</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(numCores, myThreadFactory);</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;:Hello, world!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="任务阻塞队列"><a href="#任务阻塞队列" class="headerlink" title="任务阻塞队列"></a>任务阻塞队列</h2><p>Java中的阻塞队列（<code>BlockingQueue</code>）与普通队列相比有一个重要的特点：<strong>在阻塞队列为空时会阻塞当前线程的元素获取操作</strong>。具体来说，在一个线程从一个空的阻塞队列中获取元素时线程会被阻塞，直到阻塞队列中有了元素；当队列中有元素后，被阻塞的线程会自动被唤醒（唤醒过程不需要用户程序干预）。</p><p>Java线程池使用<code>BlockingQueue</code>实例暂时接收到的异步任务，<code>BlockingQueue</code>是JUC包的一个超级接口，比较常用的实现类有：</p><ol><li><code>ArrayBlockingQueue</code>：是一个数组实现的有界阻塞队列（有界队列），队列中的元素按FIFO排序。<code>ArrayBlockingQueue</code>在创建时必须设置大小，接收的任务超出corePoolSize数量时，任务被缓存到该阻塞队列中，<strong>任务缓存的数量只能为创建时设置的大小</strong>，若该阻塞队列已满，则会为新的任务创建线程，直到线程池中的线程总数大于maximumPoolSize。</li><li><code>LinkedBlockingQueue</code>：是一个基于链表实现的阻塞队列，按FIFO排序任务，可以设置容量（有界队列），不设置容量则默认使用Integer.Max_VALUE作为容量（无界队列）。该队列的吞吐量高于ArrayBlockingQueue。如果不设置LinkedBlockingQueue的容量（无界队列），当接收的任务数量超出corePoolSize时，则新任务可以被无限制地缓存到该阻塞队列中，直到资源耗尽。有两个快捷创建线程池的工厂方法<code>Executors.newSingleThreadExecutor</code>和<code>Executors.newFixedThreadPool</code>使用了这个队列，并且都没有设置容量（无界队列）。</li><li><code>PriorityBlockingQueue</code>：是具有优先级的无界队列。</li><li><code>DelayQueue</code>：这是一个无界阻塞延迟队列，底层基于<code>PriorityBlockingQueue</code>实现，队列中每个元素都有过期时间，当从队列获取元素（元素出队）时，只有已经过期的元素才会出队，队列头部的元素是过期最快的元素。快捷工厂方法<code>Executors.newScheduledThreadPool</code>所创建的线程池使用此队列。</li><li><code>SynchronousQueue</code>：（同步队列）是一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程的调用移除操作，否则插入操作一直处于阻塞状态，其吞吐量通常高于<code>LinkedBlockingQueue</code>。快捷工厂方法<code>Executors.newCachedThreadPool</code>所创建的线程池使用此队列。与前面的队列相比，这个队列比较特殊，它不会保存提交的任务，而是直接新建一个线程来执行新来的任务。</li></ol><table><thead><tr><th>阻塞队列类型</th><th>特点</th><th>用途</th><th>行为</th></tr></thead><tbody><tr><td><strong>ArrayBlockingQueue</strong></td><td>基于数组的有界阻塞队列。提供固定大小的缓冲区来存储元素。</td><td>适合创建时即确定任务数量的情况使用。</td><td>线程在添加元素到已满的队列时会被挂起；从空队列中获取元素时被挂起；当队列为空或已满时，线程会自动唤醒并继续执行操作。</td></tr><tr><td><strong>LinkedBlockingQueue</strong></td><td>基于链表的阻塞队列。提供无界（可配置大小）或有界的缓冲区来存储元素。</td><td>适合任务数量不确定或很大的情况使用。</td><td>线程在添加元素到已满的队列时会被挂起；从空队列中获取元素时被挂起；当队列为空或已满时，线程会自动唤醒并继续执行操作。</td></tr><tr><td><strong>PriorityBlockingQueue</strong></td><td>有界的优先级队列，根据元素的优先级排序。</td><td>适合需要对任务进行排序以按优先级执行的情况使用。</td><td>线程在从空队列中获取元素时会被挂起；当队列中有新的高优先级元素被添加时，会自动唤醒等待的线程。</td></tr><tr><td><strong>DelayQueue</strong></td><td>基于<code>PriorityBlockingQueue</code>实现，每个元素都有一个过期时间。</td><td>用于在指定的时间后才能被取走的任务。</td><td>线程在从空队列中获取元素时会被挂起；当队列中的最早过期元素被移除时，会自动唤醒等待的线程。</td></tr><tr><td><strong>SynchronousQueue</strong></td><td>不存储元素的阻塞队列。即每个插入操作必须等到另一个线程调用移除操作，否则会一直阻塞。</td><td>适合任务立即执行或直接调度到工作线程的情况使用。</td><td>线程在尝试从空队列中获取元素时会被挂起；当有其他线程添加元素时，等待的线程会被自动唤醒并继续执行操作。</td></tr></tbody></table><ul><li><strong>内部实现</strong>：<ul><li><code>ArrayBlockingQueue</code>：使用一个循环数组来实现有界阻塞队列，并通过<code>synchronized</code>方法和<code>wait()</code>、<code>notifyAll()</code>机制来管理线程的挂起与唤醒。</li><li><code>LinkedBlockingQueue</code>：使用单向链表结构，内部维护了两个<code>Condition</code>对象（一个用于获取操作，另一个用于添加操作），同样依赖于<code>synchronized</code>方法和<code>wait()</code>、<code>notifyAll()</code>机制来实现。</li><li><code>PriorityBlockingQueue</code> 和 <code>DelayQueue</code> 等也类似地实现了基于锁和条件变量的线程管理。</li></ul></li></ul><h2 id="调度器的钩子方法"><a href="#调度器的钩子方法" class="headerlink" title="调度器的钩子方法"></a>调度器的钩子方法</h2><p>ThreadPoolExecutor线程池调度器为每个任务执行前后都提供了钩子方法。ThreadPoolExecutor类提供了三个钩子方法（空方法），这三个钩子方法一般用作被子类重写，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务执行之前的钩子方法（前钩子）</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> &#123; &#125;</span><br><span class="line"> <span class="comment">//任务执行之后的钩子方法（后钩子）</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> &#123; &#125;</span><br><span class="line"> <span class="comment">//线程池终止时的钩子方法（停止钩子）</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">terminated</span><span class="params">()</span> &#123; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>beforeExecute和afterExecute两个方法在每个任务执行前后被调用，如果钩子（回调方法）引发异常，内部工作线程可能失败并突然终止。</p></blockquote><h3 id="beforeExecute"><a href="#beforeExecute" class="headerlink" title="beforeExecute"></a><code>beforeExecute</code></h3><p>线程池工作线程在异步<strong>执行目标实例（如Runnable实例）前调用此钩子方法</strong>。此方法仍然由执行任务的工作线程调用。默认实现不执行任何操作，但可以在子类中对其进行自定义。</p><p>此方法由执行目标实例的工作线程调用，可用于重新初始化ThreadLocal线程本地变量实例、更新日志记录、开始计时统计、更新上下文变量等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledThreadPoolExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义预执行钩子方法</span></span><br><span class="line">        ThreadPoolExecutor.<span class="type">BeforeExecuteHook</span> <span class="variable">beforeExecuteHook</span> <span class="operator">=</span> (t, r) -&gt; System.out.println(<span class="string">&quot;Task is about to start on thread: &quot;</span> + t.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置自定义的钩子方法</span></span><br><span class="line">        executor.prestartAllCoreThreads();</span><br><span class="line">        executor.beforeExecute(beforeExecuteHook);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并提交任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskNumber</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Executing task: &quot;</span> + taskNumber);</span><br><span class="line">            executor.schedule(task, i, java.util.concurrent.TimeUnit.SECONDS); <span class="comment">// 每隔一秒执行一次任务</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="afterExecute"><a href="#afterExecute" class="headerlink" title="afterExecute"></a><code>afterExecute</code></h3><p>线程池工作线程在异步<strong>执行目标实例后调用此钩子方法</strong>。此方法仍然由执行任务的工作线程调用。此钩子方法的默认实现不执行任何操作，可以在调度器子类中对其进行自定义。</p><p>此方法由执行目标实例的工作线程调用，可用于清除ThreadLocal线程本地变量、更新日志记录、收集统计信息、更新上下文变量等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">java<span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledThreadPoolExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义后执行钩子方法</span></span><br><span class="line">        ThreadPoolExecutor.<span class="type">AfterExecuteHook</span> <span class="variable">afterExecuteHook</span> <span class="operator">=</span> (t, r) -&gt; System.out.println(<span class="string">&quot;Task has finished on thread: &quot;</span> + t.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置自定义的钩子方法</span></span><br><span class="line">        executor.prestartAllCoreThreads();</span><br><span class="line">        executor.afterExecute(afterExecuteHook);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并提交任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskNumber</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Executing task: &quot;</span> + taskNumber);</span><br><span class="line">            executor.schedule(task, i, java.util.concurrent.TimeUnit.SECONDS); <span class="comment">// 每隔一秒执行一次任务</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="terminated"><a href="#terminated" class="headerlink" title="terminated"></a><code>terminated</code></h3><p>terminated钩子方法在Executor终止时调用，默认实现不执行任何操作。</p><h3 id="定制钩子方法"><a href="#定制钩子方法" class="headerlink" title="定制钩子方法"></a>定制钩子方法</h3><p>继承<code>ThreadPoolExecutor</code>类，并重写其中的几个钩子方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title class_">ThreadPoolExecutor</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, <span class="type">int</span> maximumPoolSize, <span class="type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> MeasuredTask) &#123; <span class="comment">// 假设我们的任务都是MeasuredTask类型，这个类可以保存开始时间。</span></span><br><span class="line">            ((MeasuredTask)r).startTime = System.nanoTime(); <span class="comment">// 用System.nanoTime()获取纳秒级别的精度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> MeasuredTask) &#123; </span><br><span class="line">            <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> System.nanoTime() - ((MeasuredTask)r).startTime;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务执行时间: &quot;</span> + duration / <span class="number">1e6</span> + <span class="string">&quot; ms&quot;</span>); <span class="comment">// 将纳秒转换为毫秒输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">terminated</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.terminated();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程池已终止&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title class_">ThreadPoolExecutor</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, <span class="type">int</span> maximumPoolSize, <span class="type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> MeasuredTask) &#123; <span class="comment">// 假设我们的任务都是MeasuredTask类型，这个类可以保存开始时间。</span></span><br><span class="line">            ((MeasuredTask)r).startTime = System.nanoTime(); <span class="comment">// 用System.nanoTime()获取纳秒级别的精度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> MeasuredTask) &#123; </span><br><span class="line">            <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> System.nanoTime() - ((MeasuredTask)r).startTime;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务执行时间: &quot;</span> + duration / <span class="number">1e6</span> + <span class="string">&quot; ms&quot;</span>); <span class="comment">// 将纳秒转换为毫秒输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">terminated</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.terminated();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程池已终止&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个具体的任务类，继承自Runnable，并添加开始时间记录字段。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MeasuredTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">long</span> startTime; <span class="comment">// 开始执行的时间点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MeasuredTask</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.runnable = task;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable runnable;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        runnable.run(); <span class="comment">// 执行实际的任务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2><p>在线程池的任务缓存队列为有界队列（有容量限制的队列）的时候，如果队列满了，提交任务到线程池的时候就会被拒绝。总体来说，任务被拒绝有两种情况：</p><ol><li>线程池已经被关闭。</li><li>工作队列已满且maximumPoolSize已满。</li></ol><p>无论以上哪种情况任务被拒绝，线程池都会调用<code>RejectedExecutionHandler</code>实例的<code>rejectedExecution</code>方法。</p><p>RejectedExecutionHandler是拒绝策略的接口，JUC为该接口提供了以下几种实现：</p><ol><li><code>AbortPolicy</code>：拒绝策略。</li><li><code>DiscardPolicy</code>：抛弃策略。</li><li><code>DiscardOldestPolicy</code>：抛弃最老任务策略。</li><li><code>CallerRunsPolicy</code>：调用者执行策略。</li><li>自定义策略。</li></ol><h3 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h3><p>这是默认策略，当线程池队列已满并且无法容纳更多任务时抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">5</span>,  <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="number">20</span>, <span class="comment">// 最大线程数</span></span><br><span class="line">    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>), </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">AbortPolicy</span>()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h3><p>当任务无法添加到线程池时，它由提交该任务的线程执行，不会使用线程池中的线程去执行新任务。这可以降低新任务的数量或提高正在运行的任务完成的速度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">5</span>, </span><br><span class="line">    <span class="number">20</span>,</span><br><span class="line">    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>), </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CallerRunsPolicy</span>()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h3><p>当任务无法添加到线程池时，直接丢弃该任务。不抛出异常或给出任何通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">5</span>, </span><br><span class="line">    <span class="number">20</span>,</span><br><span class="line">    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>), </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">DiscardPolicy</span>()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h3><p>当任务无法添加到线程池时，丢弃队列中最旧的任务，并尝试重新插入新任务。因为队列是队尾进队头出，队头元素是最老的，所以每次都是移除队头元素后再尝试入队。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">5</span>, </span><br><span class="line">    <span class="number">20</span>,</span><br><span class="line">    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>), </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">DiscardOldestPolicy</span>()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="自定义拒绝策略"><a href="#自定义拒绝策略" class="headerlink" title="自定义拒绝策略"></a>自定义拒绝策略</h3><p>除了使用内置的拒绝策略，你还可以创建自定义类来实现<code>RejectedExecutionHandler</code>接口，并通过构造方法或<code>setRejectedExecutionHandler()</code>方法将该对象设置为线程池的工作参数。</p><p>下面是一个简单的示例，展示了如何创建一个自定义的拒绝策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRejectPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">        <span class="comment">// 打印一条日志信息或执行其他操作来处理被拒绝的任务</span></span><br><span class="line">        System.err.println(<span class="string">&quot;任务被线程池拒绝: &quot;</span> + r.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义的拒绝策略创建线程池</span></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">customPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">5</span>, </span><br><span class="line">    <span class="number">20</span>,</span><br><span class="line">    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>), </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CustomRejectPolicy</span>()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="线程池的优雅关闭"><a href="#线程池的优雅关闭" class="headerlink" title="线程池的优雅关闭"></a>线程池的优雅关闭</h2><p>一般情况下，线程池启动后建议手动关闭。在介绍线程池的优雅关闭之前，我们先了解一下线程池的状态。线程池总共存在5种状态，定义在<code>ThreadPoolExecutor</code>类中，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><p>线程池的5种状态具体如下：</p><ol><li><code>RUNNING</code>：线程池创建之后的初始状态，这种状态下可以执行任务。</li><li><code>SHUTDOWN</code>：该状态下线程池不再接受新任务，但是会将工作队列中的任务执行完毕。</li><li><code>STOP</code>：该状态下线程池不再接受新任务，也不会处理工作队列中的剩余任务，并且将会中断所有工作线程。</li><li><code>TIDYING</code>：该状态下所有任务都已终止或者处理完成，将会执行terminated()钩子方法。</li><li><code>TERMINATED</code>：执行完<code>terminated()</code>钩子方法之后的状态</li></ol><p>线程池的状态转换规则为：</p><ol><li>线程池创建之后状态为<code>RUNNING</code>。</li><li>执行线程池的<code>shutdown()</code>实例方法，会使线程池状态从<code>RUNNING</code>转变为<code>SHUTDOWN</code>。</li><li>执行线程池的<code>shutdownNow()</code>实例方法，会使线程池状态从<code>RUNNING</code>转变为<code>STOP</code>。</li><li>当线程池处于SHUTDOWN状态时，执行其<code>shutdownNow()</code>方法会将其状态转变为<code>STOP</code>。</li><li>等待线程池的所有工作线程停止，工作队列清空之后，线程池状态会从STOP转变为<code>TIDYING</code>。</li><li>执行完<code>terminated()</code>钩子方法之后，线程池状态从<code>TIDYING</code>转变为<code>TERMINATED</code>。</li></ol><p>优雅地关闭线程池主要涉及的方法有3个：</p><ol><li><code>shutdown</code>：是JUC提供的一个有序关闭线程池的方法，此方法会<strong>等待当前工作队列中的剩余任务全部执行完成之后，才会执行关闭</strong>，但是此方法被调用之后线程池的状态转为SHUTDOWN，线程池不会再接收新的任务。</li><li><code>shutdownNow</code>：是JUC提供的一个立即关闭线程池的方法，此方法会打断正在执行的工作线程，并且会清空当前工作队列中的剩余任务，返回的是尚未执行的任务。</li><li><code>awaitTermination</code>：等待线程池完成关闭。在调用线程池的<code>shutdown()</code>与<code>shutdownNow()</code>方法时，当前线程会立即返回，不会一直等待直到线程池完成关闭。如果需要等到线程池关闭完成，可以调用<code>awaitTermination()</code>方法。</li></ol><h3 id="shutdown-方法的原理"><a href="#shutdown-方法的原理" class="headerlink" title="shutdown()方法的原理"></a>shutdown()方法的原理</h3><p>Shutdown()方法首先加锁，其次检查调用者是否用于执行线程池关闭的Java Security权限。接着shutdown()方法会将线程池状态变为SHUTDOWN，在这之后线程池不再接受提交的新任务。此时如果还继续往线程池提交任务，将会使用线程池拒绝策略响应，默认的拒绝策略将会使用ThreadPoolExecutor.AbortPolicy，接收新任务时会抛出RejectedExecutionException异常。</p><p><code>shutdown()</code>方法的源码大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检查权限</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 设置线程池状态</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 中断空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        <span class="comment">// 钩子函数，主要用于清理一些资源</span></span><br><span class="line">        onShutdown();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="shutdownNow-方法的原理"><a href="#shutdownNow-方法的原理" class="headerlink" title="shutdownNow()方法的原理"></a>shutdownNow()方法的原理</h3><p><code>shutdownNow()</code>方法将会把线程池状态设置为STOP，然后中断所有线程（包括工作线程以及空闲线程），最后清空工作队列，取出工作队列所有未完成的任务返回给调用者。与有序的shutdown()方法相比，**<code>shutdownNow()方法比较粗暴，直接中断工作线程</code>**。不过这里需要注意的是，中断线程并不代表线程立刻结束，只是通过工作线程的interrupt()实例方法设置了中断状态，这里需要用户程序主动配合线<br>程进行中断操作。</p><p><code>shutdownNow()</code>方法的源码大致如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检查状态</span></span><br><span class="line">        checkShutdownAccess(); <span class="comment">// 将线程池状态变为 STOP</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 中断所有线程，包括工作线程以及空闲线程</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 丢弃工作队列中的剩余任务</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="awaitTermination-方法的使用"><a href="#awaitTermination-方法的使用" class="headerlink" title="awaitTermination()方法的使用"></a>awaitTermination()方法的使用</h3><p>调用了线程池的shutdown()与shutdownNow()方法之后，用户程序都不会主动等待线程池关闭完成，<strong>如果需要等待线程池关闭完成，需要调用awaitTermination()进行主动等待</strong>。调用方法大致如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">threadPool.shutdown();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 一直等待，直到线程池完成关闭</span></span><br><span class="line">    <span class="keyword">while</span></span><br><span class="line">    (!threadPool.awaitTermination(<span class="number">60</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程池任务还未执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果线程池完成关闭，awaitTermination()方法将会返回true，否则当等待时间超过指定时间后将会返回false。如果需要调用awaitTermination()，<strong>建议不是永久等待，而是设置一定重试次数</strong>。<br>下面的代码参考了阿里巴巴著名的分布式框架Dubbo框架中线程池关闭源码中的部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!threadPool.isTerminated()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) <span class="comment">// 循环关闭1000次，每次等待10毫秒</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (threadPool.awaitTermination(<span class="number">10</span>,</span><br><span class="line">                    TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            threadPool.shutdownNow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        System.err.println(e.getMessage());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        System.err.println(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优雅地关闭线程池"><a href="#优雅地关闭线程池" class="headerlink" title="优雅地关闭线程池"></a>优雅地关闭线程池</h3><p>可以结合shutdown()、shutdownNow()、awaitTermination()三个方法优雅地关闭一个线程池，大致分为以下几步：</p><ol><li>执行shutdown()方法，拒绝新任务的提交，并等待所有任务有序地执行完毕。</li><li>执行awaitTermination(long timeout,TimeUnit unit)方法，指定超时时间，判断是否已经关闭所有任务，线程池关闭完成。</li><li>如果awaitTermination()方法返回false，或者被中断，就调用shutDownNow()方法立即关闭线程池所有任务。</li><li>补充执行awaitTermination(long timeout,TimeUnit unit)方法，判断线程池是否关闭完成。如果超时，就可以进入循环关闭，循环一定的次数（如1000次），不断关闭线程池，直到其关闭或者循环结束。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.fulsun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shutdownThreadPoolGracefully</span><span class="params">(ExecutorService threadPool)</span> &#123;</span><br><span class="line">        <span class="comment">// 若已经关闭则返回</span></span><br><span class="line">        <span class="keyword">if</span> (!(threadPool <span class="keyword">instanceof</span> ExecutorService) || threadPool.isTerminated()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            threadPool.shutdown(); <span class="comment">// 拒绝接受新任务</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待60秒，等待线程池中的任务完成执行</span></span><br><span class="line">            <span class="keyword">if</span> (!threadPool.awaitTermination(<span class="number">60</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                <span class="comment">// 调用 shutdownNow() 方法取消正在执行的任务</span></span><br><span class="line">                threadPool.shutdownNow();</span><br><span class="line">                <span class="comment">// 再次等待60秒，如果还未结束，可以再次尝试，或者直接放弃</span></span><br><span class="line">                <span class="keyword">if</span> (!threadPool.awaitTermination(<span class="number">60</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;线程池任务未正常执行结束&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">            <span class="comment">// 捕获异常，重新调用 shutdownNow() 方法</span></span><br><span class="line">            threadPool.shutdownNow();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 仍然没有关闭，循环关闭1000次，每次等待10毫秒</span></span><br><span class="line">        <span class="keyword">if</span> (!threadPool.isTerminated()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (threadPool.awaitTermination(<span class="number">10</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    threadPool.shutdownNow();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.err.println(e.getMessage());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                System.err.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="注册JVM钩子函数自动关闭线程池"><a href="#注册JVM钩子函数自动关闭线程池" class="headerlink" title="注册JVM钩子函数自动关闭线程池"></a>注册JVM钩子函数自动关闭线程池</h3><p>如果使用了线程池，可以在JVM中注册一个钩子函数，在JVM进程关闭之前，由钩子函数自动将线程池优雅地关闭，以确保资源正常释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SeqOrScheduledTargetThreadPoolLazyHolder</span> &#123;</span><br><span class="line">    <span class="comment">// 线程池：用于定时任务、顺序排队执行任务</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ScheduledThreadPoolExecutor</span> <span class="variable">EXECUTOR</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">CustomThreadFactory</span>(<span class="string">&quot;seq&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 注册JVM关闭时的钩子函数</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">ShutdownHookThread</span>(<span class="string">&quot;定时和顺序任务线程池&quot;</span>, (Callable&lt;Void&gt;) () -&gt; &#123;</span><br><span class="line">            <span class="comment">// 优雅地关闭线程池</span></span><br><span class="line">            shutdownThreadPoolGracefully(EXECUTOR);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Executors快捷创建线程池的潜在问题"><a href="#Executors快捷创建线程池的潜在问题" class="headerlink" title="Executors快捷创建线程池的潜在问题"></a>Executors快捷创建线程池的潜在问题</h2><p>在很多公司（如阿里、华为等）的编程规范中，非常明确地禁止使用Executors快捷创建线程池，为什么呢？这里从源码讲起，介绍使用Executors工厂方法快捷创建线程池将会面临的潜在问题。</p><h3 id="newFixedThreadPool-1"><a href="#newFixedThreadPool-1" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>使用Executors创建“固定数量的线程池”的潜在问题使用newFixedThreadPool工厂方法创建“固定数量的线程池”的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads, <span class="comment">// 核心线程数 最大线程数</span></span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="comment">// 线程最大空闲（Idle）时长 时间单位：毫秒</span></span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()); <span class="comment">//任务的排队队列，无界队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newFixedThreadPool工厂方法返回一个ThreadPoolExecutor实例，该线程池实例的corePoolSize数量为参数nThread，其maximumPoolSize数量也为参数nThread，其workQueue属性的值为<code>LinkedBlockingQueue&lt;Runnable&gt;()</code>无界阻塞队列。使用Executors创建“固定数量的线程池”的潜在问题主要存在于其workQueue上，其值为LinkedBlockingQueue（无界阻塞队列）。<strong>如</strong><br><strong>果任务提交速度持续大于任务处理速度，就会造成队列中大量的任务等待。如果队列很大，很有可能导致JVM出现OOM</strong>（Out Of Memory）异常，即内存资源耗尽.</p><h3 id="newSingleThreadExecutor-1"><a href="#newSingleThreadExecutor-1" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoShutdownDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(), <span class="comment">//无界队列</span></span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Executors创建的“单线程化线程池”与“固定大小的线程池”一样，其潜在问题仍然存在于其workQueue属性上，该属性的值为LinkedBlockingQueue（无界阻塞队列）。如果任务提交速度持续大于任务处理速度，就会造成队列大量阻塞。如果队列很大，很有可能导致JVM的OOM异常，甚至造成内存资源耗尽。</p><h3 id="newCachedThreadPool-1"><a href="#newCachedThreadPool-1" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码通过调用ThreadPoolExecutor标准构造器创建一个核心线程数为0、最大线程数不设限制的线程池。所以，理论上“可缓存线程池”可以拥有无数个工作线程，即线程数量几乎无限制。“可缓存线程池”的workQueue为SynchronousQueue同步队列，这个队列类似于一个接力棒，入队出队必须同时传递，正因为“可缓存线程池”可以无限制地创建线程，不会有任务等待，所以才使用SynchronousQueue。使用Executors创建的“可缓存线程池”的潜在<strong>问题存在于其最大线程数量不设上限</strong>。由于其maximumPoolSize的值为<code>Integer.MAX_VALU</code>E（非常大），可以认为可以无限创建线程，如果任务提交较多，就会造成大量的线程被启动，很有可能造成OOM异常，甚至导致CPU线程资源耗尽。</p><h3 id="newScheduledThreadPool-1"><a href="#newScheduledThreadPool-1" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Executors的newScheduledThreadPool工厂方法调用了ScheduledThreadPoolExecutor实现类的构造器，而ScheduledThreadPoolExecutor继承了ThreadPoolExecutor的普通线程池类，在其构造器内部进一步调用了该父类的构造器，具体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ScheduledThreadPoolExecutor#execute</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.ScheduledThreadPoolExecutor#execute</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    schedule(command, <span class="number">0</span>, NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// java.util.concurrent.ScheduledThreadPoolExecutor#schedule(java.lang.Runnable, long, java.util.concurrent.TimeUnit)</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                   <span class="type">long</span> delay,</span><br><span class="line">                                   TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span> || unit == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="literal">null</span>,</span><br><span class="line">                                      triggerTime(delay, unit),</span><br><span class="line">                                      sequencer.getAndIncrement()));</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.util.concurrent.ScheduledThreadPoolExecutor#delayedExecute</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">delayedExecute</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isShutdown())</span><br><span class="line">        reject(task);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="keyword">if</span> (!canRunInCurrentRunState(task) &amp;&amp; remove(task))</span><br><span class="line">            task.cancel(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.util.concurrent.ThreadPoolExecutor#ensurePrestart</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">ensurePrestart</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(ctl.get());</span><br><span class="line">    <span class="keyword">if</span> (wc &lt; corePoolSize)</span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wc == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码创建了一个ThreadPoolExecutor实例，其corePoolSize为传递来的参数，maximumPoolSize为Integer.MAX_VALUE，表示线程数不设上限，其workQueue为一个DelayedWorkQueue实例，这是一个按到期时间升序排序的阻塞队列。<del>使用Executors创建的“可缓存线程池”的潜在问题存在于其最大线程数量不设限上。由于其线程数量不设限，如果到期任务太多，就会导致CPU的线程资源耗尽</del>。</p><p>通过分析execute方法的源码ensurePrestart方法，线程最大只有corePoolsize个，不会创建过多的线程。虽然DelayedWorkQueue可以存储一些任务，如果任务提交速度持续大于任务处理速度，会造成workQueue队列中大量的任务等待。如果队列很大，很有可能导致JVM出现OOM异常，甚至造成内存资源耗尽。</p><h2 id="确定线程池的线程数"><a href="#确定线程池的线程数" class="headerlink" title="确定线程池的线程数"></a>确定线程池的线程数</h2><p>使用线程池的好处主要有以下三点：</p><ol><li>降低资源消耗：线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，通过重复利用已创建的线程可以降低线程创建和销毁造成的消耗。</li><li>提高响应速度：当任务到达时，可以不需要等待线程创建就能立即执行。</li><li>提高线程的可管理性：线程池提供了一种限制、管理资源的策略，维护一些基本的线程统计信息，如已完成任务的数量等。通过线程池可以对线程资源进行统一的分配、监控和调优。</li></ol><p>虽然使用线程池的好处很多，但是如果其线程数配置得不合理，不仅可能达不到预期效果，反而可能降低应用的性能</p><h3 id="按照任务类型对线程池进行分类"><a href="#按照任务类型对线程池进行分类" class="headerlink" title="按照任务类型对线程池进行分类"></a>按照任务类型对线程池进行分类</h3><p>使用标准构造器ThreadPoolExecutor创建线程池时，会涉及线程数的配置，而线程数的配置与异步任务类型是分不开的。这里将线程</p><p>池的异步任务大致分为以下三类：</p><ol><li>IO密集型任务<ul><li>此类任务主要是执行IO操作。由于执行IO操作的时间较长，导致CPU的利用率不高，这类任务CPU常处于空闲状态。Netty的IO读写操作为此类任务的典型例子。</li></ul></li><li>CPU密集型任务<ul><li>此类任务主要是执行计算任务。由于响应时间很快，CPU一直在运行，这种任务CPU的利用率很高。</li></ul></li><li>混合型任务<ul><li>此类任务既要执行逻辑计算，又要进行IO操作（如RPC调用、数据库访问）。相对来说，由于执行IO操作的耗时较长（一次网络往返往往在数百毫秒级别），这类任务的CPU利用率也不是太高。Web服务器的HTTP请求处理操作为此类任务的典型例子。</li></ul></li></ol><p>一般情况下，针对以上不同类型的异步任务需要创建不同类型的线程池，并进行针对性的参数配置。</p><h3 id="为IO密集型任务确定线程数"><a href="#为IO密集型任务确定线程数" class="headerlink" title="为IO密集型任务确定线程数"></a>为IO密集型任务确定线程数</h3><p>由于IO密集型任务的CPU使用率较低，导致线程空余时间很多，因此<strong>通常需要开CPU核心数两倍的线程</strong>。当IO线程空闲时，可以启用其他线程继续使用CPU，以提高CPU的使用率。<br>Netty的IO处理任务就是典型的IO密集型任务。所以，Netty的Reactor（反应器）实现类（定制版的线程池）的IO处理线程数默认正好为CPU核数的两倍，以下是其相关的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程版本Reactor实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MultithreadEventLoopGroup</span> <span class="keyword">extends</span> <span class="title class_">MultithreadEventExecutorGroup</span> <span class="keyword">implements</span> <span class="title class_">EventLoopGroup</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IO事件处理线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> DEFAULT_EVENT_LOOP_THREADS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IO事件处理线程数默认值为CPU核数的两倍</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">                SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.eventLoopThreads&quot;</span>,</span><br><span class="line"></span><br><span class="line">                        Runtime.getRuntime().availableProcessors() * <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">MultithreadEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory, Object... args)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为CPU密集型任务确定线程数"><a href="#为CPU密集型任务确定线程数" class="headerlink" title="为CPU密集型任务确定线程数"></a>为CPU密集型任务确定线程数</h3><p>CPU密集型任务也叫计算密集型任务，其特点是要进行大量计算而需要消耗CPU资源，比如计算圆周率、对视频进行高清解码等。CPU密集型任务虽然也可以并行完成，但是并行的任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以要最高效地利用CPU，<strong>CPU密集型任务并行执行的数量应当等于CPU的核心数</strong>。</p><p>比如4个核心的CPU，通过4个线程并行地执行4个CPU密集型任务，此时的效率是最高的。但是如果线程数远远超出CPU核心数量，就需要频繁地切换线程，线程上下文切换时需要消耗时间，反而会使得任务效率下降。因此，对于CPU密集型的任务来说，线程数等于CPU数就行。</p><h3 id="为混合型任务确定线程数"><a href="#为混合型任务确定线程数" class="headerlink" title="为混合型任务确定线程数"></a>为混合型任务确定线程数</h3><p>混合型任务既要执行逻辑计算，又要进行大量非CPU耗时操作（如RPC调用、数据库访问、网络通信等），所以混合型任务CPU的利用率不是太高，非CPU耗时往往是CPU耗时的数倍。比如在Web应用中处理HTTP请求时，一次请求处理会包括DB操作、RPC操作、缓存操作等多种耗时操作。一般来说，一次Web请求的CPU计算耗时往往较少，大致在100～500毫秒，而其他耗时操作会占用500～1000毫秒，甚至更多的时间。</p><p>在为混合型任务创建线程池时，如何确定线程数呢？业界有一个比较成熟的估算公式，具体如下：<code>最佳线程数 = ((线程等待时间+线程CPU时间) / 线程CPU时间) * CPU核数</code>,经过简单的换算，以上公式可进一步转换为：<code> 最佳线程数目 = (线程等待时间与线程CPU时间之比 + 1) * CPU核数</code></p><p>通过公式可以看出：等待时间所占的比例越高，需要的线程就越多；CPU耗时所占的比例越高，需要的线程就越少。下面举一个例子：比如在Web服务器处理HTTP请求时，假设平均线程CPU运行时间为100毫秒，而线程等待时间（比如包括DB操作、RPC操作、缓存操作等）为900毫秒，如果CPU核数为8，那么根据上面这个公式，估算如下：<code>(900毫秒 + 100毫秒) / 100毫秒 * 8 = 10 * 8 = 80</code></p><p>在使用如上代码创建混合型线程池时，建议按照前面的最佳线程数估算公式提前预估好线程数（如80），然后设置在环境变量<code>mixed.thread.amount</code>中，测试用例如下：</p><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CPU_MAX</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">IO_MAX</span> <span class="operator">=</span> <span class="number">2</span> * CPU_MAX; <span class="comment">// I/O密集型任务可以使用更大的线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MIXED_THREAD_AMOUNT</span> <span class="operator">=</span> <span class="string">&quot;mixed.thread.amount&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIXED_MAX</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 混合型任务的线程池单例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MixedTargetThreadPoolLazyHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">maxThreads</span> <span class="operator">=</span> Integer.parseInt(System.getProperty(MIXED_THREAD_AMOUNT, String.valueOf(MIXED_MAX)));</span><br><span class="line">            <span class="comment">// 创建一个可调整大小的线程池，根据任务的需求动态增加或减少线程。</span></span><br><span class="line">            executor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                Runtime.getRuntime().availableProcessors(),  <span class="comment">// 核心线程数</span></span><br><span class="line">                maxThreads,                               <span class="comment">// 最大线程数</span></span><br><span class="line">                <span class="number">60L</span>,                                      <span class="comment">// 空闲时间后核心线程的存活时间（秒）</span></span><br><span class="line">                TimeUnit.SECONDS,                         <span class="comment">// 时间单位</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">128</span>),            <span class="comment">// 队列大小，可根据需要调整</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()  <span class="comment">// 拒绝策略：主线程执行任务</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取混合型任务的线程池实例。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ExecutorService 线程池实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> ExecutorService <span class="title function_">getMixedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MixedTargetThreadPoolLazyHolder.executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取CPU密集型任务的线程池实例。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ExecutorService 线程池实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CpuIntensiveThreadPoolLazyHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">maxThreads</span> <span class="operator">=</span> CPU_MAX;</span><br><span class="line">            executor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                maxThreads,                                 <span class="comment">// 核心线程数</span></span><br><span class="line">                maxThreads,                                 <span class="comment">// 最大线程数，CPU密集型任务保持较小的线程池大小以减少资源消耗</span></span><br><span class="line">                <span class="number">60L</span>,                                        <span class="comment">// 空闲时间后核心线程的存活时间（秒）</span></span><br><span class="line">                TimeUnit.SECONDS,                           <span class="comment">// 时间单位</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">128</span>)              <span class="comment">// 队列大小，可根据需要调整</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">getCpuIntensiveThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CpuIntensiveThreadPoolLazyHolder.executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取I/O密集型任务的线程池实例。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ExecutorService 线程池实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">IoIntensiveThreadPoolLazyHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">maxThreads</span> <span class="operator">=</span> IO_MAX;</span><br><span class="line">            executor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">1</span>,                                          <span class="comment">// 核心线程数，保持较低的初始核心线程数以减少资源消耗</span></span><br><span class="line">                maxThreads,                                 <span class="comment">// 最大线程数，I/O密集型任务可以使用更大的线程池大小</span></span><br><span class="line">                <span class="number">60L</span>,                                        <span class="comment">// 空闲时间后核心线程的存活时间（秒）</span></span><br><span class="line">                TimeUnit.SECONDS,                           <span class="comment">// 时间单位</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">128</span>)              <span class="comment">// 队列大小，可根据需要调整</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">getIoIntensiveThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> IoIntensiveThreadPoolLazyHolder.executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭执行器，释放资源。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executor 要关闭的ExecutorService</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shutdownExecutor</span><span class="params">(ExecutorService executor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="literal">null</span> &amp;&amp; !executor.isShutdown()) &#123;</span><br><span class="line">            executor.shutdown();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 给出合理的等待时间让所有任务执行完毕，然后终止线程池。</span></span><br><span class="line">                <span class="keyword">if</span> (!executor.awaitTermination(<span class="number">60</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                    executor.shutdownNow(); <span class="comment">// 强制关闭</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                executor.shutdownNow();</span><br><span class="line">                Thread.currentThread().interrupt(); <span class="comment">// 恢复中断状态</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">mixedExecutor</span> <span class="operator">=</span> getMixedThreadPool();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">cpuExecutor</span> <span class="operator">=</span> getCpuIntensiveThreadPool();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">ioExecutor</span> <span class="operator">=</span> getIoIntensiveThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用线程池执行任务...</span></span><br><span class="line">        </span><br><span class="line">        shutdownExecutor(mixedExecutor);</span><br><span class="line">        shutdownExecutor(cpuExecutor);</span><br><span class="line">        shutdownExecutor(ioExecutor); <span class="comment">// 确保在适当的时候关闭执行器。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script>var description="文章介绍了线程池的一系列关键概念和一些常用的工具类方法和建议，这些可以帮助开发者更加方便地管理和优化他们的线程池配置。"</script>]]></content>
      
      
      <categories>
          
          <category> 多线程编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程编程基础</title>
      <link href="/p/5843451d.html"/>
      <url>/p/5843451d.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>在现代计算机系统中，多线程编程是一种常见的编程范式，它能够充分利用多核处理器的计算资源，提高程序的执行效率和响应速度。本文将详细介绍多线程编程的基础知识，包括进程与线程的概念、并发与并行的区别、Java线程模型等。</p><h2 id="进程与线程的概念"><a href="#进程与线程的概念" class="headerlink" title="进程与线程的概念"></a>进程与线程的概念</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是操作系统进行资源分配和程序运行的基本单位。它具有独立的地址空间、系统资源拥有者等特性。当用户运行一个程序时，操作系统会创建一个进程，并为它分配所需的资源，如内存空间、磁盘空间、I&#x2F;O设备等。进程是系统中的并发执行单位，它在操作系统中以独立的方式运行，拥有完整的运行环境。</p><ul><li>进程是操作系统对一个正在运行的程序的一种抽象结构。</li><li>进程是指在操作系统中能独立运行并作为资源分配的基本单位，<strong>由一组机器指令、数据和堆栈等组成的能独立运行的活动实体</strong>。</li><li>操作系统可以同时运行多个进程，多个进程直接可以并发执行和交换信息。</li><li>进程在运行是需要一定的资源，如CPU、存储空间和I&#x2F;O设备等。</li><li>Java编写的程序都运行在Java虚拟机（JVM）中，每当使用Java命令启动一个Java应用程序时，就会启动一个JVM进程。在这个JVM进程内部，所有Java程序代码都是以线程来运行的。JVM找到程序的入口点main()方法，然后运行main()方法，这样就产生了一个线程，这个线程被称为主线程。当main()方法结束后，主线程运行完成，JVM进程也随即退出。</li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是进程中最小的调度单元，它是CPU调度执行的最小单位。<strong>一个进程可以包含多个线程，这些线程共享进程的资源，如内存、文件句柄等</strong>。线程间的切换通常比进程间快得多，因为线程不需要像进程那样进行完整的上下文切换。线程的引入使得程序能够更加灵活地进行并发执行，提高了系统的响应速度和资源利用率。</p><ul><li><p>线程比进程更轻量</p></li><li><p>线程能独立运行，独立调度，拥有资源（一般是CPU资源，程序计数器等）</p></li><li><p>线程调度能大幅度减小调度的成本（相对于进程来说），线程的切换不会引起进程的切换</p></li><li><p>线程的引入进一步提高了操作系统的并发性，线程能并发执行</p></li><li><p>同一个进程的多个线程共享进程的资源（省去了资源调度现场保护的很多工作）</p></li></ul><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ul><li>协程是<strong>用户模式</strong>下的轻量级线程，操作系统内核对协程一无所知</li><li>协程的调度完全有应用程序来控制，操作系统不管这部分的调度</li><li>一个线程可以包含一个或多个协程</li><li>协程拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下纹和栈保存起来，在切换回来时恢复先前保运的寄存上下文和栈</li><li>协程能保留上一次调用时的状态，看到这里各种生成器（生成器是被阉割的协程）的概念浮现出来了。。</li><li>Windows下的实现叫纤程</li></ul><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>把管程放最后还加了一道分割线原因是管程跟上面的几个概念不是同一类东东，虽然长得很像，就像Car和Bar一样。</p><p>管程，字面意思，是<strong>用来管理进程的</strong>。所谓的<strong>管程实际上是定义的一种数据结构和控制进程的一些操作的集合。</strong></p><blockquote><p>临界资源的概念：</p></blockquote><ul><li><p>一次只允许一个进程访问的资源</p></li><li><p>多个进程只能互斥访问的资源</p></li></ul><p>临界资源的访问需要同步操作，比如信号量就是一种方便有效的进程同步机制。但信号量的方式要求每个访问临界资源的进程都具有wait和signal操作。这样使大量的同步操作分散在各个进程中，不仅给系统管理带来了麻烦，而且会因同步操作的使用不当导致死锁。管程就是为了解决这样的问题而产生的。</p><p>管程就是代表共享资源的数据结构以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序共同构成的一个操作系统的资源管理模块。管程被请求和释放临界资源的进程所调用，<strong>确保每次仅有一个进程使用该共享资源，这样就可以统一管理对共享资源的所有访问，实现临界资源互斥访问</strong>。</p><p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor，更常见的是直接将它称为“锁”）来实现的。<br>方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池中的方法表结构中的ACCSYNCHRONIZED访问标志得知一个方法是否被声明为<br>同步方法。当方法调用时，调用指令将会检查方法的ACCSYNCHRONIZED访问标志是否被设置，如果设置了，<strong>执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成</strong><br><strong>还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同</strong><br><strong>步方法所持有的管程将在异常抛到同步方法边界之外时自动释放</strong>。</p><h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><p>线程上下文切换就是因为某些原因导致 cpu 不再执行当前线程的指令流，转而执行另一个线程的指令流，原因一般如下：</p><ul><li>分配给该线程的当前的时间片刚好用完</li><li>jvm开启垃圾回收，停止所有用户线程</li><li>有更高优先级的线程待执行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li></ul><p>当线程上下文发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住所在线程的下一条 jvm 指令的执行地址，是线程私有的。如果 cpu 频繁的进行线程上下文切换，那么就会影响到程序的性能.</p><h3 id="线程的调度模型"><a href="#线程的调度模型" class="headerlink" title="线程的调度模型"></a>线程的调度模型</h3><p>目前主要分为两种调度模型：分时调度模型、抢占式调度模型</p><ul><li>分时调度模型： 平均分配CPU时间片，每个线程占有的CPU时间片长度一样，平均分配，一切平等</li><li>抢占式调度模型： 系统按照线程优先级分配CPU时间片。优先级高的线程，优先分配CPU时间片；如果所有的就绪线程的优先级相同，那么会随机选择一个；优先级高的线程获取的CPU时间片相对多一些。</li><li>由于目前大部分操作系统都是使用抢占式调度模型进行线程调度。Java的线程管理和调度是委托给了操作系统完成的，与之相对应，Java的线程调度也是使用抢占式调度模型。所以，Java的线程都有优先级。</li></ul><h3 id="线程越多越好？"><a href="#线程越多越好？" class="headerlink" title="线程越多越好？"></a>线程越多越好？</h3><ul><li>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活 </li><li>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的 有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分，也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义 </li><li>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化</li></ul><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化。</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>并发是指<strong>多个线程在同一CPU核心上面进行轮流切换的串行执行</strong>。操作系统中的任务调度器会将CPU的时间片分给不同的线程，使得多个线程在宏观上看起来像是同时执行的。并发的实现依赖于线程的快速切换和调度，它能够在单核CPU上提高程序的响应速度，使得多个任务能够交替执行，不至于一个任务长时间占用CPU资源。</p><blockquote><p>注意：单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活</p></blockquote><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>并行是指<strong>多个线程在多个CPU核心上同时执行</strong>。并行的实现需要多核CPU的支持，每个核心可以独立地执行一个线程。并行能够显著提高程序的执行效率，特别是在进行大规模计算或数据处理时，通过将任务分配到多个核心上并行执行，可以大幅减少程序的运行时间。</p><blockquote><p>注意：多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的。有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分（参考【阿姆达尔定律】）。也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</p></blockquote><h3 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h3><ul><li><strong>执行方式</strong>：并发是多个线程在单个CPU核心上轮流执行；并行是多个线程在多个CPU核心上同时执行。</li><li><strong>资源需求</strong>：并发不需要多核CPU，而并行需要多核CPU的支持。</li><li><strong>效率提升</strong>：并发主要用于提高程序的响应速度和资源利用率；并行主要用于提高程序的执行效率和计算能力。</li></ul><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>一个标准的线程主要由三部分组成，即线程描述信息、程序计数器（Program Counter，PC）和栈内存 在线程的结构中，栈内存是代码段中局部变量的存储空间，为线程所独立拥有，在线程之间不共享。在JDK 1.8中，每个线程在创建时默认被分配1MB的栈内存。</p><h3 id="通用的线程生命周期"><a href="#通用的线程生命周期" class="headerlink" title="通用的线程生命周期"></a>通用的线程生命周期</h3><blockquote><p>通用的线程生命周期基本上可以用下图这个“五态模型”来描述。这五态分别是：<code>初始状态</code>、<code>可运行状态</code>、<code>运行状态</code>、<code>休眠状态</code>和<code>终止状态</code>。</p></blockquote><ol><li>初始状态，指的是线程已经被创建，但是还不允许分配 CPU 执行。这个状态属于编程语言特有的，不过这里所谓的被创建，仅仅是在编程语言层面被创建，而在操作系统层面，真正的线程还没有创建。</li><li>可运行状态，指的是线程可以分配 CPU 执行。在这种状态下，真正的操作系统线程已经被成功创建了，所以可以分配 CPU 执行。</li><li>当有空闲的 CPU 时，操作系统会将其分配给一个处于可运行状态的线程，被分配到 CPU 的线程的状态就转换成了运行状态。</li><li>运行状态的线程如果调用一个阻塞的 API（例如以阻塞方式读文件）或者等待某个事件（例如条件变量），那么线程的状态就会转换到休眠状态，同时释放 CPU 使用权，休眠状态的线程永远没有机会获得 CPU 使用权。当等待的事件出现了，线程就会从休眠状态转换到可运行状态。</li><li>线程执行完或者出现异常就会进入终止状态，终止状态的线程不会切换到其他任何状态，进入终止状态也就意味着线程的生命周期结束了</li></ol><p><img src="/p/5843451d/0341e85e7a71d469e14b9881edafa6c4.jpg"></p><p>这<strong>五种状态在不同编程语言里会有简化合并</strong>。例如，C 语言的 POSIX Threads 规范，就把初始状态和可运行状态合并了；Java 语言里则把可运行状态和运行状态合并了，这两个状态在操作系统调度层面有用，而 JVM 层面不关心这两个状态，因为 JVM 把线程调度交给操作系统处理了。除了简化合并，这五种状态也有可能被细化，比如，Java 语言里就细化了休眠状态（这个下面我们会详细讲解）。</p><h3 id="Java-中线程的生命周期"><a href="#Java-中线程的生命周期" class="headerlink" title="Java 中线程的生命周期"></a>Java 中线程的生命周期</h3><ul><li><p>Java 语言中线程共有六种状态，分别是：</p><ul><li><strong>NEW（新建状态）</strong>：线程对象被创建后，但尚未启动时的状态。</li><li><strong>RUNNABLE（可运行状态）</strong>：线程正在JVM中执行时的状态，可能正在CPU上运行，也可能正在等待CPU时间片。</li><li><strong>BLOCKED（阻塞状态）</strong>：线程在等待获取一个被其他线程持有的锁时的状态。</li><li><strong>WAITING（等待状态）</strong>：线程在等待其他线程执行特定操作时的状态，如调用wait()方法。</li><li><strong>TIMED_WAITING（超时等待状态）</strong>：线程在等待其他线程执行特定操作，但等待时间有限时的状态，如调用sleep()方法。</li><li><strong>TERMINATED（终止状态）</strong>：线程执行完毕或因异常结束时的状态。</li></ul></li><li><p>这看上去挺复杂的，状态类型也比较多。但其实在操作系统层面，Java 线程中的 <code>BLOCKED</code>、<code>WAITING</code>、<code>TIMED_WAITING</code> 是一种状态，即前面我们提到的休眠状态。也就是说只要 Java 线程处于这三种状态之一，那么这个线程就永远没有 CPU 的使用权。</p></li><li><p>其中，<code>BLOCKED</code>、<code>WAITING</code>、<code>TIMED_WAITING </code>可以理解为线程导致休眠状态的三种原因。那具体是哪些情形会导致线程从 <code>RUNNABLE</code> 状态转换到这三种状态呢？而这三种状态又是何时转换回 <code>RUNNABLE</code> 的呢？以及 <code>NEW</code>、<code>TERMINATED</code> 和 <code>RUNNABLE</code> 状态是如何转换的？</p></li></ul><p><img src="/p/5843451d/ad73161bb865e3dcb5d52f31a794d3a4.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestState</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;  <span class="comment">// new 状态</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t2&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// runnable 状态</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t3&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t4&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (TestState.class) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000000</span>); <span class="comment">// timed_waiting 显示阻塞状态</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t5&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t2.join(); <span class="comment">// waiting 状态</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t5.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t6&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (TestState.class) &#123; <span class="comment">// 等待 t4 释放锁 blocked 状态</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t6.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;t1 state &quot;</span> + t1.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;t2 state &quot;</span> + t2.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;t3 state &quot;</span> + t3.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;t4 state &quot;</span> + t4.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;t5 state &quot;</span> + t5.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;t6 state &quot;</span> + t6.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">running...</span><br><span class="line">t1 state NEW</span><br><span class="line">t2 state RUNNABLE</span><br><span class="line">t3 state TERMINATED</span><br><span class="line">t4 state TIMED_WAITING</span><br><span class="line">t5 state WAITING</span><br><span class="line">t6 state BLOCKED</span><br></pre></td></tr></table></figure><h3 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h3><p><img src="/p/5843451d/fdcb8541e1ae3ac95c90624cafac1b89.png"></p><p>假设有线程 Thread t</p><ol><li><p>NEW &lt;–&gt; RUNNABLE</p><ul><li><code>t.start()</code>方法时，<code>NEW --&gt; RUNNABLE</code></li></ul></li><li><p>RUNNABLE &lt;–&gt; WAITING</p><ul><li>t 线程进入<code>synchronized(obj)</code>获取了对象锁后，调用<code>obj.wait()</code>方法时，t 线程进入 waitSet 中，从<code>RUNNABLE --&gt; WAITING</code></li><li>调用 <code>obj.notify()</code>，<code>obj.notifyAll()</code>，<code>t.interrupt()</code> 时，唤醒的线程都到 entrySet 阻塞队列和其他线程进行锁的竞争<ul><li><strong>竞争锁成功</strong>，t 线程从 <code>WAITING --&gt; RUNNABLE</code></li><li><strong>竞争锁失败</strong>，t 线程从 <code>WAITING --&gt; BLOCKED</code></li></ul></li></ul></li><li><p>RUNNABLE &lt;–&gt; WAITING</p><ul><li><strong>当前线程</strong>调用 <code>t.join()</code>方法时，<strong>当前线程</strong>从 <code>RUNNABLE --&gt; WAITING</code> <ul><li>注意是<code>当前线程在 t 线程对象在 waitSet 上等待</code></li></ul></li><li>t 线程运行结束，或调用了当前线程的 <code>interrupt()</code> 时，当前线程从 <code>WAITING --&gt; RUNNABLE</code></li></ul></li><li><p>RUNNABLE &lt;–&gt; WAITING</p><ul><li>当前线程调用<code>LockSupport.park()</code>方法会让当前线程从<code>RUNNABLE --&gt; WAITING</code></li><li>调用 <code>LockSupport.unpark（目标线程）</code>或调用了线程 的 <code>interrupt()</code> ，会让目标线程从 <code>WAITING --&gt; RUNNABLE</code></li></ul></li><li><p>RUNNABLE &lt;–&gt; TIMED_WAITING （带超时时间的 wait)</p><ul><li><p>t 线程进入<code>synchronized(obj)</code>获取了对象锁后，调用<code>obj.wait(long n)</code>方法时，t 线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></p></li><li><p>t 线程等待时间超过了 n 毫秒，或调用 <code>obj.notify()</code> ， <code>obj.notifyAll()</code> ， <code>t.interrupt()</code>时；, 唤醒的线程都到 entrySet 阻塞队列和其他线程进行锁的竞争</p><ul><li>竞争锁成功，t 线程从<code>TIMED_WAITING --&gt; RUNNABLE</code></li><li>竞争锁失败，t 线程从<code>TIMED_WAITING --&gt; BLOCKED</code></li></ul></li></ul></li><li><p>RUNNABLE &lt;–&gt; TIMED_WAITING</p><ul><li>当前线程调用<code>t.join(long n)</code> 方法时，当前线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code> <ul><li>注意是<code>当前线程在 t 线程对象在 waitSet 上等待</code></li></ul></li><li>当前线程等待时间超过了 n 毫秒，或 t 线程运行结束，或调用了当前线程的 <code>interrupt()</code> 时，当前线程从 <code>TIMED_WAITING --&gt; RUNNABLE</code></li></ul></li><li><p>RUNNABLE &lt;–&gt; TIMED_WAITING</p><ul><li>当前线程调用 <code>Thread.sleep(long n)</code> ，当前线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li><li>当前线程等待时间超过了 n 毫秒或调用了线程的 <code>interrupt()</code>，当前线程从 <code>TIMED_WAITING --&gt; RUNNABLE</code></li></ul></li><li><p>RUNNABLE &lt;–&gt; TIMED_WAITING</p><ul><li>当前线程调用 <code>LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis)</code> 时，当前线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li><li>调用<code>LockSupport.unpark（目标线程） 或调用了线程 的 interrupt()</code> ，或是等待超时，会让目标线程从 <code>TIMED_WAITING--&gt; RUNNABLE</code></li></ul></li><li><p>RUNNABLE &lt;–&gt; BLOCKED</p><ul><li>t 线程用<code> synchronized(obj)</code> 获取了对象锁时如果<code>竞争失败</code>，从 <code>RUNNABLE –&gt; BLOCKED</code>\</li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争<ul><li>如果其中 t 线程竞争成功，从 BLOCKED –&gt; RUNNABLE ，</li><li>其它失败的线程仍然 BLOCKED</li></ul></li></ul></li><li><p>RUNNABLE &lt;–&gt; TERMINATED</p><ul><li>当前线程所有代码运行完毕，进入 TERMINATED</li></ul></li></ol><h2 id="Java中的线程实现方式"><a href="#Java中的线程实现方式" class="headerlink" title="Java中的线程实现方式"></a>Java中的线程实现方式</h2><p>Java提供了多种方式来实现线程，主要包括以下三种：</p><ol><li>第一种是继承Thread类</li><li>第二中是实现Runnable接</li><li>第三种则是使用FutureTask类</li></ol><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><ul><li><p><strong>继承Thread类</strong>：通过继承Thread类并重写run()方法来实现线程。这种方式简单直接，但缺点是线程类不能继承其他类，因为Java不支持多继承。</p><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><ul><li><p><strong>实现Runnable接口</strong>：通过实现Runnable接口并实现run()方法来实现线程。这种方式更加灵活，允许线程类继承其他类，并且更容易与线程池等高级API配合使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过阅读Runnable接口的源码，可以看到是一个函数式接口，因此可以使用Lambda表达式简化过程。</span></span><br></pre></td></tr></table></figure></li><li><p>缺点:</p><ul><li><p>不能获取异步执行目标的结果</p></li><li><p>不能取消异步执行的任务</p></li><li><p>解决方案可使用 Future接口和 FutureTask类型可以进行管理的异步任务类</p></li></ul></li></ul><h3 id="FutureTask类"><a href="#FutureTask类" class="headerlink" title="FutureTask类"></a>FutureTask类</h3><ul><li><p><strong>使用FutureTask类</strong>：FutureTask类实现了Runnable和Future接口，可以用于创建有返回值的线程任务。这种方式适用于需要获取线程执行结果的场景。</p><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 线程执行的代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>; <span class="comment">// 返回值</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> task.get(); <span class="comment">// 获取线程执行结果</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="通过线程池创建线程"><a href="#通过线程池创建线程" class="headerlink" title="通过线程池创建线程"></a>通过线程池创建线程</h3><p>Thread实例在执行完成之后都销毁了，这些线程实例都是不可复用的。实际上创建一个线程实例在时间成本、资源耗费上都很高（稍后会介绍），在高并发的场景中，断然不<br>能频繁进行线程实例的创建与销毁，而是需要对已经创建好的<strong>线程实例进行复用</strong>，这就涉及线程池的技术。</p><ul><li>submit()方法在提交异步target执行目标之后会返回Future异步任务实例，以便对target的异步执行过程进行控制，比如取消执行、获取结果等。</li><li>execute()没有任何返回，target执行目标实例在执行之后没有办法对其异步执行过程进行控制，只能任其执行，直到其执行结束。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个包含三个线程的线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span>  Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法一：执行一个 Runnable类型的target执行目标实例，无返回</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line"><span class="comment">//方法二：提交一个 Callable类型的target执行目标实例, 返回一个</span></span><br><span class="line">Future异步任务实例</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"><span class="comment">//方法三：提交一个 Runnable类型的target执行目标实例, 返回一个</span></span><br><span class="line">Future异步任务实例</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure><h2 id="查看线程"><a href="#查看线程" class="headerlink" title="查看线程"></a>查看线程</h2><h3 id="系统命令方式"><a href="#系统命令方式" class="headerlink" title="系统命令方式"></a>系统命令方式</h3><ul><li>Windows <ul><li>任务管理器可以查看进程和线程数，也可以用来杀死进程 </li><li><code>tasklist</code> 查看进程 </li><li><code>taskkill</code> 杀死进程 <ul><li><code>/F</code>: 强行终止</li><li><code>/T</code>: 终止进程和它的子进程 ，</li><li><code>/PID processID</code> 指定进程的 pid</li></ul></li></ul></li><li>linux <ul><li><code>ps -fe</code>查看所有进程 </li><li><code>ps -fT -p </code> 查看某个进程（PID）的所有线程 </li><li><code>kill</code> 杀死进程 </li><li><code>top</code> 按大写 H 切换是否显示线程 </li><li><code>top -H -p </code> 查看某个进程（PID）的所有线程</li></ul></li><li>Java <ul><li><code>jps</code> 命令查看所有 Java 进程</li><li><code>jstack</code>  查看某个 Java 进程（PID）的所有线程状态 </li><li><code>jconsole</code> 来查看某个 Java 进程中线程的运行情况（图形界面）</li></ul></li></ul><h3 id="jconsole-监控"><a href="#jconsole-监控" class="headerlink" title="jconsole 监控"></a>jconsole 监控</h3><ul><li><p>对于服务器上的 jar 包，需要开启远程连接，以如下方式运行你的 java 类</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.rmi.server.hostname=`ip 地址` -Dcom.sun.management.jmxremote -</span><br><span class="line">Dcom.sun.management.jmxremote.port=`连接端口` -Dcom.sun.management.jmxremote.ssl=是否安全连接 -</span><br><span class="line">Dcom.sun.management.jmxremote.authenticate=是否认证 java 类</span><br></pre></td></tr></table></figure></li><li><p>修改 &#x2F;etc&#x2F;hosts 文件将 127.0.0.1 映射至主机名 </p></li><li><p>如果要认证访问，还需要做如下步骤 </p><ul><li>复制 jmxremote.password 文件，修改 jmxremote.password 和 jmxremote.access 文件的权限为 600, 即文件所有者可读写 </li><li>连接时填入 controlRole（用户名），R&amp;D（密码）</li></ul></li></ul><h3 id="Jstack工具"><a href="#Jstack工具" class="headerlink" title="Jstack工具"></a>Jstack工具</h3><p>Jstack命令的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack &lt;pid&gt; <span class="comment">//pid表示Java进程id，可以用jps命令查看</span></span><br></pre></td></tr></table></figure><p>一般情况下，通过Jstack输出的线程信息主要包括：JVM线程、用户线程等。其中，JVM线程在JVM启动时就存在，主要用于执行譬如垃圾回收、低内存的检测等后台任务，这些线程往往在JVM初始化的时候<br>就存在。而用户线程则是在程序创建了新的线程时才会生成。这里需要注意的是：</p><ul><li>在实际运行中，往往一次DUMP的信息不足以确认问题。建议产生三次DUMP信息，如果每次DUMP都指向同一个问题，我们才能确定问题的典型性。</li><li>不同的Java虚拟机的线程导出来的DUMP信息格式是不一样的，并且同一个JVM的不同版本，DUMP信息也有差别。</li></ul><blockquote><p>Jstack指令所输出的信息中包含以下重要信息：</p></blockquote><ol><li>tid：线程实例在JVM进程中的id。</li><li>nid：线程实例在操作系统中对应的底层线程的线程id。</li><li>prio：线程实例在JVM进程中的优先级。</li><li>os_prio：线程实例在操作系统中对应的底层线程的优先级。</li><li>线程状态：如runnable、waiting on condition等。</li><li>用户线程往往是执行业务逻辑的线程，是大家所关注的重点，也是最容易产生死锁的地方。接下来会用Jstack命令来分析用户线程的WAITING、BLOCKED两种状态。</li></ol><h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><h3 id="常用方法概述"><a href="#常用方法概述" class="headerlink" title="常用方法概述"></a>常用方法概述</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">start() </span><br><span class="line"><span class="comment"># 启动一个新线程，在新的线程运行run方法, start方法只是让线程进入就绪，里面代码不一定立刻运行（CPU的时间片还没分给它）。每个线程对象的start方法只能调用一次，如果调用了多次会出现IllegalThreadStateException</span></span><br><span class="line"></span><br><span class="line">run()</span><br><span class="line"><span class="comment"># 新线程启动后会调用的方法， 如果在构造Thread对象时传递了Runnable参数，则线程启动后会调用Runnable中的run方法，否则默认不执行任何操作。但可以创建Thread的子类对象，来覆盖默认行为</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">join</span>()</span><br><span class="line"><span class="comment"># 等待线程运行结束</span></span><br><span class="line"><span class="built_in">join</span>(long n)</span><br><span class="line"><span class="comment"># 等待线程运行结束,最多等待n亳秒</span></span><br><span class="line"></span><br><span class="line">getId()</span><br><span class="line"><span class="comment"># 获取线程长整型的id, id唯一</span></span><br><span class="line"></span><br><span class="line">getName()</span><br><span class="line"><span class="comment"># 获取线程名</span></span><br><span class="line"></span><br><span class="line">setName(String)</span><br><span class="line"><span class="comment"># 修改线程名</span></span><br><span class="line"></span><br><span class="line">getPriority</span><br><span class="line"><span class="comment"># 获取线程优先级,java中规定线程优先级是1~10的整数，较大的优先级能提高该线程被CPU调度的机率</span></span><br><span class="line">setPriority(int)</span><br><span class="line"><span class="comment"># 修改线程优先级</span></span><br><span class="line"></span><br><span class="line">getState()</span><br><span class="line"><span class="comment"># 获取线程状态,Java中线程状态是用6个enum表示，分别为：NEW,RUNNABLE,BLOCKED,WAITING,TIMED_WAITING,TERMINATED</span></span><br><span class="line"></span><br><span class="line">isAlive()</span><br><span class="line"><span class="comment"># 线程是否存活（还没有运行完毕）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interrupt()</span><br><span class="line"><span class="comment"># 打断线程, 如果打断的断线程正在sleep，wait，join会导致被打断的线程抛出InterruptedException，并清除打断标记；park的线程被打断，也会设置打断标记</span></span><br><span class="line">isInterrupted()</span><br><span class="line"><span class="comment"># 判断是否被打断，不会清除打断标记</span></span><br><span class="line">static interrupted()</span><br><span class="line"><span class="comment"># 判断当前线程是否被打断，会清除打断标记</span></span><br><span class="line"></span><br><span class="line">static <span class="built_in">sleep</span>(long n)</span><br><span class="line"><span class="comment"># 让当前执行的线程休眠 n 毫秒，休眠时让出cpu的时间片给其他线程</span></span><br><span class="line"></span><br><span class="line">static yeild() </span><br><span class="line"><span class="comment"># 提示线程调度器让出当前线程对cpu的使用</span></span><br><span class="line"></span><br><span class="line">static currentThread()</span><br><span class="line"><span class="comment"># 获取当前正在执行的线程</span></span><br><span class="line"></span><br><span class="line">不推荐的方法,容易破坏同步代码块，造成线程死锁</span><br><span class="line">stop </span><br><span class="line"><span class="built_in">suspend</span></span><br><span class="line">resume</span><br></pre></td></tr></table></figure><h3 id="线程名称的设置和获取"><a href="#线程名称的设置和获取" class="headerlink" title="线程名称的设置和获取"></a>线程名称的设置和获取</h3><p>在Thread类中可以通过构造器<code>Thread(…)初始化</code>设置线程名称，也可以通过<code>setName(…)</code>实例方法设置线程名称，取得线程名称可以通过<code>getName()</code>方法完成。关于线程名称有以下几个要点：</p><ol><li>线程名称一般在启动线程前设置，但也允许为运行的线程设置名称。</li><li>允许两个Thread对象有相同的名称，但是应该避免。</li><li>如果程序没有为线程指定名称，系统会自动为线程设置名称。<code>Thread-加上自动编号的形式</code>进行自动命名，如Thread-0、Thread-1等。</li></ol><p>一个简单的线程名称操作实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(target).start(); <span class="comment">// 系统自动设置线程名称</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(target, <span class="string">&quot;手动命名线程-A&quot;</span>).start();<span class="comment">// 手动设置线程名称</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(target, <span class="string">&quot;手动命名线程-B&quot;</span>).start();<span class="comment">// 手动设置线程名称</span></span><br></pre></td></tr></table></figure><h3 id="start-与-run"><a href="#start-与-run" class="headerlink" title="start 与 run"></a>start 与 run</h3><ul><li><p>start是让线程进入就绪，里面代码不一定立刻运行（CPU 的时间片还没分给它）。每个线程对象的 start 方法只能调用一次，如果调用了多次会出现 illegalThreadStateException。</p></li><li><p>而 run 则是新线程启动后会调用的方法，如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的 run 方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象，来覆盖默认行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;我是一个新建的线程正在运行中&quot;</span>);</span><br><span class="line">            FileReader.read(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread.setName(<span class="string">&quot;新建线程&quot;</span>);</span><br><span class="line">    <span class="comment">// thread.start();</span></span><br><span class="line">    thread.run();</span><br><span class="line">    log.debug(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11:59:40.711 [main] DEBUG com.concurrent.test.Test4 - 主线程</span><br><span class="line">11:59:40.711 [新建线程] DEBUG com.concurrent.test.Test4 - 我是一个新建的线程正在运行中</span><br><span class="line">11:59:40.732 [新建线程] DEBUG com.concurrent.test.FileReader - <span class="built_in">read</span> [<span class="built_in">test</span>] start ...</span><br><span class="line">11:59:40.735 [新建线程] DEBUG com.concurrent.test.FileReader - <span class="built_in">read</span> [<span class="built_in">test</span>] end ... cost: 3 ms</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">12:03:46.711 [main] DEBUG com.concurrent.test.Test4 - 我是一个新建的线程正在运行中</span><br><span class="line">12:03:46.727 [main] DEBUG com.concurrent.test.FileReader - <span class="built_in">read</span> [<span class="built_in">test</span>] start ...</span><br><span class="line">12:03:46.729 [main] DEBUG com.concurrent.test.FileReader - <span class="built_in">read</span> [<span class="built_in">test</span>] end ... cost: 2 ms</span><br><span class="line">12:03:46.730 [main] DEBUG com.concurrent.test.Test4 - 主线程</span><br></pre></td></tr></table></figure></li><li><p>只有当调用start方法的时候才是我们创建的Thread类对象t1去执行run方法的代码，但是如果直接调用run方法，则是调用这个方法的线程（即Main线程）直接去执行run方法里面的代码。</p><ul><li><strong>直接调用 run 是在主线程中执行了 run，没有启动新的线程</strong> </li><li>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</li></ul></li></ul><h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><ul><li><p>wait 方法是属于 <strong>Object</strong> 类中的，wait 过程中线程会释放对象锁，只有当其他线程调用 notify 才能唤醒此线程。</p></li><li><p><code>wait 使用时必须先获取对象锁，即必须在 synchronized 修饰的代码块中使用，那么相应的 notify 方法同样必须在 synchronized 修饰的代码块中使用</code>，如果没有在 synchronized 修饰的代码块中使用时运行时会抛出 IllegalMonitorStateException 的异常</p></li><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1 start&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                obj.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1 end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        obj.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li></li></ul><h3 id="sleep-与-yield"><a href="#sleep-与-yield" class="headerlink" title="sleep 与 yield"></a>sleep 与 yield</h3><ul><li><p>调用 sleep 会让当前线程从 <code>Running</code> 进入 <code>Timed Waiting</code> 状态（阻塞）  </p></li><li><p>其它线程可以使用 <code>interrupt 方法打断</code>正在睡眠的线程，这时 sleep 方法会<code>抛出 InterruptedException </code> </p></li><li><p>睡眠结束后的线程未必会立刻得到执行（需要分配到 cpu 时间片） </p></li><li><p>建议用 <code>TimeUnit.sleep()</code> 代替 Thread 的 sleep 来获得更好的可读性 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">//线程睡眠3s</span></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TimeUnit</span></span><br><span class="line">TimeUnit.DAYS.sleep(<span class="number">1</span>);<span class="comment">//天</span></span><br><span class="line">TimeUnit.HOURS.sleep(<span class="number">1</span>);<span class="comment">//小时</span></span><br><span class="line">TimeUnit.MINUTES.sleep(<span class="number">1</span>);<span class="comment">//分</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);<span class="comment">//秒</span></span><br><span class="line">TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);<span class="comment">//毫秒</span></span><br><span class="line">TimeUnit.MICROSECONDS.sleep(<span class="number">1000</span>);<span class="comment">//微妙</span></span><br><span class="line">TimeUnit.NANOSECONDS.sleep(<span class="number">1000</span>);<span class="comment">//纳秒</span></span><br></pre></td></tr></table></figure></li><li><p>调用 yield 会让当前线程从 <code>Running</code> 进入 <code>Runnable</code> 就绪状态，然后调度执行其它线程, yield不能保证使得当前正在运行的线程迅速转换到就绪状态。</p></li><li><p>即使完成了迅速切换，系统通过线程调度机制从所有就绪线程中挑选下一个执行线程时，就绪的线程有可能被选中，也有可能不被选中，其调度的过程受到其他因素（如优先级）的影响。具体的实现依赖于操作系统的任务调度器；而 sleep 需要等过了休眠时间之后才有可能被分配 cpu 时间片</p></li></ul><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><ul><li>Java中线程优先级可以指定，范围是 1~10。但是并不是所有的操作系统都支持10级优先级的划分（比如有些操作系统只支持3级划分：低，中，高），Java只是给操作系统一个优先级的参考值，<strong>线程最终在操作系统的优先级是多少还是由操作系统决定</strong>。</li><li>Java默认的线程优先级为5，线程的执行顺序由调度程序来决定，线程的优先级会在线程被调用之前设定。通常情况下，高优先级的线程将会比低优先级的线程有更高的几率得到执行。我们使用方法Thread类setPriority()实例方法来设定线程的优先级。</li><li>说明：<ul><li>线程优先级会<code>提示（hint）调度器</code>优先调度该线程，但它仅仅是一个提示，调度器可以忽略它 </li><li>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task1</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----&gt;1 &quot;</span> + count++);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// Thread.yield();</span></span><br><span class="line">        System.out.println(<span class="string">&quot; ----&gt;2 &quot;</span> + count++);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task1, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task2, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t1.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">    t2.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">----&gt;<span class="number">1</span> <span class="number">6307</span></span><br><span class="line">----&gt;<span class="number">2</span> <span class="number">9016</span></span><br></pre></td></tr></table></figure><h3 id="join-方法"><a href="#join-方法" class="headerlink" title="join 方法"></a>join 方法</h3><ul><li><p>join方法的作用是<strong>在当前线程等待其它线程运行结束再运行该线程</strong>，即同步,在<code>主线程</code>中调用<code>t1.join</code>，则<code>主线程</code>会<code>等待 t1 线程执行完之后</code>再<code>继续执行</code></p></li><li><p>分析下面代码, 可以看到打印的结果是0，而不是10，分析如下：首先，线程t1和main线程是并行执行的，t1线程需要1s后才能计算出r&#x3D;10，但是main线程是立刻就需要打印r的值，因此打印出来的r还是原来的0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">            r = <span class="number">10</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        log.debug(<span class="string">&quot;结果为:&#123;&#125;&quot;</span>, r);</span><br><span class="line">        log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果要让r打印的值变成10</p><ul><li><p>我们可以使用sleep方法，让main线程sleep的时间长于t1线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1.start();</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">log.debug(<span class="string">&quot;结果为:&#123;&#125;&quot;</span>, r);</span><br></pre></td></tr></table></figure></li><li><p>sleep的方法明显有点硬编码的意思，不够灵活，这时候join方法就有用处了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t1.start();</span><br><span class="line"><span class="comment">//在main线程中等待t1线程的结束才继续执行main线程的代码</span></span><br><span class="line">t1.join();</span><br><span class="line">t1.join(<span class="number">2000</span>);</span><br><span class="line">log.debug(<span class="string">&quot;结果为:&#123;&#125;&quot;</span>, r);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="interrupt-方法"><a href="#interrupt-方法" class="headerlink" title="interrupt 方法"></a>interrupt 方法</h3><ul><li><p>interrupt方法是打断线程的方法，但是关于打断的线程，需要分情况而论：</p><ul><li>如果是打断正在sleep、wait、join的线程则会抛出 InterruptedException 异常，并且打断标志置不会返回true，而是返回false</li><li>如果打断的是正常运行的线程，该线程的打断标记会置为true，但是不会去停止被打断的线程，只是告诉它我想要打断，要真正打断还是需要它自己去停止自己，即给它处理后事的机会</li></ul></li><li><p>优雅地终止线程</p><ul><li><p>可以调用Thread类的isInterrupted方法获取线程打断标志程：</p></li><li><p>两阶段终止模式: 它将终止过程分成两个阶段，第一阶段由线程T1向线程T2发送终止指令，第二阶段是由线程T2响应终止指令。这种模式通过将停止线程这个动作分解为准备阶段和执行阶段这两个阶段，提供了一种通用的用于优雅地停止线程的方法！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 并发设计模式-两阶段终止模式-interrupt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">TwoStageTermination</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TwoStageTermination</span>();</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        t1.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TwoStageTermination</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread monitor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        monitor = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="comment">// 根据打断标记，退出循环，线程结束</span></span><br><span class="line">                <span class="comment">// isInterrupted() 获取打断标记的状态，不会清除打断标记</span></span><br><span class="line">                <span class="keyword">if</span>(currentThread.isInterrupted())&#123;   </span><br><span class="line">                    System.out.println(<span class="string">&quot;打断标记：true, 线程退出！&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 情况一：睡眠中打断,抛出InterruptedException异常，唤醒线程，清除打断标记：false,需要手动重置打断标记为true</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">                    <span class="comment">// 情况二：线程正常运行，打断后，线程不会自动停止，打断标记置为：true，用打断标记写if判断</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程运行中···&quot;</span>); </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">// 再次打断：重置打断标记为true,使得循环退出</span></span><br><span class="line">                    currentThread.interrupt(); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打断线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        monitor.interrupt();   <span class="comment">// interrupt() 打断线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><ul><li><p>setDaemon 方法</p><ul><li><code>public final void setDaemon(boolean on)</code>，默认 false.</li><li>将该线程标记为守护线程或用户线程。</li></ul></li><li><p>默认情况下，java 进程需要等待所有的线程结束后才会停止，但是有一种特殊的线程，叫做守护线程，在其他线程全部结束的时候即使守护线程还未结束代码未执行完 java 进程也会停止。</p></li><li><p>注意要点：</p><ul><li>该方法必须在启动线程前调用。<code>t1.setDeamon(true);</code>,启动之后不能再将用户线程设置为守护线程，否则JVM会抛出一个InterruptedException异常。</li><li>如果线程全部是守护线程，那么 jvm 就停止。</li><li>守护线程创建的线程也是守护线程。在创建之后，如果通过调用setDaemon(false)将新的线程显式地设置为用户线程，新的线程可以调整成用户线程。</li></ul></li><li><p>如：Java 垃圾回收线程就是一个典型的守护线程；</p></li><li><p>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</p></li></ul><h3 id="sleep，yiled，wait，join-对比"><a href="#sleep，yiled，wait，join-对比" class="headerlink" title="sleep，yiled，wait，join 对比"></a>sleep，yiled，wait，join 对比</h3><ul><li><p>sleep，join，yield，interrupted 是 Thread 类中的方法</p></li><li><p>wait&#x2F;notify 是 object 中的方法</p></li><li><p>sleep 不释放锁、释放 cpu</p></li><li><p>yiled 不释放锁、释放 cpu</p></li><li><p>join 释放锁、抢占 cpu</p></li><li><p>wait 释放锁、释放 cpu</p></li><li><p>参考</p><ul><li><p>关于 join 的原理和这几个方法的对比：<a href="https://blog.csdn.net/dataiyangu/article/details/104956755">Join() 会不会释放锁？<em>A Short Life-CSDN 博客</em> join 释放锁吗</a></p></li><li><p>join 底层使用的 wait，synchronized(this), 锁的是 thread 对象，调用 join 方法会让调用者进入等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// join 核心</span></span><br><span class="line"><span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;  <span class="comment">//由于上一步传入参数为 0，因此调用当前判断</span></span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123; <span class="comment">//判断子线程是否存活</span></span><br><span class="line">        wait(<span class="number">0</span>); <span class="comment">//调用 wait(0) 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>多线程编程是现代软件开发中不可或缺的一部分，它能够充分利用多核处理器的计算资源，提高程序的执行效率和响应速度。掌握多线程编程的基础知识，如进程与线程的概念、并发与并行的区别、Java线程模型等，对于编写高效、可靠的并发程序至关重要。在实际开发中，还需要根据具体的应用场景和需求，合理地设计和使用多线程技术，以达到最佳的性能和效果。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV16J411h7Rd">黑马程序员全面深入学习 Java 并发编程，JUC 并发编程全套教程</a></p><p><a href="https://blog.csdn.net/m0_37989980/article/details/111460733">学习 Java 并发编程</a></p><p><a href="https://www.yuque.com/gaohanghang/sgrbwh/wng754">全面深入学习 java 并发编程 · 语雀 (yuque.com)</a></p><p><a href="https://gitee.com/gu_chun_bo/java-construct/tree/master">java-construct</a></p><p><a href="https://www.cnblogs.com/noteless/p/10372826.html#0">interrupt() 方法的相关知识</a></p><script>var description="这篇文章详细介绍了进程与线程的基础知识以及Java中的多线程编程相关概念和技术细节。"</script>]]></content>
      
      
      <categories>
          
          <category> 多线程编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态修改日志级别</title>
      <link href="/p/8872e19a.html"/>
      <url>/p/8872e19a.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>在 Logback 中，除了通过 JMX 动态修改日志级别外，还可以通过编程方式动态调整日志级别，而不依赖 JMX。这种方式在某些场景下更加灵活，例如从 REST 接口、配置文件或命令行参数中动态修改日志级别。</p><h2 id="LoggerContext修改日志级别"><a href="#LoggerContext修改日志级别" class="headerlink" title="LoggerContext修改日志级别"></a>LoggerContext修改日志级别</h2><p><code>LoggerContext</code> 是 Logback 的核心组件，提供了对日志记录器和配置的直接控制。可以通过 <code>LoggerContext</code> 修改某个日志记录器的级别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.Level;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.Logger;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.LoggerContext;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicLogLevelExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 LoggerContext</span></span><br><span class="line">        <span class="type">LoggerContext</span> <span class="variable">context</span> <span class="operator">=</span> (LoggerContext) LoggerFactory.getILoggerFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取目标 Logger</span></span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> context.getLogger(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印当前日志级别</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Current Log Level: &quot;</span> + logger.getLevel());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态修改日志级别为 DEBUG</span></span><br><span class="line">        logger.setLevel(Level.DEBUG);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印修改后的日志级别</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Updated Log Level: &quot;</span> + logger.getLevel());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试日志输出</span></span><br><span class="line">        logger.info(<span class="string">&quot;This is an INFO message&quot;</span>);</span><br><span class="line">        logger.debug(<span class="string">&quot;This is a DEBUG message&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="配置文件动态加载日志级别"><a href="#配置文件动态加载日志级别" class="headerlink" title="配置文件动态加载日志级别"></a>配置文件动态加载日志级别</h2><p>可以监控外部配置文件的变化，并动态更新日志级别。例如，使用 Logback 的 <code>ConfigurationAction</code> 类来重新加载配置。</p><p>在 Logback 配置中启用自动重载，通过编辑配置文件中的日志级别，Logback 会在下次扫描时自动加载更新。</p><ul><li><code>scan=&quot;true&quot;</code>：启用配置文件监控。</li><li><code>scanPeriod=&quot;30 seconds&quot;</code>：每 30 秒检查一次配置文件的变化。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">&quot;true&quot;</span> <span class="attr">scanPeriod</span>=<span class="string">&quot;30 seconds&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;logLevel&quot;</span> <span class="attr">value</span>=<span class="string">&quot;INFO&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;$&#123;logLevel&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="REST-API-动态调整日志级别"><a href="#REST-API-动态调整日志级别" class="headerlink" title="REST API 动态调整日志级别"></a>REST API 动态调整日志级别</h2><p>如果需要通过外部接口控制日志级别，可以结合 <code>LoggerContext</code> 和 REST 框架（如 Spring Boot）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.Level;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.Logger;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.LoggerContext;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/log&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/level&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">changeLogLevel</span><span class="params">(<span class="meta">@RequestParam</span> String loggerName, <span class="meta">@RequestParam</span> String level)</span> &#123;</span><br><span class="line">        <span class="type">LoggerContext</span> <span class="variable">context</span> <span class="operator">=</span> (LoggerContext) LoggerFactory.getILoggerFactory();</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> context.getLogger(loggerName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Logger not found: &quot;</span> + loggerName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Level</span> <span class="variable">newLevel</span> <span class="operator">=</span> Level.valueOf(level.toUpperCase());</span><br><span class="line">            logger.setLevel(newLevel);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Logger level updated to &quot;</span> + newLevel + <span class="string">&quot; for logger &quot;</span> + loggerName;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Invalid log level: &quot;</span> + level;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST <span class="string">&quot;http://localhost:8080/log/level&quot;</span> -d <span class="string">&quot;loggerName=com.example.MyClass&quot;</span> -d <span class="string">&quot;level=DEBUG&quot;</span></span><br></pre></td></tr></table></figure><h2 id="从数据库或外部配置源加载日志级别"><a href="#从数据库或外部配置源加载日志级别" class="headerlink" title="从数据库或外部配置源加载日志级别"></a>从数据库或外部配置源加载日志级别</h2><p>在某些场景中，日志级别可能存储在数据库或其他外部配置中，可以定期检查这些配置并更新日志级别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.Level;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.Logger;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.LoggerContext;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicLogLevelFromDb</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                updateLogLevel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">60000</span>); <span class="comment">// 每 60 秒检查一次</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateLogLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">LoggerContext</span> <span class="variable">context</span> <span class="operator">=</span> (LoggerContext) LoggerFactory.getILoggerFactory();</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> context.getLogger(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟从数据库获取日志级别</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dbLogLevel</span> <span class="operator">=</span> getLogLevelFromDb(); <span class="comment">// 假设这个方法从数据库中获取日志级别</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dbLogLevel != <span class="literal">null</span>) &#123;</span><br><span class="line">            logger.setLevel(Level.valueOf(dbLogLevel.toUpperCase()));</span><br><span class="line">            System.out.println(<span class="string">&quot;Updated logger level to &quot;</span> + dbLogLevel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getLogLevelFromDb</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟从数据库中获取日志级别</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DEBUG&quot;</span>; <span class="comment">// 实际情况应通过数据库查询获取</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><strong>编程动态修改</strong>：通过 <code>LoggerContext</code> 直接修改日志级别，简单高效。</li><li><strong>配置文件自动加载</strong>：监控配置文件的变化，自动更新日志级别。</li><li><strong>REST API</strong>：通过接口灵活控制日志级别，适合微服务架构。</li><li><strong>外部配置（如数据库）</strong>：定期检查外部配置，并动态更新日志级别。</li></ol><script>var description="文章介绍了在Logback中通过编程方式动态调整日志级别的方法。"</script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志工具类封装</title>
      <link href="/p/bd56ad46.html"/>
      <url>/p/bd56ad46.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>日常用法就是在每个需要记录日志的类里，构造一个属于自己类的log实例，本身这么做没什么问题，只是可能有的项目考虑如果每个类里都写这样一个开头，有点麻烦，同时，如果每个类一个独立的声明，log4j内存会缓存很多的实例，占用内存，可能有时候也不便于统一配置管理。所以考虑了对log进行封装。 </p><p>配置文件（<code>logback.xml</code>）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;console&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;36&#125;:%line - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;debug&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="错误写法"><a href="#错误写法" class="headerlink" title="错误写法"></a>错误写法</h2><p>这种写法仔细查看发现对我们调试很有帮助的日志发生时的<strong>类名、行号都变成了封装类里面的类和行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLog4j</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;MyLog4j&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        logger.info(msg);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    MyLog4j. info(<span class="string">&quot;这是一个Info级别的log4j日志。&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INFO  &gt;&gt; main &gt;&gt; com.coderli.log4jpackage.MyLog4j.info(MyLog4j.java:<span class="number">16</span> ) &gt;&gt; 这是一个Info级别的log4j日志。</span><br></pre></td></tr></table></figure><h2 id="Java的调用堆栈分析"><a href="#Java的调用堆栈分析" class="headerlink" title="Java的调用堆栈分析"></a>Java的调用堆栈分析</h2><p>在Java中可以通过Throwable来获取调用堆栈, 例如我们将如下代码，放在MyLog4j类的info方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">throwable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Throwable</span>();</span><br><span class="line">    StackTraceElement[] ste = throwable.getStackTrace();</span><br><span class="line">    <span class="keyword">for</span> (StackTraceElement stackTraceElement : ste) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ClassName: &quot;</span> + stackTraceElement.getClassName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Method Name: &quot;</span> + stackTraceElement.getMethodName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Line number: &quot;</span> + stackTraceElement.getLineNumber());</span><br><span class="line">    &#125;</span><br><span class="line">    logger.info(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次通过<code> MyLog4j.info(&quot;这是一个Info级别的log4j日志。&quot;);</code>调用，就可获得如下输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassName: pers.fulsun.MyLog4j</span><br><span class="line">Method Name: info</span><br><span class="line">Line number: 10</span><br><span class="line">ClassName: pers.fulsun.App</span><br><span class="line">Method Name: main</span><br><span class="line">Line number: 11</span><br></pre></td></tr></table></figure><p>由此可见只要在调用堆栈里找到用户的类，就可以获得所有我们需要的信息。</p><h2 id="问题1：日志输出的类名不正确"><a href="#问题1：日志输出的类名不正确" class="headerlink" title="问题1：日志输出的类名不正确"></a>问题1：日志输出的类名不正确</h2><blockquote><p>解决这个问题的关键是，我们需要确保在输出日志时，能够动态地获取到调用日志方法的实际类名，而不是日志工具类（<code>MyLog4j</code>）的类名。</p></blockquote><p>具体的解决思路是：</p><ol><li><strong>动态获取调用者的类名</strong>：通过 <code>Thread.currentThread().getStackTrace()</code> 获取当前线程的堆栈信息，进而获取调用日志方法的类名。</li><li><strong>将日志记录器动态绑定到调用者的类</strong>：使用 <code>LoggerFactory.getLogger()</code> 动态获取调用日志方法的类名。</li></ol><h3 id="动态获取调用者的类名"><a href="#动态获取调用者的类名" class="headerlink" title="动态获取调用者的类名"></a>动态获取调用者的类名</h3><ul><li><p><code>stackTrace[0]</code> 是 <code>getStackTrace()</code> 方法自身的调用栈。</p></li><li><p><code>stackTrace[1]</code> 是 <code>LogUtil</code> 类中的方法调用栈。</p></li><li><p><code>stackTrace[2]</code> 是调用 <code>LogUtil.info()</code> 的类的调用栈。</p></li></ul><blockquote><p>因此，我们使用 <code>stackTrace[3]</code> 来获取调用 <code>LogUtil</code> 的类名。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取调用此方法的类名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger <span class="title function_">getLogger</span><span class="params">()</span> &#123;</span><br><span class="line">        StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();</span><br><span class="line">        <span class="comment">// 第 2 个栈帧为调用此方法的类</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> stackTrace[<span class="number">3</span>].getClassName();</span><br><span class="line">        <span class="keyword">return</span> LoggerFactory.getLogger(className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        getLogger().info(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        getLogger().debug(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        getLogger().error(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="问题2：日志输出的行号不正确"><a href="#问题2：日志输出的行号不正确" class="headerlink" title="问题2：日志输出的行号不正确"></a>问题2：日志输出的行号不正确</h2><p>类似于类名的问题，Logback 默认会将 <code>Logger</code> 的行号输出设置为 <code>Logger</code> 所在的类的方法行号。由于我们在工具类中封装了日志方法，<code>Logger</code> 的调用会显示在工具类的行号，而不是调用该方法的类的行号。</p><p>解决思路: 为了确保日志输出的行号显示的是调用日志的实际代码行号，我们可以使用 Logback 的 <strong>调用者过滤器（CallerData）</strong>，通过 <code>MDC</code> 或自定义堆栈信息来处理。</p><h3 id="方案1：使用-caller-模式"><a href="#方案1：使用-caller-模式" class="headerlink" title="方案1：使用 %caller 模式"></a>方案1：使用 <code>%caller</code> 模式</h3><p>Logback 提供了 <code>%caller</code> 模式来自动获取调用日志的类和行号，通常只需要通过适当的配置来启用它。</p><blockquote><p><code>%caller</code> 将显示调用者的类名和行号，而不是日志记录器本身的类名。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;appender name=<span class="string">&quot;console&quot;</span> class=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;<span class="number">36</span>&#125;:%caller - %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;root level=<span class="string">&quot;debug&quot;</span>&gt;</span><br><span class="line">        &lt;appender-ref ref=<span class="string">&quot;console&quot;</span> /&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h3 id="方案2：手动设置日志堆栈信息"><a href="#方案2：手动设置日志堆栈信息" class="headerlink" title="方案2：手动设置日志堆栈信息"></a>方案2：手动设置日志堆栈信息</h3><p>如果不使用 <code>%caller</code>，可以通过 <code>StackTraceElement</code> 来手动获取调用堆栈，类似于获取类名的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取调用者的 Logger</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger <span class="title function_">getLogger</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的堆栈信息</span></span><br><span class="line">    StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第3个栈帧，即调用 LogUtil 类的调用者</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> stackTrace[<span class="number">3</span>].getClassName();</span><br><span class="line">    <span class="type">int</span> <span class="variable">lineNumber</span> <span class="operator">=</span> stackTrace[<span class="number">3</span>].getLineNumber();</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> stackTrace[<span class="number">3</span>].getMethodName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出调用类名和行号</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Caller class: &quot;</span> + className);</span><br><span class="line">    System.out.println(<span class="string">&quot;Caller method: &quot;</span> + methodName);</span><br><span class="line">    System.out.println(<span class="string">&quot;Caller line: &quot;</span> + lineNumber);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> LoggerFactory.getLogger(className);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整实现代码"><a href="#完整实现代码" class="headerlink" title="完整实现代码"></a>完整实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取调用者的 Logger</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger <span class="title function_">getLogger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前线程的堆栈信息</span></span><br><span class="line">        StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// stackTrace[0] 是 getStackTrace() 方法本身</span></span><br><span class="line">        <span class="comment">// stackTrace[1] 是 LogUtil 的调用</span></span><br><span class="line">        <span class="comment">// stackTrace[2] 是调用 LogUtil 方法的类</span></span><br><span class="line">        <span class="comment">// stackTrace[3] 是调用日志方法的类所在行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第3个栈帧，即调用 LogUtil 类的调用者</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> stackTrace[<span class="number">3</span>].getClassName();</span><br><span class="line">        <span class="type">int</span> <span class="variable">lineNumber</span> <span class="operator">=</span> stackTrace[<span class="number">3</span>].getLineNumber();</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> stackTrace[<span class="number">3</span>].getMethodName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出调用类名和行号</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;Caller class: &quot; + className);</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;Caller method: &quot; + methodName);</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;Caller line: &quot; + lineNumber);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> LoggerFactory.getLogger(className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装日志方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String message, Object... args)</span> &#123;</span><br><span class="line">        getLogger().info(message, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String message, Object... args)</span> &#123;</span><br><span class="line">        getLogger().debug(message, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">(String message, Object... args)</span> &#123;</span><br><span class="line">        getLogger().error(message, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">(String message, Throwable throwable)</span> &#123;</span><br><span class="line">        getLogger().error(message, throwable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">warn</span><span class="params">(String message, Object... args)</span> &#123;</span><br><span class="line">        getLogger().warn(message, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="增加异步日志支持"><a href="#增加异步日志支持" class="headerlink" title="增加异步日志支持"></a>增加异步日志支持</h2><p>Logback 本身提供了 <code>AsyncAppender</code> 来支持异步日志记录，它允许您将日志记录的操作异步化，从而提高性能，特别是在日志记录的频率较高或者日志内容生成较为复杂时。</p><p>通过代码方式添加异步日志支持，实际上是通过动态添加 <code>AsyncAppender</code> 来实现。我们将日志的输出首先传递给 <code>AsyncAppender</code>，然后将 <code>AsyncAppender</code> 配置为输出到 <code>ConsoleAppender</code> 或其他实际的输出目标。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><ol><li><strong>工具类初始化异步日志</strong>：工具类需要在初始化时确保异步日志的配置已完成。可以通过在 <code>LogUtil</code> 类中进行异步日志配置，确保所有调用 <code>LogUtil</code> 的日志都会是异步的。</li><li><strong>将异步配置与日志方法结合</strong>：工具类中的每个日志方法（如 <code>info</code>, <code>debug</code>, <code>error</code> 等）都会调用已经配置好的异步日志记录器。这样，日志记录不会阻塞主线程，并且保持了日志的异步特性。</li><li><strong>灵活配置</strong>：可以根据需要在工具类中提供异步日志的开启与关闭功能，确保在特定的环境中启用异步日志，而在其他环境中禁用。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul><li><code>AsyncAppender</code> 会将日志事件推送到另一个线程进行处理，这样可以避免日志记录的线程阻塞应用程序的其他操作。</li><li>异步日志记录的优点是 <strong>提高性能</strong>，特别是在高并发、高频次的日志记录场景中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.Logger;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.LoggerContext;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.core.ConsoleAppender;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.core.encoder.LayoutWrappingEncoder;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.core.layout.PatternLayout;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.AsyncAppender;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isAsyncConfigured</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 Logger（异步）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger <span class="title function_">getLogger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果异步日志还没配置，进行配置</span></span><br><span class="line">        <span class="keyword">if</span> (!isAsyncConfigured) &#123;</span><br><span class="line">            configureAsyncLogging();</span><br><span class="line">            isAsyncConfigured = <span class="literal">true</span>; <span class="comment">// 确保只配置一次</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取当前调用的类名作为 Logger</span></span><br><span class="line">        StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> stackTrace[<span class="number">3</span>].getClassName();</span><br><span class="line">        <span class="keyword">return</span> (Logger) LoggerFactory.getLogger(className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置异步日志</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">configureAsyncLogging</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">LoggerContext</span> <span class="variable">context</span> <span class="operator">=</span> (LoggerContext) LoggerFactory.getILoggerFactory();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建 ConsoleAppender（控制台输出）</span></span><br><span class="line">        <span class="type">ConsoleAppender</span> <span class="variable">consoleAppender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsoleAppender</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建 PatternLayout（日志格式化）</span></span><br><span class="line">        <span class="type">PatternLayout</span> <span class="variable">patternLayout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PatternLayout</span>();</span><br><span class="line">        patternLayout.setContext(context);</span><br><span class="line">        patternLayout.setPattern(<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;36&#125;:%line - %msg%n&quot;</span>);</span><br><span class="line">        patternLayout.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置日志编码器</span></span><br><span class="line">        <span class="type">LayoutWrappingEncoder</span> <span class="variable">encoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LayoutWrappingEncoder</span>();</span><br><span class="line">        encoder.setLayout(patternLayout);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置编码器</span></span><br><span class="line">        consoleAppender.setEncoder(encoder);</span><br><span class="line">        consoleAppender.setContext(context);</span><br><span class="line">        consoleAppender.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建 AsyncAppender（异步日志）</span></span><br><span class="line">        <span class="type">AsyncAppender</span> <span class="variable">asyncAppender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsyncAppender</span>();</span><br><span class="line">        asyncAppender.setContext(context);</span><br><span class="line">        asyncAppender.addAppender(consoleAppender);</span><br><span class="line">        asyncAppender.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 配置 root logger 使用异步 appender</span></span><br><span class="line">        <span class="type">Logger</span> <span class="variable">rootLogger</span> <span class="operator">=</span> context.getLogger(<span class="string">&quot;ROOT&quot;</span>);</span><br><span class="line">        rootLogger.addAppender(asyncAppender);</span><br><span class="line">        rootLogger.setLevel(ch.qos.logback.classic.Level.DEBUG); <span class="comment">// 设置默认日志级别</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装日志方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String message, Object... args)</span> &#123;</span><br><span class="line">        getLogger().info(message, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String message, Object... args)</span> &#123;</span><br><span class="line">        getLogger().debug(message, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">(String message, Object... args)</span> &#123;</span><br><span class="line">        getLogger().error(message, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">(String message, Throwable throwable)</span> &#123;</span><br><span class="line">        getLogger().error(message, throwable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">warn</span><span class="params">(String message, Object... args)</span> &#123;</span><br><span class="line">        getLogger().warn(message, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="如何启用-禁用异步日志"><a href="#如何启用-禁用异步日志" class="headerlink" title="如何启用&#x2F;禁用异步日志"></a><strong>如何启用&#x2F;禁用异步日志</strong></h3><p>如果希望在特定环境下禁用异步日志，您可以通过传入一个配置参数来决定是否启用异步日志，或者通过系统属性、配置文件等动态设置。</p><p>例如，在 <code>configureAsyncLogging()</code> 方法中加入一个判断条件，只在特定条件下配置异步日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">configureAsyncLogging</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isAsyncConfigured &amp;&amp; System.getProperty(<span class="string">&quot;enableAsyncLogging&quot;</span>, <span class="string">&quot;true&quot;</span>).equals(<span class="string">&quot;true&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 进行异步日志配置</span></span><br><span class="line">        <span class="type">LoggerContext</span> <span class="variable">context</span> <span class="operator">=</span> (LoggerContext) LoggerFactory.getILoggerFactory();</span><br><span class="line">        <span class="comment">// 其他配置代码...</span></span><br><span class="line">        isAsyncConfigured = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，您可以通过设置系统属性来启用或禁用异步日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-DenableAsyncLogging=<span class="literal">true</span>  <span class="comment">// 启用异步日志</span></span><br></pre></td></tr></table></figure><script>var description="文章介绍了如何制作一份美味的蛋糕。"</script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Slf4j的运行原理</title>
      <link href="/p/cf904808.html"/>
      <url>/p/cf904808.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="Slf4j类与接口"><a href="#Slf4j类与接口" class="headerlink" title="Slf4j类与接口"></a>Slf4j类与接口</h2><table><thead><tr><th><strong>类与接口</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td>org.slf4j.LoggerFactory(class)</td><td>给调用方提供的创建Logger的工厂类，在编译时绑定具体的日志实现组件</td></tr><tr><td>org.slf4j.Logger(interface)</td><td>给调用方提供的日志记录抽象方法，例如debug(String msg),info(String msg)等方法</td></tr><tr><td>org.slf4j.ILoggerFactory(interface)</td><td>获取的Logger的工厂接口，具体的日志组件实现此接口</td></tr><tr><td>org.slf4j.helpers.NOPLogger(class)</td><td>对org.slf4j.Logger接口的一个没有任何操作的实现，也是Slf4j的默认日志实现</td></tr><tr><td>org.slf4j.impl.StaticLoggerBinder(class)</td><td>与具体的日志实现组件实现的桥接类，具体的日志实现组件需要定义org.slf4j.impl包，并在org.slf4j.impl包下提供此类，注意在slf4j-api-version.jar中不存在org.slf4j.impl.StaticLoggerBinder，在源码包slf4j-api-version-source.jar中才存在此类</td></tr></tbody></table><h2 id="Slf4j调用过程源码分析"><a href="#Slf4j调用过程源码分析" class="headerlink" title="Slf4j调用过程源码分析"></a>Slf4j调用过程源码分析</h2><p>只加入slf4j-api-version.jar，不加入任何实现包, pom配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--只有slf4j-api依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.7</span><span class="number">.35</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>程序入口类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.fulsun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(App.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源码追踪分析"><a href="#源码追踪分析" class="headerlink" title="源码追踪分析"></a>源码追踪分析</h3><blockquote><p>slf4j的用法就是LoggerFactory去拿slf4j提供的一个Logger接口的具体实现。</p><p>“<code>Logger logger = LoggerFactory.getLogger(Object.class);</code>“</p></blockquote><ol><li><p>调用LoggerFactory的getLogger()方法创建Logger</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title function_">getLogger</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">    <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> getLogger(clazz.getName());</span><br><span class="line">    <span class="keyword">if</span> (DETECT_LOGGER_NAME_MISMATCH) &#123;</span><br><span class="line">        Class&lt;?&gt; autoComputedCallingClass = Util.getCallingClass();</span><br><span class="line">        <span class="keyword">if</span> (autoComputedCallingClass != <span class="literal">null</span> &amp;&amp; nonMatchingClasses(clazz, autoComputedCallingClass)) &#123;</span><br><span class="line">            Util.report(String.format(<span class="string">&quot;Detected logger name mismatch. Given name: \&quot;%s\&quot;; computed name: \&quot;%s\&quot;.&quot;</span>, logger.getName(),</span><br><span class="line">                            autoComputedCallingClass.getName()));</span><br><span class="line">            Util.report(<span class="string">&quot;See &quot;</span> + LOGGER_NAME_MISMATCH_URL + <span class="string">&quot; for an explanation&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> logger;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用LoggerFactory的getILoggerFactory方法来创建ILoggerFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a logger named according to the name parameter using the</span></span><br><span class="line"><span class="comment"> * statically bound &#123;<span class="doctag">@link</span> ILoggerFactory&#125; instance.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> *            The name of the logger.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> logger</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title function_">getLogger</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="type">ILoggerFactory</span> <span class="variable">iLoggerFactory</span> <span class="operator">=</span> getILoggerFactory();</span><br><span class="line">    <span class="keyword">return</span> iLoggerFactory.getLogger(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>调用LoggerFactory的performInitialization方法来进行初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ILoggerFactory <span class="title function_">getILoggerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (INITIALIZATION_STATE == UNINITIALIZED) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (LoggerFactory.class) &#123;</span><br><span class="line">               <span class="keyword">if</span> (INITIALIZATION_STATE == UNINITIALIZED) &#123;</span><br><span class="line">                   INITIALIZATION_STATE = ONGOING_INITIALIZATION;</span><br><span class="line">                   performInitialization();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">switch</span> (INITIALIZATION_STATE) &#123;</span><br><span class="line">       <span class="keyword">case</span> SUCCESSFUL_INITIALIZATION:</span><br><span class="line">           <span class="keyword">return</span> StaticLoggerBinder.getSingleton().getLoggerFactory();</span><br><span class="line">       <span class="keyword">case</span> NOP_FALLBACK_INITIALIZATION:</span><br><span class="line">           <span class="keyword">return</span> NOP_FALLBACK_FACTORY;</span><br><span class="line">       <span class="keyword">case</span> FAILED_INITIALIZATION:</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(UNSUCCESSFUL_INIT_MSG);</span><br><span class="line">       <span class="keyword">case</span> ONGOING_INITIALIZATION:</span><br><span class="line">           <span class="comment">// support re-entrant behavior.</span></span><br><span class="line">           <span class="comment">// See also http://jira.qos.ch/browse/SLF4J-97</span></span><br><span class="line">           <span class="keyword">return</span> SUBST_FACTORY;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unreachable code&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>进行绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">performInitialization</span><span class="params">()</span> &#123;</span><br><span class="line">    bind();</span><br><span class="line">    <span class="keyword">if</span> (INITIALIZATION_STATE == SUCCESSFUL_INITIALIZATION) &#123;</span><br><span class="line">        versionSanityCheck();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/p/cf904808/709c7a285f47dc774327ed6924a47ae8.png"></p></li><li><p>调用LoggerFactory的findPossibleStaticLoggerBinderPathSet()方法获取StaticLoggerBinderPath集合</p><p><img src="/p/cf904808/13ebc5fd0dc8c8912f4d167dc7330524.png"></p></li><li><p>回到第四步，Classpath下没有StaticLoggerBinderPath，集合元素为空，调用LoggerFactory的reportMultipleBindingAmbiguity()方法，记录绑定的StaticLoggerBinder信息</p><p><img src="/p/cf904808/89d7da3dc6ed454deccb04cd9acf1f8a.png"></p></li><li><p>LoggerFactory的bind()方法找不到StaticLoggerBinder，抛出NoClassDefFoundError异常</p><p><img src="/p/cf904808/2408a3c8154ac8895a3d1ffb642a5bd6.png"></p></li><li><p>LoggerFactory的bind()方法捕获NoClassDefFoundError异常，匹配到StaticLoggerBinder关键词记录信息到控制台</p><p><img src="/p/cf904808/54d33fc85656ce91f4ec51a1b49c81ed.png"></p></li><li><p>LoggerFactory的performInitialization()方法内部调用bind()方法结束, 此时INITIALIZATION_STATE 不等于SUCCESSFUL_INITIALIZATION</p></li><li><p>LoggerFactory的getLogger()方法内部getILoggerFactory()方法调用完成，创建出NOPLoggerFactory，然后由NOPLoggerFactory调用内部的getLogger()方法，创建出NOPLogger</p><p><img src="/p/cf904808/f27209c5f05227dfc23d17a497853ce0.png"></p><p><img src="/p/cf904808/d173c3ca6986e7c92d7c5adf9b01e86f.png"></p></li><li><p>调用NOPLoggerFactory的 getLogger() 创建NOPLogger</p><p><img src="/p/cf904808/1edf3f45c035c87b00890c05361939a6.png"></p></li><li><p>App类内部的logger实际为NOPLogger,调用logger.info()方法实际调用的是NOPLogger的info方法</p><p><img src="/p/cf904808/8a79c61e164541f6350ae9e3452d2a97.png"></p></li></ol><h3 id="加入Logback组件源码分析"><a href="#加入Logback组件源码分析" class="headerlink" title="加入Logback组件源码分析"></a>加入Logback组件源码分析</h3><blockquote><p>Slf4j作为门面采用Logback作为实现或者采用其它上面提到过的组件作为实现类似，这里只分析采用Logback组件作为实现</p></blockquote><p>pom配置如下，程序入口类同上</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.35<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--logback-classic依赖logback-core，会自动级联引入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>1、2、3、4步同上</p></li><li><p>调用LoggerFactory的findPossibleStaticLoggerBinderPathSet()方法获取StaticLoggerBinderPath集合，此时staticLoggerBinderPathSet 集合有一个元素</p><p><img src="/p/cf904808/500a976d93389fea07777219548cd833.png"></p></li><li><p>reportMultipleBindingAmbiguity 判断元素是否&gt;1,不满足</p><p><img src="/p/cf904808/fed0878942901d467d5aa36de9f69672.png"></p></li><li><p>在LoggerFactory的bind()方法中调用loback包下的StaticLoggerBinder创建单例对象</p><p><img src="/p/cf904808/71c8b2e17b20cf190fb510c7fa7346ff.png"></p></li><li><p>在LoggerFactory的bind()方法中调用reportActualBinding()记录日志加载的真实绑定信息</p></li><li><p>LoggerFactory中INITIALIZATION_STATE的值为SUCCESSFUL_INITIALIZATION，调用StaticLoggerBinder的单例对象获取ILoggerFactory</p><p><img src="/p/cf904808/c5a57283bb5f384cca634ece5261c09d.png"></p><p><img src="/p/cf904808/84a9ffa5e1d5cd69f714ea9506da1497.png"></p></li><li><p>此时LoggerFactory中的getLogger()方法中获取到的ILoggerFactory实际上是logback jar下的LoggerContext</p><p><img src="/p/cf904808/75afe42685cbdc5e3d8fdd48d825e6dc.png"></p></li><li><p>此时LoggerFactory调用getLogger()方法获取到的Logger实际上是logback jar下的Logger</p><p><img src="/p/cf904808/caab54b4dd2ed7865b08e3e9cf06300a.png"></p></li><li><p>最后输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">58</span>:<span class="number">15.868</span> [main] INFO pers.fulsun.App - Hello World</span><br></pre></td></tr></table></figure></li></ul><h3 id="加入多种日志实现组件"><a href="#加入多种日志实现组件" class="headerlink" title="加入多种日志实现组件"></a>加入多种日志实现组件</h3><p>pom.xml 配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.35<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--logback-classic依赖logback-core，会自动级联引入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.35<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-jcl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-jdk14<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基本步骤同上，这里只追踪主要不同点</p><ul><li><p>追踪LoggerFactory的bind()方法内部调用findPossibleStaticLoggerBinderPathSet()方法后，从classpath下4个jar包内找到StaticLoggerBinder</p></li><li><p>此时LoggerFactory的bind()方法内部调用reportMultipleBindingAmbiguity()方法，给出警告信息classpath下同时存在多个StaticLoggerBinder,JVM会随机选择一个StaticLoggerBinder</p><p><img src="/p/cf904808/c2ca7d5fc094e0dcc0b90d1bdfa7f14a.png"></p></li><li><p>此时LoggerFactory的bind()方法内部调用reportMultipleBindingAmbiguity()方法，给出警告信息classpath下同时存在多个StaticLoggerBinder,</p><p><img src="/p/cf904808/48369dee7efd3df6575522ab98ad4235.png"></p></li><li><p>JVM会随机选择一个StaticLoggerBinder，这个地方sfl4j也在reportActualBinding方法中报告了绑定的是哪个日志框架：</p><p><img src="/p/cf904808/f77662b042967b0c162627d67f951fb7.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reportActualBinding</span><span class="params">(Set&lt;URL&gt; binderPathSet)</span> &#123;</span><br><span class="line">    <span class="comment">// binderPathSet can be null under Android</span></span><br><span class="line">    <span class="keyword">if</span> (binderPathSet != <span class="literal">null</span> &amp;&amp; isAmbiguousStaticLoggerBinderPathSet(binderPathSet)) &#123;</span><br><span class="line">    Util.report(<span class="string">&quot;Actual binding is of type [&quot;</span> + StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="StaticLoggerBinder"><a href="#StaticLoggerBinder" class="headerlink" title="StaticLoggerBinder"></a>StaticLoggerBinder</h3><ul><li>getLogger的时候会去classpath下找<code>STATIC_LOGGER_BINDER_PATH</code>，<code>STATIC_LOGGER_BINDER_PATH</code>值为”<code>org/slf4j/impl/StaticLoggerBinder.class</code>“，即<strong>所有slf4j的实现，在提供的jar包路径下，一定是有”org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class”存在的</strong>，我们可以看一下：</li></ul><p><img src="/p/cf904808/65891f8f48b4ba3ab8ca52db8c90a5ba.png"></p><p><img src="/p/cf904808/fea9299ca1f0cd071f2a547f8fee43b2.png"></p><p><img src="/p/cf904808/a240b1580f7a65d9f7593b4f54ad0234.png"></p><h2 id="Slf4j时如何桥接遗留的api"><a href="#Slf4j时如何桥接遗留的api" class="headerlink" title="Slf4j时如何桥接遗留的api"></a>Slf4j时如何桥接遗留的api</h2><p>在实际环境中我们经常会遇到不同的组件使用的日志框架不同的情况，例如Spring Framework使用的是日志组件是Commons Logging，XSocket依赖的则是Java Util Logging。当我们在同一项目中使用不同的组件时应该如果解决不同组件依赖的日志组件不一致的情况呢？现在我们需要统一日志方案，统一使用Slf4j，把他们的日志输出重定向到Slf4j，然后Slf4j又会根据绑定器把日志交给具体的日志实现工具。Slf4j带有几个桥接模块，可以重定向Log4j，JCL和java.util.logging中的Api到Slf4j。</p><table><thead><tr><th><strong>log4j-over-slf4j-version.jar</strong></th><th>将Log4j重定向到Slf4j</th></tr></thead><tbody><tr><td><strong>jcl-over-slf4j-version.jar</strong></td><td>将Commons Logging里的Simple Logger重定向到slf4j</td></tr><tr><td><strong>jul-to-slf4j-version.jar</strong></td><td>将Java Util Logging重定向到Slf4j</td></tr></tbody></table><script>var description="文章介绍了SLF4J类与接口的调用过程、源码分析及不同日志实现组件的加入方法。"</script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全面解析 Java 日志体系</title>
      <link href="/p/1d9b5506.html"/>
      <url>/p/1d9b5506.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>日志是软件开发中的关键工具，用于调试、监控和分析应用程序的行为。在 Java 生态系统中，从早期的 <code>Log4j</code> 到现代的 <code>SLF4J</code> 和 <code>Logback</code>，日志框架不断演进以适应开发者的需求。本文将详细介绍 Java 日志体系的历史、框架分类、SLF4J 的运行原理以及 Logback 的配置与使用。</p><hr><h2 id="Java-日志体系的历史"><a href="#Java-日志体系的历史" class="headerlink" title="Java 日志体系的历史"></a>Java 日志体系的历史</h2><p>Java 日志体系的发展是一个逐步迭代和优化的过程：</p><ol><li><p><strong>1996 年：<code>Log4j</code></strong></p><ul><li>由 Ceki Gülcü 开发，最初是一个项目内部的追踪工具。</li><li>后来成为 Apache 基金会的一部分，并迅速成为 Java 社区的事实标准。</li></ul></li><li><p><strong>2002 年：<code>JUL (Java Util Logging)</code></strong></p><ul><li>随 <code>Java 1.4</code> 引入，是 Sun 官方日志实现。</li><li>由于 Log4j 已经成熟，JUL 的采纳率不如预期。</li></ul></li><li><p><strong>2006 年：<code>SLF4J</code> 和 <code>Logback</code></strong></p><ul><li>Ceki 离开 Apache 后创建了这两个项目。</li><li><code>SLF4J</code> 是日志门面，<code>Logback</code> 是高性能实现。</li></ul></li><li><p><strong>2012 年：<code>Log4j2</code></strong></p></li></ol><ul><li>Apache 重写了 Log4j，加入了异步日志处理和更多现代化特性。</li></ul><p>这些框架共同构成了 Java 日志体系的发展轨迹。</p><h2 id="日志框架的分类与选型"><a href="#日志框架的分类与选型" class="headerlink" title="日志框架的分类与选型"></a>日志框架的分类与选型</h2><p>日志框架主要分为两类：</p><ol><li><p><strong>门面型日志框架</strong></p><ul><li>提供统一的接口，支持切换底层实现。</li><li><strong>代表框架：SLF4J 和 JCL</strong><ul><li>SLF4J 是目前的主流选择，具有简单、灵活的特点。</li></ul></li></ul></li><li><p><strong>记录型日志框架</strong></p><ul><li>提供具体的日志实现。</li><li><strong>代表框架：Log4j、Logback 和 JUL</strong></li></ul></li></ol><h2 id="日志框架的作用"><a href="#日志框架的作用" class="headerlink" title="日志框架的作用"></a>日志框架的作用</h2><ul><li>控制日志输出内容与格式。</li><li>管理日志输出位置，如控制台、文件等。</li><li>支持异步操作、日志归档和压缩。</li><li>提供灵活的日志级别控制。</li></ul><h2 id="框架选型建议"><a href="#框架选型建议" class="headerlink" title="框架选型建议"></a>框架选型建议</h2><ul><li>新项目：推荐 <code>SLF4J + Logback</code>。</li><li>遗留系统：可通过桥接器逐步迁移至现代方案。</li></ul><h2 id="日志的使用实例"><a href="#日志的使用实例" class="headerlink" title="日志的使用实例"></a>日志的使用实例</h2><h3 id="使用-Log4j"><a href="#使用-Log4j" class="headerlink" title="使用 Log4j"></a>使用 Log4j</h3><p>早期项目中通常使用 Log4j 直接记录日志，代码示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    private static final Logger logger = Logger.getLogger(Test.class);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        logger.info(&quot;信息日志&quot;);</span><br><span class="line">        logger.error(&quot;错误日志&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-JUL"><a href="#使用-JUL" class="headerlink" title="使用 JUL"></a>使用 JUL</h3><p>JUL 是 Java 自带的日志框架，使用方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    private static final Logger logger = Logger.getLogger(Test.class.getName());</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        logger.info(&quot;信息日志&quot;);</span><br><span class="line">        logger.warning(&quot;警告日志&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-JCL"><a href="#使用-JCL" class="headerlink" title="使用 JCL"></a>使用 JCL</h3><p>JCL 提供了一种抽象方式，可以在运行时选择具体的日志实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.logging.Log;</span><br><span class="line">import org.apache.commons.logging.LogFactory;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    private static final Log log = LogFactory.getLog(Test.class);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        log.info(&quot;信息日志&quot;);</span><br><span class="line">        log.debug(&quot;调试日志&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-SLF4J"><a href="#使用-SLF4J" class="headerlink" title="使用 SLF4J"></a>使用 SLF4J</h3><p>SLF4J 提供统一的接口，结合现代实现框架（如 Logback）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(Test.class);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        logger.info(&quot;信息日志&quot;);</span><br><span class="line">        logger.debug(&quot;调试日志&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SLF4J快速开始"><a href="#SLF4J快速开始" class="headerlink" title="SLF4J快速开始"></a>SLF4J快速开始</h2><h3 id="为什么使用-SLF4J？"><a href="#为什么使用-SLF4J？" class="headerlink" title="为什么使用 SLF4J？"></a>为什么使用 SLF4J？</h3><ol><li><strong>日志实现的松耦合</strong>：通过 SLF4J，应用程序不需要直接依赖具体的日志实现，可以根据需求切换不同的日志框架。</li><li><strong>统一接口</strong>：简化了开发者面对多种日志库的学习成本，提供了标准化的日志 API。</li><li><strong>性能优化</strong>：通过延迟字符串拼接（使用占位符），避免了不必要的性能开销。</li></ol><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>SLF4J 本身只提供接口，需搭配具体的日志实现才能正常工作。如 <code>slf4j-nop.jar</code> <code>slf4j-simple.jar</code>, <code>slf4j-log4j12.jar</code>, <code>slf4j-jdk14.jar</code> or <code>logback-classic.jar</code> 中的任意一个。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SLF4J API --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 日志实现，例如 Logback --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="SLF4J-的基本使用"><a href="#SLF4J-的基本使用" class="headerlink" title="SLF4J 的基本使用"></a><strong>SLF4J 的基本使用</strong></h3><p>SLF4J 的核心接口是 <code>org.slf4j.Logger</code> 和 <code>org.slf4j.LoggerFactory</code>。以下是常见的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Slf4jExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Slf4jExample.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;This is an INFO message&quot;</span>);</span><br><span class="line">        logger.debug(<span class="string">&quot;This is a DEBUG message&quot;</span>);</span><br><span class="line">        logger.error(<span class="string">&quot;This is an ERROR message&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="占位符替换"><a href="#占位符替换" class="headerlink" title="占位符替换"></a>占位符替换</h3><p>LF4J 提供了占位符 <code>&#123;&#125;</code> 替换机制，避免字符串拼接的性能开销。如果日志级别被设置为 <code>WARN</code> 或更高，<code>logger.info()</code> 的占位符会被跳过，避免了字符串拼接造成的性能浪费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">logger.info(<span class="string">&quot;User &#123;&#125; has logged in&quot;</span>, user);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="异常信息记录"><a href="#异常信息记录" class="headerlink" title="异常信息记录"></a>异常信息记录</h3><p>SLF4J 支持直接记录异常堆栈信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">    logger.error(<span class="string">&quot;An exception occurred: &#123;&#125;&quot;</span>, e.getMessage(), e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">An exception occurred: / by zero</span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">    at Slf4jExample.main(Slf4jExample.java:10)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="动态绑定日志实现"><a href="#动态绑定日志实现" class="headerlink" title="动态绑定日志实现"></a>动态绑定日志实现</h3><p>SLF4J 支持动态绑定不同的日志实现，只需引入相应的依赖即可。如果需要切换到 Log4j，只需替换依赖为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.20.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="日志上下文"><a href="#日志上下文" class="headerlink" title="日志上下文"></a>日志上下文</h3><p>某些日志实现（如 Logback）支持使用 <code>MDC</code>（Mapped Diagnostic Context）或 <code>NDC</code>（Nested Diagnostic Context）来记录上下文信息。</p><p>配置日志输出格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;36&#125; [userId=%X&#123;userId&#125;] - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.MDC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Slf4jMdcExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Slf4jMdcExample.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MDC.put(<span class="string">&quot;userId&quot;</span>, <span class="string">&quot;12345&quot;</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;User action executed&quot;</span>);</span><br><span class="line">        MDC.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2025-01-01 12:00:00 [main] INFO  Slf4jMdcExample [userId=12345] - User action executed</span></span><br></pre></td></tr></table></figure><h3 id="延迟日志（Lambda-表达式）"><a href="#延迟日志（Lambda-表达式）" class="headerlink" title="延迟日志（Lambda 表达式）"></a>延迟日志（Lambda 表达式）</h3><p>在 SLF4J 2.x 中，可以使用 Lambda 表达式延迟生成日志内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果当前日志级别低于 DEBUG，performExpensiveComputation() 不会被执行，提升性能。</span></span><br><span class="line">logger.debug(<span class="string">&quot;Expensive computation result: &#123;&#125;&quot;</span>, () -&gt; performExpensiveComputation());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">performExpensiveComputation</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Expensive Result&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="直接输出与延迟日志的区别"><a href="#直接输出与延迟日志的区别" class="headerlink" title="直接输出与延迟日志的区别"></a>直接输出与延迟日志的区别</h3><ul><li><p>直接输出是指在日志方法调用之前就完成了日志消息的生成，即使日志最终不会被输出（例如当前日志级别不符合条件），也会执行字符串拼接或复杂的计算操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> performExpensiveComputation();</span><br><span class="line">logger.debug(<span class="string">&quot;Computation result: &quot;</span> + result);</span><br><span class="line"><span class="comment">// 性能问题：即使当前日志级别高于 DEBUG，performExpensiveComputation() 仍然会执行，浪费 1 秒时间。。</span></span><br><span class="line"><span class="comment">// 如果 performExpensiveComputation() 是一个耗时操作（如数据库查询、大量数据计算），会造成性能浪费。</span></span><br></pre></td></tr></table></figure></li><li><p>延迟日志使用 Lambda 表达式，将日志消息的生成推迟到真正需要输出时才执行。</p><ol><li><code>logger.debug()</code> 方法会先检查当前日志级别是否允许输出。</li><li>如果日志级别不符合（如当前级别为 <code>INFO</code>），Lambda 表达式 <code>() -&gt; performExpensiveComputation()</code> 不会被执行。</li><li>只有当日志级别符合条件（<code>DEBUG</code> 或更低级别）时，才会调用 Lambda 表达式，并执行 <code>performExpensiveComputation()</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;Computation result: &#123;&#125;&quot;</span>, () -&gt; performExpensiveComputation());</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="SLF4j与日志依赖"><a href="#SLF4j与日志依赖" class="headerlink" title="SLF4j与日志依赖"></a>SLF4j与日志依赖</h3><h4 id="SLF4J-SLF4J自带的简单实现"><a href="#SLF4J-SLF4J自带的简单实现" class="headerlink" title="SLF4J+SLF4J自带的简单实现"></a>SLF4J+SLF4J自带的简单实现</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="SLF4J-logback"><a href="#SLF4J-logback" class="headerlink" title="SLF4J+logback"></a>SLF4J+logback</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只留下logback，那么slf4j门面使用的就是logback日志实现。值得一提的是，这一次没有多余的提示信息，所以在实际应用的时候，我们一般情况下，仅仅只是做一种日志实现的集成就可以了。</p><h4 id="SLF4J-nop"><a href="#SLF4J-nop" class="headerlink" title="SLF4J+nop"></a>SLF4J+nop</h4><p>使用slf4j-nop，表示不记录日志。这个实现依赖与logback和simple是属于一类的，通过集成依赖的顺序而定，所以如果想要让nop发挥效果，禁止所有日志的打印，那么就必须要将slf4j-nop的依赖放在所有日志实现依赖的上方。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-nop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="SLF4J-log4j"><a href="#SLF4J-log4j" class="headerlink" title="SLF4J+log4j"></a>SLF4J+log4j</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 导入log4j适配器依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加入配置 <code>log4j.properties</code>配置文件。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Root logger option</span></span><br><span class="line"><span class="attr">log4j.rootLogger</span>=<span class="string">INFO, stdout</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Direct log messages to stdout</span></span><br><span class="line"><span class="attr">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="attr">log4j.appender.stdout.Target</span>=<span class="string">System.out</span></span><br><span class="line"><span class="attr">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="attr">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %c&#123;1&#125;:%L - %m%n</span></span><br></pre></td></tr></table></figure><h4 id="SLF4J-JUL"><a href="#SLF4J-JUL" class="headerlink" title="SLF4J+JUL"></a>SLF4J+JUL</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-jdk14<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="SLF4J-logback-slf4j-simple"><a href="#SLF4J-logback-slf4j-simple" class="headerlink" title="SLF4J+logback+slf4j-simple"></a>SLF4J+logback+slf4j-simple</h4><p>在真实生产环境中，slf4j只要绑定一个日志实现框架就可以了，如果绑定多个日志实现，默认使用导入依赖的第一个，而且会产生没有必要的警告信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以此时虽然集成了logback，可以看到提示你包含了多个SLF4J的绑定，并且此时实际的绑定是SimpleLogger。</p><p>可以调整导入的位置，先导入<code>logback-classic</code>，此时实际绑定的是logback</p><h2 id="SLF4J-的设计理念与运行原理"><a href="#SLF4J-的设计理念与运行原理" class="headerlink" title="SLF4J 的设计理念与运行原理"></a>SLF4J 的设计理念与运行原理</h2><p><a href="https://www.slf4j.org/"><code>SLF4J</code></a> (Simple Logging Facade for Java) 是一种日志门面框架，其主要目标是为 Java 应用提供统一的日志接口，同时支持灵活的底层日志实现替换。</p><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><ul><li><p><strong>统一接口</strong>：抽象日志操作，避免直接依赖具体实现。</p></li><li><p><strong>桥接与适配</strong>：支持将其他日志框架（如 Log4j 和 JUL）的输出重定向至 SLF4J。最上层表示桥接层，下层表示具体的实现层，中间是接口层。</p><p>![](1-全面解析 Java 日志体系&#x2F;3ca7cd611cacf1aeb2a50ade833d8413.png)</p></li></ul><h3 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h3><p>SLF4J 通过以下方式工作：</p><ol><li><p><strong>LoggerFactory 创建日志记录器</strong><code>:LoggerFactory</code> 会通过 <code>StaticLoggerBinder</code> 绑定具体的日志实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MyClass.class);</span><br></pre></td></tr></table></figure></li><li><p><strong>绑定实现</strong></p><ul><li><p>在编译时，SLF4J 会查找 <code>org/slf4j/impl/StaticLoggerBinder.class</code>，并加载对应的日志实现（如 Logback）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticLoggerBinder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">StaticLoggerBinder</span> <span class="variable">SINGLETON</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticLoggerBinder</span>();</span><br><span class="line">    <span class="keyword">public</span> ILoggerFactory <span class="title function_">getLoggerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LogbackLoggerFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>桥接器与适配器</strong></p><ul><li><p><strong>桥接器（Bridge）</strong>：将其他日志框架的输出重定向到 SLF4J。</p><ul><li>例如：<code>log4j-over-slf4j</code> 、<code>jul-to-slf4j</code>、<code>jcl-over-slf4j</code>。</li></ul></li><li><p>适配器（Adapter）：连接 SLF4J 和具体实现。</p><ul><li>例如：<code>slf4j-log4j12</code>、<code>slf4j-jdk14</code>。</li></ul></li><li></li></ul></li><li><p><strong>避免冲突的注意事项</strong></p><ul><li><p>同一项目中只能存在一个具体实现，否则可能导致冲突。错误配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="使用桥接器统一日志"><a href="#使用桥接器统一日志" class="headerlink" title="使用桥接器统一日志"></a>使用桥接器统一日志</h3><p>假设项目中有模块 A 使用 <code>Log4j</code>，模块 B 使用 <code>JUL</code>，需要统一到 <code>SLF4J</code>：</p><ol><li><p>添加桥接器依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jul-to-slf4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置具体实现（如 Logback）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.11&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>初始化桥接器（针对 JUL）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.bridge.SLF4JBridgeHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogSetup</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 清除了 JUL 的根记录器（root logger）上的所有默认处理器，避免重复日志输出。</span></span><br><span class="line">        SLF4JBridgeHandler.removeHandlersForRootLogger();</span><br><span class="line">        <span class="comment">// 为 JUL 的根记录器安装一个新的处理器，该处理器会将 JUL 的日志事件重定向到 SLF4J。</span></span><br><span class="line">        SLF4JBridgeHandler.install();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这样，所有日志都将通过 SLF4J 统一输出到 Logback。</p><h2 id="Logback-的配置详解"><a href="#Logback-的配置详解" class="headerlink" title="Logback 的配置详解"></a>Logback 的配置详解</h2><p>Logback 是 SLF4J 的默认实现，具有高性能和丰富的特性。其配置主要通过 <code>logback.xml</code> 文件完成。</p><h3 id="配置文件结构"><a href="#配置文件结构" class="headerlink" title="配置文件结构"></a>配置文件结构</h3><p>Logback 的配置通常由 XML 配置文件控制，文件名为 <code>logback.xml</code>，放置在类路径中。Logback 配置文件的结构由以下几个部分组成：</p><ul><li><strong>日志级别</strong>：指定日志的输出级别。</li><li><strong>Appender</strong>：日志输出的目标，Logback 支持多种类型的输出方式（如控制台、文件、数据库等）。</li><li><strong>Logger</strong>：用于实际记录日志的组件，日志记录器可以配置为不同的日志级别。</li><li><strong>Encoder</strong>：日志消息格式化的方式。</li></ul><h3 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h3><p>Logback 配置文件的核心是 <code>&lt;configuration&gt;</code> 元素，它包含多个子元素，如 <code>&lt;appender&gt;</code>、<code>&lt;logger&gt;</code>、<code>&lt;root&gt;</code> 等。</p><ol><li><p><strong><code>appender</code></strong></p><ul><li>定义日志输出方式，如控制台或文件。</li></ul></li><li><p><strong><code>logger</code></strong></p><ul><li>为特定包或类设置日志级别和输出。</li></ul></li><li><p><strong><code>root</code></strong></p><ul><li>定义默认的日志输出。</li></ul></li></ol><p>一个简单的 <code>logback.xml</code> 配置文件如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 控制台日志输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;console&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 文件日志输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.FileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/app.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 设置日志级别为 DEBUG --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.example&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置 root logger --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="关键元素解析"><a href="#关键元素解析" class="headerlink" title="关键元素解析"></a>关键元素解析</h3><ul><li><p><code>&lt;configuration&gt;</code>：配置文件的根元素。</p></li><li><p><code>&lt;appender&gt;</code>：定义日志输出目标。Logback 支持不同类型的 Appender，比如：</p><ul><li><code>ConsoleAppender</code>：输出到控制台。</li><li><code>FileAppender</code>：输出到文件。</li><li><code>RollingFileAppender</code>：输出到滚动文件（用于文件分割）。</li></ul><p>每个 Appender 可以设置多个参数，如输出格式（<code>&lt;encoder&gt;</code>）和文件路径（<code>&lt;file&gt;</code>）。</p></li><li><p><code>&lt;logger&gt;</code>：定义一个日志记录器。每个日志记录器有一个名称，可以指定其输出级别。通常，Logger 使用包名作为其名称。通过设置 <code>level</code> 属性，可以控制该 Logger 的日志级别。</p></li><li><p><code>&lt;root&gt;</code>：定义根日志记录器（Root Logger），它控制默认的日志级别和输出目标。根日志记录器是最上层的记录器，所有未明确配置的日志记录器都会继承该设置。</p></li></ul><h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><p>Logback 支持以下日志级别（按优先级递增）：</p><ul><li><code>TRACE</code>：最详细的日志级别，用于开发过程中调试和诊断。</li><li><code>DEBUG</code>：用于开发过程中的调试信息。</li><li><code>INFO</code>：用于一般的信息输出，常用于生产环境中。</li><li><code>WARN</code>：警告信息，可能不影响程序运行，但需要注意。</li><li><code>ERROR</code>：错误信息，通常表示程序发生了异常或错误。</li><li><code>OFF</code>：关闭所有日志。</li></ul><h3 id="日志滚动策略"><a href="#日志滚动策略" class="headerlink" title="日志滚动策略"></a>日志滚动策略</h3><p><code>RollingFileAppender</code> 可以在文件达到一定大小时自动进行日志滚动。上述配置将日志按日期和大小滚动存储，每个文件的最大大小为 10MB，最多保存 30 天的日志。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;rollingFile&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/app.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 滚动日志文件的命名模式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>logs/app.%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 单个日志文件的最大大小 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>10MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 保存的历史日志文件数量 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志文件最大存储总大小 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>2GB<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="日志输出的格式"><a href="#日志输出的格式" class="headerlink" title="日志输出的格式"></a>日志输出的格式</h3><p>在 <code>logback</code> 中，<code>encoder.pattern</code> 用于定义日志输出的格式。常见的配置项包括日志的时间、日志级别、日志信息、线程名等。以下是一些常用的配置项及其含义：</p><ol><li><code>%d&#123;yyyy-MM-dd HH:mm:ss&#125;</code></li></ol><ul><li><strong>含义</strong>：表示日志事件的时间。<code>yyyy-MM-dd HH:mm:ss</code> 是日期和时间的格式，可以根据需要自定义格式。</li><li><strong>示例</strong>：<code>2025-01-01 12:34:56</code></li></ul><ol start="2"><li><code>%thread</code></li></ol><ul><li><strong>含义</strong>：表示输出日志的线程名。</li><li><strong>示例</strong>：<code>main</code></li></ul><ol start="3"><li><code>%level</code></li></ol><ul><li><strong>含义</strong>：表示日志级别（例如：<code>DEBUG</code>、<code>INFO</code>、<code>WARN</code>、<code>ERROR</code>）。</li><li><strong>示例</strong>：<code>INFO</code></li></ul><ol start="4"><li><code>%logger</code>,<code>%logger&#123;36&#125;</code>：打印记录器的名称，最多 36 个字符</li></ol><ul><li><strong>含义</strong>：表示日志记录器的名称，通常是类名。</li><li><strong>示例</strong>：<code>com.example.MyClass</code></li></ul><ol start="5"><li><code>%msg</code></li></ol><ul><li><strong>含义</strong>：表示日志消息的内容，即调用日志方法时传入的消息。</li><li><strong>示例</strong>：<code>Something went wrong</code></li></ul><ol start="6"><li><code>%n</code></li></ol><ul><li><strong>含义</strong>：表示换行符。通常用于日志输出后进行换行。</li><li><strong>示例</strong>：换行</li></ul><ol start="7"><li><code>%M</code></li></ol><ul><li><strong>含义</strong>：表示调用日志方法的类方法名。</li><li><strong>示例</strong>：<code>main</code>（方法名）</li></ul><ol start="8"><li><code>%file</code></li></ol><ul><li><strong>含义</strong>：表示日志所在的源文件名。</li><li><strong>示例</strong>：<code>MyClass.java</code></li></ul><ol start="9"><li><code>%line</code></li></ol><ul><li><strong>含义</strong>：表示日志调用所在的代码行号。</li><li><strong>示例</strong>：<code>42</code></li></ul><ol start="10"><li><code>%replace</code></li></ol><ul><li><strong>含义</strong>：用于替换日志消息中的某些内容，可以进行正则替换。</li><li><strong>示例</strong>：<code>%replace(%msg)&#123;&#39;foo&#39;:&#39;bar&#39;&#125;</code> 将日志消息中的 <code>foo</code> 替换为 <code>bar</code>。</li></ul><ol start="11"><li><code>%ex</code></li></ol><ul><li><strong>含义</strong>：表示异常信息（如果有的话）。</li><li><strong>示例</strong>：<code>java.lang.NullPointerException</code></li></ul><ol start="12"><li><code>%logger&#123;length&#125;</code></li></ol><ul><li><strong>含义</strong>：表示日志记录器的名称，<code>length</code> 指定输出的最小字符长度。如果日志名称短于这个长度，会进行截取。</li><li><strong>示例</strong>：<code>%logger&#123;15&#125;</code> 输出长度为 15 的日志记录器名称。</li></ul><ol start="13"><li><code>%contextName</code></li></ol><ul><li><strong>含义</strong>：表示日志上下文的名称。</li><li><strong>示例</strong>：<code>myApp</code></li></ul><ol start="14"><li><code>%X&#123;key&#125;</code></li></ol><ul><li><strong>含义</strong>：表示从 <code>MDC</code>（Mapped Diagnostic Context）中获取键为 <code>key</code> 的值，<code>MDC</code> 是用于存储和传递日志上下文信息的工具。</li><li><strong>示例</strong>：<code>%X&#123;userId&#125;</code> 输出当前线程中 <code>userId</code> 的值。</li></ul><ol start="15"><li><code>%uuid</code></li></ol><ul><li><strong>含义</strong>：表示日志事件的唯一标识符。</li><li><strong>示例</strong>：<code>6bcfc019-d208-4960-a9ea-88d970124b45</code></li></ul><h2 id="Logback高级配置"><a href="#Logback高级配置" class="headerlink" title="Logback高级配置"></a>Logback高级配置</h2><h3 id="AsyncAppender-异步日志输出"><a href="#AsyncAppender-异步日志输出" class="headerlink" title="AsyncAppender 异步日志输出"></a>AsyncAppender 异步日志输出</h3><p><code>AsyncAppender</code> 可用于提高日志记录性能，通过异步方式将日志写入目标文件。</p><ul><li><p><code>queueSize</code>：指定日志队列的大小。</p></li><li><p><code>discardingThreshold</code>：控制在队列接近满时丢弃的日志级别。</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;async&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">queueSize</span>&gt;</span>500<span class="tag">&lt;/<span class="name">queueSize</span>&gt;</span> <span class="comment">&lt;!-- 日志队列大小 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">discardingThreshold</span>&gt;</span>0<span class="tag">&lt;/<span class="name">discardingThreshold</span>&gt;</span> <span class="comment">&lt;!-- 丢弃日志的阈值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="SMTPAppender-邮件通知"><a href="#SMTPAppender-邮件通知" class="headerlink" title="SMTPAppender 邮件通知"></a>SMTPAppender 邮件通知</h3><p>当系统发生严重错误时，可以通过 <code>SMTPAppender</code> 发送电子邮件通知。</p><ul><li><code>smtpHost</code> 和 <code>smtpPort</code>：邮件服务器的地址和端口。</li><li><code>username</code> 和 <code>password</code>：邮件服务器的登录信息。</li><li><code>filter</code>：用于指定只有 <code>ERROR</code> 级别的日志会触发邮件发送。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.net.SMTPAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">smtpHost</span>&gt;</span>smtp.example.com<span class="tag">&lt;/<span class="name">smtpHost</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">smtpPort</span>&gt;</span>587<span class="tag">&lt;/<span class="name">smtpPort</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>your_email@example.com<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>your_password<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">to</span>&gt;</span>admin@example.com<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">from</span>&gt;</span>no-reply@example.com<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">subject</span>&gt;</span>Critical Error Alert<span class="tag">&lt;/<span class="name">subject</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="日志上下文变量"><a href="#日志上下文变量" class="headerlink" title="日志上下文变量"></a>日志上下文变量</h3><p>通过 <code>&lt;property&gt;</code> 标签设置变量，可以让配置文件更灵活。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置变量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;logDir&quot;</span> <span class="attr">value</span>=<span class="string">&quot;logs&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;appName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;MyApp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.FileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;logDir&#125;/$&#123;appName&#125;.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在实际应用中，可以通过 <code>-D</code> 系统属性传递变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -DlogDir=/var/logs -DappName=MyApp -jar app.jar</span><br></pre></td></tr></table></figure><h3 id="动态日志级别调整"><a href="#动态日志级别调整" class="headerlink" title="动态日志级别调整"></a>动态日志级别调整</h3><p>Logback 支持在运行时动态调整日志级别，方便调试和排查问题。</p><ol><li><p>在配置文件中启用 JMX 支持：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jmxConfigurator</span>/&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通过 JMX 工具（如 JConsole）可以动态调整日志级别。启动jconsole, 连接应用，选择MBean,找到<code>ch.qos.logback.classic.default</code>目录下的类<code>ch.qos.logback.classic.jmx.JMXConfigurator</code>，选择操作，选择setLoggerLevel,输入参数,第一个是loggerName,第二个是loggerLevel,点击按钮</p></li></ol><h3 id="基于环境的日志配置"><a href="#基于环境的日志配置" class="headerlink" title="基于环境的日志配置"></a>基于环境的日志配置</h3><p>通过条件判断实现不同环境的日志配置，比如开发环境和生产环境。,运行应用时通过 <code>-Denv=dev</code> 或 <code>-Denv=prod</code> 指定环境。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">condition</span>=<span class="string">&#x27;property(&quot;env&quot;) == &quot;dev&quot;&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">then</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">then</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">condition</span>=<span class="string">&#x27;property(&quot;env&quot;) == &quot;prod&quot;&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">then</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">then</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="过滤器-Filters"><a href="#过滤器-Filters" class="headerlink" title="过滤器 (Filters)"></a>过滤器 (Filters)</h3><p>过滤器允许对日志进行更精细的控制。</p><blockquote><p><code>LevelFilter</code> 是一种简单的过滤器，用于按日志级别控制日志的输出。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span> <span class="comment">&lt;!-- 匹配成功时的动作 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span> <span class="comment">&lt;!-- 匹配失败时的动作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>阈值过滤器 (ThresholdFilter) , eg: 只输出级别大于等于 <code>WARN</code> 的日志。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">level</span>&gt;</span>WARN<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>正则过滤器 (RegexFilter): 匹配包含特定关键字的日志消息。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.filter.EvaluatorFilter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">evaluator</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.boolex.JaninoEventEvaluator&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">expression</span>&gt;</span>return message.contains(&quot;specialKeyword&quot;);<span class="tag">&lt;/<span class="name">expression</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">evaluator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">OnMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">OnMatch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">OnMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">OnMismatch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>EvaluatorFilter</code> 是 Logback 提供的高级过滤器，支持基于条件表达式动态控制日志的输出。</p></blockquote><p> <code>EvaluatorFilter</code> 中，<strong>不支持直接定义多个 <code>&lt;expression&gt;</code> 标签，可以配置多个 <code>EvaluatorFilter</code>, 可以通过在单个 <code>&lt;expression&gt;</code> 中组合多个条件来实现复杂逻辑</strong>，使用 Java 的逻辑运算符（如 <code>&amp;&amp;</code>、<code>||</code>）即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.filter.EvaluatorFilter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">evaluator</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.boolex.JaninoEventEvaluator&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 自定义条件表达式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">expression</span>&gt;</span>return logger.equals(&quot;com.example.MyClass&quot;) &amp;&amp; level.toString().equals(&quot;ERROR&quot;);<span class="tag">&lt;/<span class="name">expression</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 过滤包含 &quot;CriticalError&quot; 的 ERROR 日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">expression</span>&gt;</span>return level.toString().equals(&quot;ERROR&quot;) &amp;&amp; message.contains(&quot;CriticalError&quot;);<span class="tag">&lt;/<span class="name">expression</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 组合多个条件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">expression</span>&gt;</span></span><br><span class="line">            return (logger.equals(&quot;com.example.MyClass&quot;) &amp;&amp; level.toString().equals(&quot;ERROR&quot;)) </span><br><span class="line">                || message.contains(&quot;CriticalError&quot;);</span><br><span class="line">        <span class="tag">&lt;/<span class="name">expression</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">evaluator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">OnMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">OnMatch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">OnMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">OnMismatch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="JSON-格式化日志"><a href="#JSON-格式化日志" class="headerlink" title="JSON 格式化日志"></a>JSON 格式化日志</h3><p>对于需要将日志以 JSON 格式输出的场景，可以使用第三方库如 <code>logstash-logback-encoder</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.logstash.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logstash-logback-encoder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置 JSON Encoder</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;jsonFile&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.FileAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/json.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">providers</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timestamp</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">loggerName</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">message</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">context</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">providers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java 日志体系通过不断演化，提供了多种解决方案以满足不同场景的需求。从 SLF4J 的灵活接口到 Logback 的高性能实现，开发者可以根据项目需求选择合适的框架和配置方式。在实际开发中，建议优先采用现代化的日志方案，如 <code>SLF4J + Logback</code>，以获得最佳性能和维护性。</p><script>var description="文章介绍了Java日志体系的历史、框架分类、SLF4J与Logback原理及配置。"</script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOS 高级环境配置指南</title>
      <link href="/p/b2607acb.html"/>
      <url>/p/b2607acb.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h2><p>Homebrew 是 macOS 的包管理器，它让你轻松安装和管理各种软件工具。</p><h3 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 Homebrew</h3><p><strong>推荐方法：标准安装脚本</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/zsh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><p><strong>追求速度？试试极速安装脚本</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/zsh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)</span>&quot;</span> speed</span><br></pre></td></tr></table></figure><p><strong>卸载 Homebrew：</strong></p><p>如果需要卸载 Homebrew，运行以下脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/zsh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Homebrew-常用命令"><a href="#Homebrew-常用命令" class="headerlink" title="Homebrew 常用命令"></a>Homebrew 常用命令</h3><ul><li><p><strong>更新 Homebrew 数据库：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br></pre></td></tr></table></figure></li><li><p><strong>搜索软件包：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew search &lt;软件名&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>安装软件包：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install &lt;软件名&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="NVM-和-Node-js"><a href="#NVM-和-Node-js" class="headerlink" title="NVM 和 Node.js"></a>NVM 和 Node.js</h2><h3 id="安装-NVM"><a href="#安装-NVM" class="headerlink" title="安装 NVM"></a>安装 NVM</h3><p>使用 Homebrew 安装 NVM：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nvm</span><br></pre></td></tr></table></figure><p>安装后，在 <code>.zshrc</code> 文件中添加以下配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">&quot;<span class="variable">$HOME</span>/.nvm&quot;</span></span><br><span class="line">[ -s <span class="string">&quot;/usr/local/opt/nvm/nvm.sh&quot;</span> ] &amp;&amp; . <span class="string">&quot;/usr/local/opt/nvm/nvm.sh&quot;</span></span><br><span class="line">[ -s <span class="string">&quot;/usr/local/opt/nvm/etc/bash_completion.d/nvm&quot;</span> ] &amp;&amp; . <span class="string">&quot;/usr/local/opt/nvm/etc/bash_completion.d/nvm&quot;</span></span><br></pre></td></tr></table></figure><h3 id="切换国内源"><a href="#切换国内源" class="headerlink" title="切换国内源"></a>切换国内源</h3><p>使用国内源加速 Node.js 下载：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\nexport NVM_NODEJS_ORG_MIRROR=http://npmmirror.com/mirrors/node&quot;</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><p>刷新配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><h3 id="管理-npm-源"><a href="#管理-npm-源" class="headerlink" title="管理 npm 源"></a>管理 npm 源</h3><p>使用 <code>nrm</code> 轻松切换 npm 源：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g nrm --registry https://registry.npmmirror.com/</span><br></pre></td></tr></table></figure><h2 id="多版本-JDK-配置指南"><a href="#多版本-JDK-配置指南" class="headerlink" title="多版本 JDK 配置指南"></a>多版本 JDK 配置指南</h2><p>在开发过程中，你可能需要切换不同版本的 JDK。这是具体步骤：</p><h3 id="安装多版本-JDK"><a href="#安装多版本-JDK" class="headerlink" title="安装多版本 JDK"></a>安装多版本 JDK</h3><ol><li><p>下载并安装 JDK 8。</p></li><li><p>下载 JDK 11 的压缩包，运行以下命令解压：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> tar -zxvf jdk-11_osx-x64_bin.tar.gz -C /Library/Java/JavaVirtualMachines/</span><br></pre></td></tr></table></figure></li><li><p>验证安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /Library/Java/JavaVirtualMachines</span><br><span class="line"><span class="built_in">ls</span> -al</span><br></pre></td></tr></table></figure><p>确保你能看到 JDK 8 和 JDK 11 的目录。</p></li></ol><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>在 <code>.zshrc</code> 文件中添加以下内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_8_HOME=<span class="string">&quot;<span class="subst">$(/usr/libexec/java_home -v 1.8)</span>&quot;</span></span><br><span class="line"><span class="built_in">export</span> JAVA_11_HOME=<span class="string">&quot;<span class="subst">$(/usr/libexec/java_home -v 11)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认使用 JDK 8</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=<span class="variable">$JAVA_8_HOME</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态切换 JDK 版本</span></span><br><span class="line"><span class="built_in">alias</span> jdk8=<span class="string">&quot;export JAVA_HOME=<span class="variable">$JAVA_8_HOME</span>&quot;</span></span><br><span class="line"><span class="built_in">alias</span> jdk11=<span class="string">&quot;export JAVA_HOME=<span class="variable">$JAVA_11_HOME</span>&quot;</span></span><br></pre></td></tr></table></figure><p>刷新配置后，运行以下命令查看默认 JDK 版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure><p>切换到 JDK 11：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jdk11</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上配置，你的 macOS 开发环境将更加高效和灵活。从 Homebrew 管理工具到多版本 JDK 的切换，这些方法可以大大提升你的生产力。如果你有其他问题或需要进一步优化，欢迎随时交流！</p><script>var description="文章介绍了Homebrew及其在macOS中安装、使用及卸载的方法，并涵盖NVM和多版本JDK的配置技巧。"</script>]]></content>
      
      
      <categories>
          
          <category> MacOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
            <tag> 开发环境 </tag>
            
            <tag> Homebrew </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS 使用指南</title>
      <link href="/p/e037d75e.html"/>
      <url>/p/e037d75e.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="切换到-zsh-——-新手必备操作"><a href="#切换到-zsh-——-新手必备操作" class="headerlink" title="切换到 zsh —— 新手必备操作"></a>切换到 zsh —— 新手必备操作</h2><p>从 macOS Catalina 开始，系统默认使用 zsh 作为 Shell。如果你还停留在 Bash，不妨尝试切换到更现代的 zsh：</p><ol><li>点击苹果菜单  &gt; 系统偏好设置 &gt; 用户与群组。</li><li>按住 Control 键点击你的用户名，选择“高级选项”。</li><li>在“登录 Shell”菜单中，选择 <code>zsh</code>，然后点击“好”。</li></ol><p>简单吧？一键切换到 zsh，你会发现新世界！</p><h2 id="轻松配置-zsh"><a href="#轻松配置-zsh" class="headerlink" title="轻松配置 zsh"></a>轻松配置 zsh</h2><p>zsh 的配置文件是 <code>~/.zshrc</code>，它可以让你的终端变得更好用。以下是一些推荐的设置：</p><h3 id="常用别名"><a href="#常用别名" class="headerlink" title="常用别名"></a>常用别名</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -alF&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">&#x27;ls -A&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> l=<span class="string">&#x27;ls -CF&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="自定义终端显示"><a href="#自定义终端显示" class="headerlink" title="自定义终端显示"></a>自定义终端显示</h3><p>用下面的代码让你的终端看起来更酷：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PS1=<span class="string">&quot;%10F%m%f:%11F%1~%f \$ &quot;</span></span><br></pre></td></tr></table></figure><p>修改后别忘了执行 <code>source ~/.zshrc</code> 来加载配置。</p><h2 id="让补全更智能"><a href="#让补全更智能" class="headerlink" title="让补全更智能"></a>让补全更智能</h2><p>默认情况下，zsh 在补全路径时区分大小写。如果你希望忽略大小写并开启智能补全，可以试试这个方法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">autoload</span> -Uz compinit &amp;&amp; compinit</span><br><span class="line"><span class="built_in">zstyle</span> <span class="string">&#x27;:completion:*&#x27;</span> matcher-list <span class="string">&#x27;m:&#123;[:lower:][:upper:]&#125;=&#123;[:upper:][:lower:]&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>有时你可能会遇到权限问题，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zsh compinit: insecure directories, run compaudit <span class="keyword">for</span> list.</span><br><span class="line">Ignore insecure directories and <span class="built_in">continue</span> [y] or abort compinit [n]?</span><br></pre></td></tr></table></figure><p>解决方法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> g-w /usr/local/share/zsh</span><br><span class="line"><span class="built_in">chmod</span> g-w /usr/local/share/zsh/site-functions</span><br></pre></td></tr></table></figure><p>搞定后，再次执行 <code>source ~/.zshrc</code>，就可以愉快地用上智能补全了！</p><h2 id="优化-GitHub-访问速度"><a href="#优化-GitHub-访问速度" class="headerlink" title="优化 GitHub 访问速度"></a>优化 GitHub 访问速度</h2><p>如果你觉得 GitHub 加载慢，可以试试手动修改 Hosts 文件：</p><ol><li><p>打开 Hosts 文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> code /etc/hosts</span><br></pre></td></tr></table></figure><p>如果你没有安装 VSCode，也可以用其他编辑器。</p></li><li><p>添加以下内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">140.82.113.4 github.com</span><br><span class="line">140.82.114.5 api.github.com</span><br><span class="line">185.199.108.133 raw.githubusercontent.com</span><br></pre></td></tr></table></figure></li><li><p>保存后刷新网络缓存：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> killall -HUP mDNSResponder</span><br></pre></td></tr></table></figure></li></ol><p>完成后，你会发现访问速度快了不少！</p><h2 id="给-Git-添加一点小魔法"><a href="#给-Git-添加一点小魔法" class="headerlink" title="给 Git 添加一点小魔法"></a>给 Git 添加一点小魔法</h2><p>Git 提供了很多方便的配置项，比如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.lg <span class="string">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#x27; --date=format:&#x27;%Y-%m-%d %H:%M:%S&#x27; --abbrev-commit&quot;</span></span><br></pre></td></tr></table></figure><p>试试这些别名配置，让你的 Git 操作更高效！</p><h2 id="用-Vim-让代码编辑更顺滑"><a href="#用-Vim-让代码编辑更顺滑" class="headerlink" title="用 Vim 让代码编辑更顺滑"></a>用 Vim 让代码编辑更顺滑</h2><p>如果你习惯用 Vim 写代码，可以用以下方法优化它的显示效果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">colorscheme default     <span class="string">&quot; 设置颜色主题</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">syntax on               &quot;</span> 语法高亮</span><br><span class="line"></span><br><span class="line">filetype on             <span class="string">&quot; 检测文件的类型</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set number              &quot;</span> 显示行号</span><br><span class="line"><span class="built_in">set</span> cursorline          <span class="string">&quot; 用浅色高亮当前行</span></span><br><span class="line"><span class="string">&quot;</span>autocmd InsertLeave * se nocul</span><br><span class="line"><span class="string">&quot;autocmd InsertEnter * se cul</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set ruler               &quot;</span> 在编辑过程中，在右下角显示光标位置的状态行</span><br><span class="line"><span class="built_in">set</span> laststatus=2        <span class="string">&quot; 显示状态栏 (默认值为 1, 无法显示状态栏)</span></span><br><span class="line"><span class="string">set statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%&#123;&amp;fileformat&#125;\ %&#123;&amp;encoding&#125;\ %c:%l/%L%)\</span></span><br><span class="line"><span class="string">                        &quot;</span> 设置在状态行显示的信息</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> tabstop=4           <span class="string">&quot; Tab键的宽度</span></span><br><span class="line"><span class="string">set softtabstop=4</span></span><br><span class="line"><span class="string">set shiftwidth=4        &quot;</span> 统一缩进为4</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> autoindent          <span class="string">&quot; vim使用自动对齐，也就是把当前行的对齐格式应用到下一行(自动缩进)</span></span><br><span class="line"><span class="string">set cindent             &quot;</span> (cindent是特别针对 C语言语法自动缩进)</span><br><span class="line"><span class="built_in">set</span> smartindent         <span class="string">&quot; 依据上面的对齐格式，智能的选择对齐方式，对于类似C语言编写上有用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set scrolloff=3         &quot;</span> 光标移动到buffer的顶部和底部时保持3行距离</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> incsearch           <span class="string">&quot; 输入搜索内容时就显示搜索结果</span></span><br><span class="line"><span class="string">set hlsearch            &quot;</span> 搜索时高亮显示被找到的文本</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> foldmethod=indent   <span class="string">&quot; 设置缩进折叠</span></span><br><span class="line"><span class="string">set foldlevel=99        &quot;</span> 设置折叠层数</span><br><span class="line">nnoremap &lt;space&gt; @=((foldclosed(line(&#x27;.&#x27;)) &lt; 0) ? <span class="string">&#x27;zc&#x27;</span> : <span class="string">&#x27;zo&#x27;</span>)&lt;CR&gt;</span><br><span class="line">                        <span class="string">&quot; 用空格键来开关折叠</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 自动跳转到上次退出的位置</span><br><span class="line"><span class="keyword">if</span> has(<span class="string">&quot;autocmd&quot;</span>)</span><br><span class="line">    au BufReadPost * <span class="keyword">if</span> line(<span class="string">&quot;&#x27;\&quot;&quot;</span>) &gt; 1 &amp;&amp; line(<span class="string">&quot;&#x27;\&quot;&quot;</span>) &lt;= line(<span class="string">&quot;$&quot;</span>) | exe <span class="string">&quot;normal! g&#x27;\&quot;&quot;</span> | endif</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>在 <code>~/.vimrc</code> 文件中添加这些配置，你的 Vim 使用体验将大幅提升。</p><h2 id="安装-Brew，玩转-macOS-软件管理"><a href="#安装-Brew，玩转-macOS-软件管理" class="headerlink" title="安装 Brew，玩转 macOS 软件管理"></a>安装 Brew，玩转 macOS 软件管理</h2><p>Homebrew 是 macOS 上不可或缺的软件包管理工具。安装方法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/bin/zsh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)</span>&quot;</span></span><br><span class="line"><span class="comment"># 卸载脚本：</span></span><br><span class="line">/bin/zsh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>安装完成后，你可以用它轻松安装各种软件，比如 NVM、MySQL 等。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>看到这里，你已经掌握了 macOS 的基础配置和优化技巧。不管是日常使用还是开发工作，这些设置都能让你的 Mac 用起来更顺手、更高效。赶紧试试吧，享受一个更强大的 macOS！</p><script>var description="文章介绍了如何在macOS上切换至zsh及其一系列优化配置步骤。"</script>]]></content>
      
      
      <categories>
          
          <category> MacOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacOS优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美化PowerShell</title>
      <link href="/p/f5d280da.html"/>
      <url>/p/f5d280da.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="/p/f5d280da/eac1038bde39343c79077cb47d9ffb55.png"></p><h2 id="为什么要美化-PowerShell？"><a href="#为什么要美化-PowerShell？" class="headerlink" title="为什么要美化 PowerShell？"></a>为什么要美化 PowerShell？</h2><p>对于许多 Windows 用户，尤其是开发者而言，Windows 默认的命令提示符和 PowerShell 界面显得过于简陋，难以满足日常开发需求。幸运的是，通过一些工具和配置，我们可以让 PowerShell 不仅美观，还兼具实用性。</p><p>接下来，我们将逐步介绍如何优化 PowerShell 界面并提升其功能。</p><h2 id="安装与配置指南"><a href="#安装与配置指南" class="headerlink" title="安装与配置指南"></a>安装与配置指南</h2><h3 id="使用-Windows-Terminal-配置"><a href="#使用-Windows-Terminal-配置" class="headerlink" title="使用 Windows Terminal 配置"></a>使用 Windows Terminal 配置</h3><p>Windows Terminal 是微软推出的一款现代化终端工具，它支持多标签、个性化配色方案、字体等。</p><h4 id="1-安装-oh-my-posh"><a href="#1-安装-oh-my-posh" class="headerlink" title="1. 安装 oh-my-posh"></a>1. 安装 oh-my-posh</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 scoop 安装 oh-my-posh</span></span><br><span class="line">scoop install oh-my-posh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装推荐字体</span></span><br><span class="line">oh-my-posh font install meslo</span><br><span class="line">scoop install Meslo-NF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置字体</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;profiles&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;defaults&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;font&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;face&quot;</span>: <span class="string">&quot;MesloLGM Nerd Font&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-配置-PowerShell-用户文件"><a href="#2-配置-PowerShell-用户文件" class="headerlink" title="2. 配置 PowerShell 用户文件"></a>2. 配置 PowerShell 用户文件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建配置文件</span></span><br><span class="line">New-Item -Path <span class="variable">$PROFILE</span> -Type File -Force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开配置文件编辑</span></span><br><span class="line">notepad <span class="variable">$PROFILE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 UTF-8 编码和初始化 oh-my-posh</span></span><br><span class="line"><span class="variable">$OutputEncoding</span> = [console]::InputEncoding = [console]::OutputEncoding = New-Object System.Text.UTF8Encoding</span><br><span class="line">oh-my-posh init pwsh | Invoke-Expression</span><br></pre></td></tr></table></figure><h4 id="3-高级自定义配置"><a href="#3-高级自定义配置" class="headerlink" title="3. 高级自定义配置"></a>3. 高级自定义配置</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过环境变量指定主题</span></span><br><span class="line">oh-my-posh init pwsh --config <span class="string">&quot;<span class="variable">$env</span>:POSH_THEMES_PATH/jandedobbeleer.omp.json&quot;</span> | Invoke-Expression</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或使用绝对路径</span></span><br><span class="line">oh-my-posh init pwsh --config C:\Users\sfuli\scoop\apps\oh-my-posh\21.26.3\themes\jandedobbeleer.omp.json | Invoke-Expression</span><br></pre></td></tr></table></figure><h3 id="安装辅助模块"><a href="#安装辅助模块" class="headerlink" title="安装辅助模块"></a>安装辅助模块</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装必需模块</span></span><br><span class="line">scoop install psreadline posh-git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑 PowerShell 用户配置文件</span></span><br><span class="line">notepad <span class="variable">$PROFILE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加以下配置</span></span><br><span class="line">Set-Alias ll Get-ChildItem</span><br><span class="line">Import-Module posh-git</span><br><span class="line">Import-Module PSReadLine</span><br></pre></td></tr></table></figure><h2 id="字体与配色"><a href="#字体与配色" class="headerlink" title="字体与配色"></a>字体与配色</h2><h3 id="字体推荐"><a href="#字体推荐" class="headerlink" title="字体推荐"></a>字体推荐</h3><p>选择合适的字体是提升终端体验的重要环节。推荐以下字体：</p><ul><li><a href="https://github.com/be5invis/Sarasa-Gothic">更纱黑体</a>：<ul><li>中文部分使用思源黑体，英文部分使用 Iosevka，内置 Powerline 字符。</li><li>推荐下载 <code>scoop install sarasa-term-sc-nerd-font</code>，专为终端设计。</li><li>安装完成后，在 PowerShell 设置中选择该字体。</li></ul></li></ul><h3 id="配色方案"><a href="#配色方案" class="headerlink" title="配色方案"></a>配色方案</h3><p>微软推出了 <a href="https://github.com/Microsoft/console/tree/master/tools/ColorTool">ColorTool</a>，支持 iTerm2 配色方案文件。推荐使用 Argonaut 配色方案。</p><h4 id="1-安装-ColorTool"><a href="#1-安装-ColorTool" class="headerlink" title="1. 安装 ColorTool"></a>1. 安装 ColorTool</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 ColorTool</span></span><br><span class="line">scoop install ColorTool</span><br></pre></td></tr></table></figure><h4 id="2-配置-Argonaut-配色"><a href="#2-配置-Argonaut-配色" class="headerlink" title="2. 配置 Argonaut 配色"></a>2. 配置 Argonaut 配色</h4><p>将 <code>Argonaut.itermcolors</code> 文件放入 <code>schemes</code> 文件夹中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ColorTool.exe -b Argonaut.itermcolors</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="脚本执行权限"><a href="#脚本执行权限" class="headerlink" title="脚本执行权限"></a>脚本执行权限</h3><p>确保在“设置 &gt; 更新和安全 &gt; 开发者选项”中启用脚本执行。</p><h3 id="字体兼容性问题"><a href="#字体兼容性问题" class="headerlink" title="字体兼容性问题"></a>字体兼容性问题</h3><p>如果发现 oh-my-zsh 默认主题箭头符号（如 <code>➜</code>）无法显示，可通过注册表解决：</p><ul><li>在 <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\FontLink\SystemLink</code> 中添加多字符串值。</li><li>名称为 <code>Sarasa Term SC</code>，内容为：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MICROSS.TTF,Microsoft Sans Serif</span><br><span class="line">MSMINCHO.TTC,MS PMincho</span><br><span class="line">BATANG.TTC,Batang</span><br><span class="line">MSYH.TTC,Microsoft YaHei UI</span><br><span class="line">MALGUN.TTF,Malgun Gothic</span><br><span class="line">SEGUISYM.TTF,Segoe UI Symbol</span><br></pre></td></tr></table></figure><h3 id="配置保存"><a href="#配置保存" class="headerlink" title="配置保存"></a>配置保存</h3><p>完成设置后，请记得点击“确定”保存。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过上述步骤，你的 PowerShell 已焕然一新，拥有现代化的界面与增强的功能。无论是开发还是日常操作，都能获得更加高效、愉悦的体验。</p><script>var description="文章介绍了如何美化和优化Windows PowerShell界面及功能，包括安装工具、配置字体和配色等步骤。"</script>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scoop包管理器：Windows开发环境的得力助手</title>
      <link href="/p/de9f934c.html"/>
      <url>/p/de9f934c.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>Scoop 是一款运行在 Windows 平台上的命令行包管理器，可方便地管理开发环境和工具。通过 Scoop 安装的软件会自动添加到系统环境变量，用户可直接在命令行中使用。</p><h2 id="🔒-安装前提条件"><a href="#🔒-安装前提条件" class="headerlink" title="🔒 安装前提条件"></a>🔒 安装前提条件</h2><ol><li><p><strong>操作系统</strong>: Windows 7 SP1+ 或 Windows Server 2008+</p></li><li><p><strong>PowerShell 版本</strong>: 5.1 及以上，或 PowerShell Core</p></li><li><p><strong>.NET Framework</strong>: 4.5 及以上</p></li><li><p><strong>脚本执行权限</strong>:</p><ul><li><p>以管理员身份运行 PowerShell，执行以下命令启用本地脚本执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser</span><br><span class="line"> set-ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure></li><li><p>Windows Defender 快速添加信任名单：Powershell 管理员权限执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Add-MpPreference -ExclusionPath <span class="string">&quot;<span class="subst">$($env:programdata)</span>\scoop&quot;</span>, <span class="string">&quot;<span class="subst">$($env:scoop)</span>&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>要撤销此操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Remove-MpPreference -ExclusionPath <span class="string">&quot;<span class="subst">$($env:programdata)</span>\scoop&quot;</span>, <span class="string">&quot;<span class="subst">$($env:scoop)</span>&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h2 id="🔧-安装-Scoop"><a href="#🔧-安装-Scoop" class="headerlink" title="🔧 安装 Scoop"></a>🔧 安装 Scoop</h2><h3 id="🔍-官方安装方法"><a href="#🔍-官方安装方法" class="headerlink" title="🔍 官方安装方法"></a>🔍 官方安装方法</h3><ol><li><p>打开 PowerShell，执行以下命令安装 Scoop：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Expression (New-Object System.Net.WebClient).DownloadString(<span class="string">&#x27;https://get.scoop.sh&#x27;</span>)</span><br></pre></td></tr></table></figure><p>或简化为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iwr -useb get.scoop.sh | iex</span><br></pre></td></tr></table></figure></li><li><p><strong>自定义安装目录</strong> (可选):</p><ul><li>配置环境变量以更改默认路径：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$env</span>:SCOOP=<span class="string">&#x27;D:\dev\Scoop&#x27;</span></span><br><span class="line">[Environment]::SetEnvironmentVariable(<span class="string">&#x27;SCOOP&#x27;</span>, <span class="variable">$env</span>:SCOOP, <span class="string">&#x27;User&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable">$env</span>:SCOOP_GLOBAL=<span class="string">&#x27;D:\dev\ScoopGlobal&#x27;</span></span><br><span class="line">[Environment]::SetEnvironmentVariable(<span class="string">&#x27;SCOOP_GLOBAL&#x27;</span>, <span class="variable">$env</span>:SCOOP_GLOBAL, <span class="string">&#x27;Machine&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="🌐-国内镜像"><a href="#🌐-国内镜像" class="headerlink" title="🌐 国内镜像"></a>🌐 国内镜像</h3><ol><li><p><strong>替换 Scoop 源地址</strong>:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scoop config SCOOP_REPO https://gitee.com/squallliu/scoop</span><br><span class="line">scoop update</span><br></pre></td></tr></table></figure></li><li><p><strong>使用Github加速工具</strong>:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">irm https://raw.githubusercontent.com/duzyn/scoop-cn/master/install.ps1 | iex</span><br><span class="line"><span class="comment"># 管理员下执行</span></span><br><span class="line">iex <span class="string">&quot;&amp; &#123;<span class="subst">$(irm https://raw.githubusercontent.com/duzyn/scoop-cn/master/install.ps1)</span>&#125; -RunAsAdmin&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>替换默认的 Main 和 Extras 仓库</strong>:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把原来的 Scoop 仓库的地址换为代理后的地址。</span></span><br><span class="line">scoop config SCOOP_REPO  https://ghgo.xyz/https://github.com/ScoopInstaller/Scoop.git</span><br><span class="line"></span><br><span class="line">scoop bucket <span class="built_in">rm</span> main</span><br><span class="line">scoop bucket add main https://mirror.ghproxy.com/github.com/ScoopInstaller/Main</span><br><span class="line"></span><br><span class="line">scoop bucket <span class="built_in">rm</span> extras</span><br><span class="line">scoop bucket add extras https://ghgo.xyz/https://github.com/ScoopInstaller/Extras</span><br><span class="line"></span><br><span class="line">scoop bucket <span class="built_in">rm</span> versions</span><br><span class="line">scoop bucket add versions https://ghgo.xyz/https://github.com/ScoopInstaller/Versions</span><br></pre></td></tr></table></figure></li><li><p>scoop-cn库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">irm  https://scoop.201704.xyz -outfile <span class="string">&#x27;install.ps1&#x27;</span></span><br><span class="line">.\install.ps1 -ScoopDir <span class="string">&#x27;D:\scoop&#x27;</span> -ScoopGlobalDir <span class="string">&#x27;D:\scoop\GlobalApps&#x27;</span> -NoProxy -RunAsAdmin</span><br></pre></td></tr></table></figure></li></ol><h3 id="✨7-Zip-和-Git-加速"><a href="#✨7-Zip-和-Git-加速" class="headerlink" title="✨7-Zip 和 Git 加速"></a>✨7-Zip 和 Git 加速</h3><ol><li><p>Scoop安装成功后，会先下载 7-Zip 和 Git 来做后面的事，因为 <a href="https://www.7-zip.org/">7-Zip 的官网</a> 也是会偶尔无法访问，Git 下载地址在 <a href="https://github.com/git-for-windows/git/releases">GitHub Release</a>，此时下载又会失败</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scoop install https://ghgo.xyz/https://raw.githubusercontent.com/duzyn/scoop-cn/master/bucket/7zip.json</span><br><span class="line">scoop install https://ghgo.xyz/https://raw.githubusercontent.com/duzyn/scoop-cn/master/bucket/git.json</span><br><span class="line">scoop install https://ghgo.xyz/https://raw.githubusercontent.com/duzyn/scoop-cn/master/bucket/aria2.json</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="🔄-Scoop-基础功能"><a href="#🔄-Scoop-基础功能" class="headerlink" title="🔄 Scoop 基础功能"></a>🔄 Scoop 基础功能</h2><h3 id="⚡️-基本命令"><a href="#⚡️-基本命令" class="headerlink" title="⚡️ 基本命令"></a>⚡️ 基本命令</h3><table><thead><tr><th>命令</th><th>操作</th></tr></thead><tbody><tr><td>search</td><td>搜索软件名</td></tr><tr><td>install</td><td>安装软件</td></tr><tr><td>update</td><td>更新软件</td></tr><tr><td>status</td><td>查看软件状态</td></tr><tr><td>uninstall</td><td>卸载软件</td></tr><tr><td>info</td><td>查看软件详情</td></tr><tr><td>home</td><td>打开软件主页</td></tr></tbody></table><h3 id="🚀-多线程下载"><a href="#🚀-多线程下载" class="headerlink" title="🚀 多线程下载"></a>🚀 多线程下载</h3><ol><li><p><strong>安装 Aria2 并启用多线程</strong>:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scoop install aria2</span><br><span class="line">scoop config aria2-enabled <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>调整 Aria2 配置</strong> (可选，默认值与下面配置似):</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scoop config aria2-retry-wait 2</span><br><span class="line">scoop config aria2-split 5</span><br><span class="line">scoop config aria2-max-connection-per-server 5</span><br><span class="line">scoop config aria2-min-split-size 5M</span><br></pre></td></tr></table></figure></li></ol><h3 id="✅-检查问题"><a href="#✅-检查问题" class="headerlink" title="✅ 检查问题"></a>✅ 检查问题</h3><p>执行以下命令检查 Scoop 配置是否存在问题：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop checkup</span><br></pre></td></tr></table></figure><h3 id="🔐-持久化设置"><a href="#🔐-持久化设置" class="headerlink" title="🔐 持久化设置"></a>🔐 持久化设置</h3><p>Scoop 会自动将应用的配置信息存储在 <code>persist</code> 文件夹中，从而避免升级时数据丢失。</p><hr><h2 id="🌐-常用软件推荐"><a href="#🌐-常用软件推荐" class="headerlink" title="🌐 常用软件推荐"></a>🌐 常用软件推荐</h2><ol><li><strong>开发工具</strong>:<ul><li>Git，Maven，Node.js，Python，Java</li></ul></li><li><strong>生产力工具</strong>:<ul><li>Visual Studio Code，Typora，Snipaste</li></ul></li><li><strong>其他工具</strong>:<ul><li>Redis，Everything（文件搜索），PotPlayer（播放器）</li></ul></li></ol><hr><h2 id="🗂-Scoop-桶管理"><a href="#🗂-Scoop-桶管理" class="headerlink" title="🗂 Scoop 桶管理"></a>🗂 Scoop 桶管理</h2><h3 id="🌟-添加正式桶"><a href="#🌟-添加正式桶" class="headerlink" title="🌟 添加正式桶"></a>🌟 添加正式桶</h3><p>使用以下命令添加 Scoop 官方桶：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># scoop bucket known 查询官方桶</span></span><br><span class="line">scoop bucket add extras</span><br><span class="line">scoop bucket add versions</span><br></pre></td></tr></table></figure><h3 id="🎮-添加第三方桶"><a href="#🎮-添加第三方桶" class="headerlink" title="🎮 添加第三方桶"></a>🎮 添加第三方桶</h3><p>使用以下命令添加第三方桶：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scoop bucket add scoop-cn https://ghgo.xyz/https://github.com/duzyn/scoop-cn</span><br><span class="line">scoop bucket add apps https://ghgo.xyz/https://https://github.com/kkzzhizhou/scoop-apps</span><br></pre></td></tr></table></figure><h3 id="📝-创建自定义桶"><a href="#📝-创建自定义桶" class="headerlink" title="📝 创建自定义桶"></a>📝 创建自定义桶</h3><ol><li>在 GitHub 创建仓库并按规则添加 JSON 配置文件。</li><li>将该 Git 仓库配置为本地桶：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop bucket add mybucket https://github.com/yourusername/mybucket</span><br></pre></td></tr></table></figure></li></ol><h2 id="🧩SourceTree启动问题"><a href="#🧩SourceTree启动问题" class="headerlink" title="🧩SourceTree启动问题"></a>🧩SourceTree启动问题</h2><ul><li><p><code>ssh-agent&quot;失败，错误代码：-1：System.Exception: Unable to to start</code></p></li><li><p>原因： scoop安装的git会导致sourceTree 的 git.exe 路径不正确</p></li><li><p>解决办法：修改内嵌git为本地版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mklink /J %userprofile%\AppData\Local\Atlassian\SourceTree\git_local %scoop%\apps\git\current</span><br></pre></td></tr></table></figure></li></ul><script>var description="文章介绍了Scoop命令行包管理器在Windows上的安装、配置及使用方法。"</script>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scoop </tag>
            
            <tag> 软件下载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows常用软件</title>
      <link href="/p/35390aee.html"/>
      <url>/p/35390aee.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li><p>软件推荐官网下载。下载后手动指定位置，注意目录不要带空格。</p></li><li><p>不推荐使用 <code>\Program Files</code>,推荐新建目录放到 <code>\Programs</code>下。</p></li><li><p>常用链接</p><ul><li><a href="http://soft.qq.com/">腾讯软件管理</a></li><li><a href="http://www.sousou88.com/">嗖嗖下载-提供官方软件下载</a></li><li><a href="http://www.rjsos.com/">软件SOS<em>玩机手册，软件安装管家</em>软件激活工具下载 (rjsos.com)</a></li><li><a href="https://www.gopojie.com/">狗破解-Go破解|GoPoJie.COM-破解软件,源码,素材,游戏,系统,分享下载！</a></li><li><a href="https://toolwa.com/github/">GitHub 加速下载 - 在线工具 (toolwa.com)</a></li><li><a href="https://shrill-pond-3e81.hunsh.workers.dev/">GitHub 文件加速 (hunsh.workers.dev)</a></li><li></li></ul></li></ul><h2 id="浏览器篇"><a href="#浏览器篇" class="headerlink" title="浏览器篇"></a>浏览器篇</h2><h3 id="书签管理"><a href="#书签管理" class="headerlink" title="书签管理"></a>书签管理</h3><ul><li><p>链接: <a href="https://chrome.google.com/webstore/detail/bookmarks-clean-up/oncbjlgldmiagjophlhobkogeladjijl">Bookmarks clean up</a></p></li><li><p>Chrome删除大量重复书签：由于Bookmarks clean up 展示完重复书签，不能自动选，而需要用户手动选中<br>如果书签量很大的话，就需要大量的工作了，下面代码功能就是自动选中其他书签</p></li><li><p>打开Bookmarks clean up -&gt; Find duplicated bookmarks -&gt; 打开Chrome 控制台 -&gt; 控制台输入下面代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dupArray = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;duplicate card&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt;dupArray.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> items = dupArray[i].<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;list-group-item&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (items.<span class="property">length</span> &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 默认设置第一个以外的item选中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt; items.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">var</span> item = items[j];</span><br><span class="line">      <span class="keyword">var</span> checkbox = item.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;custom-control-input&quot;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(checkbox);</span><br><span class="line">      checkbox.<span class="title function_">item</span>(<span class="number">0</span>).<span class="title function_">click</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="office"><a href="#office" class="headerlink" title="office"></a>office</h2><h3 id="更改安装路径"><a href="#更改安装路径" class="headerlink" title="更改安装路径"></a>更改安装路径</h3><ul><li>Office安装过程中是没有办法自定义路径的，默认情况下64位会安装到C:\Program Files\当中。但是我们可以通过障眼法让Office以为安装到了C盘当中。</li><li>可以使用NTFS文件系统的目录联接，我们可以在D盘创建一个目录，然后联接到C盘。这样所有对C盘的更改都会存储到D盘当中。</li><li>首先，创建 <code>D:\Programs\Microsoft Office</code>目录，这是我准备用来安装Office的目录。</li><li>管理员方式打开CMD，使用mklink命令联结到C盘<ul><li><code>mklink /J &quot;C:\Program Files\Microsoft Office&quot; &quot;D:\Programs\Microsoft Office&quot;</code></li></ul></li><li>检查C:\Program Files\可以发现多了一个Microsoft Office文件夹。</li><li>创建完文件夹联接就可以大胆的安装Office了</li></ul><h2 id="开发软件"><a href="#开发软件" class="headerlink" title="开发软件"></a>开发软件</h2><ul><li>开发软件一般需要下载安装包，解压后配置环境变量，有些软件还需要编译。windows并没有官方的类似brew yum rpm之类的包管理器。</li><li>不过github上有<a href="https://github.com/lukesampson/scoop">Scoop</a>和<a href="https://chocolatey.org/install">Chocolatey</a> 二个热度不错的管理器。这里推荐使用scoop(可以自定义目录)，安装软件还是对网络有要求。</li></ul><h3 id="IDEA-key"><a href="#IDEA-key" class="headerlink" title="IDEA key"></a>IDEA key</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MZEJUONTQS-eyJsaWNlbnNlSWQiOiJNWkVKVU9OVFFTIiwibGljZW5zZWVOYW1lIjoi5rC45LmF5r+A5rS7IHd3d8K3YWppaHVvwrdjb20iLCJhc3NpZ25lZU5hbWUiOiIiLCJhc3NpZ25lZUVtYWlsIjoiIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiIiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJJSSIsInBhaWRVcFRvIjoiMjAyMi0wNy0yMyIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUERCIiwicGFpZFVwVG8iOiIyMDIyLTA3LTIzIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBXUyIsInBhaWRVcFRvIjoiMjAyMi0wNy0yMyIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQR08iLCJwYWlkVXBUbyI6IjIwMjItMDctMjMiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFBTIiwicGFpZFVwVG8iOiIyMDIyLTA3LTIzIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBQQyIsInBhaWRVcFRvIjoiMjAyMi0wNy0yMyIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQUkIiLCJwYWlkVXBUbyI6IjIwMjItMDctMjMiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFNXIiwicGFpZFVwVG8iOiIyMDIyLTA3LTIzIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBTSSIsInBhaWRVcFRvIjoiMjAyMi0wNy0yMyIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQQ1dNUCIsInBhaWRVcFRvIjoiMjAyMi0wNy0yMyIsImV4dGVuZGVkIjp0cnVlfV0sIm1ldGFkYXRhIjoiMDEyMDIyMDYyNFBTQU0wMDAwMDUiLCJoYXNoIjoiMzUyMzcyODQvMDotMTM3MTYxNTczNiIsImdyYWNlUGVyaW9kRGF5cyI6NywiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-uWLydisVSyUkURq32vZUasJ/H37LCTSTVDs/o5guGCwR4Tk757t+Eoyl+/YfXvQeFnfRFJKnkmcCQTkN8VtAmO9VJvjQbsq2nstp8/G5EU8bBn2Z5HCX00f6NBb/7a+1J3WfuJyj36vFzjj1c7uBv3KFH+jcqJTeSZlgw5uYBygQeH7oCv2f/9f4Ep0vjNaFw6Z9LvCkC+NFHMGXCDeAT3t0Gt60kML6iuGXnpLKp3mvKS8d42XjEnw57eEjFovOMbc3aiYdZMGeP6JTT4r7TeAXVTyN3Cjdd7diTOZphEpj8pId1BZqGm/QBA9rsUuh0fBnYjvcigkyODjacte1ug==-MIIETDCCAjSgAwIBAgIBDTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIwMTAxOTA5MDU1M1oXDTIyMTAyMTA5MDU1M1owHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMDEwMTkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDCP4uk4SlVdA5nuA3DQC+NsEnZS9npFnO0zrmMWcz1++q2UWJNuGTh0rwi+3fUJIArfvVh7gNtIp93rxjtrQAuf4/Fa6sySp4c32MeFACfC0q+oUoWebhOIaYTYUxm4LAZ355vzt8YeDPmvWKxA81udqEk4gU9NNAOz1Um5/8LyR8SGsSc4EDBRSjcMWMwMkYSauGqGcEUK8WhfplsyF61lKSOFA6VmfUmeDK15rUWWLbOMKgn2cxFA98A+s74T9Oo96CU7rp/umDXvhnyhAXSukw/qCGOVhwKR8B6aeDtoBWQgjnvMtPgOUPRTPkPGbwPwwDkvAHYiuKJ7Bd2wH7rAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBgNVHQ4EFgQUJNoRIpb1hUHAk0foMSNM9MCEAv8wSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBAB2J1ysRudbkqmkUFK8xqhiZaYPd30TlmCmSAaGJ0eBpvkVeqA2jGYhAQRqFiAlFC63JKvWvRZO1iRuWCEfUMkdqQ9VQPXziE/BlsOIgrL6RlJfuFcEZ8TK3syIfIGQZNCxYhLLUuet2HE6LJYPQ5c0jH4kDooRpcVZ4rBxNwddpctUO2te9UU5/FjhioZQsPvd92qOTsV+8Cyl2fvNhNKD1Uu9ff5AkVIQn4JU23ozdB/R5oUlebwaTE6WZNBs+TA/qPj+5/wi9NH71WRB0hqUoLI2AKKyiPw++FtN4Su1vsdDlrAzDj9ILjpjJKA1ImuVcG329/WTYIKysZ1CWK3zATg9BeCUPAV1pQy8ToXOq+RSYen6winZ2OO93eyHv2Iw5kbn1dqfBw1BuTE29V2FJKicJSu8iEOpfoafwJISXmz1wnnWL3V/0NxTulfWsXugOoLfv0ZIBP1xH9kmf22jjQ2JiHhQZP7ZDsreRrOeIQ/c4yR8IQvMLfC0WKQqrHu5ZzXTH4NO3CwGWSlTY74kE91zXB5mwWAx1jig+UXYc2w4RkVhy0//lOmVya/PEepuuTTI4+UJwC7qbVlh5zfhj8oTNUXgN0AOc+Q0/WFPl1aw5VV/VrO8FCoB15lFVlpKaQ1Yh+DVU8ke+rt9Th0BCHXe0uZOEmH0nOnH/0onD</span><br></pre></td></tr></table></figure><h2 id="镜像地址"><a href="#镜像地址" class="headerlink" title="镜像地址"></a>镜像地址</h2><h3 id="公司类"><a href="#公司类" class="headerlink" title="公司类"></a>公司类</h3><ul><li>搜狐开源镜像站：<a href="http://mirrors.sohu.com/">http://mirrors.sohu.com/</a></li><li>网易开源镜像站：<a href="http://mirrors.163.com/">http://mirrors.163.com/</a></li><li>开源中国：<a href="http://mirrors.oschina.net/">http://mirrors.oschina.net/</a></li><li>首都在线科技股份有限公司：<a href="http://mirrors.yun-idc.com/">http://mirrors.yun-idc.com/</a></li><li>阿里云开源镜像：<a href="http://mirrors.aliyun.com/">http://mirrors.aliyun.com/</a></li><li>LUPA：<a href="http://mirror.lupaworld.com/">http://mirror.lupaworld.com/</a></li><li>常州贝特康姆软件技术有限公司(原cn99）：<a href="http://centos.bitcomm.cn/">http://centos.bitcomm.cn/</a></li></ul><h3 id="大学类"><a href="#大学类" class="headerlink" title="大学类"></a>大学类</h3><ul><li>中山大学镜像：<a href="http://mirror.sysu.edu.cn/">http://mirror.sysu.edu.cn/</a></li><li>山东理工大学：<a href="http://mirrors.sdutlinux.org/">http://mirrors.sdutlinux.org/</a></li><li>哈尔滨工业大学：<a href="http://run.hit.edu.cn/">http://run.hit.edu.cn/</a></li><li>中国地质大学：<a href="http://cugbteam.org/">http://cugbteam.org/</a></li><li>大连理工大学：<a href="http://mirror.dlut.edu.cn/">http://mirror.dlut.edu.cn/</a></li><li>西南林业大学 <a href="http://cs3.swfu.edu.cn/cs3guide.html">http://cs3.swfu.edu.cn/cs3guide.html</a></li><li>北京化工大学（仅教育网可以访问），包含 CentOS 镜像：<a href="http://ubuntu.buct.edu.cn/">http://ubuntu.buct.edu.cn/</a></li><li>天津大学：<a href="http://mirror.tju.edu.cn/">http://mirror.tju.edu.cn/</a></li><li>西南大学：<a href="http://linux.swu.edu.cn/swudownload/Distributions/">http://linux.swu.edu.cn/swudownload/Distributions/</a></li><li>青岛大学：<a href="http://mirror.qdu.edu.cn/">http://mirror.qdu.edu.cn/</a></li><li>南京师范大学：<a href="http://mirrors.njnu.edu.cn/">http://mirrors.njnu.edu.cn/</a></li><li>大连东软信息学院： <a href="http://mirrors.neusoft.edu.cn/">http://mirrors.neusoft.edu.cn/</a></li><li>浙江大学：<a href="http://mirrors.zju.edu.cn/">http://mirrors.zju.edu.cn/</a></li><li>兰州大学：<a href="http://mirror.lzu.edu.cn/">http://mirror.lzu.edu.cn/</a></li><li>厦门大学：<a href="http://mirrors.xmu.edu.cn/">http://mirrors.xmu.edu.cn/</a></li><li>北京理工大学：<br><a href="http://mirror.bit.edu.cn/">http://mirror.bit.edu.cn</a> (IPv4 only)<br><a href="http://mirror.bit6.edu.cn/">http://mirror.bit6.edu.cn</a> (IPv6 only)</li><li>北京交通大学：<br><a href="http://mirror.bjtu.edu.cn/">http://mirror.bjtu.edu.cn</a> (IPv4 only)<br><a href="http://mirror6.bjtu.edu.cn/">http://mirror6.bjtu.edu.cn</a> (IPv6 only)<br><a href="http://debian.bjtu.edu.cn/">http://debian.bjtu.edu.cn</a> (IPv4+IPv6)</li><li>上海交通大学：<br><a href="http://ftp.sjtu.edu.cn/">http://ftp.sjtu.edu.cn/</a> (IPv4 only)<br><a href="http://ftp6.sjtu.edu.cn/">http://ftp6.sjtu.edu.cn</a> (IPv6 only)</li><li>清华大学：<br><a href="http://mirrors.tuna.tsinghua.edu.cn/">http://mirrors.tuna.tsinghua.edu.cn/</a> (IPv4+IPv6)<br><a href="http://mirrors.6.tuna.tsinghua.edu.cn/">http://mirrors.6.tuna.tsinghua.edu.cn/</a> (IPv6 only)<br><a href="http://mirrors.4.tuna.tsinghua.edu.cn/">http://mirrors.4.tuna.tsinghua.edu.cn/</a> (IPv4 only)</li><li>中国科学技术大学：<br><a href="http://mirrors.ustc.edu.cn/">http://mirrors.ustc.edu.cn/</a> (IPv4+IPv6)<br><a href="http://mirrors4.ustc.edu.cn/">http://mirrors4.ustc.edu.cn/</a><br><a href="http://mirrors6.ustc.edu.cn/">http://mirrors6.ustc.edu.cn/</a></li><li>东北大学：<br><a href="http://mirror.neu.edu.cn/">http://mirror.neu.edu.cn/</a> (IPv4 only)<br><a href="http://mirror.neu6.edu.cn/">http://mirror.neu6.edu.cn/</a> (IPv6 only)</li><li>华中科技大学：<br><a href="http://mirrors.hust.edu.cn/">http://mirrors.hust.edu.cn/</a><br><a href="http://mirrors.hustunique.com/">http://mirrors.hustunique.com/</a></li><li>电子科技大学：<a href="http://ubuntu.uestc.edu.cn/">http://ubuntu.uestc.edu.cn/</a><br>电子科大凝聚工作室(Raspbian单一系统镜像) <a href="http://raspbian.cnssuestc.org/">http://raspbian.cnssuestc.org/</a><br>电子科大星辰工作室(少数小众发布版镜像) <a href="http://mirrors.stuhome.net/">http://mirrors.stuhome.net/</a></li></ul><hr><h3 id="PyPi-镜像"><a href="#PyPi-镜像" class="headerlink" title="PyPi 镜像"></a>PyPi 镜像</h3><ul><li>豆瓣：<a href="http://pypi.douban.com/">http://pypi.douban.com/</a></li><li>山东理工大学：<a href="http://pypi.sdutlinux.org/">http://pypi.sdutlinux.org/</a></li><li>中山大学：<a href="http://mirror.sysu.edu.cn/pypi/">http://mirror.sysu.edu.cn/pypi/</a></li><li>V2EX：<a href="http://pypi.v2ex.com/simple/">http://pypi.v2ex.com/simple/</a></li></ul><h3 id="RubyGems-镜像"><a href="#RubyGems-镜像" class="headerlink" title="RubyGems 镜像"></a>RubyGems 镜像</h3><ul><li>中山大学：<a href="http://mirror.sysu.edu.cn/rubygems/">http://mirror.sysu.edu.cn/rubygems/</a></li><li>山东理工大学：<a href="http://ruby.sdutlinux.org/">http://ruby.sdutlinux.org/</a></li><li>淘宝网：<a href="http://ruby.taobao.org/">http://ruby.taobao.org/</a></li></ul><h3 id="npm-镜像"><a href="#npm-镜像" class="headerlink" title="npm 镜像"></a>npm 镜像</h3><p>cnpmjs：<a href="http://cnpmjs.org/">http://cnpmjs.org/</a></p><h2 id="收藏夹"><a href="#收藏夹" class="headerlink" title="收藏夹"></a>收藏夹</h2><blockquote><p>以下内容来源于网络,如有侵权,请联系删除。</p></blockquote><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><table><thead><tr><th>说明</th><th>链接</th><th>密码</th></tr></thead><tbody><tr><td>浏览器</td><td><a href="https://www.lanzoui.com/b059xfcbg">蓝奏云 </a></td><td>密码:adqe</td></tr><tr><td>视频播放器</td><td><a href="https://www.lanzoui.com/b059xfcoj">蓝奏云</a></td><td>密码:bqrv</td></tr><tr><td>下载软件</td><td><a href="https://www.lanzoui.com/b059xfdja">蓝奏云</a> <a href="https://www.lanzoui.com/b059ywbob">IDM 密码:gh92</a></td><td>密码:b783</td></tr><tr><td>压缩软件</td><td><a href="https://www.lanzoui.com/b059xfghg">蓝奏云</a></td><td>密码:7wgq</td></tr><tr><td>网络代理</td><td><a href="https://www.lanzoui.com/b059xfgji">蓝奏云</a></td><td>密码:i3f4</td></tr><tr><td>卸载工具</td><td><a href="https://www.lanzoui.com/b059xfnyf">蓝奏云</a></td><td>密码:dnlg</td></tr><tr><td>SSH工具</td><td><a href="https://www.lanzoui.com/b059xgjoh">蓝奏云</a></td><td>密码:fpkp</td></tr><tr><td>云笔记</td><td><a href="https://www.lanzoui.com/b059xgr4f">蓝奏云</a></td><td>密码:51u2</td></tr><tr><td>文本编辑</td><td><a href="https://www.lanzoui.com/b059xi9sd">蓝奏云</a></td><td>密码:byyk</td></tr><tr><td>远程连接</td><td><a href="https://www.lanzoui.com/b059xi9te">蓝奏云</a></td><td>密码:4q5y</td></tr><tr><td>Visual C++ 2015-2019</td><td><a href="https://www.lanzoui.com/b059yr7zi">蓝奏云</a></td><td>密码:6w4j</td></tr><tr><td>Office 365&amp;系统激活</td><td><a href="https://www.lanzoui.com/b059yr8wb">蓝奏云</a></td><td>密码:d3u1</td></tr><tr><td>蓝奏云盘</td><td><a href="https://www.lanzoui.com/b059ywbkh">蓝奏云</a></td><td>密码:dg5p</td></tr><tr><td>图片压缩</td><td><a href="https://www.lanzoui.com/b059ywc1e">蓝奏云</a></td><td>密码:2xvz</td></tr><tr><td>2345看图王</td><td><a href="https://www.lanzoui.com/b059ywc0d">蓝奏云</a></td><td>密码:i8tn</td></tr><tr><td>内存优化</td><td><a href="https://www.lanzoui.com/b059ywvxa">蓝奏云</a></td><td>密码:c79o</td></tr><tr><td>QuickLook</td><td><a href="https://www.lanzoui.com/b059ywxqf">蓝奏云</a></td><td>密码:fw5x</td></tr><tr><td>分区助手</td><td><a href="https://www.lanzoui.com/b059ywxze">蓝奏云</a></td><td>密码:ekfv</td></tr><tr><td><a href="https://www.123pan.com/s/maH9-cpl9d">win11状态栏调整-汉化-ExplorerPatcher</a></td><td></td><td></td></tr><tr><td><a href="https://www.123pan.com/s/maH9-epl9d">WinRAR v5.90 x64</a></td><td></td><td></td></tr><tr><td><a href="https://www.123pan.com/s/maH9-tpl9d">typora1.4.8</a></td><td></td><td></td></tr><tr><td><a href="https://www.123pan.com/s/maH9-ipl9d">123网盘PC</a></td><td></td><td></td></tr></tbody></table><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><table><thead><tr><th>说明</th><th>链接</th><th>备注</th></tr></thead><tbody><tr><td>Vmware虚拟机</td><td><a href="https://www.lanzoui.com/b059ywcqj">蓝奏云</a></td><td>密码:9kqw</td></tr><tr><td>VMware-workstation-full-17.0.0-20800274</td><td><a href="https://www.123pan.com/s/maH9-9fl9d">VMware-workstation-full-17.0.0-20800274</a></td><td>激活码 <code>JU090-6039P-08409-8J0QH-2YR7F</code></td></tr><tr><td>SSH工具</td><td><a href="https://www.lanzoui.com/b059ywjyj">蓝奏云</a></td><td>密码:bfd3</td></tr><tr><td>Navicat</td><td><a href="https://www.lanzoui.com/b059yx19c">蓝奏云</a></td><td>密码:39ud</td></tr></tbody></table><h3 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h3><table><thead><tr><th>说明</th><th>链接</th><th>密码</th></tr></thead><tbody><tr><td>系统清理</td><td><a href="https://www.lanzoui.com/b059xeqyh">蓝奏云</a></td><td>密码:99pn</td></tr><tr><td>解压软件</td><td><a href="https://www.lanzoui.com/b059xet0b">蓝奏云</a></td><td>密码:7ngo</td></tr><tr><td>MWeb Markdown编辑器</td><td><a href="https://www.lanzoui.com/b059xi9rc">蓝奏云</a></td><td>密码:5xxu</td></tr><tr><td>系统备份</td><td><a href="https://www.lanzoui.com/b059xi9oj">蓝奏云</a></td><td>密码:cqhb</td></tr></tbody></table><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><table><thead><tr><th></th><th>链接</th><th>密码</th></tr></thead><tbody><tr><td>WPS Office</td><td><a href="https://www.lanzoui.com/b059wiceb">蓝奏云</a></td><td>密码:29fq</td></tr><tr><td>英语相关</td><td><a href="https://www.lanzoui.com/b059wijva">蓝奏云</a></td><td>密码:8hvb</td></tr><tr><td>QQ音乐</td><td><a href="https://www.lanzoui.com/b059xhdng">蓝奏云</a></td><td>密码:9mdw</td></tr></tbody></table><script>var description="软件推荐官网下载。下载后手动指定位置，注意目录不要带空格。"</script>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows系统设置</title>
      <link href="/p/d4131f31.html"/>
      <url>/p/d4131f31.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="安装篇"><a href="#安装篇" class="headerlink" title="安装篇"></a>安装篇</h2><h3 id="迁移用户目录"><a href="#迁移用户目录" class="headerlink" title="迁移用户目录"></a>迁移用户目录</h3><h4 id="初始安装迁移"><a href="#初始安装迁移" class="headerlink" title="初始安装迁移"></a>初始安装迁移</h4><ul><li><p>安装上 windows，重启电脑之后，当进入<strong>区域选择界面</strong>时，按下 <code>Ctrl Shift F3</code> ，这时 windows 会重启，进入 Audit Mode，然后显示一个 <code>System Preparation Tool</code>，将它关闭。</p><p><img src="/p/d4131f31/84be9596d1e4c426f621244d26f2fa2c.jpg"></p></li><li><p>接下来我们要使用 <code>System Preparation Tool</code> (Sysprep) 工具来设置用户路径。这个工具会执行一个 xml 文件中的配置（也就是 <code>unattended answer file</code>）</p></li><li><p>我们现在只需要一个非常简单的 answer file，只需包含以下内容：</p><ul><li>windows 的版本（32 或 64 bit）</li><li>用户文件夹的新路径（例如 M:&#x2F;Users）</li></ul></li><li><p>现在打开 Notepad，将下列代码粘贴进去：一定注意里面的 <code>amd64</code>和 <code>D:\Users</code>根据自己实际情况进行调整。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">unattend</span> <span class="attr">xmlns</span>=<span class="string">&quot;urn:schemas-microsoft-com:unattend&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span> <span class="attr">pass</span>=<span class="string">&quot;oobeSystem&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">&quot;Microsoft-Windows-Shell-Setup&quot;</span> <span class="attr">processorArchitecture</span>=<span class="string">&quot;amd64&quot;</span> <span class="attr">publicKeyToken</span>=<span class="string">&quot;31bf3856ad364e35&quot;</span> <span class="attr">language</span>=<span class="string">&quot;neutral&quot;</span> <span class="attr">versionScope</span>=<span class="string">&quot;nonSxS&quot;</span> <span class="attr">xmlns:wcm</span>=<span class="string">&quot;http://schemas.microsoft.com/WMIConfig/2002/State&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">FolderLocations</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ProfilesDirectory</span>&gt;</span>D:\Users<span class="tag">&lt;/<span class="name">ProfilesDirectory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">FolderLocations</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">unattend</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>将这个 xml 文件保存到磁盘根目录（不能是 C 盘），例如我把它保存到了：<code>D:\relocate.xml</code></p></li><li><p>以管理员模式运行 cmd ，首先，确保 WMP Network Sharing Service 已停止运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net stop wmpnetworksvc</span><br></pre></td></tr></table></figure></li><li><p>然后运行然下后列运命,<strong>特别注意</strong>:这里的命令中的 <code>d:\relocate.xml</code>是将relocate.xml放在了D盘根目录，请根据具体情况做相应调整再执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">windir%\system32\sysprep\sysprep.exe /oobe /reboot /unattend:d:\relocate.xml</span></span><br></pre></td></tr></table></figure></li><li><p>上述命令告诉系统从 <code>Windows\System32\Sysprep</code> 运行 Sysprep，执行 <code>D:/relocate.xml</code> 中的指令，为 <code>OOBE（the firlst boot of newly installed Windows）</code> 重启准备系统，最后重启。</p></li></ul><h4 id="备份迁移方式"><a href="#备份迁移方式" class="headerlink" title="备份迁移方式"></a>备份迁移方式</h4><ul><li><p>对于已安装使用的系统也可以迁移<strong>：执行这个操作之前，一定要先创建一个系统映像，做好备份。</strong></p></li><li><p>同上，新建一个 unattended answer file，保存为 D:\relocate.xml，运行 Sysprep</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net stop wmpnetworksvc</span><br><span class="line">%windir%\system32\sysprep\sysprep.exe /oobe /reboot /unattend:d:\relocate.xml</span><br></pre></td></tr></table></figure></li><li><p>虽然你已经安装了 Win10，但是在 Sysprep 运行之后 OOBE 仍然会运行，这意味着你的电脑会经历初始化程序。</p></li><li><p>这里有两点需要注意：</p><ul><li>尽管 windows 要求你输入产品密钥，但是你不需要去输入，单击跳过就行了</li><li>你之前的账户还会存在，但是 OOBE 会要求你新建一个用户，如果你新建的这个用户和已存在的用户名字相同，那就会发生错误。</li><li>你只需要新建一个随意的账户，之后，再把他删掉就可以了</li></ul></li></ul><h2 id="设置篇"><a href="#设置篇" class="headerlink" title="设置篇"></a>设置篇</h2><h3 id="时间设置为UTC"><a href="#时间设置为UTC" class="headerlink" title="时间设置为UTC"></a>时间设置为UTC</h3><ul><li><p>让 Windows 把硬件时间当作 UTC</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Reg add HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="电源模式"><a href="#电源模式" class="headerlink" title="电源模式"></a>电源模式</h3><ul><li><p>使用高性能或者卓越模式</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powercfg <span class="literal">-duplicatescheme</span> e9a42b02<span class="literal">-d5df-448d-aa00-03f14749eb61</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="系统保护"><a href="#系统保护" class="headerlink" title="系统保护"></a>系统保护</h3><ul><li>虽然windows的<strong>重置</strong>功能很好用，但是环境安装又需要来一遍。</li><li>解决方案，环境放到虚拟机内（体验不好）</li><li>开启系统还原点，win+Q 搜索 “<strong>还原点</strong>”，进入系统保护 - 选择配置 - 创建还原点 。 养成定时备份的习惯，需要的时候使用系统还原回到创建点(部分软件丢失)。</li><li>公司电脑注意点,可能会掉域（我试过，找IT重装解决）。</li></ul><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><ul><li>内存够大的忽略。不能解决内存不够的问题，在程序申请内存的时候不会报错</li><li>位置：win+Q 搜索“性能”</li><li>合理值：1.5~3 倍 如8G : 12288M ~ 24576M</li></ul><h2 id="命令篇"><a href="#命令篇" class="headerlink" title="命令篇"></a>命令篇</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>calc</td><td>启动计算器</td></tr><tr><td>charmap</td><td>启动字符映射表</td></tr><tr><td>chkdsk.exe</td><td>Chkdsk磁盘检查</td></tr><tr><td>cleanmgr</td><td>打开磁盘清理工具</td></tr><tr><td>cmd.exe</td><td>CMD命令提示符</td></tr><tr><td>compmgmt.msc</td><td>计算机管理</td></tr><tr><td>conf</td><td>启动系统配置实用程序</td></tr><tr><td>dcomcnfg</td><td>打开系统组件服务</td></tr><tr><td>devmgmt.msc</td><td>设备管理器</td></tr><tr><td>dfrg.msc</td><td>磁盘碎片整理程序</td></tr><tr><td>diskmgmt.msc</td><td>磁盘管理实用程序</td></tr><tr><td>eventvwr</td><td>事件查看器</td></tr><tr><td>explorer</td><td>打开资源管理器</td></tr><tr><td>fsmgmt.msc</td><td>共享文件夹管理器</td></tr><tr><td>gpedit.msc</td><td>组策略</td></tr><tr><td>logoff</td><td>注销命令</td></tr><tr><td>lusrmgr.msc</td><td>本机用户和组</td></tr><tr><td>magnify</td><td>放大镜实用程序</td></tr><tr><td>MdSched</td><td>启动Windows内存诊断程序</td></tr><tr><td>mmc</td><td>打开控制台</td></tr><tr><td>mobsync</td><td>同步命令</td></tr><tr><td>Msconfig.exe</td><td>系统配置实用程序</td></tr><tr><td>mspaint</td><td>画图板</td></tr><tr><td>mstsc</td><td>远程桌面连接</td></tr><tr><td>notepad</td><td>打开记事本</td></tr><tr><td>nslookup</td><td>网络管理的工具向导</td></tr><tr><td>OptionalFeatures</td><td>打开“打开或关闭Windows功能”对话框</td></tr><tr><td>osk</td><td>打开屏幕键盘</td></tr><tr><td>perfmon.msc</td><td>计算机性能监测程序</td></tr><tr><td>regedit.exe</td><td>注册表</td></tr><tr><td>regedt32</td><td>注册表编辑器</td></tr><tr><td>rsop.msc</td><td>组策略结果集</td></tr><tr><td>services.msc</td><td>本地服务设置</td></tr><tr><td>shrpubw</td><td>创建共享文件夹</td></tr><tr><td>sigverif</td><td>文件签名验证程序</td></tr><tr><td>sysedit</td><td>系统配置编辑器</td></tr></tbody></table><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://ld246.com/article/1599457575130">改变 Windows 用户文件夹默认路径 (C:&#x2F;Users)</a></li></ul><script>var description="文章介绍了Windows系统迁移用户目录的方法及设置建议。"</script>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/p/4a17b156.html"/>
      <url>/p/4a17b156.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>你好。当能看到这个页面的时候，表示我的博客正式生成了。<br>本站所有文章和源码均免费开放，如您喜欢，可以请我喝杯☕<br>有问题请留言，收到后会逐一回复，谢谢~</p><p>欢迎转载，请在文章页面明显位置给出原文连接。<br>最后，感谢您在茫茫文海中阅读了我的文章。(^__^) Y……</p></blockquote><h2 id="网站推荐"><a href="#网站推荐" class="headerlink" title="网站推荐"></a>网站推荐</h2><ul><li>学习英语GPT <a href="https://pi.ai/onboarding">Pi, your personal AI</a></li></ul><h2 id="Contact"><a href="#Contact" class="headerlink" title="Contact"></a>Contact</h2><p><strong>Personal</strong> ：本人95后，2015年毕业至今，从事 JAVA 开发，喜欢涉猎新事物… 希望有一天可以赚很多的钱，去干够风骚且有意义的事情。</p><ul><li>Email: <a href="mailto:&#x66;&#x6c;&#x5f;&#x36;&#49;&#52;&#x35;&#64;&#x31;&#54;&#x33;&#x2e;&#x63;&#x6f;&#x6d;">&#x66;&#x6c;&#x5f;&#x36;&#49;&#52;&#x35;&#64;&#x31;&#54;&#x33;&#x2e;&#x63;&#x6f;&#x6d;</a></li><li>GitHub: <a href="https://github.com/fulsun">https://github.com/fulsun</a></li></ul><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><h3 id="2021年"><a href="#2021年" class="headerlink" title="2021年"></a>2021年</h3><h4 id="06月"><a href="#06月" class="headerlink" title="06月"></a>06月</h4><ul><li>主题版本更新到 3.7.1</li><li>全局&amp;页脚 背景透明渐变</li><li>添加<a href="/talking/">说说</a>模块</li></ul><h4 id="05月"><a href="#05月" class="headerlink" title="05月"></a>05月</h4><ul><li>国庆后，回到上海进入新项目</li><li>办理手续，熟悉项目</li></ul><h4 id="04月"><a href="#04月" class="headerlink" title="04月"></a>04月</h4><ul><li>新项目一期的开发工作结束。</li><li>准备面试新的项目组</li><li>4月中旬面上项目，交接工作。</li></ul><h4 id="02-03月"><a href="#02-03月" class="headerlink" title="02-03月"></a>02-03月</h4><ul><li>相亲：失败告终</li><li>这是自信心被打击的一个月</li></ul><h4 id="01月"><a href="#01月" class="headerlink" title="01月"></a>01月</h4><ul><li>祝大家新年快乐🎉🎉🎉！</li><li>删除了文章下的评论（打开影响速度）</li></ul><h3 id="2020年"><a href="#2020年" class="headerlink" title="2020年"></a>2020年</h3><h4 id="12月"><a href="#12月" class="headerlink" title="12月"></a>12月</h4><ul><li>11月份工作交接，找房（房子被整改）</li><li>准备面试新项目，技术是吃饭的本事</li><li>12月份进入新项目，远程办公1个月，新项目花了很多时间，加班严重（997）。</li><li>开始接触前后端分离vue+Springboot, Angular+Springboot</li></ul><h4 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h4><ul><li>今天是17号的周末。 是国庆后的第一个假期。去掉博客中的日记。</li><li>对于已发布的文章，在原有基础上进行内容补充和错误的修订。</li><li>由于文章是抽空写的。为了保证博客的阅读性，做了以下调整：<ul><li>根据文章的内容进行分类。</li><li>时间：根据分类的情况顺序递增。</li></ul></li></ul><h3 id="2019年"><a href="#2019年" class="headerlink" title="2019年"></a>2019年</h3><h4 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h4><ul><li>2019.11.03是S9英雄联盟全球总决赛半决赛。IG:FPX 1:3 , IG的奇迹团也没能改变，遗憾<a href="/love">😿😿😿</a>。 </li><li>凤凰《涅槃》，浴火重生。恭喜冠军FPX。</li><li>双十一决定换手机，双十二购买K20 Pro。</li></ul><h4 id="08月"><a href="#08月" class="headerlink" title="08月"></a>08月</h4><ul><li>由于计算机专业，从大一就想着搭建一个属于自己的网站。因此对搭建博客的兴趣比较浓厚。</li><li>我到大学之前还没有到网吧上过网(去过二次，当时没有开机子)，大学也只去过一次。那是我第一次被带着完LOL。就只能玩寒冰盖伦这种新手免费的英雄。直到我毕业了，当时冲的20元还是没有用完。</li><li>等到大二的时候才攒了点钱，京东上买了一台联想小新700 i5+1T+128SSD ,花了我将近6000RMB，一直用到我现在工作。</li><li>由于接触的少，很多东西都不熟悉，这个愿望就一直搁置了，直到大二下的时候，接触到了web编程，java后，开始了解github。这才开始慢点开始。<ul><li>由于git用的不熟练，踩过很多坑，之前写的东西都没有备份，导致博客更换的时候丢失额。</li><li>我也恢复了一些，可能排版不好，内容衔接不够等问题。但是可以看到自己的进步是一件不容易的事情。</li></ul></li><li>7月份走上了工作岗位，很多事情和心态都改变了，不会有人敦促你，还是想记录点什么。希望我能把写博客坚持下去。</li><li>重新搭建时间：2019-08-12</li></ul><script>var description="这篇文章介绍了作者的博客正式生成以及网站推荐的内容"</script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
