<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CAS原理与JUC原子类 | 凉月の博客</title><meta name="author" content="凉月"><meta name="copyright" content="凉月"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="介绍CAS的原理和弊端，然后介绍基于CAS实现的JUC原子类。">
<meta property="og:type" content="article">
<meta property="og:title" content="CAS原理与JUC原子类">
<meta property="og:url" content="https://fulsun.github.io/p/4793d884">
<meta property="og:site_name" content="凉月の博客">
<meta property="og:description" content="介绍CAS的原理和弊端，然后介绍基于CAS实现的JUC原子类。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fulsun.github.io/medias/featureimages/002.webp">
<meta property="article:published_time" content="2025-01-08T20:56:22.000Z">
<meta property="article:modified_time" content="2025-02-16T05:36:57.312Z">
<meta property="article:author" content="凉月">
<meta property="article:tag" content="CAS原理">
<meta property="article:tag" content="JUC原子类">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fulsun.github.io/medias/featureimages/002.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CAS原理与JUC原子类",
  "url": "https://fulsun.github.io/p/4793d884",
  "image": "https://fulsun.github.io/medias/featureimages/002.webp",
  "datePublished": "2025-01-08T20:56:22.000Z",
  "dateModified": "2025-02-16T05:36:57.312Z",
  "author": [
    {
      "@type": "Person",
      "name": "凉月",
      "url": "https://fulsun.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/medias/favicon.png"><link rel="canonical" href="https://fulsun.github.io/p/4793d884"><link rel="preconnect" href="//unpkg.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.3.2"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')
          
          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 凉月","link":"链接: ","source":"来源: 凉月の博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CAS原理与JUC原子类',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: linear-gradient(90deg, rgba(247, 149, 51, .1), rgba(243, 112, 85, .1) 15%, rgba(239, 78, 123, .1) 30%, rgba(161, 102, 171, .1) 44%, rgba(80, 115, 184, .1) 58%, rgba(16, 152, 173, .1) 72%, rgba(7, 179, 155, .1) 86%, rgba(109, 186, 130, .1));"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/avatar.jpg" onerror="this.onerror=null;this.src='/medias/detail/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heartbeat"></i><span> 我的</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> 联系</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 博主</span></a></li><li><a class="site-page child" href="/contact"><i class="fa-fw fas fa-comments"></i><span> 留言</span></a></li><li><a class="site-page child" href="/journal"><i class="fa-fw fas fa-cogs"></i><span> 日志</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> JS动画</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/snake/"><i class="fa-fw fas fa-gamepad"></i><span> 贪吃蛇</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/medias/featureimages/002.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">凉月の博客</span></a><a class="nav-page-title" href="/"><span class="site-name">CAS原理与JUC原子类</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heartbeat"></i><span> 我的</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> 联系</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 博主</span></a></li><li><a class="site-page child" href="/contact"><i class="fa-fw fas fa-comments"></i><span> 留言</span></a></li><li><a class="site-page child" href="/journal"><i class="fa-fw fas fa-cogs"></i><span> 日志</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> JS动画</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/snake/"><i class="fa-fw fas fa-gamepad"></i><span> 贪吃蛇</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">CAS原理与JUC原子类</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-08T20:56:22.000Z" title="发表于 2025-01-08 20:56:22">2025-01-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-16T05:36:57.312Z" title="更新于 2025-02-16 05:36:57">2025-02-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/">多线程编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">12.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:500,&quot;messagePrev&quot;:&quot;至上次更新后的&quot;,&quot;messageNext&quot;:&quot;天,文章内容可能已过时。&quot;,&quot;postUpdate&quot;:&quot;2025-02-16 05:36:57&quot;}" hidden></div><span id="more"></span>

<p>由于JVM的Synchronized重量级锁涉及操作系统（如Linux）内核态下互斥锁的使用，因此其线程阻塞和唤醒都涉及进程在用户态到内核态的频繁切换，导致重量级锁开销大、性能低。而JVM的Synchronized轻量级锁使用CAS（Compare And Swap，比较并交换）进行自旋抢锁，<strong>CAS是CPU指令级的原子操作，并处于用户态下，所以JVM轻量级锁的开销较小</strong>。</p>
<h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p>JDK 5所增加的JUC（java.util.concurrent）并发包对操作系统的底层CAS原子操作进行了封装，为上层Java程序提供了CAS操作的API。</p>
<h2 id="Unsafe类中的CAS方法"><a href="#Unsafe类中的CAS方法" class="headerlink" title="Unsafe类中的CAS方法"></a>Unsafe类中的CAS方法</h2><p>Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全的底层操作，如直接访问系统内存资源、自主管理内存资源等。Unsafe大量的方法都是native方法，基于C++语言实现，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。</p>
<p>Unsafe类的全限定名为<strong>sun.misc.Unsafe</strong>，从名字中可以看出这个类对普通程序员来说是“危险”的，一般的应用开发都不会涉及此类，<strong>Java官方也不建议直接在应用程序中使用这些类</strong>。</p>
<p>为什么此类取名为Unsafe呢？由于使用Unsafe类可以像C语言一样使用指针操作内存空间，这无疑增加了指针相关问题、内存泄漏问题出现的概率。总之，在程序中过度使用Unsafe类会使得程序出错的概率变大，使得安全的语言Java变得不再安全，因此对Unsafe的使用一定要慎重。</p>
<p><strong>操作系统层面的CAS是一条CPU的原子指令（cmpxchg指令），正是由于该指令具备原子性，因此使用CAS操作数据时不会造成数据不一致的问题</strong>，Unsafe提供的CAS方法直接通过native方式（封装C++代码）调用了底层的CPU指令cmpxchg。</p>
<p>完成Java应用层的CAS操作主要涉及Unsafe方法的调用，具体如下：</p>
<ol>
<li>获取Unsafe实例。</li>
<li>调用Unsafe提供的CAS方法，这些方法主要封装了底层CPU的CAS原子操作。</li>
<li>调用Unsafe提供的字段偏移量方法，这些方法用于获取对象中的字段（属性）偏移量，此偏移量值需要作为参数提供给CAS操作。</li>
</ol>
<h3 id="获取Unsafe实例"><a href="#获取Unsafe实例" class="headerlink" title="获取Unsafe实例"></a>获取Unsafe实例</h3><p>Unsafe类是一个final修饰的不允许继承的最终类，而且其构造函数是private类型的方法，具体的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Unsafe</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INVALID_FIELD_OFFSET</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">registerNatives</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 构造函数是private的，不允许外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Unsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，我们无法在外部对Unsafe进行实例化，那么怎么获取Unsafe的实例呢？可以通过反射的方式自定义地获取Unsafe实例的辅助方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略import</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JvmUtil</span> &#123; </span><br><span class="line">    <span class="comment">//自定义地获取Unsafe实例的辅助方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> (Unsafe) theUnsafe.get(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 省略不相干代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用Unsafe提供的CAS方法"><a href="#调用Unsafe提供的CAS方法" class="headerlink" title="调用Unsafe提供的CAS方法"></a>调用Unsafe提供的CAS方法</h3><p>Unsafe提供的CAS方法包含4个操作数——字段所在的对象、字段内存位置、预期原值及新值。<strong>在执行Unsafe的CAS方法时，这些方法首先将内存位置的值与预期值（旧的值）比较，如果相匹配，那么CPU会</strong><br><strong>自动将该内存位置的值更新为新值，并返回true；如果不匹配，CPU不做任何操作，并返回false</strong>。</p>
<p>Unsafe的CAS操作会将第一个参数（对象的指针、地址）与第二个参数（字段偏移量）组合在一起，计算出最终的内存操作地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义在Unsafe类中的三个“比较并交换”原子方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 需要操作的字段所在的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset 需要操作的字段的偏移量（相对的，相对于对象头）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expected 期望值（旧的值）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update 更新值（新的值）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 更新成功 | false 更新失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(</span></span><br><span class="line"><span class="params">    Object o, <span class="type">long</span> offset, Object expected, Object update)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(</span></span><br><span class="line"><span class="params">    Object o, <span class="type">long</span> offset, <span class="type">int</span> expected, <span class="type">int</span> update)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(</span></span><br><span class="line"><span class="params">    Object o, <span class="type">long</span> offset, <span class="type">long</span> expected, <span class="type">long</span> update)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="调用Unsafe提供的偏移量相关"><a href="#调用Unsafe提供的偏移量相关" class="headerlink" title="调用Unsafe提供的偏移量相关"></a>调用Unsafe提供的偏移量相关</h3><p>Unsafe提供的获取字段（属性）偏移量的相关操作主要如下：</p>
<ul>
<li>staticFieldOffset()方法用于<strong>获取静态属性Field在Class对象中的偏移量</strong>，在CAS中操作静态属性时会用到这个偏移量。</li>
<li>objectFieldOffset()方法用于<strong>获取非静态Field（非静态属性）在Object实例中的偏移量</strong>，在CAS中操作对象的非静态属性时会用到这个偏移量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义在Unsafe类中的几个获取字段偏移量的方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> o 需要操作字段的反射</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 字段的偏移量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">staticFieldOffset</span><span class="params">(Field field)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">objectFieldOffset</span><span class="params">(Field field)</span>;</span><br></pre></td></tr></table></figure>

<p>一个获取非静态Field（非静态属性）在Object实例中的偏移量的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取反射的Field对象</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> OptimisticLockingPlus.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 取得内存偏移</span></span><br><span class="line">        valueOffset = unsafe.objectFieldOffset(field);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用CAS进行无锁编程"><a href="#使用CAS进行无锁编程" class="headerlink" title="使用CAS进行无锁编程"></a>使用CAS进行无锁编程</h2><p>CAS是一种无锁算法，该算法关键依赖两个值——期望值（旧值）和新值，底层CPU利用原子操作判断内存原值与期望值是否相等，如果相等就给内存地址赋新值，否则不做任何操作。</p>
<p>使用CAS进行无锁编程的步骤大致如下：</p>
<ol>
<li>获得字段的期望值（oldValue）。</li>
<li>计算出需要替换的新值（newValue）。</li>
<li>通过CAS将新值（newValue）放在字段的内存地址上，如果CAS失败就重复第（1）步到第（2）步，一直到CAS成功，这种重复俗称<strong>CAS自旋</strong>。</li>
</ol>
<p>使用CAS进行无锁编程的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    获得字段的期望值（oldValue）;</span><br><span class="line">    计算出需要替换的新值（newValue）;</span><br><span class="line">&#125; <span class="keyword">while</span> (!CAS(内存地址，oldValue，newValue))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假如某个内存地址（某对象的属性）的值为100，现在有两个线程（线程A和线程B）使用CAS无锁编程对该内存地址进行更新，线程A欲将其值更新为200，线程B欲将其值更新为300，线程是并发执行的，谁都有可能先执行。但是CAS是原子操作，对同一个内存地址的CAS操作在同一时刻只能执行一个。因此，在这个例<br>子中，要么线程A先执行，要么线程B先执行。</p>
<ul>
<li>假设线程A的CAS(100,200)执行在前，由于内存地址的旧值100与该CAS的期望值100相等，因此线程A会操作成功，内存地址的值被更新为200。</li>
<li>接下来执行线程B的CAS(100,300)操作，此时内存地址的值为200，不等于CAS的期望值100，线程B操作失败。线程B只能自旋，开始新的循环，这一轮循环首先获取到内存地址的值200，然后进行CAS(200,300)操作，这一次内存地址的值与CAS的预期值（oldValue）相等，线程B操作成功。</li>
</ul>
<p>当CAS将内存地址的值与预期值进行比较时，如果相等，就证明内存地址的值没有被修改，可以替换成新值，然后继续往下运行；如果不相等，就说明内存地址的值已经被修改，放弃替换操作，然后重新自旋。当并发修改的线程少，冲突出现的机会少时，自旋的次数也会很少，CAS的性能会很高；当并发修改的线程多，冲突出现的机会多时，自旋的次数也会很多，CAS的性能会大大降低。所以，<strong>提升CAS无</strong><br><strong>锁编程效率的关键在于减少冲突的机会</strong>。</p>
<h3 id="无锁编程实现轻量级安全自增"><a href="#无锁编程实现轻量级安全自增" class="headerlink" title="无锁编程实现轻量级安全自增"></a>无锁编程实现轻量级安全自增</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">// 统计失败的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">failure</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ++value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自增</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">synchronincrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ++value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cas自增</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">casincrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">expected</span> <span class="operator">=</span> value;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newvalue</span> <span class="operator">=</span> expected + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!compareAndSwap(expected, newvalue)) &#123;</span><br><span class="line">            expected = value;</span><br><span class="line">            newvalue = expected + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newvalue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compareAndSwap</span><span class="params">(<span class="type">int</span> expected, <span class="type">int</span> newvalue)</span> &#123;</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            unsafe = (Unsafe) theUnsafe.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> unsafe.objectFieldOffset(Test.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;offset:&quot;</span> + offset);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, offset, expected, newvalue);</span><br><span class="line">            <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                failure.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 对value进行CAS操作</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    obj.casincrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i] = thread;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待所有线程执行完毕</span></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(obj.value);</span><br><span class="line">        System.out.println(<span class="string">&quot;失败次数：&quot;</span> + failure.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// offset:12</span></span><br><span class="line"><span class="comment">// 10000</span></span><br><span class="line"><span class="comment">// 失败次数：49430</span></span><br></pre></td></tr></table></figure>

<h3 id="字段偏移量的计算"><a href="#字段偏移量的计算" class="headerlink" title="字段偏移量的计算"></a>字段偏移量的计算</h3><p>调用Unsafe.objectFieldOffset(…)方法获取到的Object字段（也叫Object成员属性）的偏移量值是字段相<strong>对于Object头部的偏移</strong><br><strong>量，是一个相对的内存地址值，不是绝对的内存地址值</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">// 统计失败的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">failure</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然Test类有2个字段，但是其中有1个是静态字段，属于类的成员而不是对象的成员，真正属于对象的字段只有其中的value字段。所以类的对象结构<br>如图所示:</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/4793d884/0122f5b891aacc36aceff1fdd33307e0.png"></p>
<p>在64位的JVM堆区中一个Test对象的Object Header（头部）占用了12字节，其中Mark Word占用了8字节（64位），压缩过的Class Pointer占用了4字节。接在Object Header之后的就是成员属性value的内存区域<strong>，所以value属性相对于Object Header的偏移量为12</strong>。</p>
<h2 id="JUC原子类"><a href="#JUC原子类" class="headerlink" title="JUC原子类"></a>JUC原子类</h2><p>在多线程并发执行时，诸如“++”或“–”类的运算不具备原子性，不是线程安全的操作。通常情况下，大家会使用synchronized将这些线程不安全的操作变成同步操作，但是这样会降低并发程序的性能。所以，JDK为这些类型不安全的操作提供了一些原子类，与synchronized同步机制相比，JDK原子类是基于CAS轻量级原子操作的实现，使得程序运行效率变得更高。</p>
<h3 id="Atomic原子操作包"><a href="#Atomic原子操作包" class="headerlink" title="Atomic原子操作包"></a>Atomic原子操作包</h3><p>Atomic操作翻译成中文是指一个不可中断的操作，即使在多个线程一起执行Atomic类型操作的时候，一个操作一旦开始，就不会被其<br>他线程中断。所谓Atomic类，指的是具有原子操作特征的类。JUC并发包中原子类的位置JUC并发包中的原子类都存放在<code>java.util.concurrent.atomic</code>类路径下.</p>
<p>根据操作的目标数据类型，可以将JUC包中的原子类分为4类：<code>基本原子类</code>、<code>数组原子类</code>、<code>原子引用类</code>和<code>字段更新原子类</code>。</p>
<h3 id="基本原子类"><a href="#基本原子类" class="headerlink" title="基本原子类"></a>基本原子类</h3><ul>
<li>基本原子类的功能是通过原子方式更新Java基础类型变量的值。</li>
<li>基本原子类主要包括以下三个：<ul>
<li><code>AtomicInteger</code>：整型原子类。</li>
<li><code>AtomicLong</code>：长整型原子类。</li>
<li><code>AtomicBoolean</code>：布尔型原子类。</li>
</ul>
</li>
</ul>
<h3 id="数组原子类"><a href="#数组原子类" class="headerlink" title="数组原子类"></a>数组原子类</h3><ul>
<li>数组原子类的功能是通过原子方式更数组中的某个元素的值。数</li>
<li>组原子类主要包括以下三个：<ul>
<li><code>AtomicIntegerArray</code>：整型数组原子类。</li>
<li><code>AtomicLongArray</code>：长整型数组原子类。</li>
<li><code>AtomicReferenceArray</code>：引用类型数组原子类。</li>
</ul>
</li>
</ul>
<h3 id="引用原子类"><a href="#引用原子类" class="headerlink" title="引用原子类"></a>引用原子类</h3><ul>
<li>引用原子类主要包括以下三个：<ul>
<li><code>AtomicReference</code>：引用类型原子类。</li>
<li><code>AtomicMarkableReference</code>：带有更新标记位的原子引用类型。</li>
<li><code>AtomicStampedReference</code>：带有更新版本号的原子引用类型。</li>
</ul>
</li>
<li><code>AtomicMarkableReference</code>类将boolean标记与引用关联起来，可以解决使用AtomicBoolean进行原子更新时可能出现的ABA问题。</li>
<li><code>AtomicStampedReference</code>类将整数值与引用关联起来，可以解决使用AtomicInteger进行原子更新时可能出现的ABA问题。</li>
</ul>
<h3 id="字段更新原子类"><a href="#字段更新原子类" class="headerlink" title="字段更新原子类"></a>字段更新原子类</h3><ul>
<li><strong>字段更新</strong>原子类主要包括以下三个：<ul>
<li><code>AtomicIntegerFieldUpdater</code>：原子更新整型字段的更新器。</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器。</li>
<li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型中的字段</li>
</ul>
</li>
</ul>
<h3 id="基础原子类AtomicInteger"><a href="#基础原子类AtomicInteger" class="headerlink" title="基础原子类AtomicInteger"></a>基础原子类AtomicInteger</h3><p>基础原子类AtomicInteger常用的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span> <span class="comment">//获取当前的值，然后设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> <span class="comment">//获取当前的值，然后自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，然后自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//通过CAS方式设置整数值</span></span><br></pre></td></tr></table></figure>

<p>下面是一个基础原子类AtomicInteger的使用示例，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerExample</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个 Atomic Integer 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建并启动多个线程来更新计数器</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; updateCounter(<span class="number">5</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; updateCounter(<span class="number">3</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; updateCounter(<span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有线程执行完毕</span></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        thread3.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final counter value: &quot;</span> + counter.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateCounter</span><span class="params">(<span class="type">int</span> increment)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; increment; i++) &#123;</span><br><span class="line">            <span class="comment">// 使用原子操作方法安全地增加计数值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">newValue</span> <span class="operator">=</span> counter.addAndGet(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; updated the counter to: &quot;</span> + newValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组原子类AtomicIntegerArray"><a href="#数组原子类AtomicIntegerArray" class="headerlink" title="数组原子类AtomicIntegerArray"></a>数组原子类AtomicIntegerArray</h3><p>AtomicIntegerArray.AtomicLongArray,AtomicReferenceArray三个类提供的方法几乎相同，所以我们这里以AtomicIntegerArray为例来介绍。</p>
<p>AtomicIntegerArray类的常用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取 index=i 位置元素的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回 index=i 位置当前的值，并将其设置为新值：newValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> newValue)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">(<span class="type">int</span> i)</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 index=i 位置元素的值，并加上预期的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//如果输入的数值等于预期值，就以原子方式将位置i的元素值设置为输入值（update）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//最终将位置i的元素设置为newValue</span></span><br><span class="line"><span class="comment">//lazySet()方法可能导致其他线程在之后的一小段时间内还是可以读到旧的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> newValue)</span>下</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAtomicIntegerArray</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tempvalue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 原始的数组</span></span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包装为原子数组</span></span><br><span class="line">    <span class="type">AtomicIntegerArray</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(array);</span><br><span class="line">    <span class="comment">// 获取第0个元素，然后设置为2</span></span><br><span class="line">    tempvalue = i.getAndSet(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 输出tempvalue:1; i:[2, 2, 3, 4, 5, 6]</span></span><br><span class="line">    Print.fo(<span class="string">&quot;tempvalue:&quot;</span> + tempvalue + <span class="string">&quot;; i:&quot;</span> + i);</span><br><span class="line">    <span class="comment">// 获取第0个元素，然后自增</span></span><br><span class="line">    tempvalue = i.getAndIncrement(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 输出tempvalue:2; i:[3, 2, 3, 4, 5, 6]</span></span><br><span class="line">    Print.fo(<span class="string">&quot;tempvalue:&quot;</span> + tempvalue + <span class="string">&quot;; i:&quot;</span> + i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第0个元素，然后增加一个delta 5</span></span><br><span class="line">    tempvalue = i.getAndAdd(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 输出tempvalue:3; i:[8, 2, 3, 4, 5, 6]</span></span><br><span class="line">    Print.fo(<span class="string">&quot;tempvalue:&quot;</span> + tempvalue + <span class="string">&quot;; i:&quot;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AtomicInteger线程安全原理"><a href="#AtomicInteger线程安全原理" class="headerlink" title="AtomicInteger线程安全原理"></a>AtomicInteger线程安全原理</h3><p>基础原子类（以AtomicInteger为例）<strong>主要通过CAS自旋+volatile的方案实现</strong>，既保障了变量操作的线程安全性，又避免了synchronized重量级锁的高开销，使得Java程序的执行效率大为提升。</p>
<p>AtomicInteger源码中的主要方法都是通过CAS自旋实现的。CAS自旋的主要操作为：<strong>如果一次CAS操作失败，获取最新的value值后，再</strong><br><strong>次进行CAS操作，直到成功</strong>。</p>
<p>另外，AtomicInteger所包装的内部value成员是一个使用关键字volatile修饰的内部成员。关键字volatile的原理比较复杂，简单地<br>说，该关键字可以保证任何线程在任何时刻总能拿到该变量的最新值，其目的在于保障变量值的线程可见性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicInteger</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe类实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部value值，使用volatile保证线程可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// value属性值的地址偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 计算value 属性值的地址偏移量</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset(</span><br><span class="line"></span><br><span class="line">                    AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">(<span class="type">int</span> initialValue)</span> &#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前value值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法：返回旧值并赋新值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;<span class="comment">// 自旋</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();<span class="comment">// 获取旧值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 以CAS方式赋值，直到成功返回</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, newValue)) <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法：封装底层的CAS操作，对比expect(期望值)与value，若不同则返回false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若expect与value相同，则将新值赋给value，并返回true</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法：安全自增 i++</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123; <span class="comment">// 自旋</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next)) <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法：自定义增量数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123; <span class="comment">// 自旋</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + delta;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next)) <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法：类似++i，返回自增后的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123; <span class="comment">// 自旋</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next)) <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法：返回加上delta后的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">addAndGet</span><span class="params">(<span class="type">int</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123; <span class="comment">// 自旋</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + delta;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next)) <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他源码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用类型原子类"><a href="#引用类型原子类" class="headerlink" title="引用类型原子类"></a>引用类型原子类</h3><ul>
<li>引用类型原子类包括以下种：<ul>
<li>AtomicReference：基础的引用原子类。</li>
<li>AtomicStampedReference：带印戳的引用原子类。</li>
<li>AtomicMarkableReference：带修改标志的引用原子类。</li>
</ul>
</li>
<li>上面三个类提供的方法几乎相同，所以这里以AtomicReference为例来介绍。</li>
</ul>
<p>下面为大家介绍一个简单的AtomicReference类的使用示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">qwen2<span class="number">.5</span>:7b</span><br><span class="line">在Java中，AtomicReference 是一个可以支持原子操作的类。它允许你以线程安全的方式更新对象的引用，而不必担心同步问题。这在多线程环境中非常有用。</span><br><span class="line"></span><br><span class="line">下面是一个使用 AtomicReference 对 User 引用进行原子性修改的例子：</span><br><span class="line"></span><br><span class="line">java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 其他属性和方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个User对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用AtomicReference包装user引用</span></span><br><span class="line">        AtomicReference&lt;User&gt; atomicUserRef = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个线程尝试更新用户的名字</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);  <span class="comment">// 模拟一些延迟</span></span><br><span class="line">                <span class="type">User</span> <span class="variable">newUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jane&quot;</span>);</span><br><span class="line">                atomicUserRef.set(newUser);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程尝试读取用户的名字</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);  <span class="comment">// 模拟一些延迟</span></span><br><span class="line">                <span class="type">User</span> <span class="variable">readUser</span> <span class="operator">=</span> atomicUserRef.get();</span><br><span class="line">                System.out.println(<span class="string">&quot;Name after update: &quot;</span> + readUser.getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待所有线程完成</span></span><br><span class="line">            thread1.join();</span><br><span class="line">            thread2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性更新原子类"><a href="#属性更新原子类" class="headerlink" title="属性更新原子类"></a>属性更新原子类</h3><p>此这里以<code>AtomicIntegerFieldUpdater</code>为例来介绍。使用属性更新原子类保障属性安全更新的流程大致需要两步：</p>
<ol>
<li>第一步，更新的对象属性必须使用<code>public volatile</code>修饰符。</li>
<li>第二步，因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须调用静态方法newUpdater()创建一个更新器，并且需要设<br>置想要更新的类和属性。</li>
</ol>
<p>下面为大家介绍一个简单的AtomicIntegerFieldUpdater类的使用示例，原子性地更新User对象的age属性，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAtomicIntegerFieldUpdater</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用静态方法newUpdater()创建一个更新器updater</span></span><br><span class="line">    AtomicIntegerFieldUpdater&lt;User&gt; updater = AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用属性更新器的getAndIncrement、getAndAdd增加user的age值</span></span><br><span class="line"></span><br><span class="line">    Print.tco(updater.getAndIncrement(user));<span class="comment">// 1</span></span><br><span class="line">    Print.tco(updater.getAndAdd(user, <span class="number">100</span>));<span class="comment">// 101</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用属性更新器的get获取user的age值</span></span><br><span class="line">    Print.tco(updater.get(user));<span class="comment">// 101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>由于CAS原子操作性能高，因此其在JUC包中被广泛应用，只不过如果使用得不合理，CAS原子操作就会存在ABA问题。</p>
<h3 id="了解ABA问题"><a href="#了解ABA问题" class="headerlink" title="了解ABA问题"></a>了解ABA问题</h3><p>什么是ABA问题？举一个例子来说明。比如一个线程A从内存位置M中取出V1，另一个线程B也取出V1。现在假设线程B进行了一些操作之<br>后将M位置的数据V1变成了V2，然后又在一些操作之后将V2变成了V1。之后，线程A进行CAS操作，但是线程A发现M位置的数据仍然是V1，然<br>后线程A操作成功。<strong>尽管线程A的CAS操作成功，但是不代表这个过程是没有问题的，线程A操作的数据V1可能已经不是之前的V1，而是被线程</strong><br><strong>B替换过的V1，这就是ABA问题</strong>。</p>
<p>并发业务场景下,两个并发的查询库存操作，同时从数据库都得到了库存是5。用户1购买了3个库存，于是库存要设置为2, 用户2购买了2个库存，于是库存要设置为3,这两个设置库存的接口并发执行，库存会先变成2，再变成3，导致数据不一致（实际卖出了5件商品，但库存只扣减了2，最后一次设置库存会覆盖和掩盖前一次并发操作）</p>
<h3 id="ABA问题解决方案"><a href="#ABA问题解决方案" class="headerlink" title="ABA问题解决方案"></a>ABA问题解决方案</h3><p>很多乐观锁的实现版本都是使用版本号（Version）方式来解决ABA问题。<strong>乐观锁每次在执行数据的修改操作时都会带上一个版本号，版本号和数据的版本号一致就可以执行修改操作并对版本号执行加1操作，否则执行失败。</strong>因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加，不会减少。</p>
<h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><p>参考乐观锁的版本号，JDK提供了一个AtomicStampedReference类来解决ABA问题。AtomicStampReference在CAS的基础上增加了一个<br>Stamp（印戳或标记），使用这个印戳可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验。</p>
<p>AtomicStampReference的compareAndSet()方法首先检查当前的对象引用值是否等于预期引用，并且当前印戳（Stamp）标志是否等于预<br>期标志，如果全部相等，就以原子方式将引用值和印戳（Stamp）标志的值更新为给定的更新值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器，V表示要引用的原始数据，initialStamp表示最初的版本印戳（版本号）</span></span><br><span class="line">AtomicStampedReference(V initialRef, <span class="type">int</span> initialStamp)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取被封装的数据</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">getRerference</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取被封装的数据的版本印戳</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStamp</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(</span></span><br><span class="line"><span class="params"> V expectedReference, //预期引用值</span></span><br><span class="line"><span class="params"> V newReference, //更新后的引用值</span></span><br><span class="line"><span class="params"> <span class="type">int</span> expectedStamp, //预期印戳（Stamp）标志值</span></span><br><span class="line"><span class="params"> <span class="type">int</span> newStamp)</span> <span class="comment">//更新后的印戳（Stamp）标志值</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>compareAndSet()方法的第一个参数是原来的CAS中的参数，第二个参数是替换后的新参数，第三个参数是原来CAS数据旧的版本号，第<br>四个参数表示替换后的新参数版本号。进行CAS操作时，若当前引用值等于预期引用值，并且当前印戳值等于预期印戳值，则以原子方式将引用值和印戳值更新为给定的更新值。<br>下面是一个简单的AtomicStampedReference使用示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 AtomicStampedReference 存储当前的库存值和版本号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicStampedReference&lt;Integer&gt; stock = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateInventory</span><span class="params">(<span class="type">int</span> quantity)</span> &#123;</span><br><span class="line">        <span class="type">int</span> currentValue, newStamp;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            currentValue = stock.getReference(); <span class="comment">// 获取当前库存值</span></span><br><span class="line">            newStamp = stock.getStamp() + <span class="number">1</span>; <span class="comment">// 获取并增加版本号</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currentValue &gt;= quantity) &#123; <span class="comment">// 检查是否足够库存</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">newValue</span> <span class="operator">=</span> currentValue - quantity;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">updated</span> <span class="operator">=</span> stock.compareAndSet(currentValue, newValue, newStamp, newStamp + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (!updated) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Failed to update inventory in thread &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Insufficient stock for update by thread &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>); <span class="comment">// 重试循环，直到更新成功</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><p>AtomicMarkableReference是AtomicStampedReference的简化版，<strong>不关心修改过几次，只关心是否修改</strong>过。因此，其标记属性mark是boolean类型，而不是数字类型，标记属性mark仅记录值是否修改过。<strong>AtomicMarkableReference适用于只要知道对象是否被修改过，而不适用于对象被反复修改的场景</strong>。</p>
<p>下面是一个简单的AtomicMarkableReference使用示例，通过两个线程分别更新同一个stock 的值，第一个线程会更新成功，而第二个线程会更新失败，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 AtomicMarkableReference 存储当前的库存值和标记（表示是否有效）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicMarkableReference&lt;Integer&gt; stock = <span class="keyword">new</span> <span class="title class_">AtomicMarkableReference</span>&lt;&gt;(<span class="number">10</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateInventory</span><span class="params">(<span class="type">int</span> quantity)</span> &#123;</span><br><span class="line">        <span class="type">int</span> currentValue, currentMark;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 获取当前的库存值和标记</span></span><br><span class="line">            currentValue = stock.getReference();</span><br><span class="line">            currentMark = stock.getMark();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!currentMark &amp;&amp; currentValue &gt;= quantity) &#123; <span class="comment">// 检查是否足够库存且标记未被更改</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">updated</span> <span class="operator">=</span> stock.compareAndSet(currentValue, currentValue - quantity, currentMark, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (updated) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Inventory updated by thread &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + currentValue - quantity);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Failed to update inventory in thread &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Insufficient stock for update by thread &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!updated); <span class="comment">// 重试循环，直到更新成功</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="提升高并发场景下CAS操作的性能"><a href="#提升高并发场景下CAS操作的性能" class="headerlink" title="提升高并发场景下CAS操作的性能"></a>提升高并发场景下CAS操作的性能</h2><p>在争用激烈的场景下，会导致大量的CAS空自旋。比如，在大量线程同时并发修改一个AtomicInteger时，可能有很多线程会不停地自旋，甚至有的线程会进入一个无限重复的循环中。大量的CAS空自旋会浪费大量的CPU资源，大大降低了程序的性能。</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/4793d884/c68e12d7533c2c50690ff886b5e60704.webp"></p>
<blockquote>
<p><strong>除了存在CAS空自旋之外，在SMP架构的CPU平台上，大量的CAS操作还可能导致“总线风暴”</strong></p>
</blockquote>
<blockquote>
<p>在高并发场景下如何提升CAS操作的性能呢？<strong>可以使用LongAdder替代AtomicInteger</strong>。</p>
</blockquote>
<h3 id="以空间换时间：LongAdder"><a href="#以空间换时间：LongAdder" class="headerlink" title="以空间换时间：LongAdder"></a>以空间换时间：LongAdder</h3><p>Java 8提供了一个新的类<code>LongAdder</code>，以空间换时间的方式提升高并发场景下CAS操作的性能。LongAdder的核心思想是热点分离，与ConcurrentHashMap的设计思想类似<strong>：将value值分离成一个数组，当多线程访问时，通过Hash算法将线程映射到数组的一个元素进行操作；而获取最终的value结果时，则将数组的元素求和</strong>。最终，通过LongAdder将内部操作对象<strong>从单个value值“演变”成一系列的数组元素，从而减小了内部竞争的粒度。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicLongAdderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        testAtomicLongAdder(<span class="number">1</span>, <span class="number">10000000</span>);</span><br><span class="line">        testAtomicLongAdder(<span class="number">10</span>, <span class="number">10000000</span>);</span><br><span class="line">        testAtomicLongAdder(<span class="number">100</span>, <span class="number">10000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAtomicLongAdder</span><span class="params">(<span class="type">int</span> threadCount, <span class="type">int</span> times)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;threadCount: &quot;</span> + threadCount + <span class="string">&quot;, times: &quot;</span> + times);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        testLongAdder(threadCount, times);</span><br><span class="line">        System.out.println(<span class="string">&quot;LongAdder 耗时：&quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;threadCount: &quot;</span> + threadCount + <span class="string">&quot;, times: &quot;</span> + times);</span><br><span class="line">        <span class="type">long</span> <span class="variable">atomicStart</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        testAtomicLong(threadCount, times);</span><br><span class="line">        System.out.println(<span class="string">&quot;AtomicLong 耗时：&quot;</span> + (System.currentTimeMillis() - atomicStart) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAtomicLong</span><span class="params">(<span class="type">int</span> threadCount, <span class="type">int</span> times)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">AtomicLong</span> <span class="variable">atomicLong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line">        List&lt;Thread&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; times; j++) &#123;</span><br><span class="line">                    atomicLong.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : list) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : list) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;AtomicLong value is : &quot;</span> + atomicLong.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testLongAdder</span><span class="params">(<span class="type">int</span> threadCount, <span class="type">int</span> times)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">LongAdder</span> <span class="variable">longAdder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">        List&lt;Thread&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; times; j++) &#123;</span><br><span class="line">                    longAdder.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : list) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : list) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;LongAdder value is : &quot;</span> + longAdder.longValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">threadCount: <span class="number">1</span>, times: <span class="number">10000000</span></span><br><span class="line">LongAdder value is : <span class="number">10000000</span></span><br><span class="line">LongAdder 耗时：75ms</span><br><span class="line">threadCount: <span class="number">1</span>, times: <span class="number">10000000</span></span><br><span class="line">AtomicLong value is : <span class="number">10000000</span></span><br><span class="line">AtomicLong 耗时：23ms</span><br><span class="line">----------------------------------------</span><br><span class="line">threadCount: <span class="number">10</span>, times: <span class="number">10000000</span></span><br><span class="line">LongAdder value is : <span class="number">100000000</span></span><br><span class="line">LongAdder 耗时：52ms</span><br><span class="line">threadCount: <span class="number">10</span>, times: <span class="number">10000000</span></span><br><span class="line">AtomicLong value is : <span class="number">100000000</span></span><br><span class="line">AtomicLong 耗时：958ms</span><br><span class="line">----------------------------------------</span><br><span class="line">threadCount: <span class="number">100</span>, times: <span class="number">10000000</span></span><br><span class="line">LongAdder value is : <span class="number">1000000000</span></span><br><span class="line">LongAdder 耗时：266ms</span><br><span class="line">threadCount: <span class="number">100</span>, times: <span class="number">10000000</span></span><br><span class="line">AtomicLong value is : <span class="number">1000000000</span></span><br><span class="line">AtomicLong 耗时：12221ms</span><br><span class="line">----------------------------------------</span><br></pre></td></tr></table></figure>

<p>这里可以看到<strong>随着并发的增加</strong>，<code>AtomicLong</code>性能是急剧下降的，耗时是<code>LongAdder</code>的数倍。至于原因我们还是接着往后看。</p>
<h3 id="AtomicLong可以弃用了吗？"><a href="#AtomicLong可以弃用了吗？" class="headerlink" title="AtomicLong可以弃用了吗？"></a>AtomicLong可以弃用了吗？</h3><p>看上去<code>LongAdder</code>的性能全面超越了<code>AtomicLong</code>，而且阿里巴巴开发手册也提及到 <strong>推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观<br>锁的重试次数）</strong>，但是我们真的就可以舍弃掉<code>LongAdder</code>了吗？</p>
<p>当然不是，我们需要看场景来使用，如果是并发不太高的系统，使用<code>AtomicLong</code>可能会更好一些，而且内存需求也会小一些。</p>
<p>我们通过分析源码<code>sum()</code>方法后可以知道<code>LongAdder</code>在统计的时候如果有并发更新，可能导致统计的数据有误差。而在<strong>高并发统计计数</strong>的场景下，才更适合使用<code>LongAdder</code>。</p>
<h2 id="LongAdder的原理"><a href="#LongAdder的原理" class="headerlink" title="LongAdder的原理"></a>LongAdder的原理</h2><h3 id="操作原理图"><a href="#操作原理图" class="headerlink" title="操作原理图"></a>操作原理图</h3><p>先看下<code>LongAdder</code>的操作原理图：</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/4793d884/e98ecf700241547c45fca7b722731752.webp"></p>
<p>既然说到<code>LongAdder</code>可以显著提升高并发环境下的性能，那么它是如何做到的？</p>
<h3 id="分段加锁思路"><a href="#分段加锁思路" class="headerlink" title="分段加锁思路"></a>分段加锁思路</h3><blockquote>
<p><strong>设计思想上，<code>LongAdder</code>采用”分段”的方式降低<code>CAS</code>失败的频次</strong></p>
</blockquote>
<p>我们知道，<code>AtomicLong</code>中有个内部变量<code>value</code>保存着实际的<code>long</code>值，所有的操作都是针对该变量进行。也就是说，高并发环境下，<code>value</code>变量其实是一个<strong>热点数据</strong>，也就是<strong>N个线程竞争一个热点。</strong></p>
<p><code>LongAdder</code>的基本思路就是<strong>分散热点</strong>，将<code>value</code>值的新增操作分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个<code>value</code>值进行<code>CAS</code>操作，这样热点就被分散了，冲突的概率就小很多。</p>
<p><code>LongAdder</code>有一个全局变量<code>volatile long base</code>值，当并发不高的情况下都是通过<code>CAS</code>来直接操作<code>base</code>值，如果<code>CAS</code>失败，则针对<code>LongAdder</code>中的<code>Cell[]</code>数组中的<code>Cell</code>进行<code>CA</code>S操作，减少失败的概率。</p>
<p>例如当前类中<code>base = 10</code>，有三个线程进行<code>CAS</code>原子性的**+1操作<strong>，</strong>线程一执行成功，此时base&#x3D;11<strong>，</strong>线程二、线程三执行失败后<strong>开始针对于<code>Cell[]</code>数组中的<code>Cell</code>元素进行</strong>+1操作**，同样也是<code>CAS</code>操作，此时数组<code>index=1</code>和<code>index=2</code>中<code>Cell</code>的<code>value</code>都被设置为了1.</p>
<p>执行完成后，统计累加数据：<code>sum = 11 + 1 + 1 = 13</code>，利用<code>LongAdder</code>进行累加的操作就执行完了，流程图如下：</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/4793d884/b4dd2afb58703348ca052a7c60f69c28.webp" alt="img"></p>
<p>如果要获取真正的<code>long</code>值，只要将各个槽中的变量值累加返回。这种分段的做法类似于<code>JDK7</code>中<code>ConcurrentHashMap</code>的分段锁。</p>
<h3 id="消除伪共享"><a href="#消除伪共享" class="headerlink" title="消除伪共享"></a>消除伪共享</h3><p>在 <code>LongAdder</code> 的父类 <code>Striped64</code> 中存在一个 <code>volatile Cell[] cells;</code> 数组，其长度是<strong>2 的幂次方</strong>，每个<code>Cell</code>都使用 <code>@Contended</code> 注解进行修饰，而<code>@Contended</code>注解可以进行<strong>缓存行填充</strong>，从而解决<strong>伪共享问题</strong>。伪共享会导致缓存行失效，缓存一致性开销变大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>伪共享</strong>指的是多个线程同时读写同一个缓存行的不同变量时导致的 <code>CPU缓存失效</code>。尽管这些变量之间没有任何关系，但由于在主内存中邻近，存在于同一个缓存行之中，它们的相互覆盖会导致频繁的缓存未命中，引发性能下降。这里对于伪共享我只是提一下概念，并不会深入去讲解，大家可以自行查阅一些资料。</p>
<p>解决伪共享的方法一般都是使用<strong>直接填充</strong>，我们只需要保证不同线程的变量存在于不同的 <code>CacheLine</code> 即可，使用多余的字节来填充可以做点这一点，这样就不会出现伪共享问题。</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/4793d884/ce27aa2be39adda70bf145511c97db76.webp" alt="缓存行填充代码"></p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/4793d884/8fde5d0fa2f94996d4777c0ccbd37b5c.webp" alt="缓存行填充"></p>
<p>在<code>Striped64</code>类中我们可以看看<code>Doug Lea</code>在<code>Cell</code>上加的注释也有说明这一点：</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/4793d884/11fdd9afd2b4d9ebcd6a057231a8946c.webp" alt="Cell注释"></p>
<blockquote>
<p>红框中的翻译如下：</p>
</blockquote>
<p><code>Cell</code>类是<code>AtomicLong</code>添加了<code>padded（via@sun.misc.compended)</code>来消除<strong>伪共享</strong>的变种版本。缓存行填充对于大多数原子来说是繁琐的，因为它们通常不规则地分散在内存中，因此彼此之间不会有太大的干扰。但是，驻留在数组中的原子对象往往彼此相邻，因此在没有这种预防措施的情况下，通常会共享缓存行数据（对性能有巨大的负面影响）。</p>
<h3 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h3><p><code>LongAdder</code>只有在使用<code>longValue()</code>获取当前累加值时才会真正的去结算计数的数据，<code>longValue()</code>方法底层就是调用<code>sum()</code>方法，对<code>base</code>和<code>Cell数组</code>的数据累加然后返回，做到数据写入和读取分离。</p>
<p>而<code>AtomicLong</code>使用<code>incrementAndGet()</code>每次都会返回<code>long</code>类型的计数值，每次递增后还会伴随着数据返回，增加了额外的开销。</p>
<h3 id="LongAdder实现原理"><a href="#LongAdder实现原理" class="headerlink" title="LongAdder实现原理"></a>LongAdder实现原理</h3><p>之前说了，<code>AtomicLong</code>是多个线程针对单个<strong>热点值value进行原子操作</strong>。而<code>LongAdder</code>是每个线程拥有自己的槽，各个线程一般只对自己槽中的那个值进行<code>CAS操作</code>。</p>
<p>比如有三个线程同时对value增加1，那么value &#x3D; 1 + 1 + 1 &#x3D; 3</p>
<p>但是对于LongAdder来说，内部有一个base变量，一个Cell[]数组。</p>
<ul>
<li>base变量：非竞态条件下，直接累加到该变量上</li>
<li>Cell[]数组：竞态条件下，累加个各个线程自己的槽Cell[i]中</li>
<li>最终结果的计算是下面这个形式：<img src= "/medias/detail/load.gif" data-lazy-src="/p/4793d884/29aef632bff858ae987efb979152a631.png"></li>
</ul>
<h2 id="LongAdder源码剖析"><a href="#LongAdder源码剖析" class="headerlink" title="LongAdder源码剖析"></a>LongAdder源码剖析</h2><p>前面已经用图分析了<code>LongAdder</code>高性能的原理，我们继续看下<code>LongAdder</code>实现的源码：</p>
<h3 id="add-方法"><a href="#add-方法" class="headerlink" title="add()方法"></a><code>add()</code>方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongAdder</span> <span class="keyword">extends</span> <span class="title class_">Striped64</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        add(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">        Cell[] as; <span class="type">long</span> b, v; <span class="type">int</span> m; Cell a;</span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                (a = as[getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">                !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">                longAccumulate(x, <span class="literal">null</span>, uncontended);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">casBase</span><span class="params">(<span class="type">long</span> cmp, <span class="type">long</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="built_in">this</span>, BASE, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般我们进行计数时都会使用<code>increment()</code>方法，每次进行**+1操作**，<code>increment()</code>会直接调用<code>add()</code>方法。</p>
<p><strong>变量说明：</strong></p>
<ul>
<li>as 表示cells引用</li>
<li>b 表示获取的base值</li>
<li>v 表示 期望值,</li>
<li>m 表示 cells 数组的长度</li>
<li>a 表示当前线程命中的cell单元格</li>
</ul>
<blockquote>
<p><strong>条件一：as &#x3D;&#x3D; null || (m &#x3D; as.length - 1) &lt; 0</strong><br>此条件成立说明cells数组未初始化。如果不成立则说明cells数组已经完成初始化，对应的线程需要找到Cell数组中的元素去写值。</p>
</blockquote>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/4793d884/aed52a589a2825d1c38318fc9bf31a7f.webp" alt="条件一"></p>
<blockquote>
<p><strong>条件二：(a &#x3D; as[getProbe() &amp; m]) &#x3D;&#x3D; null</strong></p>
</blockquote>
<p>getProbe()获取当前线程的hash值，m表示cells长度-1，cells长度是2的幂次方数，原因之前也讲到过，与数组长度取模可以转化为按位与运算，提升计算性能。</p>
<p>当条件成立时说明当前线程通过hash计算出来数组位置处的cell为空，进一步去执行longAccumulate()方法。如果不成立则说明对应的cell不为空，下一步将要将x值通过CAS操作添加到cell中。</p>
<blockquote>
<p><strong>条件三：!(uncontended &#x3D; a.cas(v &#x3D; a.value, v + x)</strong></p>
</blockquote>
<p>主要看a.cas(v &#x3D; a.value, v + x)，接着条件二，说明当前线程hash与数组长度取模计算出的位置的cell有值，此时直接尝试一次CAS操作，如果成功则退出if条件，失败则继续往下执行longAccumulate()方法。</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/4793d884/c6ef3eb9446da4a3daea08bf7c71a1d2.webp" alt="条件二/条件三"></p>
<h3 id="longAccumulate-方法"><a href="#longAccumulate-方法" class="headerlink" title="longAccumulate()方法"></a>longAccumulate()方法</h3><p>接着往下看核心的<code>longAccumulate()</code>方法，代码很长，后面会一步步分析，先上代码：<code>java.util.concurrent.atomic.Striped64.</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">longAccumulate</span><span class="params">(<span class="type">long</span> x, LongBinaryOperator fn, <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.current();</span><br><span class="line">        h = getProbe();</span><br><span class="line">        wasUncontended = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Cell[] as; Cell a; <span class="type">int</span> n; <span class="type">long</span> v;</span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">Cell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(x);</span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Cell[] rs; <span class="type">int</span> m, j;</span><br><span class="line">                            <span class="keyword">if</span> ((rs = cells) != <span class="literal">null</span> &amp;&amp; (m = rs.length) &gt; <span class="number">0</span> &amp;&amp; rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)</span><br><span class="line">                wasUncontended = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        cells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            h = advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                    Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[<span class="number">2</span>];</span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cell</span>(x);</span><br><span class="line">                    cells = rs;</span><br><span class="line">                    init = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">            <span class="keyword">break</span>;                          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很长，<code>if else</code>分支很多，除此看肯定会很头疼。这里一点点分析，然后结合画图一步步了解其中实现原理。</p>
<p><strong>我们首先要清楚执行这个方法的前置条件，它们是或的关系，如上面条件一、二、三</strong></p>
<ol>
<li>cells数组没有初始化</li>
<li>cells数组已经初始化，但是当前线程对应的cell数据为空</li>
<li>cells数组已经初始化， 当前线程对应的cell数据为空，且CAS操作+1失败</li>
</ol>
<p><strong>longAccumulate()方法的入参：</strong></p>
<ul>
<li>long x 需要增加的值，一般默认都是1</li>
<li>LongBinaryOperator fn 默认传递的是null</li>
<li>wasUncontended竞争标识，如果是false则代表有竞争。只有cells初始化之后，并且当前线程CAS竞争修改失败，才会是false</li>
</ul>
<p><strong>然后再看下Striped64中一些变量或者方法的定义：</strong></p>
<ul>
<li>base: 类似于AtomicLong中全局的value值。在没有竞争情况下数据直接累加到base上，或者cells扩容时，也需要将数据写入到base上</li>
<li>collide：表示扩容意向，false 一定不会扩容，true可能会扩容。</li>
<li>cellsBusy：初始化cells或者扩容cells需要获取锁, 0:表示无锁状态 1:表示其他线程已经持有了锁</li>
<li>casCellsBusy(): 通过CAS操作修改cellsBusy的值，CAS成功代表获取锁，返回true</li>
<li>NCPU：当前计算机CPU数量，Cell数组扩容时会使用到</li>
<li>getProbe(): 获取当前线程的hash值</li>
<li>advanceProbe(): 重置当前线程的hash值</li>
</ul>
<p><strong>接着开始正式解析longAccumulate()源码：</strong></p>
<h4 id="获取当前线程的hash值"><a href="#获取当前线程的hash值" class="headerlink" title="获取当前线程的hash值"></a>获取当前线程的hash值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> PROBE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">    ThreadLocalRandom.current();</span><br><span class="line">    h = getProbe();</span><br><span class="line">    wasUncontended = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getProbe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.getInt(Thread.currentThread(), PROBE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们上面说过<code>getProbe()</code>方法是为了获取当前线程的<code>hash值</code>，具体实现是通过<code>UNSAFE.getInt()</code>实现的，<code>PROBE</code>是在初始化时候获取当前线程<code>threadLocalRandomProbe</code>的值。</p>
<blockquote>
<p>注：Unsafe.getInt()有三个重载方法getInt(Object o, long offset)、getInt(long address) 和getIntVolatile(long address)，都是从指定的位置获取变量的值，只不过第一个的offset是相对于对象o的相对偏移量，第二个address是绝对地址偏移量。如果第一个方法中o为null是，offset也会被作为绝对偏移量。第三个则是带有volatile语义的load读操作。</p>
</blockquote>
<p>如果当前线程的<strong>hash值h&#x3D;getProbe()为0，0与任何数取模都是0，会固定到数组第一个位置</strong>，所以这里做了优化，使用<code>ThreadLocalRandom</code>为当前线程重新计算一个<code>hash</code>值。最后设置<code>wasUncontended = true</code>，这里含义是重新计算了当前线程的<code>hash</code>后认为此次不算是一次竞争。<code>hash</code>值被重置就好比一个全新的线程一样，所以设置了竞争状态为<code>true</code>。</p>
<p>可以画图理解为：</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/4793d884/186462a13495f6f110241fdbcbcca51a.webp" alt="wasUncontended设置说明"></p>
<p>接着执行<code>for循环</code>，我们可以把<code>for循环</code>代码拆分一下，每个<code>if条件</code>算作一个<code>CASE</code>来分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">longAccumulate</span><span class="params">(<span class="type">long</span> x, LongBinaryOperator fn, <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Cell[] as; Cell a; <span class="type">int</span> n; <span class="type">long</span> v;</span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">                                   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，第一个<code>if语句代表CASE1</code>，里面再有<code>if判断</code>会以<code>CASE1.1</code>这种形式来讲解，下面接着的<code>else if</code>为<code>CASE2</code>， 最后一个为<code>CASE3</code></p>
<h4 id="CASE1执行条件："><a href="#CASE1执行条件：" class="headerlink" title="CASE1执行条件："></a><strong>CASE1执行条件</strong>：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cells数组</code>不为空，且数组长度大于0的情况会执行<code>CASE1</code>，<code>CASE1</code>的实现细节代码较多，放到最后面讲解。</p>
<h4 id="CASE2执行条件和实现原理："><a href="#CASE2执行条件和实现原理：" class="headerlink" title="CASE2执行条件和实现原理："></a><strong>CASE2执行条件和实现原理</strong>：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[<span class="number">2</span>];</span><br><span class="line">                rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cell</span>(x);</span><br><span class="line">                cells = rs;</span><br><span class="line">                init = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            cellsBusy = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (init)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CASE2</code> 标识<code>cells数组</code>还未初始化，因为判断<code>cells == as</code>，这个代表当前线程到了这里获取的<code>cells</code>还是之前的一致。我们可以先看这个<code>case</code>，最后再回头看最为麻烦的<code>CASE1</code>实现逻辑。</p>
<p><code>cellsBusy</code>上面说了是加锁的状态，初始化<code>cells数组</code>和扩容的时候都要获取加锁的状态，这个是通过<code>CAS</code>来实现的，为0代表无锁状态，为1代表其他线程已经持有锁了。<code>cells==as</code>代表当前线程持有的数组未进行修改过，<code>casCellsBusy()</code>通过<code>CAS操作</code>去获取锁。但是里面的<code>if条件</code>又再次判断了<code>cell==as</code>，这一点是不是很奇怪？通过画图来说明下问题：</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/4793d884/273e36a3302c5dfc8bf2f377874698b0.webp" alt="cells==as双重判断说明"></p>
<p>如果上面条件都执行成功就会执行数组的初始化及赋值操作， <code>Cell[] rs = new Cell[2]</code>表示数组的长度为2，<code>rs[h &amp; 1] = new Cell(x)</code> 表示创建一个新的<code>Cell元素</code>，<strong>value是x值，默认为1。</strong></p>
<p><code>h &amp; 1</code>类似于我们之前<code>HashMap</code>或者<code>ThreadLocal</code>里面经常用到的计算散列桶<code>index</code>的算法，通常都是<code>hash &amp; (table.len - 1)</code>，这里就不做过多解释了。 执行完成后直接退出<code>for循环</code>。</p>
<h4 id="CASE3执行条件和实现原理："><a href="#CASE3执行条件和实现原理：" class="headerlink" title="CASE3执行条件和实现原理："></a><strong>CASE3执行条件和实现原理</strong>：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>进入到这里说明<code>cells</code>正在或者已经初始化过了，执行<code>caseBase()</code>方法，通过<code>CAS操作</code>来修改<code>base</code>的值，如果修改成功则跳出循环，这个<code>CAS</code>E只有在初始化<code>Cell数组</code>的时候，多个线程尝试<code>CAS</code>修改<code>cellsBusy</code>加锁的时候，失败的线程会走到这个分支，然后直接<code>CAS</code>修改<code>base</code>数据。</p>
<h4 id="CASE1-实现原理："><a href="#CASE1-实现原理：" class="headerlink" title="CASE1 实现原理："></a><strong>CASE1 实现原理</strong>：</h4><p>分析完了<code>CASE2和CASE3</code>，我们再折头回看一下<code>CASE1</code>，进入<code>CASE1</code>的前提是：<code>cells数组</code>不为空，已经完成了初始化赋值操作。</p>
<p>接着还是一点点往下拆分代码，首先看第一个判断分支<code>CASE1.1</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Cell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Cell[] rs; <span class="type">int</span> m, j;</span><br><span class="line">                <span class="keyword">if</span> ((rs = cells) != <span class="literal">null</span> &amp;&amp; (m = rs.length) &gt; <span class="number">0</span> &amp;&amp; rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    rs[j] = r;</span><br><span class="line">                    created = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (created)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    collide = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个if条件中<code>(a = as[(n - 1) &amp; h]) == null</code>代表当前线程对应的数组下标位置的<code>cell</code>数据为<code>null</code>，代表没有线程在此处创建<code>Cell</code>对象。</p>
<p>接着判断<code>cellsBusy==0</code>，代表当前锁未被占用。然后新创建<code>Cell对象</code>，接着又判断了一遍<code>cellsBusy == 0</code>，然后执行<code>casCellsBusy()</code>尝试通过CAS操作修改<code>cellsBusy=1</code>，加锁成功后修改扩容意向<code>collide = false;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((rs = cells) != <span class="literal">null</span> &amp;&amp; (m = rs.length) &gt; <span class="number">0</span> &amp;&amp; rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">        rs[j] = r;</span><br><span class="line">        created = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (created)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码判断当前线程<code>hash</code>后指向的数据位置元素是否为空，如果为空则将<code>cell</code>数据放入数组中，跳出循环。如果不为空则继续循环。</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/4793d884/832cea35b7087f97d7436e2a43d3ce6c.webp" alt="CASE1.1"></p>
<p>继续往下看代码，<strong>CASE1.2</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)</span><br><span class="line">    wasUncontended = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">h = advanceProbe(h);</span><br></pre></td></tr></table></figure>

<p><code>wasUncontended</code>表示<code>cells</code>初始化后，当前线程竞争修改失败<code>wasUncontended =false</code>，这里只是重新设置了这个值为<code>true</code>，紧接着执行<code>advanceProbe(h)</code>重置当前线程的<code>hash</code>，重新循环。</p>
<p>接着看<strong>CASE1.3</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>进入<code>CASE1.3</code>说明当前线程对应的数组中有了数据，也重置过<code>hash值</code>，这时通过CAS操作尝试对当前数中的<code>value值</code>进行累加x操作，x默认为1，如果<code>CAS</code>成功则直接跳出循环。</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/4793d884/eadaba5e49615bb61782925ea51f9f41.webp"></p>
<p>接着看<strong>CASE1.4：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">    collide = <span class="literal">false</span>;    </span><br></pre></td></tr></table></figure>

<p>如果<code>cells数组</code>的长度达到了<code>CPU核心数</code>，或者<code>cells</code>扩容了，设置扩容意向<code>collide为false</code>并通过下面的<code>h = advanceProbe(h)</code>方法修改线程的<code>probe</code>再重新尝试</p>
<p>至于这里为什么要提出和<code>CPU数量</code>做判断的问题：每个线程会通过线程对<code>cells[threadHash%cells.length]</code>位置的<code>Cell</code>对象中的<code>value</code>做累加，这样相当于将线程绑定到了<code>cells</code>中的某个<code>cell</code>对象上，如果超过<code>CPU数量</code>的时候就不再扩容是因为<code>CPU</code>的数量代表了机器处理能力，当超过<code>CPU</code>数量时，多出来的<code>cells</code>数组元素没有太大作用。</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/4793d884/5b3daf38f674ba23d23b9d1b397c7e85.webp" alt="多线程更新Cell"></p>
<p>接着看<strong>CASE1.5</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">  collide = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>如果扩容意向<code>collide</code>是<code>false</code>则修改它为<code>true</code>，然后重新计算当前线程的<code>hash</code>值继续循环，在<code>CASE1.4</code>中，如果当前数组的长度已经大于了<code>CPU</code>的核数，就会再次设置扩容意向<code>collide=false</code>，这里的意义是保证扩容意向为<code>false</code>后不再继续往后执行<code>CASE1.6</code>的扩容操作。</p>
<p><strong>接着看CASE1.6分支：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">            Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                rs[i] = as[i];</span><br><span class="line">            cells = rs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        cellsBusy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    collide = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面执行的其实是扩容逻辑，首先是判断通过<code>CAS</code>改变<code>cellsBusy</code>来尝试加锁，如果<code>CAS</code>成功则代表获取锁成功，继续向下执行，判断当前的<code>cells</code>数组和最先赋值的<code>as</code>是同一个，代表没有被其他线程扩容过，然后进行扩容，扩容大小为之前的容量的两倍，这里用的按位左移1位来操作的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[n &lt;&lt; <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>扩容后再将之前数组的元素拷贝到新数组中，释放锁设置<code>cellsBusy = 0</code>，设置扩容状态，然后继续循环执行。</p>
<p>到了这里，我们已经分析完了<code>longAccumulate()</code>所有的逻辑，逻辑分支挺多，仔细分析看看其实还是挺清晰的，流程图如下：</p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src= "/medias/detail/load.gif" data-lazy-src="/p/4793d884/04c5a16508f70601000b53f8e19045e5.webp" alt="流程图"></p>
<p>我们再举一些线程执行的例子里面场景覆盖不全，大家可以按照这种模式自己模拟场景分析代码流程：</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/4793d884/38b5b0eee12d2b7b5d6ecaabbdae7ffd.webp" alt="多线程执行示例"></p>
<p>如有问题也请及时指出，我会第一时间更正，不胜感激！</p>
<h3 id="LongAdder的sum方法"><a href="#LongAdder的sum方法" class="headerlink" title="LongAdder的sum方法"></a>LongAdder的sum方法</h3><p>当我们最终获取计数器值时，我们可以使用<code>LongAdder.longValue()</code>方法，其内部就是使用<code>sum</code>方法来汇总数据的。</p>
<p><code>java.util.concurrent.atomic.LongAdder.sum()</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现很简单，base + 遍历<code>cells</code>数组中的值，然后累加。</p>
<h2 id="CAS在JDK中的广泛应用"><a href="#CAS在JDK中的广泛应用" class="headerlink" title="CAS在JDK中的广泛应用"></a>CAS在JDK中的广泛应用</h2><h3 id="CAS操作的弊端和规避措施"><a href="#CAS操作的弊端和规避措施" class="headerlink" title="CAS操作的弊端和规避措施"></a>CAS操作的弊端和规避措施</h3><p>CAS操作的弊端主要有以下三点：</p>
<ol>
<li>ABA问题<ul>
<li>使用CAS操作内存数据时，数据发生过变化也能更新成功，如操作序列A&#x3D;&#x3D;&gt;B&#x3D;&#x3D;&gt;A时，最后一个CAS的预期数据A实际已经发生过更改，但也能更新成功，这就产生了ABA问题。</li>
<li>ABA问题的解决思路是使用版本号。在变量前面追加上版本号，每次变量更新的时候将版本号加1，那么操作序列A&#x3D;&#x3D;&gt;B&#x3D;&#x3D;&gt;A就会变成A1&#x3D;&#x3D;&gt;B2&#x3D;&#x3D;&gt;A3，如果将A1当作A3的预期数据，就会操作失败。</li>
<li>JDK提供了两个类<code>AtomicStampedReference</code>和<code>AtomicMarkableReference</code>来解决ABA问题。比较常用的是AtomicStampedReference类，该类的compareAndSet()方法的作用是首先检查当前引用是否等于预期引用，以及当前印戳是否等于预期印戳，如果全部相等，就以原子方式将引用和印戳的值一同设置为新的值。</li>
</ul>
</li>
<li>只能保证一个共享变量之间的原子性操作<ul>
<li>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，CAS就无法保证操作的原子<br>性。</li>
<li>一个比较简单的规避方法为：把多个共享变量合并成一个共享变量来操作。</li>
<li>JDK提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，可以把多个变量放在一个AtomicReference实例后再进行CAS操作。比如有两个共享变量i＝1、j&#x3D;2，可以将二者合并成一个对象，然后用CAS来操作该合并对象的AtomicReference引用。</li>
</ul>
</li>
<li>开销问题自旋CAS如果长时间不成功（不成功就一直循环执行，直到成功），就会给CPU带来非常大的执行开销。<strong>解决CAS恶性空自旋的有效方式之一是以空间换时间</strong>，较为常见的方案为：<ul>
<li>分散操作热点，使用LongAdder替代基础原子类AtomicLong，LongAdder将单个CAS热点（value值）分散到一个cells数组中。</li>
<li>使用队列削峰，将发生CAS争用的线程加入一个队列中排队，降低CAS争用的激烈程度。JUC中非常重要的基础类AQS（抽象队列同步器）就是这么做的。</li>
</ul>
</li>
</ol>
<h3 id="CAS操作在JDK中的应用"><a href="#CAS操作在JDK中的应用" class="headerlink" title="CAS操作在JDK中的应用"></a>CAS操作在JDK中的应用</h3><ul>
<li>CAS在java.util.concurrent.atomic包中的原子类、Java AQS以及显式锁、CurrentHashMap等重要并发容器类的实现都有非常广泛的应用。</li>
<li>在java.util.concurrent.atomic包的原子类（如AtomicXXX）中都使用了CAS来保障对数字成员进行操作的原子性。</li>
<li>java.util.concurrent的大多数类（包括显式锁、并发容器）都是基于AQS和AtomicXXX来实现的，其中AQS通过CAS保障它内部双向队列头部、尾部操作的原子性。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/r1-12king/p/17406220.html">longadder原理 - r1-12king - 博客园</a></p>
<script>var description="介绍CAS的原理和弊端，然后介绍基于CAS实现的JUC原子类。"</script></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://fulsun.github.io">凉月</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://fulsun.github.io/p/4793d884">https://fulsun.github.io/p/4793d884</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://fulsun.github.io" target="_blank">凉月の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CAS%E5%8E%9F%E7%90%86/">CAS原理</a><a class="post-meta__tags" href="/tags/JUC%E5%8E%9F%E5%AD%90%E7%B1%BB/">JUC原子类</a></div><div class="post-share"><div class="social-share" data-image="/medias/featureimages/002.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/p/6feba110" title="Java内置锁的核心原理"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/005.webp" onerror="onerror=null;src='/medias/detail/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Java内置锁的核心原理</div></div><div class="info-2"><div class="info-item-1">从线程安全问题开始讲起，为大家揭秘Java内置锁的核心原理。</div></div></div></a><a class="pagination-related" href="/p/1c8195dc" title="可见性与有序性的原理"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/011.webp" onerror="onerror=null;src='/medias/detail/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">可见性与有序性的原理</div></div><div class="info-2"><div class="info-item-1">介绍Java如何解决并发编程中的可见性和有序性问题。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/p/1c8195dc" title="可见性与有序性的原理"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/011.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-10</div><div class="info-item-2">可见性与有序性的原理</div></div><div class="info-2"><div class="info-item-1">介绍Java如何解决并发编程中的可见性和有序性问题。</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/avatar.jpg" onerror="this.onerror=null;this.src='/medias/detail/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">凉月</div><div class="author-info-description">记录生活,分享知识。</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/fulsun"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/fulsun" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:fl_6145@163.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">感谢访问本站，若喜欢请收藏 ^_^</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCAS"><span class="toc-text">什么是CAS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unsafe%E7%B1%BB%E4%B8%AD%E7%9A%84CAS%E6%96%B9%E6%B3%95"><span class="toc-text">Unsafe类中的CAS方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Unsafe%E5%AE%9E%E4%BE%8B"><span class="toc-text">获取Unsafe实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8Unsafe%E6%8F%90%E4%BE%9B%E7%9A%84CAS%E6%96%B9%E6%B3%95"><span class="toc-text">调用Unsafe提供的CAS方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8Unsafe%E6%8F%90%E4%BE%9B%E7%9A%84%E5%81%8F%E7%A7%BB%E9%87%8F%E7%9B%B8%E5%85%B3"><span class="toc-text">调用Unsafe提供的偏移量相关</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8CAS%E8%BF%9B%E8%A1%8C%E6%97%A0%E9%94%81%E7%BC%96%E7%A8%8B"><span class="toc-text">使用CAS进行无锁编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%94%81%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%AE%89%E5%85%A8%E8%87%AA%E5%A2%9E"><span class="toc-text">无锁编程实现轻量级安全自增</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E5%81%8F%E7%A7%BB%E9%87%8F%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-text">字段偏移量的计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JUC%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-text">JUC原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%8C%85"><span class="toc-text">Atomic原子操作包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-text">基本原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-text">数组原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-text">引用原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-text">字段更新原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicInteger"><span class="toc-text">基础原子类AtomicInteger</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicIntegerArray"><span class="toc-text">数组原子类AtomicIntegerArray</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicInteger%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8E%9F%E7%90%86"><span class="toc-text">AtomicInteger线程安全原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-text">引用类型原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%9B%B4%E6%96%B0%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-text">属性更新原子类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ABA%E9%97%AE%E9%A2%98"><span class="toc-text">ABA问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3ABA%E9%97%AE%E9%A2%98"><span class="toc-text">了解ABA问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ABA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">ABA问题解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicStampedReference"><span class="toc-text">AtomicStampedReference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicMarkableReference"><span class="toc-text">AtomicMarkableReference</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E5%8D%87%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8BCAS%E6%93%8D%E4%BD%9C%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-text">提升高并发场景下CAS操作的性能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E7%A9%BA%E9%97%B4%E6%8D%A2%E6%97%B6%E9%97%B4%EF%BC%9ALongAdder"><span class="toc-text">以空间换时间：LongAdder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicLong%E5%8F%AF%E4%BB%A5%E5%BC%83%E7%94%A8%E4%BA%86%E5%90%97%EF%BC%9F"><span class="toc-text">AtomicLong可以弃用了吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LongAdder%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">LongAdder的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-text">操作原理图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%8A%A0%E9%94%81%E6%80%9D%E8%B7%AF"><span class="toc-text">分段加锁思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E4%BC%AA%E5%85%B1%E4%BA%AB"><span class="toc-text">消除伪共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC"><span class="toc-text">惰性求值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LongAdder%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">LongAdder实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LongAdder%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-text">LongAdder源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#add-%E6%96%B9%E6%B3%95"><span class="toc-text">add()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#longAccumulate-%E6%96%B9%E6%B3%95"><span class="toc-text">longAccumulate()方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E7%9A%84hash%E5%80%BC"><span class="toc-text">获取当前线程的hash值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CASE1%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-text">CASE1执行条件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CASE2%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">CASE2执行条件和实现原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CASE3%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">CASE3执行条件和实现原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CASE1-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">CASE1 实现原理：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-text">流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LongAdder%E7%9A%84sum%E6%96%B9%E6%B3%95"><span class="toc-text">LongAdder的sum方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS%E5%9C%A8JDK%E4%B8%AD%E7%9A%84%E5%B9%BF%E6%B3%9B%E5%BA%94%E7%94%A8"><span class="toc-text">CAS在JDK中的广泛应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E6%93%8D%E4%BD%9C%E7%9A%84%E5%BC%8A%E7%AB%AF%E5%92%8C%E8%A7%84%E9%81%BF%E6%8E%AA%E6%96%BD"><span class="toc-text">CAS操作的弊端和规避措施</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E6%93%8D%E4%BD%9C%E5%9C%A8JDK%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">CAS操作在JDK中的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考:</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/p/b3bc049e" title="Java中的SPI服务发现机制"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/003.webp" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Java中的SPI服务发现机制"/></a><div class="content"><a class="title" href="/p/b3bc049e" title="Java中的SPI服务发现机制">Java中的SPI服务发现机制</a><time datetime="2025-02-16T05:36:57.339Z" title="发表于 2025-02-16 05:36:57">2025-02-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/3ca9bef3" title="SpringBoot预览PDF文件"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/001.webp" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="SpringBoot预览PDF文件"/></a><div class="content"><a class="title" href="/p/3ca9bef3" title="SpringBoot预览PDF文件">SpringBoot预览PDF文件</a><time datetime="2025-02-07T10:19:00.000Z" title="发表于 2025-02-07 10:19:00">2025-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/9b5fc26a" title="Debain12配置"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/013.webp" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Debain12配置"/></a><div class="content"><a class="title" href="/p/9b5fc26a" title="Debain12配置">Debain12配置</a><time datetime="2025-02-06T16:07:00.000Z" title="发表于 2025-02-06 16:07:00">2025-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/42bd8820" title="Docker安装脚本与换源"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/009.webp" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Docker安装脚本与换源"/></a><div class="content"><a class="title" href="/p/42bd8820" title="Docker安装脚本与换源">Docker安装脚本与换源</a><time datetime="2025-02-05T16:00:00.000Z" title="发表于 2025-02-05 16:00:00">2025-02-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/c3561f90" title="Nvm包管理器"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/007.webp" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Nvm包管理器"/></a><div class="content"><a class="title" href="/p/c3561f90" title="Nvm包管理器">Nvm包管理器</a><time datetime="2025-01-22T16:00:55.000Z" title="发表于 2025-01-22 16:00:55">2025-01-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 凉月</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.3.2"></script><script src="/js/main.js?v=5.3.2"></script><script src="https://unpkg.com/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://waline-fulsun.netlify.app/.netlify/functions/comment',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://unpkg.com/@waline/client@3.4.3/dist/waline.css')
        .then(() => import('https://unpkg.com/@waline/client@3.4.3/dist/waline.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://unpkg.com/butterfly-extsrc@1.1.4/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>