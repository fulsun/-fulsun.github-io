<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JUC显式锁的原理与实战 | 凉月の博客</title><meta name="author" content="凉月"><meta name="copyright" content="凉月"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JUC显式锁是一种非常灵活的、使用纯Java语言实现的锁。">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC显式锁的原理与实战">
<meta property="og:url" content="https://fulsun.github.io/p/de78061e">
<meta property="og:site_name" content="凉月の博客">
<meta property="og:description" content="JUC显式锁是一种非常灵活的、使用纯Java语言实现的锁。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fulsun.github.io/medias/featureimages/013.webp">
<meta property="article:published_time" content="2025-01-11T00:15:06.000Z">
<meta property="article:modified_time" content="2025-02-16T05:36:57.325Z">
<meta property="article:author" content="凉月">
<meta property="article:tag" content="JUC显式锁">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fulsun.github.io/medias/featureimages/013.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JUC显式锁的原理与实战",
  "url": "https://fulsun.github.io/p/de78061e",
  "image": "https://fulsun.github.io/medias/featureimages/013.webp",
  "datePublished": "2025-01-11T00:15:06.000Z",
  "dateModified": "2025-02-16T05:36:57.325Z",
  "author": [
    {
      "@type": "Person",
      "name": "凉月",
      "url": "https://fulsun.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/medias/favicon.png"><link rel="canonical" href="https://fulsun.github.io/p/de78061e"><link rel="preconnect" href="//unpkg.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.3.2"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')
          
          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 凉月","link":"链接: ","source":"来源: 凉月の博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JUC显式锁的原理与实战',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: linear-gradient(90deg, rgba(247, 149, 51, .1), rgba(243, 112, 85, .1) 15%, rgba(239, 78, 123, .1) 30%, rgba(161, 102, 171, .1) 44%, rgba(80, 115, 184, .1) 58%, rgba(16, 152, 173, .1) 72%, rgba(7, 179, 155, .1) 86%, rgba(109, 186, 130, .1));"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/avatar.jpg" onerror="this.onerror=null;this.src='/medias/detail/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heartbeat"></i><span> 我的</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> 联系</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 博主</span></a></li><li><a class="site-page child" href="/contact"><i class="fa-fw fas fa-comments"></i><span> 留言</span></a></li><li><a class="site-page child" href="/journal"><i class="fa-fw fas fa-cogs"></i><span> 日志</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> JS动画</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/snake/"><i class="fa-fw fas fa-gamepad"></i><span> 贪吃蛇</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/medias/featureimages/013.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">凉月の博客</span></a><a class="nav-page-title" href="/"><span class="site-name">JUC显式锁的原理与实战</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heartbeat"></i><span> 我的</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> 联系</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 博主</span></a></li><li><a class="site-page child" href="/contact"><i class="fa-fw fas fa-comments"></i><span> 留言</span></a></li><li><a class="site-page child" href="/journal"><i class="fa-fw fas fa-cogs"></i><span> 日志</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> JS动画</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/snake/"><i class="fa-fw fas fa-gamepad"></i><span> 贪吃蛇</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">JUC显式锁的原理与实战</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-11T00:15:06.000Z" title="发表于 2025-01-11 00:15:06">2025-01-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-16T05:36:57.325Z" title="更新于 2025-02-16 05:36:57">2025-02-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/">多线程编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">20.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>71分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:500,&quot;messagePrev&quot;:&quot;至上次更新后的&quot;,&quot;messageNext&quot;:&quot;天,文章内容可能已过时。&quot;,&quot;postUpdate&quot;:&quot;2025-02-16 05:36:57&quot;}" hidden></div><span id="more"></span>

<h2 id="显式锁"><a href="#显式锁" class="headerlink" title="显式锁"></a>显式锁</h2><p>使用Java内置锁时，不需要通过Java代码显式地对同步对象的监视器进行抢占和释放，这些工作由JVM底层完成，而且任何一个Java对象都能作为一个内置锁使用，所以Java的对象锁使用起来非常方便。</p>
<p>但是，Java内置锁的功能相对单一，不具备一些比较高级的锁功能，比如：</p>
<ol>
<li>限时抢锁：在抢锁时设置超时时长，如果超时还未获得锁就放弃，不至于无限等下去。</li>
<li>可中断抢锁：在抢锁时，外部线程给抢锁线程发一个中断信号，就能唤起等待锁的线程，并终止抢占过程。</li>
<li>多个等待队列：为锁维持多个等待队列，以便提高锁的效率。比如在生产者-消费者模式实现中，生产者和消费者共用一把锁，<br>该锁上维持两个等待队列，即一个生产者队列和一个消费者队列。</li>
</ol>
<p>除了以上功能问题之外，Java对象锁还存在性能问题。在竞争稍微激烈的情况下，Java对象锁会膨胀为重量级锁（基于操作系统的<br>Mutex Lock实现），而重量级锁的线程阻塞和唤醒操作需要进程在内核态和用户态之间来回切换，导致其性能非常低。所以，迫切需要提供一种新的锁来提升争用激烈场景下锁的性能。</p>
<p><strong>Java显式锁就是为了解决这些Java对象锁的功能问题、性能问题而生的</strong>。JDK 5版本引入了Lock接口，Lock是Java代码级别的锁。为了与Java对象锁相区分，Lock接口叫作显式锁接口，其对象实例叫作显式锁对象。</p>
<h2 id="显式锁Lock接口"><a href="#显式锁Lock接口" class="headerlink" title="显式锁Lock接口"></a>显式锁Lock接口</h2><p>JDK 5版本引入了java.util.concurrent并发包，简称为JUC包，里面提供了各种高并发工具类，通过此JUC工具包可以在Java代码中实现功能非常强大的多线程并发操作。所以，Java显式锁也叫JUC显式锁。</p>
<blockquote>
<p>JUC出自并发大师Doug Lea之手，Doug Lea对Java并发性能的提升做出了巨大的贡献。除了实现JUC包外，Doug Lea还提供了高并发IO模式——Reactor模式多个版本的参考实现。</p>
</blockquote>
<p>Lock接口位于<code>java.util.concurrent.locks</code>包中，是JUC显式锁的一个抽象，Lock接口的主要抽象方法如表所示。</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>void lock()</code></td>
<td>获取锁。若锁不可用，调用线程会阻塞，直至获取到锁</td>
</tr>
<tr>
<td><code>void lockInterruptibly() throws InterruptedException</code></td>
<td>获取锁，该方法能响应中断，等待锁时若被中断则抛出<code>InterruptedException</code>，同时清除线程中断状态</td>
</tr>
<tr>
<td><code>boolean tryLock()</code></td>
<td>尝试获取锁，锁可用则获取并返回<code>true</code>；若不可用，立即返回<code>false</code>，线程不阻塞</td>
</tr>
<tr>
<td><code>boolean tryLock(long time, TimeUnit unit) throws InterruptedException</code></td>
<td>在指定时长内尝试获取锁，若在时长内获取到锁返回<code>true</code>，超时未获取则返回<code>false</code>，期间可响应中断</td>
</tr>
<tr>
<td><code>void unlock()</code></td>
<td>释放锁，通常需搭配<code>lock</code>系列方法在<code>finally</code>块中调用，确保锁能正常释放</td>
</tr>
<tr>
<td><code>Condition newCondition()</code></td>
<td>创建一个与该锁绑定的条件对象，用于线程间复杂的同步控制，像实现等待 &#x2F; 通知机制</td>
</tr>
</tbody></table>
<p>JUC包中提供了一系列的显式锁实现类（如ReentrantLock），当然也允许应用程序提供自定义的锁实现类。与synchronized关键字不同，显式锁不再作为Java内置特性来实现，而是作为Java语言可编程特性来实现。这就为多种不同功能的锁实现留下了空间，各种锁实现可能有不同的调度算法、性能特性或者锁定语义。<br>从Lock提供的接口方法可以看出，显式锁至少比Java内置锁多了以下优势：</p>
<ul>
<li><strong>可中断获取锁</strong><br>使用synchronized关键字获取锁的时候，如果线程没有获取到被阻塞，阻塞期间该线程是不响应中断信号（interrupt）的；而调用<code>Lock.lockInterruptibly()</code>方法获取锁时，如果线程被中断，线程将抛出中断异常。</li>
<li><strong>可非阻塞获取锁</strong><br>使用synchronized关键字获取锁时，如果没有成功获取，线程只有被阻塞；而调用<code>Lock.tryLock()</code>方法获取锁时，如果没有获取成功，线程也不会被阻塞，而是直接返回false。</li>
<li><strong>可限时抢锁</strong><br>调用<code>Lock.tryLock(long time,TimeUnit unit)</code>方法，显式锁可以设置限定抢占锁的超时时间。而在使用synchronized关键字获取锁时，如果不能抢到锁，线程只能无限制阻塞。</li>
</ul>
<p>除了以上能通过Lock接口直接观察出来的三点优势之外，显式锁还有不少其他的优势，稍后在介绍显式锁种类繁多的实现类时，大家就能感觉到。</p>
<h2 id="可重入锁ReentrantLock"><a href="#可重入锁ReentrantLock" class="headerlink" title="可重入锁ReentrantLock"></a>可重入锁ReentrantLock</h2><p>ReentrantLock是JUC包提供的显式锁的一个基础实现类，ReentrantLock类实现了Lock接口，它拥有与synchronized相同的并发性和内存语义，但是<strong>拥有了限时抢占、可中断抢占等一些高级锁特性</strong>。此外，ReentrantLock基于内置的抽象队列同步器（Abstract Queued Synchronized，AQS）实现，在争用激烈的场景下，能表现出表内置锁更佳的性能。</p>
<p>ReentrantLock是一个可重入的独占（或互斥）锁，其中两个修饰词的含义为：</p>
<ul>
<li><p><strong>可重入</strong>的含义：表示该锁能够支持一个线程对资源的重复加锁，也就是说，一个线程可以多次进入同一个锁所同步的临界区代码<br>块。比如，同一线程在外层函数获得锁后，在内层函数能再次获取该锁，甚至多次抢占到同一把锁。<br>下面是一段对可重入锁进行两次抢占和释放的伪代码，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lock.lock(); <span class="comment">// 第一次获取锁</span></span><br><span class="line">lock.lock(); <span class="comment">// 第二次获取锁，重新进入 </span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">// 临界区代码块 </span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">    lock.unlock(); <span class="comment">// 第二次释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>独占</strong>的含义：在同一时刻只能有一个线程获取到锁，而其他获取锁的线程只能等待，只有拥有锁的线程释放了锁后，其他的线程<br>才能够获取锁。</p>
</li>
<li><p>一个简单地使用ReentrantLock进行同步累加的演示案例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread1.join();</span><br><span class="line">            thread2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最终累加结果: &quot;</span> + count); <span class="comment">// 最终累加结果: 2000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="使用显式锁的模板代码"><a href="#使用显式锁的模板代码" class="headerlink" title="使用显式锁的模板代码"></a>使用显式锁的模板代码</h2><p>因为JUC中的显式锁都实现了Lock接口，所以不同类型的显式锁对象的使用方法都是模板化的、套路化的.</p>
<h3 id="使用lock-方法抢锁的模板代码"><a href="#使用lock-方法抢锁的模板代码" class="headerlink" title="使用lock()方法抢锁的模板代码"></a>使用lock()方法抢锁的模板代码</h3><p>通常情况下，大家会调用lock()方法进行<strong>阻塞式</strong>的锁抢占，其模板代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建锁对象，SomeLock为Lock的某个实现类，如ReentrantLock</span></span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SomeLock</span>(); </span><br><span class="line">lock.lock(); <span class="comment">//step1：抢占锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">//step2：抢锁成功，执行临界区代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> lock.unlock(); <span class="comment">//step3：释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上抢锁模板代码有以下几个需要注意的要点：</p>
<ol>
<li><strong>释放锁操作<code>lock.unlock()</code>必须在try-catch结构的finally块中执行</strong>，否则，如果临界区代码抛出异常，锁就有可能永远得不到释放。</li>
<li><strong>抢占锁操作<code>lock.lock()</code>必须在try语句块之外</strong>，而不是放在try语句块之内。为什么呢？<ul>
<li>原因之一是lock()方法没有申明抛出异常，所以可以不包含到try块中；</li>
<li>原因之二是lock()方法并不一定能够抢占锁成功，如果没有抢占成功，当然也就不需要释放锁，而且在没有占有锁的情况下去释放锁，可能会导致运行时异常。</li>
</ul>
</li>
<li><strong>在抢占锁操作<code>lock.lock()</code>和try语句之间不要插入任何代码</strong>，避免抛出异常而导致释放锁操作<code>lock.unlock()</code>执行不到，导致锁无法被释放。</li>
</ol>
<h3 id="调用tryLock-方法非阻塞抢锁的模板代码"><a href="#调用tryLock-方法非阻塞抢锁的模板代码" class="headerlink" title="调用tryLock()方法非阻塞抢锁的模板代码"></a>调用tryLock()方法非阻塞抢锁的模板代码</h3><p>lock()是阻塞式抢占，在没有抢到锁的情况下，当前线程会阻塞。如果不希望线程阻塞，可以调用tryLock()方法抢占锁。<strong>tryLock()是非阻塞抢占，在没有抢到锁的情况下，当前线程会立即返回，不会被阻塞。</strong></p>
<p>调用tryLock()方法非阻塞抢占锁，大致的模板代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建锁对象，SomeLock为Lock的某个实现类，如ReentrantLock</span></span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SomeLock</span>();</span><br><span class="line"><span class="keyword">if</span> (lock.tryLock()) &#123; <span class="comment">// step1：尝试抢占锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// step2：抢锁成功，执行临界区代码</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// step3：释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// step4：抢锁失败，执行后备动作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>tryLock()</code>方法时，线程拿不到锁就立即返回，这种处理方式在实际开发中使用不多，但是其重载版本<code>tryLock(long  time,TimeUnit unit)</code>方法在限时阻塞抢锁的场景中非常有用。</p>
<h3 id="调用tryLock-long-time-TimeUnit-unit-方法"><a href="#调用tryLock-long-time-TimeUnit-unit-方法" class="headerlink" title="调用tryLock(long time,TimeUnit unit)方法"></a>调用tryLock(long time,TimeUnit unit)方法</h3><p>tryLock(long time,TimeUnit unit)方法用于限时抢锁，该方法在抢锁时会进行一段时间的阻塞等待，其中的time参数代表最大的阻塞时长，unit参数为时长的单位（如秒）。</p>
<p>调用tryLock(long time,TimeUnit unit)方法限时抢锁，其大致的代码模板如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建锁对象，SomeLock为Lock的某个实现类，如ReentrantLock</span></span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SomeLock</span>();</span><br><span class="line"><span class="comment">// 抢锁时阻塞一段时间，如1秒</span></span><br><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123; <span class="comment">// step1：限时阻塞抢占</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// step2：抢锁成功，执行临界区代码</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// step3：释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 限时抢锁失败，执行后备操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="显式锁进行“等待-通知”"><a href="#显式锁进行“等待-通知”" class="headerlink" title="显式锁进行“等待-通知”"></a>显式锁进行“等待-通知”</h2><p>在前面介绍Java的线程间通信机制时，基于Java内置锁实现一种简单的“等待-通知”方式的线程间通信：通过Object对象的<code>wait</code>、<code>notify</code>两类方法作为开关信号，用来完成通知方线程和等待方线程之间的通信。</p>
<p>“等待-通知”方式的线程间通信机制，具体来说是指一个线程A调用了同步对象的wait()方法进入等待状态，而另一线程B调用了同步<br>对象的<code>notify()</code>或者<code>notifyAll()</code>方法去唤醒等待线程，当线程A收到线程B的唤醒通知后，就可以重新开始执行了。</p>
<p>需要特别注意的是，在通信过程中，线程需要拥有同步对象的监视器，<strong>在执行Object对象的wait、notify方法之前，线程必须先通过抢占到内置锁而成为其监视器的Owner</strong>。</p>
<p>与Object对象的wait、notify两类方法相类似，基于Lock显式锁，JUC也为大家提供了一个用于线程间进行“等待-通知”方式通信的接口——<code>java.util.concurrent.locks.Condition</code>。</p>
<h3 id="Condition接口的主要方法"><a href="#Condition接口的主要方法" class="headerlink" title="Condition接口的主要方法"></a>Condition接口的主要方法</h3><ul>
<li>Condition类的await方法和Object类的wait方法等效。</li>
<li>Condition类的signal方法和Object类的notify方法等效。</li>
<li>Condition类的signalAll方法和Object类的notifyAll方法等效。</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>await()</td>
<td>使当前线程等待，直到被通知（signal）或中断。它会释放当前持有的锁，进入等待状态。</td>
</tr>
<tr>
<td>awaitUninterruptibly()</td>
<td>和 await () 类似，不过这个方法不会响应中断，线程会一直处于等待状态直到被通知。</td>
</tr>
<tr>
<td>signal()</td>
<td>唤醒一个等待在这个 Condition 上的线程。</td>
</tr>
<tr>
<td>signalAll()</td>
<td>唤醒所有等待在这个 Condition 上的线程。</td>
</tr>
</tbody></table>
<p>Condition对象的signal（通知）方法和同一个对象的await（等待）方法是一一配对使用的，也就是说，一个Condition对象的signal（或signalAll）方法不能去唤醒其他Condition对象上的await线程。</p>
<p>Condition对象是基于显式锁的，所以不能独立创建一个Condition对象，而是需要借助于显式锁实例去获取其绑定的Condition对象。不过，每一个<strong>Lock显式锁实例都可以有任意数量的Condition对象</strong>。具体来说，可以通过<code>lock.newCondition()</code>方法去获取一个与当前显式锁绑定的Condition实例，然后通过该Condition实例进行“等待-通知”方式的线程间通信。</p>
<h3 id="显式锁Condition演示案例"><a href="#显式锁Condition演示案例" class="headerlink" title="显式锁Condition演示案例"></a>显式锁Condition演示案例</h3><p>基于Condition的“等待-通知”通信机制实现一个更高性能的生产者-消费者程序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] buffer = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">putIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">takeIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者往缓冲区放入数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> value)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 当缓冲区已满时，等待</span></span><br><span class="line">            <span class="keyword">while</span> (count == buffer.length) &#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            buffer[putIndex] = value;</span><br><span class="line">            putIndex = (putIndex + <span class="number">1</span>) % buffer.length;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 放入数据后，通知消费者缓冲区有数据了</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者从缓冲区取出数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 当缓冲区为空时，等待</span></span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> buffer[takeIndex];</span><br><span class="line">            takeIndex = (takeIndex + <span class="number">1</span>) % buffer.length;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="comment">// 取出数据后，通知生产者缓冲区有空位了</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Buffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Buffer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.put(i);</span><br><span class="line">                    System.out.println(<span class="string">&quot;生产者生产了: &quot;</span> + i);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> buffer.take();</span><br><span class="line">                    System.out.println(<span class="string">&quot;消费者消费了: &quot;</span> + value);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producerThread.start();</span><br><span class="line">        consumerThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            producerThread.join();</span><br><span class="line">            consumerThread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p>LockSupport是JUC提供的一个线程阻塞与唤醒的工具类，该工具类可以<strong>让线程在任意位置阻塞和唤醒</strong>，其所有的方法都是静态方法。</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>LockSupport的方法主要有两类：<code>park</code>和<code>unpark</code>。park的英文意思为停车，如果把Thread看成一辆车的话，<code>park()</code>方法就是让车停下，其作用是将调用<code>park()</code>方法的当前线程阻塞；而<code>unpark()方法</code>是让车启动，然后跑起来，其作用是将指定线程Thread唤醒。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>park()</code></td>
<td>无限期阻塞当前线程，直到被中断或者被<code>unpark</code>方法唤醒。</td>
<td>无参数</td>
</tr>
<tr>
<td><code>unpark(Thread thread)</code></td>
<td>唤醒指定的被阻塞线程，使其有机会继续执行。</td>
<td><code>thread</code>：要唤醒的目标线程对象</td>
</tr>
<tr>
<td><code>parkNanos(long nanos)</code></td>
<td>阻塞当前线程，不过存在超时时间限制，超时后线程会自动恢复执行，也可提前被中断或<code>unpark</code>唤醒。</td>
<td><code>nanos</code>：阻塞的最长纳秒时间</td>
</tr>
<tr>
<td><code>parkUntil(long deadline)</code></td>
<td>阻塞当前线程，直至达到指定时间，也可提前被中断或<code>unpark</code>唤醒。</td>
<td><code>deadline</code>：表示阻塞截止的绝对时间（通常基于<code>System.currentTimeMillis()</code>等计算得出）</td>
</tr>
<tr>
<td><code>park(Object blocker)</code></td>
<td>无限期阻塞当前线程，同时关联<code>blocker</code>对象，方便诊断工具确定线程阻塞原因。</td>
<td><code>blocker</code>：用于标识阻塞原因的对象</td>
</tr>
<tr>
<td><code>parkNanos(Object blocker, long nanos)</code></td>
<td>限时阻塞当前线程，并关联<code>blocker</code>对象，用于辅助分析阻塞相关情况。</td>
<td><code>blocker</code>：用于标识阻塞原因的对象 <code>nanos</code>：阻塞的最长纳秒时间</td>
</tr>
<tr>
<td><code>getBlocker(Thread t)</code></td>
<td>获取指定被阻塞线程关联的<code>blocker</code>对象，便于分析线程阻塞原因。</td>
<td></td>
</tr>
</tbody></table>
<h3 id="LockSupport的演示实例"><a href="#LockSupport的演示实例" class="headerlink" title="LockSupport的演示实例"></a>LockSupport的演示实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSupportExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程开始执行&quot;</span>);</span><br><span class="line">            <span class="comment">// 阻塞当前线程</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程被唤醒，继续执行&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程准备唤醒子线程&quot;</span>);</span><br><span class="line">        <span class="comment">// 唤醒指定线程</span></span><br><span class="line">        LockSupport.unpark(thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程开始执行</span></span><br><span class="line"><span class="comment">// 主线程准备唤醒子线程</span></span><br><span class="line"><span class="comment">// 子线程被唤醒，继续执行</span></span><br></pre></td></tr></table></figure>

<h3 id="LockSupport-park-和Thread-sleep-的区别"><a href="#LockSupport-park-和Thread-sleep-的区别" class="headerlink" title="LockSupport.park()和Thread.sleep()的区别"></a>LockSupport.park()和Thread.sleep()的区别</h3><p>从功能上说，LockSupport.park()与Thread.sleep()方法类似，都是让线程阻塞，二者的区别如下：</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>LockSupport.park()</th>
<th>Thread.sleep()</th>
</tr>
</thead>
<tbody><tr>
<td>唤醒方式</td>
<td>可通过LockSupport.unpark()从外部唤醒</td>
<td>只能等待设定时间结束自行唤醒</td>
</tr>
<tr>
<td>异常处理</td>
<td>不需要捕获中断异常</td>
<td>声明了InterruptedException中断异常，调用者需捕获或再抛出</td>
</tr>
<tr>
<td>中断响应</td>
<td>不会抛出InterruptedException异常，仅设置线程中断标志，需检查Thread.interrupted()</td>
<td>会抛出InterruptedException异常</td>
</tr>
<tr>
<td>阻塞灵活性</td>
<td>能更精准、灵活地阻塞、唤醒指定线程</td>
<td>相对不够灵活，按指定时间阻塞线程</td>
</tr>
<tr>
<td>方法性质</td>
<td>调用Unsafe类的Native方法实现，本身非Native方法</td>
<td>本身就是Native方法</td>
</tr>
<tr>
<td>附加功能</td>
<td>允许设置Blocker对象，供监视诊断工具确定阻塞原因</td>
<td>无</td>
</tr>
<tr>
<td>使用场景</td>
<td>适用于需要灵活控制线程阻塞和唤醒的场景，如线程间的复杂协作、实现自定义的锁机制、线程池中的线程管理等</td>
<td>常用于需要让线程暂停一段时间的场景，如定时任务的间隔控制、模拟网络延迟、控制并发访问的频率等</td>
</tr>
</tbody></table>
<h3 id="LockSupport-park-与Object-wait-的区别"><a href="#LockSupport-park-与Object-wait-的区别" class="headerlink" title="LockSupport.park()与Object.wait()的区别"></a>LockSupport.park()与Object.wait()的区别</h3><p>从功能上说，LockSupport.park()与Object.wait()方法也类似，都是让线程阻塞，二者的区别如下：</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>LockSupport.park()</th>
<th>Object.wait()</th>
</tr>
</thead>
<tbody><tr>
<td>阻塞和唤醒机制</td>
<td>通过<code>LockSupport.unpark(Thread thread)</code>唤醒，可先唤醒再阻塞，唤醒关系灵活</td>
<td>需搭配<code>Object.notify()</code>或<code>Object.notifyAll()</code>，在同步代码块或方法中，先阻塞后才能被唤醒</td>
</tr>
<tr>
<td>所属类与依赖条件</td>
<td><code>java.util.concurrent.locks.LockSupport</code>类的方法，不依赖锁机制或同步代码块</td>
<td><code>java.lang.Object</code>类的方法，必须在<code>synchronized</code>代码块或同步方法中调用</td>
</tr>
<tr>
<td>异常处理</td>
<td>本身不抛出受检查异常，中断时需通过其他方式处理，如检查<code>Thread.interrupted()</code></td>
<td>抛出<code>InterruptedException</code>异常，需显式处理</td>
</tr>
<tr>
<td>线程状态与可见性</td>
<td>线程状态通常为<code>WAITING</code>或<code>TIMED_WAITING</code>，阻塞状态对其他线程可见性更直接</td>
<td>线程状态变为<code>WAITING</code>或<code>TIMED_WAITING</code>，需通过获取同一对象监视器锁来感知状态变化</td>
</tr>
<tr>
<td>使用场景</td>
<td>适用于灵活控制线程阻塞和唤醒，如线程间复杂协作、自定义锁机制、线程池管理等</td>
<td>适用于基于对象监视器锁的简单线程协作，如传统生产者 - 消费者模型</td>
</tr>
<tr>
<td>提前唤醒情况</td>
<td>在<code>LockSupport.park()</code>执行之前去执行<code>LockSupport.unpark()</code>，不会抛出任何异常，是被允许的</td>
<td>如果在<code>Object.wait()</code>执行之前去执行<code>Object.notify()</code>唤醒，会抛出<code>IllegalMonitorStateException</code>异常，是不被允许的</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.fulsun._4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSupportDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        testLockSupport2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testLockSupport2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 使当前线程睡眠1秒，模拟一些前置操作</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 即将进入无限时阻塞&quot;</span>);</span><br><span class="line">            <span class="comment">// 使用LockSupport.park()阻塞当前线程</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被重新唤醒了&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;演示线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提前唤醒一次没有使用LockSupport.park()阻塞的线程，这是允许的，不会有异常</span></span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">        <span class="comment">// 再提前唤醒一次没有调用LockSupport.park()阻塞的线程，多次提前唤醒也是允许的</span></span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三次唤醒，此时线程可能已经处于被park阻塞的状态（因为前面线程已经睡了1秒后执行了park）</span></span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 主线程再等待一会儿，确保有足够时间看到子线程的完整执行情况</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleepSeconds</span><span class="params">(<span class="type">int</span> seconds)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(seconds * <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示线程 即将进入无限时阻塞</span></span><br><span class="line"><span class="comment">// 演示线程 被重新唤醒了</span></span><br></pre></td></tr></table></figure>

<p>通过结果可以看出，前两次LockSupport.unpark(t1)唤醒操作没有发生任何作用，因为线程t1还没有被LockSupport.park()阻塞。<strong>只有在被LockSupport.park()阻塞之后，LockSupport.unpark(t1)唤醒操作才能将线程t1唤醒</strong>。</p>
<h2 id="显式锁的分类"><a href="#显式锁的分类" class="headerlink" title="显式锁的分类"></a>显式锁的分类</h2><p>显式锁有多种分类方式，以下是从不同角度进行的分类及相关介绍：</p>
<h3 id="可重入锁和不可重入锁"><a href="#可重入锁和不可重入锁" class="headerlink" title="可重入锁和不可重入锁"></a>可重入锁和不可重入锁</h3><ul>
<li><strong>可重入锁（递归锁）</strong>：<ul>
<li><strong>定义</strong>：一个线程可以多次抢占同一个锁。例如线程A进入外层函数抢占Lock显式锁后，进入内层函数遇到抢占同一Lock显式锁的代码时，依然能抢到该锁。</li>
<li><strong>实现类</strong>：JUC的ReentrantLock类是可重入锁的标准实现类。</li>
</ul>
</li>
<li><strong>不可重入锁</strong>：<ul>
<li><strong>定义</strong>：一个线程只能抢占一次同一个锁。线程A进入外层函数抢占锁后，进入内层函数再遇抢占同一锁的代码时，不能抢到该锁，除非提前释放锁，才能第二次抢占。</li>
</ul>
</li>
</ul>
<h3 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h3><ul>
<li><strong>悲观锁</strong>：<ul>
<li><strong>思想及操作</strong>：秉持悲观思想，每次进入临界区操作数据时，都认为别的线程会修改，所以读写数据时都会上锁锁住同步资源，其他线程读写该数据时会阻塞等待拿锁。</li>
<li><strong>适用场景</strong>：适用于写多读少的场景，高并发写时性能高。</li>
<li><strong>示例</strong>：Java的synchronized重量级锁是一种悲观锁。</li>
</ul>
</li>
<li><strong>乐观锁</strong>：<ul>
<li><strong>思想及操作</strong>：秉持乐观思想，拿数据时认为别的线程不会修改，所以不上锁，但更新时会判断在此期间别人有无更新数据，采取先读出当前版本号，然后加锁操作（比较跟上一次版本号，一样则更新），若失败需重复读-比较-写操作。</li>
<li><strong>适用场景</strong>：适用于读多写少的场景，高并发写时性能低。</li>
<li><strong>实现方式及示例</strong>：基本通过CAS自旋操作实现，如Java的synchronized轻量级锁是一种乐观锁，JUC中基于抽象队列同步器（AQS）实现的显式锁（如ReentrantLock）都是乐观锁。不过在争用激烈场景下，CAS自旋会出现大量空自旋，导致性能大大降低，但因AQS通过队列使用减少锁争用、空的CAS自旋，所以基于AQS的JUC乐观锁在争用激烈场景下也能比悲观锁性能更佳。</li>
</ul>
</li>
</ul>
<h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><ul>
<li><strong>公平锁</strong>：<ul>
<li><strong>定义</strong>：不同线程抢占锁的机会公平、平等，按抢占时间先后，先抢占锁的线程先被满足，抢锁成功次序体现为FIFO（先进先出）顺序，保障各线程按顺序获取锁。</li>
<li><strong>示例</strong>：线程A、B、C、D依次获取锁，A先获取锁，处理完释放后唤醒B获取锁，依此类推。</li>
</ul>
</li>
<li><strong>非公平锁</strong>：<ul>
<li><strong>定义</strong>：不同线程抢占锁的机会非公平、不平等，先抢占锁的线程不一定先被满足，抢锁成功次序不体现FIFO顺序。</li>
<li><strong>示例</strong>：线程A持有锁时，B、C、D尝试获取锁进入等待队列，A释放锁后唤醒B的过程中，若有线程E尝试请求锁，E可能趁机获取锁（插队），原因是CPU唤醒线程B有上下文切换时间，E可利用此空档期在其他内核上获取锁，目的是提高锁利用效率。</li>
<li><strong>设置方式</strong>：ReentrantLock实例默认是非公平锁，构造时传入参数true可得到公平锁，ReentrantLock的tryLock()方法是特例，一旦有线程释放锁，正在tryLock的线程能优先取到锁，即便有其他线程在等待队列中。</li>
</ul>
</li>
</ul>
<h3 id="可中断锁和不可中断锁"><a href="#可中断锁和不可中断锁" class="headerlink" title="可中断锁和不可中断锁"></a>可中断锁和不可中断锁</h3><ul>
<li><strong>可中断锁</strong>：某线程A占有锁执行临界区代码，线程B阻塞式抢占锁时，若等待时间过长，B不想等待想处理其他事，可中断自己的阻塞等待，这种就是可中断锁。</li>
<li><strong>不可中断锁</strong>：一旦锁被其他线程占有，自己想抢占只能等待或阻塞，若对方永远不释放锁，自己只能永远等下去，没办法终止等待或阻塞。例如Java的synchronized内置锁是不可中断锁，JUC的显式锁（如ReentrantLock）是可中断锁。</li>
</ul>
<h3 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h3><ul>
<li><strong>独占锁</strong>：<ul>
<li><strong>定义及特点</strong>：每次只有一个线程能持有的锁，是悲观保守加锁策略，限制读&#x2F;读竞争，若某个只读线程获取锁，其他读线程只能等待，限制读操作并发性，不过读操作不影响数据一致性。</li>
<li><strong>实现类</strong>：JUC的ReentrantLock类是标准的独占锁实现类。</li>
</ul>
</li>
<li><strong>共享锁</strong>：<ul>
<li><strong>定义及特点</strong>：允许多个线程同时获取锁，容许线程并发进入临界区，是一种乐观锁，放宽加锁策略，不限制读&#x2F;读竞争，<strong>允许多个读操作线程同时访问共享资源</strong>。</li>
<li><strong>实现类及使用规则</strong>：JUC的ReentrantReadWriteLock（读写锁）类是共享锁实现类，使用时读操作可多线程一起读，但写操作只能一个线程写，且写入时别的线程不能读。用ReentrantLock替代ReentrantReadWriteLock虽能保证线程安全，但会浪费资源，在读的地方用读锁、写的地方用写锁可提高程序执行效率。</li>
</ul>
</li>
</ul>
<h2 id="悲观锁和乐观锁-1"><a href="#悲观锁和乐观锁-1" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2><p>独占锁其实就是一种悲观锁，Java的synchronized是悲观锁。悲观锁可以确保无论哪个线程持有锁，都能独占式访问临界区。虽然悲观锁的逻辑非常简单，但是存在不少问题。</p>
<h3 id="悲观锁存在的问题"><a href="#悲观锁存在的问题" class="headerlink" title="悲观锁存在的问题"></a>悲观锁存在的问题</h3><p>悲观锁总是假设会发生最坏的情况，每次线程读取数据时，也会上锁。这样其他线程在读取数据时就会被阻塞，直到它拿到锁。传统的关系型数据库用到了很多悲观锁，比如行锁、表锁、读锁、写锁等。</p>
<p>悲观锁机制存在以下问题：</p>
<ol>
<li>在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</li>
<li>一个线程持有锁后，会导致其他所有抢占此锁的线程挂起。</li>
<li>如果一个优先级高的线程等待一个优先级低的线程释放锁，就会导致线程的优先级倒置，从而引发性能风险。</li>
</ol>
<p><strong>解决以上悲观锁的这些问题的有效方式是使用乐观锁去替代悲观锁</strong>。与之类似，数据库操作中的带版本号数据更新、JUC包的原子类，都使用了乐观锁的方式提升性能。</p>
<h3 id="通过CAS实现乐观锁"><a href="#通过CAS实现乐观锁" class="headerlink" title="通过CAS实现乐观锁"></a>通过CAS实现乐观锁</h3><blockquote>
<p><strong>乐观锁是一种思想，而CAS是这种思想的一种实现。</strong></p>
</blockquote>
<p>乐观锁的操作主要就是两个步骤：</p>
<ol>
<li>第一步：冲突检测。</li>
<li>第二步：数据更新。</li>
</ol>
<p>乐观锁一种比较典型的就是CAS原子操作，JUC强大的高并发性能是建立在CAS原子之上的。CAS操作中包含三个操作数：需要操作的内存位置（V）、进行比较的预期原值（A）和拟写入的新值（B）。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置的值更新为新值B；否则处理器不做任何操作。</p>
<p>CAS操作可以非常清晰地分为两个步骤：</p>
<ol>
<li>检测位置V的值是否为A。</li>
<li>如果是，就将位置V更新为B值；否则不要更改该位置。</li>
</ol>
<p>CAS操作的两个步骤其实与乐观锁操作的两个步骤是一致的，都是在冲突检测后进行数据更新。实际上，如果需要完成数据的最终更新，仅仅进行一次CAS操作是不够的，一般情况下，需要进行自旋操作，即不断地循环重试CAS操作直到成功，这也叫<strong>CAS自旋</strong>。</p>
<p>通过CAS自旋，在不使用锁的情况下实现多线程之间的变量同步，也就是说，在没有线程被阻塞的情况下实现变量的同步，这叫作“非阻塞同步”（Non-Blocking Synchronization），或者说“无锁同步”。使用基于CAS自旋的乐观锁进行同步控制，属于无锁编程（Lock Free）的一种实践。</p>
<h3 id="自定义不可重入的自旋锁"><a href="#自定义不可重入的自旋锁" class="headerlink" title="自定义不可重入的自旋锁"></a>自定义不可重入的自旋锁</h3><p>自旋锁的基本含义为：当一个线程在获取锁的时候，如果锁已经被其他线程获取，调用者就一直在那里循环检查该锁是否已经被释放，一直到获取到锁才会退出循环。</p>
<p>CAS自旋锁的实现原理为：抢锁线程不断进行CAS自旋操作去更新锁的owner（拥有者），如果更新成功，就表明已经抢锁成功，退出抢锁方法。如果锁已经被其他线程获取（也就是owner为其他线程），调用者就一直在那里循环进行owner的CAS更新操作，一直到成功才会退出循环。</p>
<p>作为演示，这里先实现一个简单版本的自旋锁——不可重入的自旋锁，具体的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NonReentrantSpinLock</span> &#123;</span><br><span class="line">    <span class="comment">// 使用AtomicBoolean来表示锁的状态，true表示锁已被占用，false表示锁可用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用自旋的方式，不断尝试获取锁，直到成功</span></span><br><span class="line">        <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">            <span class="comment">// 可以在这里添加一些等待策略，例如短暂休眠，避免过度占用CPU</span></span><br><span class="line">            <span class="comment">// Thread.yield();  // 或者Thread.sleep(1);等</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();  <span class="comment">//让出当前剩余的CPU时间片</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁，如果锁可用，则获取锁并返回true，否则返回false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用CAS（Compare And Swap）操作来尝试将锁的状态从false设置为true</span></span><br><span class="line">        <span class="comment">// 如果当前锁的状态是false，就将其设置为true，表示获取锁成功</span></span><br><span class="line">        <span class="comment">// 如果当前锁的状态是true，说明锁已被占用，获取锁失败</span></span><br><span class="line">        <span class="keyword">return</span> locked.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 将锁的状态设置为false，表示锁已释放</span></span><br><span class="line">        locked.set(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>仔细分析以上代码就可以看出，上述NonReentrantSpinLock是不支持重入的，即当一个线程第一次已经获取到了该锁，在锁没有被释放之前，如果又一次重新获取该锁，第二次将不能成功获取到。</p>
<h3 id="自定义可重入的自旋锁"><a href="#自定义可重入的自旋锁" class="headerlink" title="自定义可重入的自旋锁"></a>自定义可重入的自旋锁</h3><p>为了实现可重入锁，主要思路是通过记录当前持有锁的线程以及重入的次数来实现可重入功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantSpinLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用AtomicBoolean来表示锁的状态，true表示锁已被占用，false表示锁可用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 记录当前持有锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread lockedOwner;</span><br><span class="line">    <span class="comment">// 记录重入的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">holdCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 如果当前线程已经持有锁，增加重入次数并直接返回，实现可重入</span></span><br><span class="line">        <span class="keyword">if</span> (currentThread == lockedOwner) &#123;</span><br><span class="line">            holdCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用自旋的方式，不断尝试获取锁，直到成功</span></span><br><span class="line">        <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">            <span class="comment">// 可以在这里添加一些等待策略，例如短暂休眠，避免过度占用CPU</span></span><br><span class="line">            <span class="comment">// Thread.yield();  // 或者Thread.sleep(1);等</span></span><br><span class="line">            LockSupport.parkNanos(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁，如果锁可用，则获取锁并返回true，否则返回false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 使用CAS（Compare And Swap）操作来尝试将锁的状态从false设置为true</span></span><br><span class="line">        <span class="keyword">if</span> (locked.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="comment">// 获取锁成功，设置当前持有锁的线程为当前线程，并将重入次数设置为1</span></span><br><span class="line">            lockedOwner = currentThread;</span><br><span class="line">            holdCount.set(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 只有当前持有锁的线程才能释放锁</span></span><br><span class="line">        <span class="keyword">if</span> (currentThread == lockedOwner) &#123;</span><br><span class="line">            <span class="comment">// 减少重入次数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> holdCount.decrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果重入次数为0，说明彻底释放锁，将锁状态设置为false，并清除持有锁的线程</span></span><br><span class="line">                locked.set(<span class="literal">false</span>);</span><br><span class="line">                lockedOwner = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CAS可能导致“总线风暴”"><a href="#CAS可能导致“总线风暴”" class="headerlink" title="CAS可能导致“总线风暴”"></a>CAS可能导致“总线风暴”</h3><p>“总线风暴” 是指在计算机系统中，多个处理器或设备频繁地对系统总线进行访问和竞争，导致总线上的数据传输量急剧增加，产生大量的冲突和等待，从而使系统性能严重下降的现象。</p>
<p><strong>CAS 操作引发总线风暴的原因:</strong></p>
<ul>
<li><strong>竞争激烈时的高频操作</strong>：CAS 操作是一种硬件级别的原子操作，用于在多线程环境下实现对共享变量的无锁并发访问。当多个线程同时竞争同一个基于 CAS 的可重入锁时，它们会频繁地执行 CAS 操作来尝试获取锁。如果竞争非常激烈，大量的 CAS 操作会在极短的时间内被发送到系统总线上，导致总线上的数据流量瞬间增大。</li>
<li><strong>缓存一致性协议的开销</strong>：现代多核处理器系统中，为了保证各个处理器缓存之间的数据一致性，通常采用缓存一致性协议（如 MESI 协议）。当一个线程通过 CAS 操作修改共享变量时，会导致其他处理器缓存中该变量的副本失效，其他处理器需要从主内存中重新读取数据。在高并发情况下，大量的 CAS 操作会使得缓存失效和数据同步操作频繁发生，这些操作都需要通过系统总线来完成，进一步增加了总线的负载。</li>
<li><strong>重试机制的影响</strong>：在基于 CAS 的可重入锁实现中，当线程获取锁失败时，通常会通过自旋的方式不断重试。这意味着线程会持续地发起 CAS 操作，而不会主动让出 CPU。如果有大量线程都在自旋等待获取锁，那么它们会不断地向总线发送 CAS 请求，使得总线的负载持续处于高位，无法得到缓解。</li>
</ul>
<p><strong>总线风暴的影响</strong>:</p>
<ul>
<li><strong>系统性能下降</strong>：总线风暴会导致系统总线的利用率急剧下降，因为总线上充斥着大量的 CAS 请求和缓存同步等操作，真正用于有效数据传输和其他正常操作的带宽被严重挤压，从而导致整个系统的性能大幅下降。</li>
<li><strong>响应时间变长</strong>：由于总线被大量无用的 CAS 操作占据，其他重要的操作（如内存读写、I&#x2F;O 操作等）无法及时得到执行，导致程序的响应时间变长，用户会明显感觉到系统变得卡顿。</li>
<li><strong>能耗增加</strong>：处理器在不断执行 CAS 操作和处理缓存一致性问题时，需要消耗更多的能量，这不仅会增加硬件的发热量，还会降低系统的能源效率。</li>
</ul>
<p>前面讲到，在争用激烈的场景下，Java轻量级锁会快速膨胀为重量级锁，其本质上一是为了减少CAS空自旋，二是为了避免同一时间大量CAS操作所导致的总线风暴。</p>
<p>那么，<strong>JUC基于CAS实现的轻量级锁如何避免总线风暴呢？答案是：使用队列对抢锁线性进行排队，最大程度上减少了CAS操作数量</strong>。</p>
<h3 id="CLH自旋锁"><a href="#CLH自旋锁" class="headerlink" title="CLH自旋锁"></a>CLH自旋锁</h3><blockquote>
<p>JUC中显式锁基于AQS抽象队列同步器，<strong>而AQS是CLH锁的一个变种</strong>，为了方便大家理解AQS的原理（此为Java工程师的必备知识），这里详细介绍一下CLH锁的实现和核心原理。</p>
</blockquote>
<p>CLH锁其实就是一种基于队列（具体为单向链表）排队的自旋锁，由于是Craig、Landin和Hagersten三人一起发明的，因此被命名为CLH锁，也叫CLH队列锁。</p>
<p>简单的CLH锁可以基于单向链表实现，申请加锁的线程首先会通过CAS操作在单向链表的尾部增加一个节点，之后该线程只需要在其前驱节点上进行普通自旋，等待前驱节点释放锁即可。由于CLH锁只有在节点入队时进行一下CAS的操作，在节点加入队列之后，抢锁线程不需要进行CAS自旋，只需普通自旋即可。因此，在争用激烈的场景下，CLH锁能大大减少CAS操作的数量，以避免CPU的总线风暴。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CLHSpinLock</span> &#123;</span><br><span class="line">    <span class="comment">// 指向最后一个加入队列的节点</span></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;QNode&gt; tail = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 当前线程对应的节点</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;QNode&gt; myNode = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁节点类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">QNode</span> &#123;</span><br><span class="line">        <span class="comment">// 表示是否已经获得锁</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建当前线程对应的节点</span></span><br><span class="line">        <span class="type">QNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QNode</span>();</span><br><span class="line">        <span class="comment">// 将当前线程的节点设置到ThreadLocal中</span></span><br><span class="line">        myNode.set(node);</span><br><span class="line">        <span class="comment">// 将新节点设置为tail节点，并获取旧的tail节点</span></span><br><span class="line">        <span class="type">QNode</span> <span class="variable">pred</span> <span class="operator">=</span> tail.getAndSet(node);</span><br><span class="line">        <span class="keyword">if</span> (pred!= <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果存在前驱节点，自旋等待前驱节点释放锁</span></span><br><span class="line">            <span class="keyword">while</span> (pred.locked) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前线程对应的节点</span></span><br><span class="line">        <span class="type">QNode</span> <span class="variable">node</span> <span class="operator">=</span> myNode.get();</span><br><span class="line">        <span class="comment">// 如果tail节点是当前线程的节点，说明没有后续节点在等待锁</span></span><br><span class="line">        <span class="keyword">if</span> (tail.compareAndSet(node, <span class="literal">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// 不需要做任何事情，直接返回</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 还有后续节点在等待锁，将当前节点的locked设置为false，让下一个节点获取锁</span></span><br><span class="line">            node.locked = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 以下是简单的测试代码，用于演示CLH自旋锁的使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CLHSpinLock</span> <span class="variable">clhSpinLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CLHSpinLock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多个线程来模拟并发获取锁的情况</span></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                clhSpinLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadIndex + <span class="string">&quot; 获取到锁&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);  <span class="comment">// 模拟线程持有锁执行任务的时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    clhSpinLock.unlock();</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadIndex + <span class="string">&quot; 释放锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动所有线程</span></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有线程执行完毕</span></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong><code>CLHSpinLock</code>类结构</strong>：<ul>
<li>内部定义了<code>Node</code>类，它代表等待锁的线程节点，节点中有一个<code>volatile</code>修饰的<code>locked</code>字段，用于表示该节点对应的线程是否获取到锁（初始为<code>true</code>，即未获取到锁，处于等待状态）。</li>
<li>有一个<code>AtomicReference&lt;Node&gt;</code>类型的<code>tail</code>字段，通过原子操作来维护等待锁的队列尾节点，初始值为<code>null</code>。</li>
<li>还有一个<code>ThreadLocal&lt;Node&gt;</code>类型的<code>myNode</code>，用于为每个线程存储其对应的节点，保证每个线程都有自己独立的等待节点信息。</li>
</ul>
</li>
<li><strong><code>lock</code>方法逻辑</strong>：<ul>
<li>首先通过<code>myNode.get()</code>获取当前线程对应的节点。</li>
<li>然后使用<code>tail.getAndSet(node)</code>原子操作将当前节点设置为尾节点，并获取原来的尾节点（也就是当前线程的前驱节点）。</li>
<li>如果前驱节点不为<code>null</code>，说明有其他线程在等待队列中，当前线程就会通过自旋（<code>while (pred.locked)</code>循环）等待前驱节点释放锁（即前驱节点的<code>locked</code>变为<code>false</code>）。</li>
</ul>
</li>
<li><strong><code>unlock</code>方法逻辑</strong>：<ul>
<li>获取当前线程对应的节点后，将该节点的<code>locked</code>字段设置为<code>false</code>，表示释放锁，让后续等待的线程有机会获取锁。并且可以选择调用<code>myNode.remove()</code>来清除线程本地变量中存储的节点，避免可能的内存泄漏问题（在实际应用中根据具体需求决定是否执行此操作）。</li>
</ul>
</li>
<li>在争用激烈的场景下，相比于那种完全依赖持续 CAS 操作来获取锁的普通自旋锁，CLH 锁通过将竞争分散到链表节点上，把大量的 CAS 操作限制在了节点入队这个环节，后续等待过程不再有 CAS 自旋，从而大大减少了整体的 CAS 操作数量，也就能够有效避免因过多 CAS 操作引发的 CPU 总线风暴问题。</li>
</ol>
<blockquote>
<p><strong>优缺点</strong></p>
</blockquote>
<ul>
<li>CLH锁是一种队列锁，其优点是空间复杂度低。如果有N个线程、L个锁，每个线程每次只获取一个锁，那么需要的存储空间是O(L+N)，N个线程有N个Node，L个锁有L个Tail。</li>
<li>CLH队列锁的一个显著缺点是它在NUMA架构的CPU平台上性能很差。线程在 CLH 锁中需要通过前驱节点来判断是否可以获取锁，这种访问方式在某些情况下可能会导致伪共享问题。因为多个线程可能会频繁访问不同节点的同一缓存行，从而导致缓存行的频繁无效化，影响性能。</li>
<li><strong>CLH 锁</strong>：更适合在单核处理器或者缓存一致性开销较小的环境中使用，能够有效地实现线程同步。</li>
<li><strong>MCS 锁</strong>：在多核处理器、高并发且对缓存性能要求较高的场景中，MCS 锁能够更好地发挥其优势，提供更高效的同步机制，减少线程之间的竞争和缓存冲突，提高系统的整体性能和并发处理能力。</li>
</ul>
<h3 id="MCS队列锁"><a href="#MCS队列锁" class="headerlink" title="MCS队列锁"></a>MCS队列锁</h3><p>高性能、公平的自旋队列锁。MCS在自身节点上自旋，可以理解为当前线程不断访问本地高速缓存中的变量，因此更适合NUMA结构的CPU。</p>
<blockquote>
<p><strong>工作原理</strong></p>
</blockquote>
<ul>
<li><strong>入队</strong>：当一个线程请求锁时，它会创建一个新的 MCS 节点，并将自己相关的信息存入节点中。然后，线程通过原子操作将自己的节点加入到队列尾部。在这个过程中，新节点会与当前的尾节点建立连接，同时更新尾节点的引用，使其指向新加入的节点。</li>
<li><strong>出队</strong>：当持有锁的线程释放锁时，它会检查自己的节点是否有后继节点。如果有后继节点，就将后继节点中的锁状态标记设置为可以获取锁的状态，通知后继线程可以尝试获取锁，然后将自己的节点从队列中移除；如果没有后继节点，说明队列中没有其他等待锁的线程，就直接将尾节点设置为 null，表示队列为空。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MCS锁节点类，代表每个等待锁的线程对应的节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MCSNode</span> &#123;</span><br><span class="line">    <span class="comment">// 标记当前节点对应的线程是否获取到锁，初始化为false表示未获取到锁</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 指向下一个节点的引用，用于构建链表结构</span></span><br><span class="line">    <span class="keyword">volatile</span> MCSNode next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MCSLock</span> &#123;</span><br><span class="line">    <span class="comment">// 原子引用，指向队列的最后一个节点，初始化为null</span></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;MCSNode&gt; tail = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 线程本地变量，用于存储当前线程对应的节点</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;MCSNode&gt; myNode = ThreadLocal.withInitial(MCSNode::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MCSNode</span> <span class="variable">node</span> <span class="operator">=</span> myNode.get();</span><br><span class="line">        <span class="type">MCSNode</span> <span class="variable">pred</span> <span class="operator">=</span> tail.getAndSet(node);</span><br><span class="line">        <span class="keyword">if</span> (pred!= <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前线程不是第一个请求锁的线程，将前驱节点的next指向自己的节点</span></span><br><span class="line">            node.locked = <span class="literal">false</span>;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="comment">// 自旋等待前驱节点释放锁并通知自己</span></span><br><span class="line">            <span class="keyword">while</span> (!node.locked) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前线程是第一个请求锁的线程，直接获取锁</span></span><br><span class="line">            node.locked = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MCSNode</span> <span class="variable">node</span> <span class="operator">=</span> myNode.get();</span><br><span class="line">        <span class="keyword">if</span> (node.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点没有后继节点，说明没有其他线程等待锁，尝试将尾节点设置为null</span></span><br><span class="line">            <span class="keyword">if</span> (tail.compareAndSet(node, <span class="literal">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果设置失败，说明有新线程在入队过程中，自旋等待新线程完成入队</span></span><br><span class="line">            <span class="keyword">while</span> (node.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将后继节点的locked标记设置为true，通知后继线程可以获取锁</span></span><br><span class="line">        node.next.locked = <span class="literal">true</span>;</span><br><span class="line">        node.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MCS和CLH实现细节对比"><a href="#MCS和CLH实现细节对比" class="headerlink" title="MCS和CLH实现细节对比"></a>MCS和CLH实现细节对比</h3><ul>
<li><p>队列中Node节点组成的链表结构不同。</p>
<ul>
<li>CLH使用前驱指针</li>
<li>MCS使用后继指针。</li>
</ul>
</li>
<li><p>自旋对象不同。</p>
<ul>
<li>CLH是在前驱节点上自旋。【查看前驱节点的Lock状态是否为false】</li>
<li>MCS是在自身节点上自旋。【查看自身节点的Lock状态是否为false】</li>
</ul>
</li>
<li><p>解锁逻辑不同</p>
<ul>
<li>CLH解锁方法是，设置自己的Lock状态为false，解除后继节点的自旋状态。</li>
<li>MCS解锁方法是，当前节点通过next指针将后继节点的Lock状态设置为false，解除其自旋状态。</li>
</ul>
</li>
</ul>
<h2 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h2><p>synchronized内置锁是一种非公平锁，<strong>默认情况下ReentrantLock锁也是非公平锁</strong>。</p>
<h3 id="非公平锁实战"><a href="#非公平锁实战" class="headerlink" title="非公平锁实战"></a>非公平锁实战</h3><p>非公平锁是指多个线程获取锁的顺序并不一定是其申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，抢锁成功的次序不一定体现为FIFO（先进先出）顺序。</p>
<p>非公平锁的<strong>优点在于吞吐量比公平锁大</strong>，它的<strong>缺点是有可能会导致线程优先级反转或者线程饥饿现象</strong>。</p>
<p>使用ReentrantLock锁作为非公平锁的实战用例，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NonFairLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建可重入锁，默认的非公平锁</span></span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 创建4个线程</span></span><br><span class="line">        Thread[] tArray = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            tArray[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; lockAndIncrease(lock), <span class="string">&quot;线程&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 启动4个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            tArray[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待4个线程执行完毕</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            tArray[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lockAndIncrease</span><span class="params">(Lock lock)</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始抢占锁&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ^-^ 抢到了锁&quot;</span>);</span><br><span class="line">            sum++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线程<span class="number">0</span> 开始抢占锁</span><br><span class="line">线程<span class="number">3</span> 开始抢占锁</span><br><span class="line">线程<span class="number">2</span> 开始抢占锁</span><br><span class="line">线程<span class="number">1</span> 开始抢占锁</span><br><span class="line">线程<span class="number">0</span> ^-^ 抢到了锁</span><br><span class="line">线程<span class="number">2</span> ^-^ 抢到了锁</span><br><span class="line">线程<span class="number">3</span> ^-^ 抢到了锁</span><br><span class="line">线程<span class="number">1</span> ^-^ 抢到了锁</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>从输出的结果可以看出，各个线程的抢锁次序为：线程0→线程3→线程2→线程1，但是抢到锁的次序为：线程0→线程2→线程3→线程1。所以说，非公平锁是不公平的。</p>
<h3 id="公平锁实战"><a href="#公平锁实战" class="headerlink" title="公平锁实战"></a>公平锁实战</h3><p>公平锁是指多个线程按照申请锁的顺序来获取锁，抢锁成功的次序体现为FIFO（先进先出）顺序。虽然ReentrantLock锁默认是非公平锁，但可以通过构造器指定该锁为公平<br>锁，具体的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//可重入、公平锁对象</span><br><span class="line">Lock lock = new ReentrantLock(true);</span><br></pre></td></tr></table></figure>



<h3 id="简单的非公平锁的示例代码"><a href="#简单的非公平锁的示例代码" class="headerlink" title="简单的非公平锁的示例代码"></a>简单的非公平锁的示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义非公平锁类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NonFairLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用AtomicBoolean来表示锁的状态，true表示锁已被占用，false表示锁可用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 用于存储当前持有锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread lockedThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 新请求的线程不管是否有其他线程已经在等待，都直接尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (locked.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">            lockedThread = Thread.currentThread();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果获取锁失败，线程进入阻塞等待状态</span></span><br><span class="line">            <span class="keyword">while</span> (locked.get()) &#123;</span><br><span class="line">                LockSupport.park();</span><br><span class="line">            &#125;</span><br><span class="line">            lockedThread = Thread.currentThread();</span><br><span class="line">            locked.set(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() == lockedThread) &#123;</span><br><span class="line">            locked.set(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// 唤醒其他等待的线程</span></span><br><span class="line">            LockSupport.unpark(getNextWaitingThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个等待的线程（这里简单返回null，实际可根据需要维护等待队列来准确获取）</span></span><br><span class="line">    <span class="keyword">private</span> Thread <span class="title function_">getNextWaitingThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="公平锁的代码示例"><a href="#公平锁的代码示例" class="headerlink" title="公平锁的代码示例"></a>公平锁的代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义公平锁类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FairLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用AtomicBoolean来表示锁的状态，true表示锁已被占用，false表示锁可用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 用于存储当前持有锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread lockedThread;</span><br><span class="line">    <span class="comment">// 等待队列，存储等待获取锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;Thread&gt; waitQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前线程加入等待队列</span></span><br><span class="line">        waitQueue.add(Thread.currentThread());</span><br><span class="line">        <span class="comment">// 循环检查是否轮到当前线程获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前线程是队列头部的线程且锁可用，尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (waitQueue.peek() == Thread.currentThread() &amp;&amp; locked.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">                lockedThread = Thread.currentThread();</span><br><span class="line">                waitQueue.poll();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果还没轮到或者锁不可用，阻塞当前线程</span></span><br><span class="line">                LockSupport.park();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() == lockedThread) &#123;</span><br><span class="line">            locked.set(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// 唤醒等待队列中的下一个线程（如果有）</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">nextThread</span> <span class="operator">=</span> waitQueue.peek();</span><br><span class="line">            <span class="keyword">if</span> (nextThread!= <span class="literal">null</span>) &#123;</span><br><span class="line">                LockSupport.unpark(nextThread);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="可中断锁与不可中断锁"><a href="#可中断锁与不可中断锁" class="headerlink" title="可中断锁与不可中断锁"></a>可中断锁与不可中断锁</h2><p>可中断锁是指抢占过程可以被中断的锁，JUC的显式锁（如ReentrantLock）是一个可中断锁。不可中断锁是指抢占过程不可以被中断的锁，如Java的synchronized内置锁就是一个不可中断锁。</p>
<h3 id="锁的可中断抢占"><a href="#锁的可中断抢占" class="headerlink" title="锁的可中断抢占"></a>锁的可中断抢占</h3><p>在JUC的显式锁Lock接口中，有以下两个方法可以用于可中断抢占：</p>
<ul>
<li><p><code>lockInterruptibly()</code></p>
<p>可中断抢占锁抢占过程中会处理Thread.interrupt()中断信号，如果线程被中断，就会终止抢占并抛出InterruptedException异常。</p>
</li>
<li><p><code>tryLock(long timeout,TimeUnit unit)</code></p>
<p>阻塞式“限时抢占”（在timeout时间内）锁抢占过程中会处理Thread.interrupt()中断信号，如果线程被中断，就会终止抢占并抛出InterruptedException异常。</p>
</li>
</ul>
<p>下面是调用lockInterruptibly()方法进行可中断抢锁的一个简单案例，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptibleLockExample</span> &#123;</span><br><span class="line">    <span class="comment">// 创建可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程1</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 尝试获取锁，可被中断</span></span><br><span class="line">                lock.lockInterruptibly();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 模拟线程执行任务，休眠5秒</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获得锁，开始执行任务&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 捕获中断异常</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被中断&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    lock.unlock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 捕获获取锁时的中断异常</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取锁时被中断&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程2</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 尝试获取锁，可被中断</span></span><br><span class="line">                lock.lockInterruptibly();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 模拟线程执行任务，休眠5秒</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获得锁，开始执行任务&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 捕获中断异常</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被中断&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    lock.unlock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 捕获获取锁时的中断异常</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取锁时被中断&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程1</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="comment">// 启动线程2</span></span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程休眠1秒，确保线程1和线程2有足够时间开始竞争锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中断线程2</span></span><br><span class="line">        thread2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread1 获得锁，开始执行任务</span><br><span class="line">Thread2 获取锁时被中断</span><br><span class="line">Thread1 释放锁</span><br></pre></td></tr></table></figure>

<h2 id="死锁的监测与中断"><a href="#死锁的监测与中断" class="headerlink" title="死锁的监测与中断"></a>死锁的监测与中断</h2><p><strong>死锁是指两个或两个以上线程因抢占锁而造成的相互等待的现象。</strong>多个线程通过AB-BA模式抢占两个锁是造成多线程死锁比较普遍的原因。</p>
<p>AB-BA模式的死锁具体表现为：线程X按照先后次序去抢占锁A与锁B，线程Y按照先后次序去抢占锁B与锁A，当线程X抢到锁A再去抢占锁B时，发现已经被其他线程拿走，然而线程Y拿到锁B后再去抢占锁A时，发现已经被其他线程拿走，于是线程X等待其他线程释放锁B，线程Y等待其他线程释放锁A，两个线程互相等待从而造成死锁。</p>
<p>JDK 8中包含的ThreadMXBean接口提供了多种监视线程的方法，其中包括两个死锁监测的方法，具体如下：</p>
<ol>
<li><code>findDeadlockedThreads</code><br>用于检测由于抢占JUC显式锁、Java内置锁引起死锁的线程。</li>
<li><code>findMonitorDeadlockedThreads</code><br>仅仅用于检测由于抢占Java内置锁引起死锁的线程。</li>
</ol>
<p>ThreadMXBean的实例可以通过JVM管理工厂ManagementFactory去获取，具体的获取代码如下：</p>
<p><code> ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadInfo;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadMXBean;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockDetectionExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建两个线程模拟死锁场景</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock1.lock();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                lock2.lock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock1.unlock();</span><br><span class="line">                lock2.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock2.lock();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                lock1.lock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock2.unlock();</span><br><span class="line">                lock1.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread-2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ThreadMXBean实例</span></span><br><span class="line">        <span class="type">ThreadMXBean</span> <span class="variable">threadMXBean</span> <span class="operator">=</span> ManagementFactory.getThreadMXBean();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环检测是否存在死锁</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">long</span>[] deadlockedThreadIds = threadMXBean.findDeadlockedThreads();</span><br><span class="line">            <span class="keyword">if</span> (deadlockedThreadIds!= <span class="literal">null</span>) &#123;</span><br><span class="line">                ThreadInfo[] threadInfos = threadMXBean.getThreadInfo(deadlockedThreadIds);</span><br><span class="line">                System.out.println(<span class="string">&quot;检测到死锁，涉及的线程信息如下：&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程名称: &quot;</span> + threadInfo.getThreadName());</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程ID: &quot;</span> + threadInfo.getThreadId());</span><br><span class="line">                    System.out.println(<span class="string">&quot;阻塞等待的锁: &quot;</span> + threadInfo.getLockName());</span><br><span class="line">                    System.out.println(<span class="string">&quot;阻塞等待的锁的持有者: &quot;</span> + threadInfo.getLockOwnerName());</span><br><span class="line">                    System.out.println(<span class="string">&quot;---------------------------&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">检测到死锁，涉及的线程信息如下：</span><br><span class="line">线程名称: Thread-<span class="number">2</span></span><br><span class="line">线程ID: <span class="number">21</span></span><br><span class="line">阻塞等待的锁: java.util.concurrent.locks.ReentrantLock$NonfairSync@16b98e56</span><br><span class="line">阻塞等待的锁的持有者: Thread-<span class="number">1</span></span><br><span class="line">---------------------------</span><br><span class="line">线程名称: Thread-<span class="number">1</span></span><br><span class="line">线程ID: <span class="number">20</span></span><br><span class="line">阻塞等待的锁: java.util.concurrent.locks.ReentrantLock$NonfairSync@7ef20235</span><br><span class="line">阻塞等待的锁的持有者: Thread-<span class="number">2</span></span><br></pre></td></tr></table></figure>



<p>JVM管理工厂ManagementFactory类提供静态方法，返回各种获取JVM信息的Bean实例。我们通过这些Bean实例能获取大量的JVM运行时信息，比如JVM堆的使用情况、GC情况、线程信息等。我们通过JVM运行时信息可以了解正在运行的JVM的情况，以便可以做出相应的参数调整。</p>
<p>如果是可中断抢占锁（如调用lockInterruptibly()方法等），就可以在监测到死锁发生之后，调用Thread.interrupt()去中断死锁线程，不让死锁线程一直等下去。</p>
<blockquote>
<p>ManagementFactory位于JDK的核心包<code>java.lang.management</code>中，该包提供了一系列的管理接口，用于监视和管理JVM以及运行JVM的底层操作系统，它同时允许从本地和远程对正在运行的JVM进行监视和管理。</p>
</blockquote>
<h2 id="共享锁与独占锁"><a href="#共享锁与独占锁" class="headerlink" title="共享锁与独占锁"></a>共享锁与独占锁</h2><p>在访问共享资源之前进行加锁操作，在访问完成之后进行解锁操作。按照“是否允许在同一时刻被多个线程持有”来区分，锁可以分为<strong>共享锁</strong>与<strong>独占锁</strong>。</p>
<h3 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h3><p>占锁也叫排他锁、互斥锁、独享锁，是指锁在同一时刻只能被一个线程所持有。一个线程加锁后，任何其他试图再次加锁的线程都会被阻塞，直到持有锁线程解锁。<strong>通俗来说，就是共享资源某一时刻只能有一个线程访问，其余线程阻塞等待</strong>。</p>
<p>如果是公平地独占锁，在持有锁线程解锁时，如果有一个以上的线程在阻塞等待，那么最先抢锁的线程被唤醒变为就绪状态去执行加锁操作，其他的线程仍然阻塞等待。<strong>Java中的Synchronized内置锁和ReentrantLock显式锁都是独占锁。</strong></p>
<h3 id="共享锁Semaphore"><a href="#共享锁Semaphore" class="headerlink" title="共享锁Semaphore"></a>共享锁Semaphore</h3><blockquote>
<p>Semaphore和ReentrantLock类似，Semaphore发放许可时有两种式：公平模式和非公平模式，默认情况下使用非公平模式。</p>
</blockquote>
<p>共享锁就是在同一时刻允许多个线程持有的锁。当然，获得共享锁的线程只能读取临界区的数据，不能修改临界区的数据。</p>
<p>JUC中的共享锁包括<code>Semaphore</code>（信号量）、<code>ReadLock</code>（读写锁）中的读锁、<code>CountDownLatch</code>。</p>
<p>Semaphore可以用来控制在同一时刻访问共享资源的线程数量，通过协调各个线程以保证共享资源的合理使用。<strong>Semaphore维护了一组虚拟许可，它的数量可以通过构造器的参数指定。线程在访问共享资源前必须调用Semaphore的<code>acquire()方法获得许可</code>，如果许可数量为0，该线程就一直阻塞。线程访问完资源后，必须调用Semaphore的<code>release()方法释放许可</code>。</strong>更形象的说法是：Semaphore是一个许可管理器。</p>
<h4 id="Semaphore的主要方法"><a href="#Semaphore的主要方法" class="headerlink" title="Semaphore的主要方法"></a>Semaphore的主要方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造一个Semaphore实例，初始化其管理的许可数量为permits参数值。</span></span><br><span class="line">Semaphore(<span class="keyword">permits</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个Semaphore实例，初始化其管理的许可数量为permits参数值，</span></span><br><span class="line"><span class="comment">// 是否以公平模式（fair参数是否为true）进行许可的发放。</span></span><br><span class="line">Semaphore(<span class="keyword">permits</span>,fair)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>方法分类</th>
<th>方法名</th>
<th>方法签名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>许可获取</td>
<td><code>acquire</code></td>
<td><code>void acquire() throws InterruptedException</code></td>
<td>从信号量获取一个许可，如果没有可用许可，则线程会被阻塞，直到有许可可用或线程被中断。</td>
</tr>
<tr>
<td>许可获取</td>
<td><code>acquire(permits)</code></td>
<td><code>void acquire() throws InterruptedException</code></td>
<td>当前线程尝试阻塞地获取permits个许可。此过程是阻塞的，线程会一直等待Semaphore发放permits个许可。如果没有足够的许可而当前线程被中断，就会抛出InterruptedException异常并终止阻塞。</td>
</tr>
<tr>
<td>许可获取</td>
<td><code>acquireUninterruptibly</code></td>
<td><code>void acquireUninterruptibly()</code></td>
<td>与<code>acquire</code>方法类似，但该方法不会响应中断，即使线程在等待许可时被中断，也会一直等待直到获取到许可。</td>
</tr>
<tr>
<td>许可获取</td>
<td><code>tryAcquire</code>（无参）</td>
<td><code>boolean tryAcquire()</code></td>
<td>尝试获取一个许可，若有许可可用，则获取许可并返回<code>true</code>；否则，立即返回<code>false</code>，不会阻塞线程。</td>
</tr>
<tr>
<td>许可获取</td>
<td><code>tryAcquire</code>（有参）</td>
<td><code>boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException</code></td>
<td>在指定的时间内尝试获取一个许可。若在超时时间内获取到许可，则返回<code>true</code>；否则，返回<code>false</code>。如果线程在等待期间被中断，会抛出<code>InterruptedException</code>异常。</td>
</tr>
<tr>
<td>许可释放</td>
<td><code>release</code></td>
<td><code>void release()</code></td>
<td>释放一个许可，将信号量的许可数量加1。如果有其他线程正在等待获取许可，则会唤醒其中一个线程使其能够获取许可。</td>
</tr>
<tr>
<td>许可数量查询</td>
<td><code>availablePermits</code></td>
<td><code>int availablePermits()</code></td>
<td>返回当前信号量中可用的许可数量。</td>
</tr>
<tr>
<td>许可数量查询</td>
<td><code>drainPermits</code></td>
<td><code>int drainPermits()</code></td>
<td>获取并返回当前所有可用的许可，并将可用许可数量置为0。</td>
</tr>
<tr>
<td>线程等待情况查询</td>
<td><code>hasQueuedThreads</code></td>
<td><code>boolean hasQueuedThreads()</code></td>
<td>查询是否有线程在等待获取该信号量的许可。</td>
</tr>
<tr>
<td>线程等待情况查询</td>
<td><code>getQueueLength</code></td>
<td><code>int getQueueLength()</code></td>
<td>返回正在等待获取许可的线程估计数。该值是一个估计值，因为在计算过程中线程的状态可能会发生变化。</td>
</tr>
</tbody></table>
<p>假设有10个人在银行办理业务，只有两个工作窗口，使用Semaphore模拟银行排队，同时只有两个线程进入临界区。大致的代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankQueueSimulation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建信号量，设置许可数量为2（对应两个工作窗口）</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟10个客户来办理业务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">customerId</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取许可，相当于排队等待窗口有空位</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户 &quot;</span> + customerId + <span class="string">&quot; 开始办理业务&quot;</span>);</span><br><span class="line">                    <span class="comment">// 模拟办理业务的耗时，这里简单用休眠来表示</span></span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户 &quot;</span> + customerId + <span class="string">&quot; 办理业务完成&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放许可，办理完业务，窗口空出来了</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><blockquote>
<p>门闩（Shuān），横插在门后使门推不开的棍子。</p>
</blockquote>
<p>CountDownLatch是一个常用的共享锁，其功能相当于一个多线程环境下的倒数门闩。</p>
<p><strong>原理</strong>：CountDownLatch 内部也是基于 AQS 实现的，它通过一个计数器来控制线程的等待和放行。计数器初始化为一个给定的值，当线程调用 countDown () 方法时，计数器会减 1，当计数器的值减到 0 时，所有等待在 CountDownLatch 上的线程会被唤醒。</p>
<p><strong>使用场景</strong>：适用于一个或多个线程等待其他多个线程完成一组任务后再继续执行的场景，如主线程等待多个子线程完成数据加载后进行数据汇总。</p>
<p>模拟游戏玩家加载的示例代码。在游戏开始前，需要等待多个玩家完成加载操作，当所有玩家都加载完成后，游戏才正式开始具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameLoadingExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 假设一共有5个玩家，CountDownLatch初始值设为5</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">playerCount</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(playerCount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟每个玩家加载的线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= playerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">playerIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 模拟玩家加载耗时，这里简单使用随机时间模拟，单位为毫秒</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">loadingTime</span> <span class="operator">=</span> (<span class="type">long</span>) (Math.random() * <span class="number">3000</span>);</span><br><span class="line">                    Thread.sleep(loadingTime);</span><br><span class="line">                    System.out.println(<span class="string">&quot;玩家&quot;</span> + playerIndex + <span class="string">&quot; 加载完成，耗时 &quot;</span> + loadingTime + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">                    <span class="comment">// 玩家加载完成，计数器减1</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 主线程（可以理解为游戏控制线程）等待所有玩家加载完毕</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;所有玩家加载完毕，游戏开始！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><ul>
<li><strong>原理</strong>：CyclicBarrier 内部使用 ReentrantLock 和 Condition 来实现线程的同步。它维护了一个计数器，当线程到达屏障点时，会调用 await () 方法，将自己阻塞，并使计数器减 1。当计数器的值为 0 时，说明所有线程都到达了屏障点，此时会唤醒所有阻塞的线程。</li>
<li><strong>使用场景</strong>:适用于一组线程相互等待，到达某个公共屏障点后再一起继续执行的场景，常用于多线程并发处理数据，每个线程处理一部分，全部处理完后进行合并等操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建CyclicBarrier，参数5表示需要5个线程都到达屏障点后才能继续执行</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;所有运动员都已准备好，比赛开始！&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并启动5个线程模拟运动员</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">athleteNumber</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;运动员&quot;</span> + athleteNumber + <span class="string">&quot; 正在做准备活动...&quot;</span>);</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">3000</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;运动员&quot;</span> + athleteNumber + <span class="string">&quot; 已准备好，等待其他运动员...&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(<span class="string">&quot;运动员&quot;</span> + athleteNumber + <span class="string">&quot; 开始比赛！&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中：</p>
<ol>
<li>首先创建了一个<code>CyclicBarrier</code>对象，构造函数传入两个参数，第一个参数<code>5</code>表示需要有<code>5</code>个线程调用<code>await</code>方法（也就是到达屏障点）后，所有线程才能继续往下执行。第二个参数是一个<code>Runnable</code>接口实现（使用了 Java 8 的 Lambda 表达式），它定义了当所有线程都到达屏障点后要执行的操作，在这里就是输出表示比赛开始的语句。</li>
<li>然后通过循环创建并启动了<code>5</code>个线程，每个线程模拟一个运动员做准备活动，然后调用<code>cyclicBarrier.await()</code>方法，表示自己已经准备好，进入等待状态，直到所有线程（也就是所有运动员）都调用了<code>await</code>方法，此时满足了屏障条件，之前传入<code>CyclicBarrier</code>构造函数中的<code>Runnable</code>会被执行，接着所有被阻塞的线程就会继续往下执行，模拟比赛开始的情况。</li>
</ol>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>读写锁的内部包含两把锁：一把是读（操作）锁，是一种共享锁；另一把是写（操作）锁，是一种独占锁。</p>
<p><strong>在没有写锁的时候，读锁可以被多个线程同时持有。写锁是具有排他性的：如果写锁被一个线程持有，其他的线程不能再持有写锁，抢占写锁会阻塞；进一步来说，如果写锁被一个线程持有，其他的线程不能再持有读锁，抢占读锁也会阻塞。</strong></p>
<p>读写锁的读写操作之间的互斥原则具体如下：</p>
<ul>
<li>读操作、读操作能共存，是相容的。</li>
<li>读操作、写操作不能共存，是互斥的。</li>
<li>写操作、写操作不能共存，是互斥的。</li>
</ul>
<p>与单一的互斥锁相比，组合起来的读写锁允许对于共享数据进行更大程度的并发操作。虽然每次只能有一个写线程，但是同时可以有多个线程并发地读数据。<strong>读写锁适用于读多写少的并发情况</strong>。</p>
<p>JUC包中的读写锁接口为<code>ReadWriteLock</code>，主要有两个方法，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回读锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     Lock <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     Lock <span class="title function_">writeLock</span><span class="params">()</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>JUC中ReadWriteLock接口的实现类为<code>ReentrantReadWriteLock</code>。</p>
<h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>通过ReentrantReadWriteLock类能获取读锁和写锁，它的读锁是可以多线程共享的共享锁，而它的写锁是排他锁，在被占时不允许其他线程再抢占操作。然而其读锁和写锁之间是有关系的：同一时刻不允许读锁和写锁同时被抢占，二者之间是互斥的。</p>
<p>代码演示，读锁是共享锁，写锁是排他锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockExample</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个Map，代表共享数据</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;String, String&gt; MAP = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">    <span class="comment">// 创建一个读写锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">// 获取读锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">READ_LOCK</span> <span class="operator">=</span> LOCK.readLock();</span><br><span class="line">    <span class="comment">// 获取写锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">WRITE_LOCK</span> <span class="operator">=</span> LOCK.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对共享数据的写操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">put</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        WRITE_LOCK.lock(); <span class="comment">// 抢写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + LocalTime.now() + <span class="string">&quot; 抢占了WRITE_LOCK，开 始执行write操作&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">put</span> <span class="operator">=</span> MAP.put(key, value); <span class="comment">// 写入共享数据</span></span><br><span class="line">            <span class="keyword">return</span> put;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            WRITE_LOCK.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对共享数据的读操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        READ_LOCK.lock(); <span class="comment">// 抢占读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + LocalTime.now() + <span class="string">&quot; 抢占了 READ_LOCK，开始执行read操作&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> MAP.get(key); <span class="comment">// 读取共享数据</span></span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            READ_LOCK.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入口方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Runnable异步可执行目标实例</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">writeTarget</span> <span class="operator">=</span> () -&gt; put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">readTarget</span> <span class="operator">=</span> () -&gt; get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建4个读线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(readTarget, <span class="string">&quot;读线程&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建2个写线程，并启动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(writeTarget, <span class="string">&quot;写线程&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">读线程<span class="number">0</span> - <span class="number">00</span>:<span class="number">14</span>:<span class="number">11.818</span> 抢占了 READ_LOCK，开始执行read操作</span><br><span class="line">读线程<span class="number">2</span> - <span class="number">00</span>:<span class="number">14</span>:<span class="number">11.819</span> 抢占了 READ_LOCK，开始执行read操作</span><br><span class="line">读线程<span class="number">1</span> - <span class="number">00</span>:<span class="number">14</span>:<span class="number">11.819</span> 抢占了 READ_LOCK，开始执行read操作</span><br><span class="line">写线程<span class="number">0</span> - <span class="number">00</span>:<span class="number">14</span>:<span class="number">12.831</span> 抢占了WRITE_LOCK，开 始执行write操作</span><br><span class="line">写线程<span class="number">1</span> - <span class="number">00</span>:<span class="number">14</span>:<span class="number">13.844</span> 抢占了WRITE_LOCK，开 始执行write操作</span><br><span class="line">读线程<span class="number">3</span> - <span class="number">00</span>:<span class="number">14</span>:<span class="number">14.858</span> 抢占了 READ_LOCK，开始执行read操作</span><br></pre></td></tr></table></figure>

<p>从输出结果可以看出：</p>
<ul>
<li>读线程0、读线程1、读线程2同时获取了读锁，说明可以同时进行共享数据的读操作。</li>
<li>写线程0、写线程1只能依次获取写锁，说明共享数据的写操作不能同时进行。</li>
<li>读线程3必须等待写线程1释放写锁后才能获取到读锁，说明读写操作是互斥的。</li>
</ul>
<h3 id="锁的升级与降级"><a href="#锁的升级与降级" class="headerlink" title="锁的升级与降级"></a>锁的升级与降级</h3><p><strong>锁升级是指读锁升级为写锁，锁降级指的是写锁降级为读锁。</strong><code>在ReentrantReadWriteLock读写锁中，只支持写锁降级为读锁，而不支持读锁升级为写锁</code>。具体的演示代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockUpgradeAndDowngradeExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">sharedData</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 演示写锁降级为读锁</span></span><br><span class="line">        writeLockDowngradeToReadLock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 演示读锁尝试升级为写锁（会报错）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            readLockUpgradeToWriteLock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读锁升级为写锁失败，出现异常: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写锁降级为读锁示例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeLockDowngradeToReadLock</span><span class="params">()</span> &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 进行写操作</span></span><br><span class="line">            sharedData = <span class="number">10</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;获取写锁，写入数据: &quot;</span> + sharedData);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 降级操作，先获取读锁，再释放写锁，实现写锁降级为读锁</span></span><br><span class="line">            readLock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;已将写锁降级为读锁，当前数据: &quot;</span> + sharedData);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">            System.out.println(<span class="string">&quot;已释放锁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读锁尝试升级为写锁示例（实际不支持，会报错）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readLockUpgradeToWriteLock</span><span class="params">()</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;获取读锁，当前数据: &quot;</span> + sharedData);</span><br><span class="line">            <span class="comment">// 这里尝试获取写锁，在当前持有读锁的情况下，会阻塞，因为不支持读锁升级为写锁</span></span><br><span class="line">            <span class="comment">// 并且如果没有额外处理，会导致死锁情况，这里只是简单演示其不支持会抛出异常</span></span><br><span class="line">            writeLock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;尝试将读锁升级为写锁成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">获取写锁，写入数据: <span class="number">10</span></span><br><span class="line">已将写锁降级为读锁，当前数据: <span class="number">10</span></span><br><span class="line">已释放锁</span><br><span class="line">获取读锁，当前数据: <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>先通过<code>readLock.lock()</code>获取读锁，然后尝试通过<code>writeLock.lock()</code>获取写锁，在<code>ReentrantReadWriteLock</code>中这种情况是不被允许的，会导致当前线程阻塞在获取写锁的操作上，并且如果不做额外处理（比如通过超时等机制打破这种等待），很容易就陷入死锁情况（因为获取写锁需要等待所有读锁都释放，而当前线程又不释放自己持有的读锁）</p>
<p>通过结果可以看出：ReentrantReadWriteLock不支持读锁的升级，主要是避免死锁，例如两个线程A和B都占了读锁并且都需要升级成写锁，A升级要求B释放读锁，B升级要求A释放读锁，二者就会由于相互等待形成死锁。</p>
<p>总结起来，与ReentrantLock相比，<code>ReentrantReadWriteLock</code>更适合<strong>读多写少</strong>的场景，可以提高并发读的效率；而<code>ReentrantLock</code>更适合<strong>读写比例相差不大或写比读多的场景。</strong></p>
<h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><p><code>StampedLock</code>是 Java 8 中引入的一种锁机制， StampedLock（印戳锁）是对ReentrantReadWriteLock读写锁的一种改进，主要的改进为：<strong>在没有写只有读的场景下，StampedLock支持不用加读锁而是直接进行读操作，最大程度提升读的效率，只有在发生过写操作之后，再加读锁才能进行读操作。</strong></p>
<h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><ul>
<li><strong>写锁（排他锁）</strong>：用于对资源进行独占式的写操作。获取写锁后，其他线程无法获取写锁或读锁，直到写锁被释放。通过<code>writeLock()</code>方法获取写锁，返回的戳记用于后续释放锁操作，使用<code>unlockWrite(stamp)</code>方法释放写锁。</li>
<li><strong>读锁（共享锁）</strong>：多个线程可以同时获取读锁，用于对资源的只读操作。获取读锁后，其他线程可以继续获取读锁，但不能获取写锁。通过<code>readLock()</code>方法获取读锁，同样返回一个戳记，释放读锁使用<code>unlockRead(stamp)</code>方法。</li>
<li><strong>乐观读锁</strong>：一种优化的读锁方式，它假设在读取数据的过程中，数据不会被其他线程修改。线程先尝试获取一个乐观读戳记，然后进行数据读取操作。在读取完成后，需要使用<code>validate(stamp)</code>方法验证戳记的有效性，以确保在读取过程中没有其他线程对数据进行了写操作。如果验证失败，说明数据可能已经被修改，需要重新读取或采取其他处理方式。虽然写锁与乐观读锁不会互斥，但是在数据被更新之后，之前通过乐观读锁获得的数据已经变成了脏数据。</li>
</ul>
<p>悲观读锁的获取与释放</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取普通读锁（悲观读锁），返回long类型的印戳值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">readLock</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放普通读锁（悲观读锁），以取锁时的印戳值作为参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlockRead</span><span class="params">(<span class="type">long</span> stamp)</span></span><br></pre></td></tr></table></figure>

<p>写锁的获取与释放 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取写锁，返回long类型的印戳值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">writeLock</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放写锁，以获取写锁时的印戳值作为参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlockWrite</span><span class="params">(<span class="type">long</span> stamp)</span></span><br></pre></td></tr></table></figure>

<p>乐观读的印戳获取与有效性判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取乐观读，返回long类型的印戳值，返回0表示当前锁处于写锁模式，不能乐观读</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">tryOptimisticRead</span><span class="params">()</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//判断乐观读的印戳值是否有效，以tryOptimisticRead返回的印戳值作为参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">tryOptimisticRead</span><span class="params">()</span></span><br></pre></td></tr></table></figure>



<p>三种模式锁获取示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StampedLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(<span class="type">int</span> newData)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = newData;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 乐观读操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">optimisticRead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> data;</span><br><span class="line">        <span class="comment">// 验证戳记有效性</span></span><br><span class="line">        <span class="keyword">if</span> (!lock.validate(stamp)) &#123;</span><br><span class="line">            <span class="comment">// 数据已被修改，重新获取读锁读取</span></span><br><span class="line">            stamp = lock.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = data;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="stamp值"><a href="#stamp值" class="headerlink" title="stamp值"></a>stamp值</h3><p><code>stamp</code>的不同取值在不同操作和场景下有特定的含义与作用：</p>
<ul>
<li><p><strong>写锁相关</strong></p>
<ul>
<li><p><strong>写锁获取成功</strong>：当通过<code>writeLock()</code>等方法成功获取写锁时，返回的<code>stamp</code>是一个非零的<code>long</code>型数值。这个数值代表了此次写锁操作的标识，后续可以使用该<code>stamp</code>来释放写锁或者进行相关的验证操作。</p>
</li>
<li><p><strong>写锁获取失败</strong>：如果获取写锁失败，通常返回的<code>stamp</code>值为<code>0</code>，这表示此次获取写锁的操作未成功，线程不能进行写操作。</p>
</li>
</ul>
</li>
<li><p><strong>读锁相关</strong></p>
<ul>
<li><strong>悲观读锁获取成功</strong>：使用<code>readLock()</code>方法获取悲观读锁成功时，会返回一个非零的<code>stamp</code>，用于标识该读锁操作。与写锁类似，后续可以用这个<code>stamp</code>来释放读锁。</li>
</ul>
</li>
<li><p><strong>乐观读相关</strong>：在乐观读场景中，首先通过<code>tryOptimisticRead()</code>方法尝试获取乐观读锁，它也会返回一个<code>stamp</code>。</p>
<ul>
<li><strong>乐观读有效</strong>：如果返回的<code>stamp</code>不为<code>0</code>，表示当前可能处于一个没有写操作在进行的状态，即乐观读有效。此时可以进行数据读取操作，并且可以通过<code>validate(stamp)</code>方法来验证在读取数据期间是否有写操作发生。</li>
<li><strong>乐观读无效</strong>：如果<code>tryOptimisticRead()</code>返回的<code>stamp</code>为<code>0</code>，则说明当前可能有写操作正在进行，乐观读无效，不建议直接进行数据读取操作。</li>
</ul>
</li>
</ul>
<h3 id="StampedLock的演示案例"><a href="#StampedLock的演示案例" class="headerlink" title="StampedLock的演示案例"></a>StampedLock的演示案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.fulsun._5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> pers.fulsun._4.LockSupportDemo.sleepSeconds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StampedLockTest</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个Map，代表共享数据</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;String, String&gt; MAP = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">    <span class="comment">// 创建一个印戳锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">StampedLock</span> <span class="variable">STAMPED_LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对共享数据的写操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">put</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> STAMPED_LOCK.writeLock(); <span class="comment">// 尝试获取写锁的印戳</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + LocalTime.now() + <span class="string">&quot; 抢占了WRITE_LOCK，开始执行write操作&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">put</span> <span class="operator">=</span> MAP.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> put;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + LocalTime.now() + <span class="string">&quot; 释放了WRITE_LOCK&quot;</span>);</span><br><span class="line">            STAMPED_LOCK.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对共享数据的悲观读操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">pessimisticRead</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + LocalTime.now() + <span class="string">&quot; 进入了悲观读模式&quot;</span>);</span><br><span class="line">        <span class="comment">// 进入了写锁模式，只能获取悲观读锁</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> STAMPED_LOCK.readLock(); <span class="comment">// 尝试获取读 锁的印戳</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 成功获取到读锁，并重新获取最新的变量值</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + LocalTime.now() + <span class="string">&quot; 抢占了READ_LOCK，开始执行read操作&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> MAP.get(key);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + LocalTime.now() + <span class="string">&quot; 释放了READ_LOCK&quot;</span>);</span><br><span class="line">            STAMPED_LOCK.unlockRead(stamp); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对共享数据的乐观读操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">optimisticRead</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 尝试进行乐观读</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> STAMPED_LOCK.tryOptimisticRead();</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != stamp) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + LocalTime.now() + <span class="string">&quot; 进入了乐观读模式&quot;</span>);</span><br><span class="line">            sleepSeconds(<span class="number">1</span>); <span class="comment">// 模拟耗费时间1秒</span></span><br><span class="line">            value = MAP.get(key);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">// 0 == stamp 表示当前为写锁模式</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + LocalTime.now() + <span class="string">&quot; 进入了写锁模式，不能进行乐观读&quot;</span>);</span><br><span class="line">            <span class="comment">// LOCK已经进入写模式，使用悲观读方法</span></span><br><span class="line">            <span class="keyword">return</span> pessimisticRead(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 乐观读操作已经间隔了一段时间，期间可能发生写入</span></span><br><span class="line">        <span class="comment">// 所以，需要验证乐观读的印戳值是否有效，即判断LOCK是否进入过写模式</span></span><br><span class="line">        <span class="keyword">if</span> (!STAMPED_LOCK.validate(stamp)) &#123;</span><br><span class="line">            <span class="comment">// 乐观读的印戳值无效，表明写锁被占用过</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + LocalTime.now() + <span class="string">&quot; 乐观读的印戳值，已经过期&quot;</span>);</span><br><span class="line">            <span class="comment">// 写锁已经被抢占，进入了写锁模式，只能通过悲观读锁再一次读取最新值</span></span><br><span class="line">            <span class="keyword">return</span> pessimisticRead(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 乐观读的印戳值有效，表明写锁没有被占用过</span></span><br><span class="line">            <span class="comment">// 不用加悲观读锁而直接读，减少了读锁的开销</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + LocalTime.now() + <span class="string">&quot; 乐观读的印戳值，没有过期&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建Runnable可执行实例</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">writeTarget</span> <span class="operator">=</span> () -&gt; put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">readTarget</span> <span class="operator">=</span> () -&gt; optimisticRead(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建1个写线程，并启动</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(writeTarget, <span class="string">&quot;写线程&quot;</span>).start();</span><br><span class="line">        <span class="comment">// 创建1个读线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(readTarget, <span class="string">&quot;读线程&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">读线程 - 00:33:19.080 进入了写锁模式，不能进行乐观读</span><br><span class="line">写线程 - 00:33:19.080 抢占了WRITE_LOCK，开始执行write操作</span><br><span class="line">读线程 - 00:33:19.081 进入了悲观读模式</span><br><span class="line">写线程 - 00:33:20.095 释放了WRITE_LOCK</span><br><span class="line">读线程 - 00:33:20.095 抢占了READ_LOCK，开始执行<span class="built_in">read</span>操作</span><br><span class="line">读线程 - 00:33:20.095 释放了READ_LOCK</span><br></pre></td></tr></table></figure>





<h3 id="StampedLock与ReentrantReadWriteLock对比"><a href="#StampedLock与ReentrantReadWriteLock对比" class="headerlink" title="StampedLock与ReentrantReadWriteLock对比"></a>StampedLock与ReentrantReadWriteLock对比</h3><ol>
<li><p>锁特性</p>
<ul>
<li><p>**<code>StampedLock</code>**：具有写锁、读锁和乐观读锁三种模式。乐观读锁是其特色，提供了一种无锁的读方式，适用于大部分读操作不会与写操作冲突的场景。</p>
</li>
<li><p>**<code>ReentrantReadWriteLock</code>**：分为读锁和写锁，支持多个线程同时获取读锁，但写锁是排他的，同一时刻只能有一个线程获取写锁。</p>
</li>
</ul>
</li>
<li><p>锁获取与释放</p>
<ul>
<li><p>**<code>StampedLock</code>**：获取锁时会返回一个戳记（<code>stamp</code>），用于后续的锁释放和验证操作。释放锁时需要传入对应的戳记。如<code>long stamp = lock.writeLock();</code>获取写锁，<code>lock.unlockWrite(stamp);</code>释放写锁。</p>
</li>
<li><p>**<code>ReentrantReadWriteLock</code>**：通过<code>readLock()</code>获取读锁，<code>writeLock()</code>获取写锁，释放锁时直接调用<code>unlock()</code>方法即可，不需要额外的标识。如<code>ReadLock readLock = readWriteLock.readLock(); readLock.lock();</code>获取读锁，<code>readLock.unlock();</code>释放读锁。</p>
</li>
</ul>
</li>
<li><p>可重入性</p>
<ul>
<li><p>**<code>StampedLock</code>**：支持可重入，但在重入时需要注意戳记的使用和管理。例如，一个线程可以多次获取读锁或写锁，每次获取都会返回一个新的戳记，但释放锁时需要按照获取的顺序和次数进行释放。</p>
</li>
<li><p>**<code>ReentrantReadWriteLock</code>**：明确支持可重入，重入时锁的获取和释放相对简单，线程可以多次获取同一类型的锁，不会出现死锁等问题。</p>
</li>
</ul>
</li>
<li><p>性能</p>
<ul>
<li><p>**<code>StampedLock</code>**：在读多写少的场景下，乐观读锁能提高读操作的并发性，性能优势明显。但如果写操作频繁，乐观读锁的验证失败率会增加，可能导致性能下降。</p>
</li>
<li><p>**<code>ReentrantReadWriteLock</code>**：读锁和写锁的分离能提高一定的并发性能，但读锁之间存在一定的竞争，在高并发读的情况下性能可能不如<code>StampedLock</code>的乐观读锁。</p>
</li>
</ul>
</li>
<li><p>公平性</p>
<ul>
<li><p>**<code>StampedLock</code>**：默认是非公平锁，但可以通过构造函数或方法调用设置为公平锁，在公平模式下，线程按照请求锁的顺序获取锁。</p>
</li>
<li><p>**<code>ReentrantReadWriteLock</code>**：也支持公平和非公平模式，公平模式下，读锁和写锁的获取都遵循先来先服务的原则。</p>
</li>
</ul>
</li>
<li><p>适用场景</p>
<ul>
<li><p>**<code>StampedLock</code>**：适用于读操作频率远高于写操作，且对数据实时性要求较高的场景，如缓存系统、实时数据分析等。在这些场景中，乐观读锁可以在不影响数据一致性的前提下，提高系统的并发性能。</p>
</li>
<li><p>**<code>ReentrantReadWriteLock</code>**：适用于读多写少，但写操作对数据一致性要求严格，且读操作之间不需要过于精细的并发控制的场景，如数据库的读写操作、文件的读写等。</p>
</li>
</ul>
</li>
</ol>
<script>var description="JUC显式锁是一种非常灵活的、使用纯Java语言实现的锁。"</script></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://fulsun.github.io">凉月</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://fulsun.github.io/p/de78061e">https://fulsun.github.io/p/de78061e</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://fulsun.github.io" target="_blank">凉月の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JUC%E6%98%BE%E5%BC%8F%E9%94%81/">JUC显式锁</a></div><div class="post-share"><div class="social-share" data-image="/medias/featureimages/013.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/p/1c8195dc" title="可见性与有序性的原理"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/011.webp" onerror="onerror=null;src='/medias/detail/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">可见性与有序性的原理</div></div><div class="info-2"><div class="info-item-1">介绍Java如何解决并发编程中的可见性和有序性问题。</div></div></div></a><a class="pagination-related" href="/p/7aaa01f1" title="AQS抽象同步器的核心原理"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/008.webp" onerror="onerror=null;src='/medias/detail/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">AQS抽象同步器的核心原理</div></div><div class="info-2"><div class="info-item-1">为了减少由于无效争夺导致的资源浪费和性能恶化，一般都基于队列进行排队与削峰。</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/avatar.jpg" onerror="this.onerror=null;this.src='/medias/detail/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">凉月</div><div class="author-info-description">记录生活,分享知识。</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/fulsun"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/fulsun" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:fl_6145@163.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">感谢访问本站，若喜欢请收藏 ^_^</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E9%94%81"><span class="toc-text">显式锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E9%94%81Lock%E6%8E%A5%E5%8F%A3"><span class="toc-text">显式锁Lock接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81ReentrantLock"><span class="toc-text">可重入锁ReentrantLock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%98%BE%E5%BC%8F%E9%94%81%E7%9A%84%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81"><span class="toc-text">使用显式锁的模板代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8lock-%E6%96%B9%E6%B3%95%E6%8A%A2%E9%94%81%E7%9A%84%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81"><span class="toc-text">使用lock()方法抢锁的模板代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8tryLock-%E6%96%B9%E6%B3%95%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%8A%A2%E9%94%81%E7%9A%84%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81"><span class="toc-text">调用tryLock()方法非阻塞抢锁的模板代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8tryLock-long-time-TimeUnit-unit-%E6%96%B9%E6%B3%95"><span class="toc-text">调用tryLock(long time,TimeUnit unit)方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E9%94%81%E8%BF%9B%E8%A1%8C%E2%80%9C%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E2%80%9D"><span class="toc-text">显式锁进行“等待-通知”</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Condition%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-text">Condition接口的主要方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E9%94%81Condition%E6%BC%94%E7%A4%BA%E6%A1%88%E4%BE%8B"><span class="toc-text">显式锁Condition演示案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LockSupport"><span class="toc-text">LockSupport</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LockSupport%E7%9A%84%E6%BC%94%E7%A4%BA%E5%AE%9E%E4%BE%8B"><span class="toc-text">LockSupport的演示实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LockSupport-park-%E5%92%8CThread-sleep-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">LockSupport.park()和Thread.sleep()的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LockSupport-park-%E4%B8%8EObject-wait-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">LockSupport.park()与Object.wait()的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">显式锁的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-text">可重入锁和不可重入锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-text">悲观锁和乐观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-text">公平锁和非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81%E5%92%8C%E4%B8%8D%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81"><span class="toc-text">可中断锁和不可中断锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E7%8B%AC%E5%8D%A0%E9%94%81"><span class="toc-text">共享锁和独占锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81-1"><span class="toc-text">悲观锁和乐观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">悲观锁存在的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87CAS%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-text">通过CAS实现乐观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-text">自定义不可重入的自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-text">自定义可重入的自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4%E2%80%9C%E6%80%BB%E7%BA%BF%E9%A3%8E%E6%9A%B4%E2%80%9D"><span class="toc-text">CAS可能导致“总线风暴”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CLH%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-text">CLH自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MCS%E9%98%9F%E5%88%97%E9%94%81"><span class="toc-text">MCS队列锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MCS%E5%92%8CCLH%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%E5%AF%B9%E6%AF%94"><span class="toc-text">MCS和CLH实现细节对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-text">公平锁与非公平锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%AE%9E%E6%88%98"><span class="toc-text">非公平锁实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%AE%9E%E6%88%98"><span class="toc-text">公平锁实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">简单的非公平锁的示例代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">公平锁的代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81%E4%B8%8E%E4%B8%8D%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81"><span class="toc-text">可中断锁与不可中断锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%8F%AF%E4%B8%AD%E6%96%AD%E6%8A%A2%E5%8D%A0"><span class="toc-text">锁的可中断抢占</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E7%9B%91%E6%B5%8B%E4%B8%8E%E4%B8%AD%E6%96%AD"><span class="toc-text">死锁的监测与中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E4%B8%8E%E7%8B%AC%E5%8D%A0%E9%94%81"><span class="toc-text">共享锁与独占锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E9%94%81"><span class="toc-text">独占锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81Semaphore"><span class="toc-text">共享锁Semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Semaphore%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-text">Semaphore的主要方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CountDownLatch"><span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CyclicBarrier"><span class="toc-text">CyclicBarrier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-text">读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantReadWriteLock"><span class="toc-text">ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E4%B8%8E%E9%99%8D%E7%BA%A7"><span class="toc-text">锁的升级与降级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StampedLock"><span class="toc-text">StampedLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%B1%BB%E5%9E%8B"><span class="toc-text">锁类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stamp%E5%80%BC"><span class="toc-text">stamp值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StampedLock%E7%9A%84%E6%BC%94%E7%A4%BA%E6%A1%88%E4%BE%8B"><span class="toc-text">StampedLock的演示案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StampedLock%E4%B8%8EReentrantReadWriteLock%E5%AF%B9%E6%AF%94"><span class="toc-text">StampedLock与ReentrantReadWriteLock对比</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/p/b3bc049e" title="Java中的SPI服务发现机制"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/003.webp" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Java中的SPI服务发现机制"/></a><div class="content"><a class="title" href="/p/b3bc049e" title="Java中的SPI服务发现机制">Java中的SPI服务发现机制</a><time datetime="2025-02-16T05:36:57.339Z" title="发表于 2025-02-16 05:36:57">2025-02-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/3ca9bef3" title="SpringBoot预览PDF文件"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/001.webp" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="SpringBoot预览PDF文件"/></a><div class="content"><a class="title" href="/p/3ca9bef3" title="SpringBoot预览PDF文件">SpringBoot预览PDF文件</a><time datetime="2025-02-07T10:19:00.000Z" title="发表于 2025-02-07 10:19:00">2025-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/9b5fc26a" title="Debain12配置"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/013.webp" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Debain12配置"/></a><div class="content"><a class="title" href="/p/9b5fc26a" title="Debain12配置">Debain12配置</a><time datetime="2025-02-06T16:07:00.000Z" title="发表于 2025-02-06 16:07:00">2025-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/42bd8820" title="Docker安装脚本与换源"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/009.webp" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Docker安装脚本与换源"/></a><div class="content"><a class="title" href="/p/42bd8820" title="Docker安装脚本与换源">Docker安装脚本与换源</a><time datetime="2025-02-05T16:00:00.000Z" title="发表于 2025-02-05 16:00:00">2025-02-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/c3561f90" title="Nvm包管理器"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/007.webp" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Nvm包管理器"/></a><div class="content"><a class="title" href="/p/c3561f90" title="Nvm包管理器">Nvm包管理器</a><time datetime="2025-01-22T16:00:55.000Z" title="发表于 2025-01-22 16:00:55">2025-01-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 凉月</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.3.2"></script><script src="/js/main.js?v=5.3.2"></script><script src="https://unpkg.com/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://waline-fulsun.netlify.app/.netlify/functions/comment',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://unpkg.com/@waline/client@3.4.3/dist/waline.css')
        .then(() => import('https://unpkg.com/@waline/client@3.4.3/dist/waline.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://unpkg.com/butterfly-extsrc@1.1.4/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>