<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java内置锁的核心原理 | 凉月の博客</title><meta name="author" content="凉月"><meta name="copyright" content="凉月"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="从线程安全问题开始讲起，为大家揭秘Java内置锁的核心原理。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java内置锁的核心原理">
<meta property="og:url" content="https://fulsun.github.io/p/6feba110">
<meta property="og:site_name" content="凉月の博客">
<meta property="og:description" content="从线程安全问题开始讲起，为大家揭秘Java内置锁的核心原理。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fulsun.github.io/medias/featureimages/005.webp">
<meta property="article:published_time" content="2025-01-07T16:48:22.000Z">
<meta property="article:modified_time" content="2025-02-16T05:36:57.301Z">
<meta property="article:author" content="凉月">
<meta property="article:tag" content="ThreadLocal">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fulsun.github.io/medias/featureimages/005.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java内置锁的核心原理",
  "url": "https://fulsun.github.io/p/6feba110",
  "image": "https://fulsun.github.io/medias/featureimages/005.webp",
  "datePublished": "2025-01-07T16:48:22.000Z",
  "dateModified": "2025-02-16T05:36:57.301Z",
  "author": [
    {
      "@type": "Person",
      "name": "凉月",
      "url": "https://fulsun.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/medias/favicon.png"><link rel="canonical" href="https://fulsun.github.io/p/6feba110"><link rel="preconnect" href="//unpkg.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.3.2"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')
          
          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 凉月","link":"链接: ","source":"来源: 凉月の博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java内置锁的核心原理',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: linear-gradient(90deg, rgba(247, 149, 51, .1), rgba(243, 112, 85, .1) 15%, rgba(239, 78, 123, .1) 30%, rgba(161, 102, 171, .1) 44%, rgba(80, 115, 184, .1) 58%, rgba(16, 152, 173, .1) 72%, rgba(7, 179, 155, .1) 86%, rgba(109, 186, 130, .1));"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/avatar.jpg" onerror="this.onerror=null;this.src='/medias/detail/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heartbeat"></i><span> 我的</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> 联系</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 博主</span></a></li><li><a class="site-page child" href="/contact"><i class="fa-fw fas fa-comments"></i><span> 留言</span></a></li><li><a class="site-page child" href="/journal"><i class="fa-fw fas fa-cogs"></i><span> 日志</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> JS动画</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/snake/"><i class="fa-fw fas fa-gamepad"></i><span> 贪吃蛇</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/medias/featureimages/005.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">凉月の博客</span></a><a class="nav-page-title" href="/"><span class="site-name">Java内置锁的核心原理</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heartbeat"></i><span> 我的</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> 联系</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 博主</span></a></li><li><a class="site-page child" href="/contact"><i class="fa-fw fas fa-comments"></i><span> 留言</span></a></li><li><a class="site-page child" href="/journal"><i class="fa-fw fas fa-cogs"></i><span> 日志</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> JS动画</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/snake/"><i class="fa-fw fas fa-gamepad"></i><span> 贪吃蛇</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java内置锁的核心原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-07T16:48:22.000Z" title="发表于 2025-01-07 16:48:22">2025-01-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-16T05:36:57.301Z" title="更新于 2025-02-16 05:36:57">2025-02-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/">多线程编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">20.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>69分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:500,&quot;messagePrev&quot;:&quot;至上次更新后的&quot;,&quot;messageNext&quot;:&quot;天,文章内容可能已过时。&quot;,&quot;postUpdate&quot;:&quot;2025-02-16 05:36:57&quot;}" hidden></div><span id="more"></span>

<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>什么是线程安全呢？当多个线程并发访问某个Java对象（Object）时，无论系统如何调度这些线程，也无论这些线程将如何交替操作，这个对象都能表现出一致的、正确的行为，那么对这个对象的操作是线程安全的。如果这个对象表现出不一致的、错误的行为，那么对这个对象的操作不是线程安全的，发生了线程的安全问题。</p>
<h3 id="自增运算不是线程安全的"><a href="#自增运算不是线程安全的" class="headerlink" title="自增运算不是线程安全的"></a>自增运算不是线程安全的</h3><p>粗看上去，感觉这是一件不可思议的事情：对一个整数进行自增运算（++），怎么可能不是线程安全的呢？这可是只有一个完整的操作，看上去是那么的不可分割。<br>使用10个线程，对一个共享的变量，每个线程自增1000次，看看最终的结果是不是1万。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotSafePlus</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的自增运算不是原子操作</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 线程数量</span></span><br><span class="line"></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[threadCount];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有线程完成</span></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Final count: 9164</span></span><br></pre></td></tr></table></figure>

<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>为什么自增运算符不是线程安全的呢？实际上，一个自增运算符是一个复合操作，至少包括三个JVM指令：“内存取值”“寄存器增加1”和“存值到内存”。这三个指令在JVM内部是独立进行的，中间完<br>全可能会出现多个线程并发进行。</p>
<p>比如在amount&#x3D;100时，假设有三个线程同一时间读取amount值，读到的都是100，增加1后结果为101，三个线程都将结果存入amount的内存，amount的结果是101，而不是103。</p>
<p>“内存取值”“寄存器增加1”和“存值到内存”这三个JVM指令本身是不可再分的，它们都具备原子性，是线程安全的，也叫原子操作。但是，两个或者两个以上的原子操作合在一起进行操作就不再具<br>备原子性了。比如先读后写，就有可能在读之后，其实这个变量被修改了，出现读和写数据不一致的情况。</p>
<h3 id="临界区资源与临界区代码段"><a href="#临界区资源与临界区代码段" class="headerlink" title="临界区资源与临界区代码段"></a>临界区资源与临界区代码段</h3><p>Java工程师在进行代码开发时，常常倾向于认为代码会以线性的、串行的方式执行，容易忽视多个线程并行执行，从而导致意想不到的结果。</p>
<p>前面的线程安全小实验展示了在多个线程操作相同资源（如变量、数组或者对象）时就可能出现线程安全问题。一般来说，只在多个线程对这个资源进行写操作的时候才会出现问题，如果是简单的读操作，不改变资源的话，显然是不会出现问题的。</p>
<p><strong>临界区资源表示一种可以被多个线程使用的公共资源或共享数据</strong>，但是每一次只能有一个线程使用它。一旦临界区资源被占用，想使用该资源的其他线程则必须等待。</p>
<p>在并发情况下，临界区资源是受保护的对象。临界区代码段（Critical Section）是每个线程中访问临界资源的那段代码，多个线程必须互斥地对临界区资源进行访问。<strong>线程进入临界区代码段之前，必须在进入区申请资源，申请成功之后执行临界区代码段，执行完成之后释放资源</strong>。</p>
<p><code>竞态条件（Race Conditions</code>）可能是由于在访问临界区代码段时没有互斥地访问而导致的特殊情况。如果多个线程在临界区代码段的并发执行结果可能因为代码的执行顺序不同而不同，我们就说这时在临界区出现了竞态条件问题。在前面的线程安全小实验的代码中，amount为临界区资源，selfPlus()可以理解为临界区代码段，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//临界区资源</span></span><br><span class="line"><span class="comment">//临界区代码段</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selfPlus</span><span class="params">()</span> &#123;</span><br><span class="line"> amount++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当多个线程访问临界区的selfPlus()方法时，就会出现竞态条件的问题。更标准地说，当两个或多个线程竞争同一个资源时，对资源的访问顺序就变得非常关键。</p>
<p>为了避免竞态条件的问题，我们必须保证临界区代码段操作具备排他性。这就意味着当一个线程进入临界区代码段执行时，其他线程不能进入临界区代码段执行。</p>
<p>在Java中，我们可以使用<code>synchronized</code>关键字同步代码块，对临界区代码段进行排他性保护，示意代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(syncObject) &#123; </span><br><span class="line">	<span class="comment">//critical section</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java中，使用<code>synchronized</code>关键字还可以使用<code>Lock显式锁</code>实例，或者使用原子变量（Atomic Variables）对临界区代码段进行排他性保护。Lock显式锁、原子变量将在后续章节中介绍，接下来将介<br>绍synchronized关键字。</p>
<h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><p>在Java中，线程同步使用最多的方法是使用<code>synchronized</code>关键字。每个Java对象都隐含有一把锁，这里称为Java内置锁（或者对象锁、隐式锁）。使用synchronized（syncObject）调用相当于获取syncObject的内置锁，所以可以使用内置锁对临界区代码段进行排他性保护。</p>
<p><strong>任何时间只允许一个线程进入同步方法（临界区代码段），如果其他线程需要执行同一个方法，那么只能等待和排队。</strong></p>
<h3 id="synchronized同步方法"><a href="#synchronized同步方法" class="headerlink" title="synchronized同步方法"></a>synchronized同步方法</h3><p>synchronized关键字是Java的保留字，<strong>当使用synchronized关键字修饰一个方法的时候，该方法被声明为同步方法</strong>，具体的例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">selfPlus</span><span class="params">()</span>&#123;</span><br><span class="line">	amount++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键字synchronized的位置处于同步方法的返回类型之前</strong>。回到前面的线程安全小实验，现在使用synchronized关键字对临界区代码段进行保护，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//临界区代码段使用synchronized进行保护</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">selfPlus</span><span class="params">()</span>&#123;</span><br><span class="line">	amount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次运行测试用例程序，累加10000次之后，最终的结果不再有偏差，与预期的结果（10000）是相同的。</p>
<h3 id="synchronized同步块"><a href="#synchronized同步块" class="headerlink" title="synchronized同步块"></a>synchronized同步块</h3><p>对于小的临界区，我们直接在方法声明中设置synchronized同步关键字，可以避免竞态条件的问题。但是对于较大的临界区代码段，为了执行效率，最好将同步方法分为小的临界区代码段。通过下面这个例子来具体讲述：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoPlus</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sum2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//同步方法</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">plus</span><span class="params">(<span class="type">int</span> val1, <span class="type">int</span> val2)</span>&#123;</span><br><span class="line">         <span class="comment">//临界区代码段</span></span><br><span class="line">         <span class="built_in">this</span>.sum1 += val1;</span><br><span class="line">         <span class="built_in">this</span>.sum2 += val2;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>两个临界区资源分别为sum1和sum2。使用synchronized对plus(int val1,int val2)进行同步保护之后，进入临界区代码段的线程拥有sum1和sum2的操作权，并且是全部占用。一旦线程进入，当线程在操<br>作sum1而没有操作sum2时，也将sum2的操作权白白占用，其他的线程由于没有进入临界区，只能看着sum2被闲置而不能去执行操作。所以，将synchronized加在方法上，如果其保护的临界区代码段<br>包含的临界区资源（要求是相互独立的）多于一个，就会<strong>造成临界区资源的闲置等待，进而会影响临界区代码段的吞吐量</strong>。为了提升吞吐量，<strong>可以将synchronized关键字放在函数体内，同步一个代码块</strong>。synchronized同步块的写法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(syncObject) <span class="comment">//同步块而不是方法</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">//临界区代码段的代码块</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在synchronized同步块后边的括号中是一个syncObject对象，代表着进入临界区代码段需要获取syncObject对象的监视锁，或者说将syncObject对象监视锁作为临界区代码段的同步锁。</p>
<p>由于<strong>每一个Java对象都有一把监视锁，因此任何Java对象都能作为synchronized的同步锁。</strong><br>单个线程在synchronized同步块后面的同步锁后，才能进入临界区代码段；反过来说，当一个线程获得syncObject对象的监视锁后，其他线程就只能等待。</p>
<blockquote>
<p><strong>synchronized方法和synchronized同步块有什么区别呢？</strong></p>
</blockquote>
<p>总体来说，synchronized方法是一种粗粒度的并发控制，某一时刻只能有一个线程执行该synchronized方法；而synchronized代码块是一种细粒度的并发控制，处于synchronized块之外的其他代码是可以被多个线程并发访问的。在一个方法中，并不一定所有代码都是临界区代码段，可能只有几行代码会涉及线程同步问题。所以synchronized代码块比synchronized方法更加细粒度地控制了多个线程的同步访问。</p>
<blockquote>
<p>synchronized方法和synchronized代码块有什么联系呢？</p>
</blockquote>
<p>在Java的内部实现上，synchronized方法实际上等同于用一个synchronized代码块，这个代码块包含同步方法中的所有语句，然后在synchronized代码块的括号中传入this关键字，使用this对象锁作为<br>进入临界区的同步锁。<strong>synchronized方法的同步锁实质上使用了this对象锁，这样就免去了手工设置同步锁的工作。而使用synchronized代码块需要手工设置同步锁。</strong></p>
<h3 id="静态的同步方法"><a href="#静态的同步方法" class="headerlink" title="静态的同步方法"></a>静态的同步方法</h3><p>在Java世界里一切皆对象。Java有两种对象：Object实例对象和Class对象。每个类运行时的类型信息用Class对象表示，它包含与类名称、继承关系、字段、方法有关的信息。JVM将一个类加载入自己的方法区内存时，会为其创建一个Class对象，对于一个类来说其Class对象是唯一的。</p>
<p>Class类没有公共的构造方法，Class对象是在类加载的时候由Java虚拟机调用类加载器中的defineClass方法自动构造的，因此不能显式地声明一个Class对象。</p>
<p>所有的类都是在第一次使用时被动态加载到JVM中的（懒加载），其各个类都是在必需时才加载的。这一点与许多传统语言（如C++）都不同，JVM为动态加载机制配套了一个判定一个类是否已经被加载的检查动作，使得类加载器首先检查这个类的Class对象是否已经被加载。如果尚未加载，类加载器就会根据类的全限定名查找.class文件，验证后加载到JVM的方法区内存，并构造其对应的Class对象。</p>
<p>普通的synchronized实例方法，其同步锁是当前对象this的监视锁。如果<strong>某个synchronized方法是static（静态）方法，而不是普通的对象实例方法</strong>，其同步锁又是什么呢？<br>下面展示一个使用synchronized关键字修饰static方法的例子，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.crazymakercircle.plus;</span><br><span class="line"><span class="comment">// 省略import</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeStaticMethodPlus</span> &#123; <span class="comment">//静态的临界区资源</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//使用synchronized关键字修饰 static方法</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">selfPlus</span><span class="params">()</span>&#123;</span><br><span class="line">     	amount++;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>大家都知道，静态方法属于Class实例而不是单个Object实例，在静态方法内部是不可以访问Object实例的this引用（也叫指针、句柄）的。所以，修饰static方法的synchronized关键字就没有办法获<br>得Object实例的this对象的监视锁。</p>
<p>实际上，<strong>使用synchronized关键字修饰static方法时，synchronized的同步锁并不是普通Object对象的监视锁，而是类所对应的Class对象的监视锁</strong>。为了以示区分，这里将Object对象的监视锁叫作对象锁，将Class对象的监视锁叫作类锁。<strong>当synchronized关键字修饰static方法时，同步锁为类锁；当synchronized关键字修饰普通的成员方法（非静态方法）时，同步锁为类锁</strong>。由于类的对象实例可以有很多，但是每个类只有一个Class实例，因此使用类锁作为synchronized的同步锁时会造成同一个JVM内的所有线程只能互斥地进入临界区段。</p>
<p>所以，<strong>使用synchronized关键字修饰static方法是非常粗粒度的同步机制</strong>。</p>
<blockquote>
<p>通过synchronized关键字所抢占的同步锁什么时候释放呢？</p>
</blockquote>
<p>一种场景是synchronized块（代码块或者方法）正确执行完毕，监视锁自动释放；另一种场景是程序出现异常，非正常退出synchronized块，监视锁也会自动释放。所以，使用synchronized块时不必担心监视锁的释放问题。</p>
<h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p>生产者-消费者问题（Producer-Consumer Problem）也称有限缓冲问题（Bounded-Buffer Problem），是一个多线程同步问题的经典案例。</p>
<p>生产者-消费者问题描述了两类访问共享缓冲区的线程（所谓的“生产者”和“消费者”）在实际运行时会发生的问题。生产者线程的主要功能是生成一定量的数据放到缓冲区中，然后重复此过程。消<br>费者线程的主要功能是从缓冲区提取（或消耗）数据。</p>
<p>生产者-消费者问题的关键是：</p>
<ol>
<li>保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区空时消耗数据。</li>
<li>保证在生产者加入过程、消费者消耗过程中，不会产生错误的数据和行为。</li>
</ol>
<p>生产者-消费者问题不仅仅是一个多线程同步问题的经典案例，而且业内已经将解决该问题的方案抽象成了一种设计模式——“生产者消费者”模式。“生产者-消费者”模式是一个经典的多线程设计模<br>式，它为多线程间的协作提供了良好的解决方案。</p>
<h3 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者-消费者模式"></a>生产者-消费者模式</h3><p>在生产者-消费者模式中，通常有两类线程，即生产者线程（若干个）和消费者线程（若干个）。生产者线程向数据缓冲区（DataBuffer）加入数据，消费者线程则从数据缓冲区消耗数据。</p>
<p>在生产者-消费者模式中，至少有以下关键点：</p>
<ol>
<li>生产者与生产者之间、消费者与消费者之间，对数据缓冲区的操作是并发进行的。</li>
<li>数据缓冲区是有容量上限的。数据缓冲区满后，生产者不能再加入数据；数据缓冲区空时，消费者不能再取出数据。</li>
<li>数据缓冲区是线程安全的。在并发操作数据缓冲区的过程中，不能出现数据不一致的情况；或者在多个线程并发更改共享数据后，不会造成出现脏数据的情况。</li>
<li>生产者或者消费者线程在空闲时需要尽可能阻塞而不是执行无效的空操作，尽量节约CPU资源。</li>
</ol>
<h3 id="线程不安全的实现版本"><a href="#线程不安全的实现版本" class="headerlink" title="线程不安全的实现版本"></a>线程不安全的实现版本</h3><p>根据上面对生产者-消费者问题的描述先来实现一个非线程安全版本，包含数据缓冲区（DataBuffer）类、生产者（Producer）类和消费者（Consumer）类。</p>
<blockquote>
<p>通用生产者类的代码具体如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 生产的时间间隔，生产一次等待的时间默认为200毫秒</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PRODUCE_GAP</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">TURN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者对象编号</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">PRODUCER_NO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产的动作</span></span><br><span class="line">    <span class="type">Callable</span> <span class="variable">action</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> PRODUCE_GAP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Callable action, <span class="type">int</span> gap)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.action = action;</span><br><span class="line">        <span class="built_in">this</span>.gap = gap;</span><br><span class="line">        name = <span class="string">&quot;生产者-&quot;</span> + PRODUCER_NO.incrementAndGet();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行生产动作</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">out</span> <span class="operator">=</span> action.call();</span><br><span class="line">                <span class="comment">// 输出生产的结果</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != out) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;第&quot;</span> + TURN.get() + <span class="string">&quot;轮生产：&quot;</span> + out);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 每一轮生产之后，稍微等待一下</span></span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(gap);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 增加生产轮次</span></span><br><span class="line">                TURN.incrementAndGet();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>通用Consumer类的代码具体如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 消费的时间间隔，默认等待100毫秒</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONSUME_GAP</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 消费总次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">TURN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 消费者对象编号</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">CONSUMER_NO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 消费者名称</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">// 消费的动作</span></span><br><span class="line">    <span class="type">Callable</span> <span class="variable">action</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费一次等待的时间，默认为100毫秒</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> CONSUME_GAP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Callable action, <span class="type">int</span> gap)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.action = action;</span><br><span class="line">        <span class="built_in">this</span>.gap = gap;</span><br><span class="line">        name = <span class="string">&quot;消费者-&quot;</span> + CONSUMER_NO.incrementAndGet();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 增加消费次数</span></span><br><span class="line">            TURN.incrementAndGet();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行消费动作</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">out</span> <span class="operator">=</span> action.call();</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != out) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;第&quot;</span> + TURN.get() + <span class="string">&quot;轮消费：&quot;</span> + out);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 每一轮消费之后，稍微等待一下</span></span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(gap);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数据区缓冲区实例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotSafeDataBuffer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_AMOUNT</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; dataList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 保存数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向数据区增加一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T element)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (amount.get() &gt; MAX_AMOUNT) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列已经满了！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dataList.add(element);</span><br><span class="line">        amount.incrementAndGet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果数据不一致，就抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (amount.get() != dataList.size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(amount + <span class="string">&quot;!=&quot;</span> + dataList.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">fetch</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (amount.get() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列已经空了！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">T</span> <span class="variable">element</span> <span class="operator">=</span> dataList.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;取出的元素是:&quot;</span> + element);</span><br><span class="line">        amount.decrementAndGet();</span><br><span class="line">        <span class="comment">// 如果数据不一致，就抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (amount.get() != dataList.size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(amount + <span class="string">&quot;!=&quot;</span> + dataList.size());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>生产动作、消费动作的定义</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotSafePetStore</span> &#123;</span><br><span class="line">    <span class="comment">// 数据缓冲区静态实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> NotSafeDataBuffer&lt;String&gt; notSafeDataBuffer = <span class="keyword">new</span> <span class="title class_">NotSafeDataBuffer</span>();</span><br><span class="line">    <span class="comment">// 生产者执行的动作</span></span><br><span class="line">    <span class="keyword">static</span> Callable&lt;String&gt; produceAction = () -&gt; &#123;</span><br><span class="line">        <span class="comment">// 首先生成一个随机的商品</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">goods</span> <span class="operator">=</span> <span class="string">&quot;商品&quot;</span> + <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 将商品加上共享数据区</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            notSafeDataBuffer.add(goods);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> goods;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者执行的动作</span></span><br><span class="line">    <span class="keyword">static</span> Callable&lt;String&gt; consumerAction = () -&gt; &#123;</span><br><span class="line">        <span class="comment">// 从PetStore获取商品</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">goods</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            goods = notSafeDataBuffer.fetch();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> goods;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        <span class="comment">// 启动三个生产者线程和一个消费者线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> <span class="title class_">Producer</span>(produceAction, <span class="number">500</span>));</span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> <span class="title class_">Consumer</span>(consumerAction, <span class="number">1500</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>启动main()方法，程序开始并发执行，稍微等待一段时间，问题<br>就出来了，部分结果截取如下：</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IndexOutOfBoundsException: Index: 0, Size: 1</span><br><span class="line">	at java.base/java.util.LinkedList.checkElementIndex(LinkedList.java:566)</span><br><span class="line">	at java.base/java.util.LinkedList.remove(LinkedList.java:536)</span><br><span class="line">	at pers.fulsun.producerandcomsumer.NotSafeDataBuffer.fetch(NotSafeDataBuffer.java:35)</span><br><span class="line">	at pers.fulsun.producerandcomsumer.NotSafePetStore.lambda$static<span class="variable">$1</span>(NotSafePetStore.java:29)</span><br><span class="line">	at pers.fulsun.producerandcomsumer.Consumer.run(Consumer.java:36)</span><br><span class="line">	at java.base/java.util.concurrent.Executors<span class="variable">$RunnableAdapter</span>.call(Executors.java:572)</span><br><span class="line">	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)</span><br><span class="line">	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)</span><br><span class="line">	at java.base/java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:642)</span><br><span class="line">	at java.base/java.lang.Thread.run(Thread.java:1583)</span><br><span class="line">java.lang.Exception: 5!=2</span><br><span class="line">	at pers.fulsun.producerandcomsumer.NotSafeDataBuffe</span><br></pre></td></tr></table></figure>

<p>从以上异常可以看出，在向数据缓冲区进行元素的增加或者提取时，多个线程在并发执行对amount、dataList两个成员操作时次序已经混乱，导致出现数据不一致和线程安全问题。</p>
<h3 id="线程安全的实现版本"><a href="#线程安全的实现版本" class="headerlink" title="线程安全的实现版本"></a>线程安全的实现版本</h3><p>解决线程安全问题很简单，为临界区代码加上synchronized关键字即可，主要修改的是涉及操作两个临界区资源amount和dataList的代码，具体为DataBuffer的add(…)和fetch()方法。</p>
<p>创建一个安全的数据缓存区类SafeDataBuffer，在其add(…)和fetch()两个实例方法的public声明后面加上<code>synchronized</code>关键字即可。其他的代码一行不动，与NotSafeDataBuffer的代码相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向数据区增加一个元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T element)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (amount.get() &gt; MAX_AMOUNT) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;队列已经满了！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dataList.add(element);</span><br><span class="line">    amount.incrementAndGet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果数据不一致，就抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (amount.get() != dataList.size()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(amount + <span class="string">&quot;!=&quot;</span> + dataList.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title function_">fetch</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (amount.get() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;队列已经空了！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">T</span> <span class="variable">element</span> <span class="operator">=</span> dataList.remove(<span class="number">0</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;取出的元素是:&quot;</span> + element);</span><br><span class="line">    amount.decrementAndGet();</span><br><span class="line">    <span class="comment">// 如果数据不一致，就抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (amount.get() != dataList.size()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(amount + <span class="string">&quot;!=&quot;</span> + dataList.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然线程安全问题顺利解决了，但是以上解决方式使用了SafeDataBuffer实例的对象锁作为同步锁，这样一来，所有的生产、消费动作在执行过程中都需要抢占同一个同步锁，最终的结果是所有<br>的生产、消费动作都被串行化了。</p>
<p>高效率的生产者-消费者模式，生产、消费动作肯定不能串行执行，而是需要并行执行，而且并行化程度越高越好。如何既保障没有线程安全问题，又能提高生产、消费动作的并行化程度呢？这就是后续的实现版本需要解决的问题。</p>
<p>如果需要开发出并行化程度更高的生产者-消费者模式实现版本，需要彻底地掌握和理解对象锁、synchronized等机制的内部原理，这就需要从Java对象的头部结构等基础知识学起。</p>
<h2 id="Java对象结构"><a href="#Java对象结构" class="headerlink" title="Java对象结构"></a>Java对象结构</h2><p>Java内置锁的很多重要信息都存放在对象结构中。作为铺垫，在介绍Java内置锁之前，先为大家介绍一下Java对象结构。</p>
<ul>
<li>Java对象（Object实例）结构包括三部分：<code>对象头</code>、<code>对象体</code>和<code>对齐字节</code></li>
</ul>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/6feba110/413e4daa801949a3715a99994ef169fd.png"></p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><ul>
<li><p>对象头包括三个字段，第一个字段叫作<code>Mark Word</code>（标记字），用于存储自身运行时的数据，例如GC标志位、哈希码、锁状态等信息。<strong>32位JVM的Mark Word为32位，64位JVM的Mark Word为64位。</strong></p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/6feba110/446df403efce132113a8e2f944b0dc80.png"></p>
</li>
<li><p>第二个字段叫作<code>Class Pointer</code>（类对象指针），用于存放方法区Class对象的地址，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
</li>
<li><p>第三个字段叫作<code>Array Length</code>（数组长度）。如果对象是一个Java数组，那么此字段必须有，用于记录数组长度的数据；如果对象不是一个Java数组，那么此字段不存在，所以这是一个可选字段。</p>
</li>
</ul>
<h3 id="对象体"><a href="#对象体" class="headerlink" title="对象体"></a>对象体</h3><p>对象体包含对象的实例变量（成员变量），用于成员属性值，包括父类的成员属性值。这部分内存按4字节对齐。</p>
<h3 id="对齐字节"><a href="#对齐字节" class="headerlink" title="对齐字节"></a>对齐字节</h3><p>对齐字节也叫作填充对齐，其作用是用来保证Java对象所占内存字节数为8的倍数, HotSpot VM的内存管理要求对象起始地址必须是8字节的整数倍。对象头本身是8的倍数，当对象的实例变量数据不是8的倍数时，便需要填充数据来保证8字节的对齐。</p>
<h3 id="UseCompressedOops"><a href="#UseCompressedOops" class="headerlink" title="UseCompressedOops"></a>UseCompressedOops</h3><p>对于对象指针而言，如果JVM中的对象数量过多，使用64位的指针将浪费大量内存，通过简单统计，64位JVM将会比32位JVM多耗费50%的内存。为了节约内存可以使用选项<code>+UseCompressedOops</code><strong>开启指针压缩</strong>。UseCompressedOops中的Oop为Ordinary object pointer（普通对象指针）的缩写。, </p>
<p>在堆内存小于32GB的情况下，64位虚拟机的UseCompressedOops选项是默认开启的，该选项表示开启Oop对象的指针压缩会将原来64位的Oop对象指针压缩为32位。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 手动开启Oop对象指针压缩的Java指令为：</span><br><span class="line"> java -XX:+UseCompressedOops mainclass</span><br><span class="line">// 手动关闭Oop对象指针压缩的Java指令为：</span><br><span class="line"> java -XX:-UseCompressedOops mainclass</span><br></pre></td></tr></table></figure>

<p><strong>如果开启UseCompressedOops选项，以下类型的指针将从64位压缩至32位</strong>：</p>
<ul>
<li>Class对象的属性指针（静态变量）。</li>
<li>Object对象的属性指针（成员变量）。</li>
<li>普通对象数组的元素指针。</li>
</ul>
<p>当然，也不是所有的指针都会压缩，一些特殊类型的指针不会压缩，比如指向PermGen（永久代）的Class对象指针（JDK 8中指向元空间的Class对象指针）、本地变量、堆栈元素、入参、返回值和NULL指针等。</p>
<p>如果对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度（Array Length字段）。Array Length字段的长度也随着JVM架构的不同而不同：在32位JVM上，长度为32位；在64位JVM上，长度为64位。64位JVM如果开启了Oop对象的指针压缩，Array Length字段的长度也将由64位压缩至32位。</p>
<h2 id="Mark-Word的结构信息"><a href="#Mark-Word的结构信息" class="headerlink" title="Mark Word的结构信息"></a>Mark Word的结构信息</h2><p>Java内置锁涉及很多重要信息，这些都存放在对象结构中，并且存放于对象头的Mark Word字段中。Mark Word的位长度为JVM的一个Word大小，也就是说32位JVM的Mark Word为32位，64位JVM为64位。<strong>Mark Word的位长度不会受到Oop对象指针压缩选项的影响</strong>。</p>
<p>Java内置锁的状态总共有4种，级别由低到高依次为：<code>无锁、偏向锁、轻量级锁和重量级锁</code>。其实在JDK 1.6之前，Java内置锁还是一个重量级锁，是一个效率比较低下的锁，<strong>在JDK 1.6之后，JVM为了提高锁的获取与释放效率，对synchronized的实现进行了优化，引入了偏向锁和轻量级锁</strong>，从此以后Java内置锁的状态就有了4种（无锁、偏向锁、轻量级锁和重量级锁），并且<strong>4种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级，也就是说只能进行锁升级</strong>（从低级别到高级别）。</p>
<p>不同锁状态下的Mark Word字段结构Mark Word字段的结构与Java内置锁的状态强相关。为了让Mark<br>Word字段存储更多的信息，JVM将Mark Word<strong>最低两个位设置为Java内置锁状态位</strong>，不同锁状态下的32位Mark Word结构如表所示。</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/6feba110/446df403efce132113a8e2f944b0dc80.png" alt="64位Mark Word的结构信息"></p>
<ul>
<li>lock：锁状态标记位，占两个二进制位，由于希望用尽可能少的二进制位表示尽可能多的信息，因此设置了lock标记。该标记的值不同，整个Mark Word表示的含义就不同。</li>
<li>biased_lock：对象是否启用偏向锁标记，只占1个二进制位。为1时表示对象启用偏向锁，为0时表示对象没有偏向锁。lock和biased_lock两个标记位组合在一起共同表示Object实例处于什么样的锁状态。</li>
<li>age：4位的Java对象分代年龄。在GC中，对象在Survivor区复制一次，年龄就增加1。当对象达到设定的阈值时，将会晋升到老年代。默认情况下，并行GC的年龄阈值为15，并发GC的年龄阈值为6。由<br>于age只有4位，因此最大值为15，这就是-XX:MaxTenuringThreshold选项最大值为15的原因。</li>
<li>identity_hashcode：31位的对象标识HashCode（哈希码）采用延迟加载技术，当调用Object.hashCode()方法或者System.identityHashCode()方法计算对象的HashCode后，其结果将被写到该对象头中。当对象被锁定时，该值会移动到Monitor（监视器）中。</li>
<li>thread：54位的线程ID值为持有偏向锁的线程ID。</li>
<li>epoch：偏向时间戳。</li>
<li>ptr_to_lock_record：占62位，在轻量级锁的状态下指向栈帧中锁记录的指针。</li>
<li>ptr_to_heavyweight_monitor：占62位，在重量级锁的状态下指向对象监视器的指针。</li>
</ul>
<h2 id="使用JOL工具查看对象的布局"><a href="#使用JOL工具查看对象的布局" class="headerlink" title="使用JOL工具查看对象的布局"></a>使用JOL工具查看对象的布局</h2><p>JOL工具是一个jar包，使用它提供的工具类可以轻松解析出运行时java对象在内存中的结构，使用时首先需要引入maven GAV信息</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Java Object Layout --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.vm.VM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    log.info(VM.current().details());</span><br><span class="line">    <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">    log.info(<span class="string">&quot;hello obj status:&#123;&#125;&quot;</span>, ClassLayout.parseInstance(hello).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># VM mode: 64 bits</span></span><br><span class="line"><span class="comment"># Compressed references (oops): disabled</span></span><br><span class="line"><span class="comment"># Compressed class pointers: 0-bit shift</span></span><br><span class="line"><span class="comment"># Object alignment: 8 bytes</span></span><br><span class="line"><span class="comment">#                       ref, bool, byte, char, shrt,  int,  flt,  lng,  dbl</span></span><br><span class="line"><span class="comment"># Field sizes:            8,    1,    1,    2,    2,    4,    4,    8,    8</span></span><br><span class="line"><span class="comment"># Array element sizes:    8,    1,    1,    2,    2,    4,    4,    8,    8</span></span><br><span class="line"><span class="comment"># Array base offsets:    16,   16,   16,   16,   16,   16,   16,   16,   16</span></span><br><span class="line"></span><br><span class="line">===============</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line">  8   4        (object header: class)    0x80041170</span><br><span class="line"> 12   4        (object alignment gap)    </span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>VM mode: 64 bits - 表示当前虚拟机是64位虚拟机</li>
<li>Compressed references (oops): 3-bit shift - 开启了对象指针压缩，在64位的Java虚拟机上，对象指针通常需要占用8字节（64位），但通过使用压缩指针技术，可以减少对象指针的占用空间，提高内存利用率。”3-bit shift” 意味着使用3位的位移操作来对对象指针进行压缩。通过将对象指针右移3位，可以消除指针中的一些无用位，从而减少对象指针的实际大小，使其占用更少的内存。</li>
<li>Compressed class pointers: 3-bit shift - 开启了类指针压缩，其余同上。</li>
<li>Object alignment: 8 bytes - 字节对齐使用8字节</li>
<li>接下来这部分输出表示引用类型、boolean、byte、char、short、int、float、long、double类型的数据所占的字节数大小以及在数组中的大小和偏移量。需要注意的是数组偏移量的概念，数组偏移量的数值其实就是对象头的大小，<strong>在上图中的16字节表示如果当前对象是数组，那对象头就是16字节，不要忘了，对象头中还有数组长度，在未开启对象指针压缩的情况下，它要占据4字节大小</strong>。</li>
<li>对象结构输出结果<ul>
<li><strong>OFF</strong>：偏移量，单位字节</li>
<li><strong>SZ</strong>：大小，单位字节</li>
<li><strong>TYPE DESCRIPTION</strong>：类型描述，这里显示的比较直观，甚至可以看到是对象头的哪一部分</li>
<li><strong>VALUE</strong>：值，使用十六进制字符串表示，注意一个字节是8bit，占据两个16进制字符串，JOL0.15版本之前是小端序展示，0.15（包含0.15）版本之后使用大端序展示。</li>
</ul>
</li>
</ul>
<h3 id="大小端问题"><a href="#大小端问题" class="headerlink" title="大小端问题"></a>大小端问题</h3><p>有关字节序列的存放格式目前有两大阵营：第一大阵营是PowerPC系列CPU，采用大端模式存放数据；第二大阵营是X86系列CPU，采用小端模式存放数据。那么究竟什么是大端模式，什么又是小端模式呢？</p>
<ul>
<li><code>大端模式</code>是指数据的<strong>高字节保存在内存的低地址中</strong>，而数据的低字节保存在内存的高地址中。大端存放模式有点类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放。</li>
<li><code>小端模式</code>是指数据的<strong>高字节保存在内存的高地址中</strong>，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，此模式和日常的数字计算在方向上是一致的。</li>
</ul>
<blockquote>
<p>在处理器（即CPU）的计算过程中，因为使用小端模式在数据类型转换的时候（尤其是指针转换）不用考虑地址问题，所以小端模式是处理器的主流字节存放模式。<code>JVM所采用的字节存放模式是小端模式</code>。</p>
</blockquote>
<blockquote>
<p>由于所有网络协议都是采用大端模式来传输数据的，因此有时也会把大端模式称为“网络字节序”。当两台采用不同字节存放模式的主机通信时，在发送数据之前，都必须经过字节次序转换，转成“网<br>络字节序”（大端模式）后再进行传输。</p>
</blockquote>
<p>例如，假设你有一个32位的整数 <code>0x12345678</code>。在大端序下，这个整数会被存储为：</p>
<ul>
<li>地址 0: 0x12</li>
<li>地址 1: 0x34</li>
<li>地址 2: 0x56</li>
<li>地址 3: 0x78</li>
</ul>
<p>而在小端序（Little-endian）下，同样的整数会被存储为：</p>
<ul>
<li>地址 0: 0x78</li>
<li>地址 1: 0x56</li>
<li>地址 2: 0x34</li>
<li>地址 3: 0x12</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigEndianExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个整数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 ByteBuffer 来以大端序将整数转换为字节数组</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">        byteBuffer.order(java.nio.ByteOrder.BIG_ENDIAN); <span class="comment">// 设置为大端序</span></span><br><span class="line">        byteBuffer.putInt(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取大端序下的字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = byteBuffer.array();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印字节数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%02X &quot;</span>, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">在这个示例中，我们使用了ByteBuffer类来实现大端序的转换。ByteBuffer可以方便地将整数以指定的字节顺序存储到字节数组中。</span><br><span class="line"></span><br><span class="line">输出结果将是：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">12</span> <span class="number">34</span> <span class="number">56</span> <span class="number">78</span> </span><br><span class="line">这表示 <span class="number">0x12345678</span> 在大端序下被正确地转换为了 [<span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x56</span>, <span class="number">0x78</span>]。</span><br><span class="line"></span><br><span class="line">You</span><br><span class="line">大小端转换的工具类</span><br><span class="line"></span><br><span class="line">qwen2<span class="number">.5</span>:7b</span><br><span class="line">好的，你可以创建一个工具类来处理大小端转换。以下是一个示例代码，展示了如何在Java中实现大小端转换的功能：</span><br><span class="line"></span><br><span class="line">java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteOrder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EndianUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字节数组从小端序转换为大端序。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> littleEndianBytes 要转换的字节数组（小端序）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 大端序的字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] littleToBigEndian(<span class="type">byte</span>[] littleEndianBytes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (littleEndianBytes == <span class="literal">null</span> || littleEndianBytes.length % <span class="number">4</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid input bytes length&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numInts</span> <span class="operator">=</span> littleEndianBytes.length / <span class="number">4</span>;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(littleEndianBytes);</span><br><span class="line">        buffer.order(ByteOrder.LITTLE_ENDIAN); <span class="comment">// 设置为小端序</span></span><br><span class="line">        <span class="type">byte</span>[] bigEndianBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[littleEndianBytes.length];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numInts; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> buffer.getInt(i * <span class="number">4</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">intBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">            intBuffer.order(ByteOrder.BIG_ENDIAN); <span class="comment">// 设置为大端序</span></span><br><span class="line">            intBuffer.putInt(intValue);</span><br><span class="line">            bigEndianBytes[i * <span class="number">4</span> + <span class="number">0</span>] = intBuffer.get(<span class="number">3</span>); <span class="comment">// 高字节在低位</span></span><br><span class="line">            bigEndianBytes[i * <span class="number">4</span> + <span class="number">1</span>] = intBuffer.get(<span class="number">2</span>);</span><br><span class="line">            bigEndianBytes[i * <span class="number">4</span> + <span class="number">2</span>] = intBuffer.get(<span class="number">1</span>);</span><br><span class="line">            bigEndianBytes[i * <span class="number">4</span> + <span class="number">3</span>] = intBuffer.get(<span class="number">0</span>); <span class="comment">// 低字节在高位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bigEndianBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字节数组从大端序转换为小端序。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bigEndianBytes 要转换的字节数组（大端序）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 小端序的字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] bigToLittleEndian(<span class="type">byte</span>[] bigEndianBytes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bigEndianBytes == <span class="literal">null</span> || bigEndianBytes.length % <span class="number">4</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid input bytes length&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numInts</span> <span class="operator">=</span> bigEndianBytes.length / <span class="number">4</span>;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(bigEndianBytes);</span><br><span class="line">        buffer.order(ByteOrder.BIG_ENDIAN); <span class="comment">// 设置为大端序</span></span><br><span class="line">        <span class="type">byte</span>[] littleEndianBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[bigEndianBytes.length];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numInts; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> buffer.getInt(i * <span class="number">4</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">intBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">            intBuffer.order(ByteOrder.LITTLE_ENDIAN); <span class="comment">// 设置为小端序</span></span><br><span class="line">            intBuffer.putInt(intValue);</span><br><span class="line">            littleEndianBytes[i * <span class="number">4</span> + <span class="number">0</span>] = intBuffer.get(<span class="number">3</span>); <span class="comment">// 高字节在低位</span></span><br><span class="line">            littleEndianBytes[i * <span class="number">4</span> + <span class="number">1</span>] = intBuffer.get(<span class="number">2</span>);</span><br><span class="line">            littleEndianBytes[i * <span class="number">4</span> + <span class="number">2</span>] = intBuffer.get(<span class="number">1</span>);</span><br><span class="line">            littleEndianBytes[i * <span class="number">4</span> + <span class="number">3</span>] = intBuffer.get(<span class="number">0</span>); <span class="comment">// 低字节在高位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> littleEndianBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 测试数据：大端序的整数序列</span></span><br><span class="line">        <span class="type">byte</span>[] bigEndianData = <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x56</span>, <span class="number">0x78</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转换为小端序</span></span><br><span class="line">        <span class="type">byte</span>[] littleEndianData = bigToLittleEndian(bigEndianData);</span><br><span class="line">        System.out.println(<span class="string">&quot;大端序数据: &quot;</span> + bytesToHex(bigEndianData));</span><br><span class="line">        System.out.println(<span class="string">&quot;转换后的小端序数据: &quot;</span> + bytesToHex(littleEndianData));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试数据：小端序的整数序列</span></span><br><span class="line">        <span class="type">byte</span>[] littleEndianTestData = <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0x78</span>, <span class="number">0x56</span>, <span class="number">0x34</span>, <span class="number">0x12</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转换为大端序</span></span><br><span class="line">        <span class="type">byte</span>[] bigEndianTestData = littleToBigEndian(littleEndianTestData);</span><br><span class="line">        System.out.println(<span class="string">&quot;小端序数据: &quot;</span> + bytesToHex(littleEndianTestData));</span><br><span class="line">        System.out.println(<span class="string">&quot;转换后的大端序数据: &quot;</span> + bytesToHex(bigEndianData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字节数组转换为十六进制字符串。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 十六进制表示的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">bytesToHex</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">hexString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">hex</span> <span class="operator">=</span> Integer.toHexString(<span class="number">0xff</span> &amp; b);</span><br><span class="line">            <span class="keyword">if</span> (hex.length() == <span class="number">1</span>) &#123;</span><br><span class="line">                hexString.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            hexString.append(hex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hexString.toString().toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="无锁、偏向锁、轻量级锁和重量级锁"><a href="#无锁、偏向锁、轻量级锁和重量级锁" class="headerlink" title="无锁、偏向锁、轻量级锁和重量级锁"></a>无锁、偏向锁、轻量级锁和重量级锁</h2><p>在JDK 1.6版本之前，所有的Java内置锁都是重量级锁。重量级锁会造成CPU在用户态和核心态之间频繁切换，所以代价高、效率低。JDK 1.6版本为了减少获得锁和释放锁所带来的性能消耗，引入了偏向锁和轻量级锁的实现。所以，在JDK 1.6版本中内置锁一共有4种状态：<strong>无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态</strong>，这些状态随着竞争情况逐渐升级。内置锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能再降级成偏向锁。这种能升级却不能降级的策略，其目的是提高获得锁和释放锁的效率。</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/6feba110/71e02105740de18d1ca2cad9cc4b2c25.png"></p>
<h3 id="无锁状态"><a href="#无锁状态" class="headerlink" title="无锁状态"></a>无锁状态</h3><p>Java对象刚创建时还没有任何线程来竞争，说明该对象处于无锁状态（无线程竞争它），这时偏向锁标识位是0，锁状态是01。</p>
<h3 id="偏向锁状态"><a href="#偏向锁状态" class="headerlink" title="偏向锁状态"></a>偏向锁状态</h3><p><strong>偏向锁是指一段同步代码一直被同一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</strong>如果内置锁处于偏向状态，当有一个线程来竞争锁时，先用偏向锁，表示内置锁偏爱这个线程，这个线程要执行该锁关联的同步代码时，不需要再做任何检查和切换。偏向锁在竞争不激烈的情况下效率非常高。</p>
<p>偏向锁状态的Mark Word会记录内置锁自己偏爱的线程ID，内置锁会将该线程当作自己的熟人。</p>
<h3 id="轻量级锁状态"><a href="#轻量级锁状态" class="headerlink" title="轻量级锁状态"></a>轻量级锁状态</h3><p>当有两个线程开始竞争这个锁对象时，情况就发生变化了，不再是偏向（独占）锁了，锁会升级为轻量级锁，两个线程公平竞争，哪个线程先占有锁对象，锁对象的Mark Word就指向哪个线程的栈帧中的锁记录。</p>
<p>当锁处于偏向锁，又被另一个线程企图抢占时，偏向锁就会升级为轻量级锁。<strong>企图抢占的线程会通过自旋的形式尝试获取锁</strong>，不会阻塞抢锁线程，以便提高性能。</p>
<p>自旋原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要进行内核态和用户态之间的切换来进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免了用户线程和内核切换的消耗。</p>
<p>但是，线程自旋是需要消耗CPU的，如果一直获取不到锁，那么线程也不能一直占用CPU自旋做无用功，所以需要设定一个自旋等待的最大时间。JVM对于自旋周期的选择，<strong>JDK 1.6之后引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不是固定的，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定的</strong>。线程如果自旋成功了，下次自旋的次数就会更多，如果自旋失败了，自旋的次数就会减少。</p>
<p>如果持有锁的线程执行的时间超过自旋等待的最大时间仍没有释放锁，就会导致其他争用锁的线程在最大等待时间内还是获取不到锁，<strong>自旋不会一直持续下去，这时争用线程会停止自旋进入阻塞状态，该锁膨胀为重量级锁</strong>。</p>
<h3 id="重量级锁状态"><a href="#重量级锁状态" class="headerlink" title="重量级锁状态"></a>重量级锁状态</h3><p>重量级锁会让其他申请的线程之间进入阻塞，性能降低。重量级锁也叫同步锁，这个锁对象Mark Word再次发生变化，会指向一个监视器对象，该监视器对象用集合的形式来登记和管理排队的线程。</p>
<h2 id="偏向锁的原理与实战"><a href="#偏向锁的原理与实战" class="headerlink" title="偏向锁的原理与实战"></a>偏向锁的原理与实战</h2><p>偏向锁主要解决无竞争下的锁性能问题，所谓的偏向就是偏心，即锁会偏向于当前已经占有锁的线程。</p>
<p>JDK 15 之前，偏向锁默认是 enabled，从 JDK 15 开始，默认就是 disabled，除非显示的通过 <code>UseBiasedLocking 开启</code>。</p>
<h3 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h3><p>在实际场景中，如果一个同步块（或方法）没有多个线程竞争，而且总是由同一个线程多次重入获取锁，如果每次还有阻塞线程，唤醒CPU从用户态转为核心态，那么对于CPU是一种资源的浪费，为了解决这类问题，就引入了偏向锁的概念。</p>
<p>偏向锁的核心原理是：<strong>如果不存在线程竞争的一个线程获得了锁，那么锁就进入偏向状态，此时Mark Word的结构变为偏向锁结构，锁对象的锁标志位（lock）被改为01，偏向标志位（biased_lock）被改为1，然后线程的ID记录在锁对象的Mark Word中（使用CAS操作完成</strong>）。以后该线程获取锁时判断一下线程ID和标志位，就可以直接进入同步块，连CAS操作都不需要，这样就省去了大量有关锁申请的操作，从而也就提升了程序的性能。</p>
<p>偏向锁的主要作用是消除无竞争情况下的同步原语，进一步提升程序性能，所以，在没有锁竞争的场合，偏向锁有很好的优化效果。但是，一旦有第二条线程需要竞争锁，那么偏向模式立即结束，进入轻量级锁的状态。假如在大部分情况下同步块是没有竞争的，那么可以通过偏向来提高性能。<strong>即在无竞争时，之前获得锁的线程再次获得锁时会判断偏向锁的线程ID是否指向自己，如果是，那么该线程将不用再次获得锁，直接就可以进入同步块；如果未指向当前线程，当前线程就会采用CAS操作将Mark Word中的线程ID设置为当前线程ID，如果CAS操作成功，那么获取偏向锁成功，执行同步代码块，如果CAS操作失败，那么表示有竞争，抢锁线程被挂起，撤销占锁线程的偏向锁，然后将偏向锁膨胀为轻量级锁</strong>。</p>
<p>偏向锁的缺点：如果锁对象时常被多个线程竞争，偏向锁就是多余的，并且其撤销的过程会带来一些性能开销。</p>
<h3 id="演示案例"><a href="#演示案例" class="headerlink" title="演示案例"></a>演示案例</h3><p><code>-XX:-UseCompressedOops -XX:+UseBiasedLocking </code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 睡眠 5s</span></span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;未进入同步块，MarkWord 为：&quot;</span>);</span><br><span class="line">    System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">        System.out.println((<span class="string">&quot;进入同步块，MarkWord 为：&quot;</span>));</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要等待5秒呢？因为JVM在启动的时候会延迟启用偏向锁机制。JVM默认把偏向锁延迟了4000毫秒，这就解释了为什么演示案例要等待5秒才能看到对象锁的偏向状态。</p>
<p>为什么偏向锁会延迟？因为JVM在启动的时候需要加载资源，这些对象加上偏向锁没有任何意义，不启用偏向锁能减少大量偏向锁撤销的成本。如果不想等待（在代码中让线程睡眠），可以直接通过修改JVM的<br>启动选项来禁止偏向锁延迟，其具体的启动选项如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0</span><br></pre></td></tr></table></figure>



<ul>
<li>non-biasable; age: 0 表示无锁</li>
<li>thin lock: 0x0000004164dff358 ,为轻量级锁</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 未睡眠时结果:</span></span><br><span class="line">未进入同步块，MarkWord 为：</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line">  8   8        (object header: class)    0x00000179124d1c00</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br><span class="line"></span><br><span class="line">进入同步块，MarkWord 为：</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x0000004164dff358 (thin lock: 0x0000004164dff358)</span><br><span class="line">  8   8        (object header: class)    0x00000179124d1c00</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>0x000001a430882005 (biased: 0x00000000690c2208; epoch: 0; age: 0),后3位101,打印了偏量锁的信息</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">未进入同步块，MarkWord 为：</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x0000000000000005 (biasable; age: 0)</span><br><span class="line">  8   8        (object header: class)    0x000001a412431c00</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br><span class="line"></span><br><span class="line">进入同步块，MarkWord 为：</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x000001a430882005 (biased: 0x00000000690c2208; epoch: 0; age: 0)</span><br><span class="line">  8   8        (object header: class)    0x000001a412431c00</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>

<h3 id="偏向锁的膨胀和撤销"><a href="#偏向锁的膨胀和撤销" class="headerlink" title="偏向锁的膨胀和撤销"></a>偏向锁的膨胀和撤销</h3><p>假如有多个线程来竞争偏向锁，此对象锁已经有所偏向，其他的线程发现偏向锁并不是偏向自己，就说明存在了竞争，尝试撤销偏向锁（很可能引入安全点），然后膨胀到轻量级锁。</p>
<blockquote>
<p><strong>偏向锁的撤销</strong>: </p>
<p>从偏向状态撤回到原来的状态，也就是将 MarkWord 的第 3 位（是否偏向撤销）的值，<code>从 1 变回 0</code></p>
</blockquote>
<p>偏向锁撤销的开销花费还是挺大的，其大概过程如下：<br>（1）在一个安全点停止拥有锁的线程。<br>（2）遍历线程的栈帧，检查是否存在锁记录。如果存在锁记录，就需要清空锁记录，使其变成无锁状态，并修复锁记录指向的MarkWord，清除其线程ID。<br>（3）将当前锁升级成轻量级锁。<br>（4）唤醒当前线程。</p>
<p><strong>撤销偏向锁的条件</strong>：<br>（1）多个线程竞争偏向锁。<br>（2）调用偏向锁对象的hashcode()方法或者System.identityHashCode()方法计算对象的HashCode之后，将哈希码放置到Mark Word中，内置锁变成无锁状态，偏向锁将被撤销。</p>
<blockquote>
<p>偏向锁是特定场景下提升程序效率的方案，可并不代表所有程序都满足这些特定场景，比如这些场景（在开启偏向锁的前提下）：</p>
</blockquote>
<ol>
<li>一个线程创建了大量对象并执行了初始的同步操作，之后在另一个线程中将这些对象作为锁进行之后的操作。这种 case 下，会导致大量的偏向锁撤销操作</li>
<li>明知有多线程竞争（生产者&#x2F;消费者队列），还要使用偏向锁，也会导致各种撤销</li>
</ol>
<blockquote>
<p>很显然，这两种场景肯定会导致偏向撤销的，一个偏向撤销的成本无所谓，大量偏向撤销的成本是不能忽视的。那怎么办？</p>
</blockquote>
<ol>
<li>某些临界区存在两个及两个以上的线程竞争，那么偏向锁反而会降低性能，可以在启动JVM时就把偏向锁的默认功能关闭。</li>
<li>既不想禁用偏向锁，还不想忍受大量撤销偏向增加的成本，这种方案就是设计一个有阶梯的底线。</li>
</ol>
<h3 id="批量重偏向（Bulk-Rebiasing）"><a href="#批量重偏向（Bulk-Rebiasing）" class="headerlink" title="批量重偏向（Bulk Rebiasing）"></a>批量重偏向（Bulk Rebiasing）</h3><ul>
<li><p>这是第一种场景的快速解决方案，以 class 为单位，为每个 class 维护一个偏向锁撤销计数器，只要 class 的对象发生偏向撤销，该计数器 +1，当这个值达到重偏向阈值（默认 20）时：<code>BiasedLockingBulkRebiasThreshold = 20</code>, JVM 就认为该 class 的偏向锁有问题，因此会进行批量重偏向, 它的实现方式就用到了我们上面说的 epoch。</p>
</li>
<li><p>Epoch，如其含义「纪元」一样，就是一个时间戳。每个 class 对象会有一个对应的epoch字段，每个处于偏向锁状态对象的mark word 中也有该字段，其初始值为创建该对象时 class 中的epoch的值（此时二者是相等的）。</p>
</li>
<li><p>每次发生批量重偏向时，就将该值加 1，同时遍历 JVM 中所有线程的栈：找到该 class 所有正处于加锁状态的偏向锁对象，将其epoch字段改为新值, class 中不处于加锁状态的偏向锁对象（没被任何线程持有，但之前是被线程持有过的，这种锁对象的 markword 肯定也是有偏向的），保持 epoch 字段值不变<br>这样下次获得锁时，发现当前对象的epoch值和 class 的epoch，本着今朝不问前朝事 的原则（上一个纪元），就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过 CAS 操作将其mark word的线程 ID 改成当前线程 ID，这也算是一定程度的优化，毕竟没升级锁；</p>
</li>
<li><p>如果 epoch 都一样，说明没有发生过批量重偏向, 如果 markword 有线程 ID，还有其他锁来竞争，那锁自然是要升级的(如同前面举的例子 epoch&#x3D;0)。</p>
</li>
<li><p>批量重偏向是第一阶梯底线，还有第二阶梯底线</p>
</li>
</ul>
<h3 id="批量撤销（bulk-revoke）"><a href="#批量撤销（bulk-revoke）" class="headerlink" title="批量撤销（bulk revoke）"></a>批量撤销（bulk revoke）</h3><p>当达到重偏向阈值后，假设该 class 计数器继续增长，当其达到批量撤销的阈值后（默认 40）时，</p>
<p>BiasedLockingBulkRevokeThreshold &#x3D; 40<br>JVM 就认为该 class 的使用场景存在多线程竞争，会标记该 class 为不可偏向。之后对于该 class 的锁，直接走轻量级锁的逻辑。</p>
<p>这就是第二阶梯底线，但是在第一阶梯到第二阶梯的过渡过程中，也就是在彻底禁用偏向锁之前，还会给一次改过自新的机会，那就是另外一个计时器：</p>
<p>BiasedLockingDecayTime &#x3D; 25000<br>如果在距离上次批量重偏向发生的 25 秒之内，并且累计撤销计数达到 40，就会发生批量撤销（偏向锁彻底 game over）<br>如果在距离上次批量重偏向发生超过 25 秒之外，就会重置在 [20, 40) 内的计数, 再给次机会<br>大家有兴趣可以写代码测试一下临界点，观察锁对象 markword 的变化。至此，整个偏向锁的工作流程可以用一张图表示：</p>
<blockquote>
<p><strong>偏向锁的膨胀</strong></p>
</blockquote>
<p>如果偏向锁被占据，一旦有第二个线程争抢这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到内置锁偏向状态，这时表明在这个对象锁上已经存在竞争了。JVM检查原来持有该对象锁的占有线程是否依然存活，如果挂了，就可以将对象变为无锁状态，然后进行重新偏向，偏向为抢锁线程。</p>
<p>如果JVM检查到原来的线程依然存活，就进一步检查占有线程的调用堆栈是否通过锁记录持有偏向锁。如果存在锁记录，就表明原来的线程还在使用偏向锁，发生锁竞争，撤销原来的偏向锁，将偏向锁膨<br>胀（INFLATING）为轻量级锁。</p>
<blockquote>
<p><strong>偏向锁的好处</strong></p>
</blockquote>
<p>经验表明，其实大部分情况下进入一个同步代码块的线程都是同一个线程。这也是JDK会引入偏向锁的原因。所以，总体来说，使用偏向锁带来的好处还是大于偏向锁撤销和膨胀所带来的代价。</p>
<h2 id="轻量级锁的原理与实战"><a href="#轻量级锁的原理与实战" class="headerlink" title="轻量级锁的原理与实战"></a>轻量级锁的原理与实战</h2><p>引入轻量级锁的主要目的是<strong>在多线程竞争不激烈的情况下，通过CAS机制竞争锁减少重量级锁产生的性能损耗</strong>。重量级锁使用了操作系统底层的互斥锁（Mutex Lock），会导致线程在用户态和核心态之间频繁切换，从而带来较大的性能损耗。<strong>轻量级锁也被称为非阻塞同步、乐观锁，因为这个过程并没有把线程阻塞挂起，而是让线程空循环等待。</strong></p>
<h3 id="核心原理-1"><a href="#核心原理-1" class="headerlink" title="核心原理"></a>核心原理</h3><p>轻量锁存在的目的是尽可能不动用操作系统层面的互斥锁，因为其性能比较差。线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁地阻塞和唤醒对CPU来说是一件负担很重的工作。同时我们可以发现，很多对象锁的锁定状态只会持续很短的一段时间，例如整数的自加操作，在很短的时间内阻塞并唤醒线程显然不值得，为此引入了轻量级锁。<strong>轻量级锁是一种自旋锁</strong>，因为JVM本身就是一个应用，所以希望在应用层面上通过自旋解决线程同步问题。</p>
<p>轻量级锁的执行过程：在抢锁线程进入临界区之前，如果内置锁（临界区的同步对象）没有被锁定，JVM首先将在抢锁线程的栈帧中建立一个锁记录（Lock Record），用于存储对象目前Mark Word的拷贝,这时的线程堆栈与内置锁对象头大致如图:</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/6feba110/ef2f04ef0ba47f3c8f82d8f798db08d3.png"></p>
<p>然后抢锁线程将使用CAS自旋操作，尝试将内置锁对象头的MarkWord的ptr_to_lock_record（锁记录指针）更新为抢锁线程栈帧中锁记录的地址，如果这个更新执行成功了，这个线程就拥有了这个对象锁。然后JVM将Mark Word中的lock标记位改为00（轻量级锁标志），即表示该对象处于轻量级锁状态。抢锁成功之后，<strong>JVM会将Mark Word中原来的锁对象信息（如哈希码等）保存在抢锁线程锁记录的Displaced Mark Word（可以理解为放错地方的Mark Word）字段中，再将抢锁线程中锁记录的owner指针指向锁对象</strong>。在轻量级锁抢占成功之后，锁记录和对象头的状态如图所示。</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/6feba110/a5cc31fdc713311c590dc5b7e4f31063.png"></p>
<blockquote>
<p>锁记录是线程私有的，每个线程都有自己的一份锁记录，在创建完锁记录后，会将内置锁对象的Mark Word复制到锁记录的DisplacedMark Word字段。这是为什么呢？</p>
</blockquote>
<ol>
<li><strong>避免频繁的内存屏障（Memory Barrier）</strong>：在某些情况下，直接修改Mark Word可能会触发内存屏障，这会影响性能。通过将内置锁对象的Mark Word复制到锁记录中的Displaced Mark Word字段中，可以减少这些不必要的屏障。</li>
<li><strong>提供临时状态信息</strong>：线程私有的锁记录可以在不立即执行完整锁定操作的情况下保存某些临时状态信息（如锁的对象引用），这有助于后续快速决定是否需要真正进入同步代码块。</li>
<li><strong>简化实现和优化</strong>：使用锁记录可以减少直接对对象头的访问，避免复杂的内存模型约束。通过复制Mark Word到锁记录中，可以在一定程度上保持原有状态，同时简化了逻辑处理流程。</li>
<li><strong>支持自旋（Spin）机制</strong>：在轻量级锁中，线程会在获取锁前先尝试自旋一段时间，如果发现锁已经被其他线程持有，则可以基于Displaced Mark Word更快地判断出当前线程是否继续等待或放弃。</li>
</ol>
<h3 id="演示案例-1"><a href="#演示案例-1" class="headerlink" title="演示案例"></a>演示案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 睡眠 5s</span></span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;未进入同步块，MarkWord 为：&quot;</span>);</span><br><span class="line">    System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">        System.out.println((<span class="string">&quot;进入同步块，MarkWord 为：&quot;</span>));</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + (<span class="string">&quot;进入同步块，MarkWord 为：&quot;</span>));</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">未进入同步块，MarkWord 为：</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x0000000000000005 (biasable; age: 0)</span><br><span class="line">  8   8        (object header: class)    0x000001ca26411c00</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br><span class="line"></span><br><span class="line">进入同步块，MarkWord 为：</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x000001c80ffa2805 (biased: 0x000000007203fe8a; epoch: 0; age: 0)</span><br><span class="line">  8   8        (object header: class)    0x000001ca26411c00</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br><span class="line"></span><br><span class="line">Thread-0进入同步块，MarkWord 为：</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x00000061744ff620 (thin lock: 0x00000061744ff620)</span><br><span class="line">  8   8        (object header: class)    0x000001ca26411c00</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在执行第一个同步代码块后，在抢占完成之后，o实例的锁状态还是为偏向锁，只不过o实例的Mark Word记录了第一个抢占线程的ID。这一步的输出与前面偏向锁演示实例的输出相同，这里不再赘述。接着开始第二个抢锁线程，在第二个线程抢锁成功之后，o实例的锁状态为轻量级锁, lock标记位改为00（轻量级锁标志），其ptr_to_lock_record（锁记录指针）更新为抢锁线程栈帧中锁记录的地址，此时的锁为轻量级锁。轻量级锁被释放之后，o实例变成无锁状态.</p>
<h3 id="轻量级锁的分类"><a href="#轻量级锁的分类" class="headerlink" title="轻量级锁的分类"></a>轻量级锁的分类</h3><p>轻量级锁主要有两种：普通自旋锁和自适应自旋锁。</p>
<h3 id="普通自旋锁"><a href="#普通自旋锁" class="headerlink" title="普通自旋锁"></a>普通自旋锁</h3><p>所谓普通自旋锁，就是指当有线程来竞争锁时，抢锁线程会在原地循环等待，而不是被阻塞，直到那个占有锁的线程释放锁之后，这个抢锁线程才可以获得锁。</p>
<blockquote>
<p>锁在原地循环等待的时候是会消耗CPU的，就相当于在执行一个什么也不干的空循环。所以<strong>轻量级锁适用于临界区代码耗时很短的场景</strong>，这样线程在原地等待很短的时间就能够获得锁了。</p>
</blockquote>
<p>默认情况下，自旋的次数为10次，用户可以通过<code>XX:PreBlockSpin</code>选项来进行更改。</p>
<h3 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h3><p>所谓自适应自旋锁，就是等待线程空循环的自旋次数并非是固定的，而是会动态地根据实际情况来改变自旋等待的次数，自旋次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。自适应自旋锁的大概原理是：</p>
<ol>
<li>如果抢锁线程在同一个锁对象上之前成功获得过锁，JVM就会认为这次自旋很有可能再次成功，因此允许自旋等待持续相对更长的时间。</li>
<li>如果对于某个锁，抢锁线程很少成功获得过，那么JVM将可能减少自旋时间甚至省略自旋过程，以避免浪费处理器资源。</li>
</ol>
<p>自适应自旋解决的是“锁竞争时间不确定”的问题。自适应自旋假定不同线程持有同一个锁对象的时间基本相当，竞争程度趋于稳定。总的思想是：<strong>根据上一次自旋的时间与结果调整下一次自旋的时间</strong>。</p>
<blockquote>
<p>JDK 1.6的轻量级锁使用的是普通自旋锁，且需要使用XX:+UseSpinning选项手工开启。JDK 1.7后，轻量级锁使用自适应自旋锁，JVM启动时自动开启，且自旋时间由JVM自动控制。</p>
</blockquote>
<h3 id="轻量级锁的膨胀"><a href="#轻量级锁的膨胀" class="headerlink" title="轻量级锁的膨胀"></a>轻量级锁的膨胀</h3><p>轻量级锁的问题在哪里呢？虽然大部分临界区代码的执行时间都是很短的，但是也会存在执行得很慢的临界区代码。临界区代码执行耗时较长，在其执行期间，其他线程都在原地自旋等待，会空消耗CPU。因此，如果竞争这个同步锁的线程很多，就会有多个线程在原地等待继续空循环消耗CPU（空自旋），这会带来很大的性能损耗。</p>
<p>轻量级锁的本意是为了减少多线程进入操作系统底层的互斥锁（Mutex Lock）的概率，并不是要替代操作系统互斥锁。所以，<strong>在争用激烈的场景下，轻量级锁会膨胀为基于操作系统内核互斥锁实现的重量级锁</strong>。</p>
<h2 id="重量级锁的原理与实战"><a href="#重量级锁的原理与实战" class="headerlink" title="重量级锁的原理与实战"></a>重量级锁的原理与实战</h2><p>在JVM中，每个对象都关联一个监视器，这里的对象包含Object实例和Class实例。监视器是一个同步工具，相当于一个许可证，拿到许可证的线程即可进入临界区进行操作，没有拿到则需要阻塞等待。<strong>重量级锁通过监视器的方式保障了任何时间只允许一个线程通过受到监视器保护的临界区代码</strong>。</p>
<h3 id="核心原理-2"><a href="#核心原理-2" class="headerlink" title="核心原理"></a>核心原理</h3><p>JVM中每个对象都会有一个监视器，监视器和对象一起创建、销毁。监视器相当于一个用来监视这些线程进入的特殊房间，其义务是保证（同一时间）只有一个线程可以访问被保护的临界区代码块。</p>
<p>本质上，监视器是一种同步工具，也可以说是一种同步机制，主要特点是：</p>
<ol>
<li>同步。监视器所保护的临界区代码是互斥地执行的。一个监视器是一个运行许可，任一线程进入临界区代码都需要获得这个许可，离开时把许可归还。</li>
<li>协作。监视器提供Signal机制，允许正持有许可的线程暂时放弃许可进入阻塞等待状态，等待其他线程发送Signal去唤醒；其他拥有许可的线程可以发送Signal，唤醒正在阻塞等待的线程，让它可以重新获得许可并启动执行。</li>
</ol>
<p>在Hotspot虚拟机中，监视器是由C++类ObjectMonitor实现的，ObjectMonitor类定义在ObjectMonitor.hpp文件中，其构造器代码大致如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Monitor结构体</span></span><br><span class="line"> ObjectMonitor::<span class="built_in">ObjectMonitor</span>() &#123; </span><br><span class="line"> _header = <span class="literal">NULL</span>; </span><br><span class="line"> _count = <span class="number">0</span>; </span><br><span class="line"> _waiters = <span class="number">0</span>, </span><br><span class="line"> <span class="comment">//线程的重入次数</span></span><br><span class="line"> _recursions = <span class="number">0</span>; </span><br><span class="line"> _object = <span class="literal">NULL</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//标识拥有该Monitor的线程</span></span><br><span class="line"> _owner = <span class="literal">NULL</span>; </span><br><span class="line"> <span class="comment">//等待线程组成的双向循环链表</span></span><br><span class="line"> _WaitSet = <span class="literal">NULL</span>; </span><br><span class="line"> _WaitSetLock = <span class="number">0</span> ; </span><br><span class="line"> _Responsible = <span class="literal">NULL</span> ;  _succ = <span class="literal">NULL</span> ; </span><br><span class="line"> <span class="comment">//多线程竞争锁进入时的单向链表</span></span><br><span class="line"> cxq = <span class="literal">NULL</span> ; </span><br><span class="line"> FreeNext = <span class="literal">NULL</span> ; </span><br><span class="line"> <span class="comment">//_owner从该双向循环链表中唤醒线程节点</span></span><br><span class="line"> _EntryList = <span class="literal">NULL</span> ; </span><br><span class="line"> _SpinFreq = <span class="number">0</span> ; </span><br><span class="line"> _SpinClock = <span class="number">0</span> ; </span><br><span class="line"> OwnerIsThread = <span class="number">0</span> ; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>ObjectMonitor的<code>Owner（_owner）</code>、<code>WaitSet（_WaitSet</code>、<code>Cxq（_cxq）</code>、<code>EntryList（_EntryList）</code>这几个属性比较关键。<br>ObjectMonitor的WaitSet、Cxq、EntryList这三个队列存放抢夺重量级锁的线程，而ObjectMonitor的Owner所指向的线程即为获得锁的线程。</p>
<ul>
<li>Cxq：竞争队列（Contention Queue），所有请求锁的线程首先被放在这个竞争队列中。</li>
<li>EntryList：Cxq中那些有资格成为候选资源的线程被移动到EntryList中。</li>
<li>WaitSet：某个拥有ObjectMonitor的线程在调用Object.wait()方法之后将被阻塞，然后该线程将被放置在WaitSet链表中。</li>
</ul>
<blockquote>
<p><strong>Cxq</strong></p>
</blockquote>
<p>Cxq并不是一个真正的队列，只是一个虚拟队列，原因在于Cxq是由Node及其next指针逻辑构成的，并不存在一个队列的数据结构。每次新加入Node会在Cxq的队头进行，通过CAS改变第一个节点的指针为<br>新增节点，同时设置新增节点的next指向后续节点；从Cxq取得元素时，会从队尾获取。显然，Cxq结构是一个无锁结构。</p>
<p>因为只有Owner线程才能从队尾取元素，即线程出列操作无争用，当然也就避免了CAS的ABA问题。</p>
<p>在线程进入Cxq前，抢锁线程会先尝试通过CAS自旋获取锁，如果获取不到，就进入Cxq队列，这明显对于已经进入Cxq队列的线程是不公平的。所以，<strong>synchronized同步块所使用的重量级锁是不公平锁</strong></p>
<blockquote>
<p><strong>EntryList</strong></p>
</blockquote>
<p>EntryList与Cxq在逻辑上都属于等待队列。Cxq会被线程并发访问，为了降低对Cxq队尾的争用，而建立EntryList。在Owner线程释放锁时，JVM会从Cxq中迁移线程到EntryList，并会指定EntryList中的某个线程（一般为Head）为OnDeck Thread（Ready Thread）。EntryList中的线程作为候选竞争线程而存在。</p>
<blockquote>
<p>OnDeck Thread与Owner Thread</p>
</blockquote>
<p>JVM不直接把锁传递给Owner Thread，而是把锁竞争的权利交给OnDeck Thread，OnDeck需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大地提升系统的吞吐量，在JVM中，也把这种选择行为称为“竞争切换”。</p>
<p>OnDeck Thread获取到锁资源后会变为Owner Thread。无法获得锁的OnDeck Thread则会依然留在EntryList中，考虑到公平性，OnDeckThread在EntryList中的位置不发生变化（依然在队头）。</p>
<p>在OnDeck Thread成为Owner的过程中，还有一个不公平的事情，就是后来的新抢锁线程可能直接通过CAS自旋成为Owner而抢到锁。</p>
<blockquote>
<p><strong>WaitSet</strong></p>
</blockquote>
<p>如果Owner线程被<code>bject.wait()</code>方法阻塞，就转移到WaitSet队列中，直到某个时刻通过<code>Object.notify()</code>或者<code>Object.notifyAll()</code>唤醒，该线程就会重新进入EntryList中。</p>
<h3 id="重量级锁的开销"><a href="#重量级锁的开销" class="headerlink" title="重量级锁的开销"></a>重量级锁的开销</h3><p>处于ContentionList、EntryList、WaitSet中的线程都处于阻塞状态，线程的阻塞或者唤醒都需要操作系统来帮忙，Linux内核下采用pthread_mutex_lock系统调用实现，进程需要从用户态切换到内核态。</p>
<p>Linux系统的体系架构分为用户态（或者用户空间）和内核态（或者内核空间）,Linux系统的内核是一组特殊的软件程序，负责控制计算机的硬件资源，例如协调CPU资源、分配内存资源，并且提供稳定的环境供应用<br>程序运行。应用程序的活动空间为用户空间，应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I&#x2F;O资源等。</p>
<p>用户态与内核态有各自专用的内存空间、专用的寄存器等，进程从用户态切换至内核态需要传递许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。</p>
<p>用户态的进程能够访问的资源受到了极大的控制，而运行在内核态的进程可以“为所欲为”。一个进程可以运行在用户态，也可以运行在内核态，那么肯定存在用户态和内核态切换的过程。进程从用户态到内核态切换主要包括以下三种方式：</p>
<ul>
<li>硬件中断。硬件中断也称为外设中断，当外设完成用户的请求时会向CPU发送中断信号。</li>
<li>系统调用。其实系统调用本身就是中断，只不过是软件中断，跟硬件中断不同。</li>
<li>异常。如果当前进程运行在用户态，这个时候发生了异常事件（例如缺页异常），就会触发切换。</li>
</ul>
<p><strong>用户态是应用程序运行的空间，为了能访问到内核管理的资源（例如CPU、内存、I&#x2F;O），可以通过内核态所提供的访问接口实现，这些接口就叫系统调用</strong>。pthread_mutex_lock系统调用是内核态为用户态进程提供的Linux内核态下互斥锁的访问机制，所以使用pthread_mutex_lock系统调用时，进程需要从用户态切换到内核态，而这种切换是需要消耗很多时间的，有可能比用户执行代码的时间还要长。</p>
<p>由于JVM轻量级锁使用CAS进行自旋抢锁，这些CAS操作都处于用户态下，进程不存在用户态和内核态之间的运行切换，因此JVM轻量级锁开销较小。而JVM重量级锁使用了Linux内核态下的互斥锁，这是重量级锁开销很大的原因。</p>
<h3 id="演示案例-2"><a href="#演示案例-2" class="headerlink" title="演示案例"></a>演示案例</h3><blockquote>
<p>wait 方法是互斥量（重量级锁）独有的，一旦调用该方法，就会升级成重量级锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 睡眠 5s</span></span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    log.info(<span class="string">&quot;未生成 hashcode，MarkWord 为：&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">        log.info((<span class="string">&quot;进入同步块，MarkWord 为：&quot;</span>));</span><br><span class="line">        log.info(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;wait 2s&quot;</span>);</span><br><span class="line">        o.wait(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        log.info((<span class="string">&quot;调用 wait 后，MarkWord 为：&quot;</span>));</span><br><span class="line">        log.info(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上输出可以看出<code>0x000001ee12fc0caa (fat lock: 0x000001ee12fc0caa)</code>，此时锁状态已经从轻量级锁膨胀为重量级锁，其lock标记为10，说明此时存在激烈的锁争用。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">未进入同步块，MarkWord 为：</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x0000000000000005 (biasable; age: 0)</span><br><span class="line">  8   8        (object header: class)    0x000001ee124d1c00</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br><span class="line"></span><br><span class="line">进入同步块，MarkWord 为：</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x000001ee41141805 (biased: 0x000000007b904506; epoch: 0; age: 0)</span><br><span class="line">  8   8        (object header: class)    0x000001ee124d1c00</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br><span class="line"></span><br><span class="line"><span class="built_in">wait</span> 2s</span><br><span class="line">调用 <span class="built_in">wait</span> 后，MarkWord 为：</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x000001ee12fc0caa (fat lock: 0x000001ee12fc0caa)</span><br><span class="line">  8   8        (object header: class)    0x000001ee124d1c00</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>

<h3 id="偏向锁、轻量级锁与重量级锁的对比"><a href="#偏向锁、轻量级锁与重量级锁的对比" class="headerlink" title="偏向锁、轻量级锁与重量级锁的对比"></a>偏向锁、轻量级锁与重量级锁的对比</h3><p>总结一下synchronized的执行过程，大致如下：</p>
<ol>
<li>线程抢锁时，JVM首先检测内置锁对象Mark Word中的biased_lock（偏向锁标识）是否设置成1，lock（锁标志位）是否为01，如果都满足，确认内置锁对象为可偏向状态。</li>
<li>在内置锁对象确认为可偏向状态之后，JVM检查Mark Word中的线程ID是否为抢锁线程ID，如果是，就表示抢锁线程处于偏向锁状态，抢锁线程快速获得锁，开始执行临界区代码。</li>
<li>如果Mark Word中的线程ID并未指向抢锁线程，就通过CAS操作竞争锁。如果竞争成功，就将Mark Word中的线程ID设置为抢锁线程，偏向标志位设置为1，锁标志位设置为01，然后执行临界区代码，此时内置锁对象处于偏向锁状态。</li>
<li>如果CAS操作竞争失败，就说明发生了竞争，撤销偏向锁，进而升级为轻量级锁。</li>
<li>JVM使用CAS将锁对象的Mark Word替换为抢锁线程的锁记录指针，如果成功，抢锁线程就获得锁。如果替换失败，就表示其他线程竞争锁，JVM尝试使用CAS自旋替换抢锁线程的锁记录指针，如果自旋成功（抢锁成功），那么锁对象依然处于轻量级锁状态。</li>
<li>如果JVM的CAS替换锁记录指针自旋失败，轻量级锁就膨胀为重量级锁，后面等待锁的线程也要进入阻塞状态。</li>
</ol>
<p>总体来说，偏向锁是在没有发生锁争用的情况下使用的；一旦有了第二个线程争用锁，偏向锁就会升级为轻量级锁；如果锁争用很激烈，轻量级锁的CAS自旋到达阈值后，轻量级锁就会升级为重量级锁。</p>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>线程是操作系统调度的最小单位，有自己的栈空间，可以按照既定的代码逐步执行，但是如果每个线程间都孤立地运行，就会造资源浪费。</p>
<p>所以在现实中，如果<strong>需要多个线程按照指定的规则共同完成一个任务，那么这些线程之间就需要互相协调，这个过程被称为线程的通信</strong>。</p>
<h3 id="线程间通信的定义"><a href="#线程间通信的定义" class="headerlink" title="线程间通信的定义"></a>线程间通信的定义</h3><p>线程的通信可以被定义为：当多个线程共同操作共享的资源时，线程间通过某种方式互相告知自己的状态，以避免无效的资源争夺。</p>
<p>线程间通信的方式可以有很多种：<strong>等待-通知、共享内存、管道流</strong>。每种方式用不同的方法来实现，这里首先介绍等待-通知的通信方式。</p>
<p>“等待-通知”通信方式是Java中使用普遍的线程间通信方式，其经典的案例是“生产者-消费者”模式。</p>
<h3 id="低效的线程轮询"><a href="#低效的线程轮询" class="headerlink" title="低效的线程轮询"></a>低效的线程轮询</h3><p>首先回到前面的生产者-消费者安全版本的数据缓冲区类 SafeDataBuffer。其存在一个隐蔽但又很耗性能的问题：消费者每一轮消费，无论数据区是否为空，都需要进行数据区的询问和判断。其轮询代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title function_">fetch</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (amount.get() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;队列已经空了！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">T</span> <span class="variable">element</span> <span class="operator">=</span> dataList.remove(<span class="number">0</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;取出的元素是:&quot;</span> + element);</span><br><span class="line">    amount.decrementAndGet();</span><br><span class="line">    <span class="comment">// 如果数据不一致，就抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (amount.get() != dataList.size()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(amount + <span class="string">&quot;!=&quot;</span> + dataList.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当数据区空时（amount &lt;&#x3D; 0），消费者无法取出数据，但是仍然做无用的数据区询问工作，白白耗费了CPU的时间片。对于生产者来说，也存在类似的无效轮询问题。当数据区满时，生产者无法加入数据，这时生产者执行add(T element)方法也白白耗费了CPU的时间片。</p>
<blockquote>
<p>如何在生产者或者消费者空闲时节约CPU时间片，免去巨大的CPU资源浪费呢？</p>
</blockquote>
<p>一个非常有效的办法是：使用“等待-通知”方式进行生产者与消费者之间的线程通信。<br>具体来说，在数据区满（amount.get() &gt; MAX_AMOUNT）时，可以让生产者等待，等到下次数据区中可以加入数据时，给生产者发通知，让生产者唤醒。同样，在数据区为空（amount &lt;&#x3D; 0）时，可以让消费者等待，等到下次数据区中可以取出数据时，消费者才能被唤醒。那么，由谁去唤醒等待状态的生产者呢？可以在消费者取出一个数据后，由消费者去唤醒等待的生产者。同样，由谁去唤醒等待状态的消费者呢？可以在生产者加入一个数据后，由生产者去唤醒等待的消费者。</p>
<p><strong>Java语言中“等待-通知”方式的线程间通信使用对象的wait()、notify()两类方法来实</strong>现。每个Java对象都有wait()、notify()两类实例方法，并且wait()、notify()方法和对象的监视器是紧密相关的。</p>
<h3 id="wait方法和notify方法的原理"><a href="#wait方法和notify方法的原理" class="headerlink" title="wait方法和notify方法的原理"></a>wait方法和notify方法的原理</h3><p>Java对象中的wait()、notify()两类方法就如同信号开关，用于等待方和通知方之间的交互。</p>
<h4 id="对象的wait-方法"><a href="#对象的wait-方法" class="headerlink" title="对象的wait()方法"></a>对象的wait()方法</h4><ul>
<li><p>对象的<code>wait()</code>方法的主要作用是让当前线程阻塞并等待被唤醒。wait()方法与对象监视器紧密相关，<strong>使用<code>wait()</code>方法时一定要放在同步块中</strong>。<code>Wait()</code>方法的调用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(locko)&#123; </span><br><span class="line">    <span class="comment">//同步保护的代码块</span></span><br><span class="line">    locko.wait();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object类中的wait()方法有三个版本：</p>
<ul>
<li><code>void wait()</code>  这是一个基础版本，当前线程调用了同步对象locko的wait()实例方法后，将导致当前的线程等待，当前线程进入locko的监视器WaitSet，等待被其他线程唤醒。</li>
</ul>
</li>
<li><p><code>void wait(long timeout)</code> 这是一个限时等待版本，导致当前的线程等待，等待被其他线程唤醒，或者指定的时间timeout用完，线程不再等待。</p>
</li>
<li><p><code>void wait(long timeout,int nanos)</code> 这是一个高精度限时等待版本，其主要作用是更精确地控制等待时间。参数nanos是一个附加的纳秒级别的等待时间，从而实现更加高精度的等待时间控制。<code>1秒=1000毫秒=1000 000微秒=1000 000 000纳秒</code>。</p>
</li>
</ul>
<h4 id="wait-方法的核心原理"><a href="#wait-方法的核心原理" class="headerlink" title="wait()方法的核心原理"></a>wait()方法的核心原理</h4><p>对象的wait()方法的核心原理大致如下：</p>
<ol>
<li>当线程调用了locko（某个同步锁对象）的wait()方法后，JVM会将当前线程加入locko监视器的WaitSet（等待集），等待被其他线程唤醒。</li>
<li>当前线程会释放locko对象监视器的Owner权利，让其他线程可以抢夺locko对象的监视器。</li>
<li>让当前线程等待，其状态变成WAITING。</li>
</ol>
<h4 id="对象的notify-方法"><a href="#对象的notify-方法" class="headerlink" title="对象的notify()方法"></a>对象的notify()方法</h4><p>对象的notify()方法的主要作用是唤醒在等待的线程。notify()方法与对象监视器紧密相关，调用notify()方法时也需要放在同步块中。notify()方法的调用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(locko)&#123; </span><br><span class="line"> <span class="comment">//同步保护的代码块</span></span><br><span class="line"> locko.notify();</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>notify()方法有两个版本：</p>
<ul>
<li>版本一：<code>void notify()</code><ul>
<li><code>notify()</code>方法的主要作用为：<code>locko.notify()</code>调用后，唤醒locko监视器等待集中的第一条等待线程；被唤醒的线程进入EntryList，其状态从WAITING变成BLOCKED。</li>
</ul>
</li>
<li>版本二：void notifyAll()<ul>
<li><code>locko.notifyAll()</code>被调用后，唤醒locko监视器等待集中的全部等待线程，所有被唤醒的线程进入EntryList，线程状态从WAITING变成BLOCKED。</li>
</ul>
</li>
</ul>
<h4 id="notify-方法的核心原理"><a href="#notify-方法的核心原理" class="headerlink" title="notify()方法的核心原理"></a>notify()方法的核心原理</h4><p>对象的notify()或者notifyAll()方法的核心原理大致如下：</p>
<ul>
<li>当线程调用了locko（某个同步锁对象）的notify()方法后，JVM会唤醒locko监视器WaitSet中的第一条等待线程。</li>
<li>当线程调用了locko的notifyAll()方法后，JVM会唤醒locko监视器WaitSet中的所有等待线程。</li>
<li>等待线程被唤醒后，会从监视器的WaitSet移动到EntryList，线程具备了排队抢夺监视器Owner权利的资格，其状态从WAITING变成BLOCKED。</li>
<li>EntryList中的线程抢夺到监视器的Owner权利之后，线程的状态从BLOCKED变成Runnable，具备重新执行的资格。</li>
</ul>
<h3 id="“等待-通知”通信模式演示案例"><a href="#“等待-通知”通信模式演示案例" class="headerlink" title="“等待-通知”通信模式演示案例"></a>“等待-通知”通信模式演示案例</h3><p>Java的“等待-通知”机制是指：一个线程A调用了同步对象的wait()方法进入等待状态，而另一线程B调用了同步对象的notify()或者notifyAll()方法通知等待线程，当线程A收到通知后，重新进入就绪状态，准备开始执行。线程间的通信需要借助同步对象（Object）的监视器来完成，Object对象的wait()、notify()方法就如开关信号，用于完成等待方和通知方之间的通信。</p>
<p>下面的演示示例定义了一个独立的同步对象locko，然后借助其wait()、notify()方法完成两个线程aitThread、NotifyThread之间的通信，具体代码如下：</p>
<ul>
<li>LOCK_OBJECT：用于临界区同步，临界区资源为数据缓冲区的dataList变量和amount变量。</li>
<li>NOT_FULL：用于数据缓冲区的未满条件等待和通知。生产者在添加元素前需要判断数据区是否已满，如果是，生产者就进入NOT_FULL的同步区等待被通知，只要消费者消耗一个元素，数据区就是未满的，进入NOT_FULL的同步区发送通知。</li>
<li>NOT_EMPTY：用于数据缓冲区的非空条件等待和通知。消费者在消耗元素前需要判断数据区是否已空，如果是，消费者就进入NOT_EMPTY的同步区等待被通知，只要生产者添加一个元素，数据区就是非空的，生产者会进入NOT_EMPTY的同步区发送通知。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK_OBJECT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">NOT_FULL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">NOT_EMPTY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向数据区增加一个元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T element)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">while</span> (amount.get() &gt; MAX_AMOUNT) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (NOT_FULL) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列已经满了！&quot;</span>);</span><br><span class="line">            <span class="comment">// 等待未满通知</span></span><br><span class="line">            NOT_FULL.wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (LOCK_OBJECT) &#123;</span><br><span class="line">        dataList.add(element);</span><br><span class="line">        amount.incrementAndGet();</span><br><span class="line">        <span class="comment">// 如果数据不一致，就抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (amount.get() != dataList.size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(amount + <span class="string">&quot;!=&quot;</span> + dataList.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (NOT_EMPTY) &#123;</span><br><span class="line">        NOT_EMPTY.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">fetch</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">while</span> (amount.get() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (NOT_EMPTY) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列已经空了！&quot;</span>);</span><br><span class="line">            NOT_EMPTY.wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">T</span> <span class="variable">element</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (LOCK_OBJECT) &#123;</span><br><span class="line">        element = dataList.remove(<span class="number">0</span>);</span><br><span class="line">        amount.decrementAndGet();</span><br><span class="line">        <span class="comment">// 如果数据不一致，就抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (amount.get() != dataList.size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(amount + <span class="string">&quot;!=&quot;</span> + dataList.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (NOT_FULL) &#123;</span><br><span class="line">        NOT_FULL.notify();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="synchronized同步块的内部使用wait和notify"><a href="#synchronized同步块的内部使用wait和notify" class="headerlink" title="synchronized同步块的内部使用wait和notify"></a>synchronized同步块的内部使用wait和notify</h3><p><strong>在调用同步对象的wait()和notify()系列方法时，“当前线程”必须拥有该对象的同步锁，也就是说，wait()和notify()系列方法需要在同步块中使用</strong>，否则JVM会抛出类似如下的异常<code>IllegalMonitorStateException</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalMonitorStateException</span><br><span class="line"> at java.lang.Object.notify(Native Method)</span><br></pre></td></tr></table></figure>

<p>为什么wait和notify不在synchronized同步块的内部使用会抛出异常呢？这需要从wait()和notify()方法的原理说起。<br><strong>wait()方法的原理</strong>：首先，JVM会释放当前线程的对象锁监视器的Owner资格；其次，JVM会将当前线程移入监视器的WaitSet队列，而这些操作都和对象锁监视器是相关的。所以，wait()方法必须在synchronized同步块的内部调用。<strong>在当前线程执行wait()方法前，必须通过synchronized()方法成为对象锁的监视器的Owner</strong>。</p>
<p><strong>notify()方法的原理</strong>：JVM从对象锁的监视器的WaitSet队列移动一个线程到其EntryList队列，这些操作都与对象锁的监视器有关。所以，notify()方法也必须在synchronized同步块的内部调用。<strong>在执行notify()方法前，当前线程也必须通过synchronized()方法成为对象锁的监视器的Owner</strong>。</p>
<blockquote>
<p>调用wait()和notify()系列方法进行线程通信的要点如下：</p>
</blockquote>
<ol>
<li>调用某个同步对象locko的wait()和notify()类型方法前，必须要取得这个锁对象的监视锁，所以wait()和notify()类型方法必须放在synchronized(locko)同步块中，如果没有获得监视锁，JVM就会报IllegalMonitorStateException异常。</li>
<li>调用wait()方法时使用while进行条件判断，如果是在某种条件下进行等待，对条件的判断就不能使用if语句做一次性判断，而是<strong>使用while循环进行反复判断。只有这样才能在线程被唤醒后继续检查wait的条件，并在条件没有满足的情况下继续等待</strong>。</li>
</ol>
<script>var description="从线程安全问题开始讲起，为大家揭秘Java内置锁的核心原理。"</script></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://fulsun.github.io">凉月</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://fulsun.github.io/p/6feba110">https://fulsun.github.io/p/6feba110</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://fulsun.github.io" target="_blank">凉月の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ThreadLocal/">ThreadLocal</a></div><div class="post-share"><div class="social-share" data-image="/medias/featureimages/005.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/p/38186d5e" title="ThreadLocal原理与实战"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/007.webp" onerror="onerror=null;src='/medias/detail/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">ThreadLocal原理与实战</div></div><div class="info-2"><div class="info-item-1">在Java中使用ThreadLocal时，为了防止内存泄漏并确保资源的有效管理，应遵循的最佳实践。</div></div></div></a><a class="pagination-related" href="/p/4793d884" title="CAS原理与JUC原子类"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/002.webp" onerror="onerror=null;src='/medias/detail/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">CAS原理与JUC原子类</div></div><div class="info-2"><div class="info-item-1">介绍CAS的原理和弊端，然后介绍基于CAS实现的JUC原子类。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/p/38186d5e" title="ThreadLocal原理与实战"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/007.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-07</div><div class="info-item-2">ThreadLocal原理与实战</div></div><div class="info-2"><div class="info-item-1">在Java中使用ThreadLocal时，为了防止内存泄漏并确保资源的有效管理，应遵循的最佳实践。</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/avatar.jpg" onerror="this.onerror=null;this.src='/medias/detail/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">凉月</div><div class="author-info-description">记录生活,分享知识。</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/fulsun"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/fulsun" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:fl_6145@163.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">感谢访问本站，若喜欢请收藏 ^_^</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-text">线程安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E8%BF%90%E7%AE%97%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84"><span class="toc-text">自增运算不是线程安全的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90"><span class="toc-text">原因分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E8%B5%84%E6%BA%90%E4%B8%8E%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BB%A3%E7%A0%81%E6%AE%B5"><span class="toc-text">临界区资源与临界区代码段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">synchronized关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-text">synchronized同步方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%90%8C%E6%AD%A5%E5%9D%97"><span class="toc-text">synchronized同步块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-text">静态的同步方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">生产者-消费者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">生产者-消费者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%89%88%E6%9C%AC"><span class="toc-text">线程不安全的实现版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%89%88%E6%9C%AC"><span class="toc-text">线程安全的实现版本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84"><span class="toc-text">Java对象结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-text">对象头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%BD%93"><span class="toc-text">对象体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%BD%90%E5%AD%97%E8%8A%82"><span class="toc-text">对齐字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UseCompressedOops"><span class="toc-text">UseCompressedOops</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mark-Word%E7%9A%84%E7%BB%93%E6%9E%84%E4%BF%A1%E6%81%AF"><span class="toc-text">Mark Word的结构信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8JOL%E5%B7%A5%E5%85%B7%E6%9F%A5%E7%9C%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%83%E5%B1%80"><span class="toc-text">使用JOL工具查看对象的布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90"><span class="toc-text">结果分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E7%AB%AF%E9%97%AE%E9%A2%98"><span class="toc-text">大小端问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E9%94%81%E3%80%81%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%92%8C%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-text">无锁、偏向锁、轻量级锁和重量级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%94%81%E7%8A%B6%E6%80%81"><span class="toc-text">无锁状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E7%8A%B6%E6%80%81"><span class="toc-text">偏向锁状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%8A%B6%E6%80%81"><span class="toc-text">轻量级锁状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%8A%B6%E6%80%81"><span class="toc-text">重量级锁状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98"><span class="toc-text">偏向锁的原理与实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-text">核心原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA%E6%A1%88%E4%BE%8B"><span class="toc-text">演示案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E8%86%A8%E8%83%80%E5%92%8C%E6%92%A4%E9%94%80"><span class="toc-text">偏向锁的膨胀和撤销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91%EF%BC%88Bulk-Rebiasing%EF%BC%89"><span class="toc-text">批量重偏向（Bulk Rebiasing）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%92%A4%E9%94%80%EF%BC%88bulk-revoke%EF%BC%89"><span class="toc-text">批量撤销（bulk revoke）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98"><span class="toc-text">轻量级锁的原理与实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-1"><span class="toc-text">核心原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA%E6%A1%88%E4%BE%8B-1"><span class="toc-text">演示案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">轻量级锁的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-text">普通自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-text">自适应自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E8%86%A8%E8%83%80"><span class="toc-text">轻量级锁的膨胀</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98"><span class="toc-text">重量级锁的原理与实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-2"><span class="toc-text">核心原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E5%BC%80%E9%94%80"><span class="toc-text">重量级锁的开销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA%E6%A1%88%E4%BE%8B-2"><span class="toc-text">演示案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E4%B8%8E%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">偏向锁、轻量级锁与重量级锁的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">线程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">线程间通信的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8E%E6%95%88%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%BD%AE%E8%AF%A2"><span class="toc-text">低效的线程轮询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait%E6%96%B9%E6%B3%95%E5%92%8Cnotify%E6%96%B9%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">wait方法和notify方法的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84wait-%E6%96%B9%E6%B3%95"><span class="toc-text">对象的wait()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wait-%E6%96%B9%E6%B3%95%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-text">wait()方法的核心原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84notify-%E6%96%B9%E6%B3%95"><span class="toc-text">对象的notify()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#notify-%E6%96%B9%E6%B3%95%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-text">notify()方法的核心原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9C%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E2%80%9D%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%BC%8F%E6%BC%94%E7%A4%BA%E6%A1%88%E4%BE%8B"><span class="toc-text">“等待-通知”通信模式演示案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%90%8C%E6%AD%A5%E5%9D%97%E7%9A%84%E5%86%85%E9%83%A8%E4%BD%BF%E7%94%A8wait%E5%92%8Cnotify"><span class="toc-text">synchronized同步块的内部使用wait和notify</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/p/b3bc049e" title="Java中的SPI服务发现机制"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/003.webp" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Java中的SPI服务发现机制"/></a><div class="content"><a class="title" href="/p/b3bc049e" title="Java中的SPI服务发现机制">Java中的SPI服务发现机制</a><time datetime="2025-02-16T05:36:57.339Z" title="发表于 2025-02-16 05:36:57">2025-02-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/3ca9bef3" title="SpringBoot预览PDF文件"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/001.webp" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="SpringBoot预览PDF文件"/></a><div class="content"><a class="title" href="/p/3ca9bef3" title="SpringBoot预览PDF文件">SpringBoot预览PDF文件</a><time datetime="2025-02-07T10:19:00.000Z" title="发表于 2025-02-07 10:19:00">2025-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/9b5fc26a" title="Debain12配置"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/013.webp" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Debain12配置"/></a><div class="content"><a class="title" href="/p/9b5fc26a" title="Debain12配置">Debain12配置</a><time datetime="2025-02-06T16:07:00.000Z" title="发表于 2025-02-06 16:07:00">2025-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/42bd8820" title="Docker安装脚本与换源"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/009.webp" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Docker安装脚本与换源"/></a><div class="content"><a class="title" href="/p/42bd8820" title="Docker安装脚本与换源">Docker安装脚本与换源</a><time datetime="2025-02-05T16:00:00.000Z" title="发表于 2025-02-05 16:00:00">2025-02-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/c3561f90" title="Nvm包管理器"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/007.webp" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Nvm包管理器"/></a><div class="content"><a class="title" href="/p/c3561f90" title="Nvm包管理器">Nvm包管理器</a><time datetime="2025-01-22T16:00:55.000Z" title="发表于 2025-01-22 16:00:55">2025-01-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 凉月</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.3.2"></script><script src="/js/main.js?v=5.3.2"></script><script src="https://unpkg.com/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://waline-fulsun.netlify.app/.netlify/functions/comment',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://unpkg.com/@waline/client@3.4.3/dist/waline.css')
        .then(() => import('https://unpkg.com/@waline/client@3.4.3/dist/waline.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://unpkg.com/butterfly-extsrc@1.1.4/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>