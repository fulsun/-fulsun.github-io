<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Vue3入门 | 凉月の博客</title><meta name="author" content="凉月"><meta name="copyright" content="凉月"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Vue3入门">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue3入门">
<meta property="og:url" content="https://fulsun.github.io/p/e930893f">
<meta property="og:site_name" content="凉月の博客">
<meta property="og:description" content="Vue3入门">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fulsun.github.io/medias/featureimages/010.webp">
<meta property="article:published_time" content="2025-01-19T09:48:22.000Z">
<meta property="article:modified_time" content="2025-02-16T05:36:57.336Z">
<meta property="article:author" content="凉月">
<meta property="article:tag" content="Vue3">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fulsun.github.io/medias/featureimages/010.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Vue3入门",
  "url": "https://fulsun.github.io/p/e930893f",
  "image": "https://fulsun.github.io/medias/featureimages/010.webp",
  "datePublished": "2025-01-19T09:48:22.000Z",
  "dateModified": "2025-02-16T05:36:57.336Z",
  "author": [
    {
      "@type": "Person",
      "name": "凉月",
      "url": "https://fulsun.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/medias/favicon.png"><link rel="canonical" href="https://fulsun.github.io/p/e930893f"><link rel="preconnect" href="//unpkg.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.3.2"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')
          
          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 凉月","link":"链接: ","source":"来源: 凉月の博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Vue3入门',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: linear-gradient(90deg, rgba(247, 149, 51, .1), rgba(243, 112, 85, .1) 15%, rgba(239, 78, 123, .1) 30%, rgba(161, 102, 171, .1) 44%, rgba(80, 115, 184, .1) 58%, rgba(16, 152, 173, .1) 72%, rgba(7, 179, 155, .1) 86%, rgba(109, 186, 130, .1));"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/avatar.jpg" onerror="this.onerror=null;this.src='/medias/detail/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heartbeat"></i><span> 我的</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> 联系</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 博主</span></a></li><li><a class="site-page child" href="/contact"><i class="fa-fw fas fa-comments"></i><span> 留言</span></a></li><li><a class="site-page child" href="/journal"><i class="fa-fw fas fa-cogs"></i><span> 日志</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> JS动画</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/snake/"><i class="fa-fw fas fa-gamepad"></i><span> 贪吃蛇</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/medias/featureimages/010.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">凉月の博客</span></a><a class="nav-page-title" href="/"><span class="site-name">Vue3入门</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heartbeat"></i><span> 我的</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> 联系</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 博主</span></a></li><li><a class="site-page child" href="/contact"><i class="fa-fw fas fa-comments"></i><span> 留言</span></a></li><li><a class="site-page child" href="/journal"><i class="fa-fw fas fa-cogs"></i><span> 日志</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> JS动画</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/snake/"><i class="fa-fw fas fa-gamepad"></i><span> 贪吃蛇</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Vue3入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-19T09:48:22.000Z" title="发表于 2025-01-19 09:48:22">2025-01-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-16T05:36:57.336Z" title="更新于 2025-02-16 05:36:57">2025-02-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Vue/">Vue</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">29.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>112分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:500,&quot;messagePrev&quot;:&quot;至上次更新后的&quot;,&quot;messageNext&quot;:&quot;天,文章内容可能已过时。&quot;,&quot;postUpdate&quot;:&quot;2025-02-16 05:36:57&quot;}" hidden></div><span id="more"></span>

<h2 id="全新的-Vue-版本"><a href="#全新的-Vue-版本" class="headerlink" title="全新的 Vue 版本"></a>全新的 Vue 版本</h2><p>在 2022 年 2 月 7 日， Vue 3 代替了 Vue 2 成为 Vue 的默认版本，也就是运行 <code>npm i vue</code> 默认会安装 Vue 3 了，无需再和以前一样，需要指定 <code>vue@next</code> 才可以安装到 Vue 3 。包括 <code>vue-router</code> 、 <code>vuex</code> 、<code>vue-loader</code> 和 <code>@vue/test-utils</code> 等相关的生态，同样不需要指定 next 版本了，都配合 Vue 3 指定了新的 latest 默认版本。</p>
<h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p>只罗列 Vue 3.0 相关的官网，有中文版的优先都放中文版。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">官网文档</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Vue 3</td>
<td align="center"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://cn.vuejs.org/">点击访问</a></td>
</tr>
<tr>
<td align="center">Vue Composition API</td>
<td align="center"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://cn.vuejs.org/guide/extras/composition-api-faq.html">点击访问</a></td>
</tr>
<tr>
<td align="center">Vue Router</td>
<td align="center"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://router.vuejs.org/zh/">点击访问</a></td>
</tr>
<tr>
<td align="center">Vuex</td>
<td align="center"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://vuex.vuejs.org/zh/">点击访问</a></td>
</tr>
<tr>
<td align="center">Pinia</td>
<td align="center"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://pinia.vuejs.org/">点击访问</a></td>
</tr>
<tr>
<td align="center">Vue CLI</td>
<td align="center"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://cli.vuejs.org/zh/">点击访问</a></td>
</tr>
<tr>
<td align="center">Vite</td>
<td align="center"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://cn.vitejs.dev/">点击访问</a></td>
</tr>
</tbody></table>
<h3 id="使用-Vue-2"><a href="#使用-Vue-2" class="headerlink" title="使用 Vue 2"></a>使用 Vue 2</h3><p>如果还需要使用 Vue 2 ，则在安装的时候需要手动指定 Tag 为 <code>legacy</code> 或者 <code>v2-latest</code> 才能安装到 Vue 2 ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 2.6.x 的最新版本</span></span><br><span class="line">npm i vue@legacy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 2.7.x 的最新版本</span></span><br><span class="line">npm i vue@v2-latest</span><br></pre></td></tr></table></figure>

<p>注意到 Vue 2 配对了两个不同的 Tag ，分别对应 2.7 系列和 2.6 系列。</p>
<ul>
<li><p>Vue 2.7 系列是在 Vue 2 的基础上，对标 Vue 3 的功能支持所作的升级，主要是面向想使用 Vue 3 的新特性、但顾虑于产品对旧浏览器的支持而无法贸然升级的开发者。</p>
</li>
<li><p>Vue 2.7 与 Vue 2.6 之前的旧版本在使用上略有不同，具体可以查看 Vue 2 的 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/vuejs/vue/blob/main/CHANGELOG.md">更新记录</a> 了解具体的差异化。</p>
</li>
</ul>
<h2 id="使用-Vite-创建项目"><a href="#使用-Vite-创建项目" class="headerlink" title="使用 Vite 创建项目"></a>使用 Vite 创建项目</h2><p>Vite 是由 Vue 作者尤雨溪先生带领团队开发的一个构建工具，它利用浏览器原生支持 ES 模块的特点，极大提升了开发体验，自 2021 年 1 月份发布 2.0 版本以来，发展非常快,整体情况非常稳定，前景非常乐观。</p>
<h3 id="Create-Vite"><a href="#Create-Vite" class="headerlink" title="Create Vite"></a>Create Vite</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/vitejs/vite/tree/main/packages/create-vite">create-vite</a> 是 Vite 官方推荐的一个脚手架工具，可以创建基于 Vite 的不同技术栈基础模板。</p>
<p>运行以下命令创建模板项目，再按照命令行的提示操作（选择 <code>vue</code> 技术栈进入），即可创建一个基于 Vite 的基础空项目。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vite</span><br></pre></td></tr></table></figure>

<p>不过这个方式创建的项目非常基础，如果需要用到 Router 、 Vuex 、 ESLint 等程序，都需要再单独安装和配置，所以推荐使用 <strong>Create Preset</strong> 。</p>
<h3 id="Create-Vue"><a href="#Create-Vue" class="headerlink" title="Create Vue"></a>Create Vue</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/vuejs/create-vue">create-vue</a> 是 Vue 官方推出的一个新脚手架，用以代替基于 Webpack 的 Vue CLI ，它可以创建基于 Vite 的 Vue 基础模板。</p>
<p>运行以下命令创建模板项目，然后根据命令行的提示操作即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init vue@3</span><br></pre></td></tr></table></figure>

<h3 id="Create-Preset"><a href="#Create-Preset" class="headerlink" title="Create Preset"></a>Create Preset</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/awesome-starter/create-preset">create-preset</a> 是 Awesome Starter 的 CLI 脚手架，提供快速创建预设项目的能力，可以创建一些有趣实用的项目启动模板，也可以用来管理的常用项目配置。</p>
<ul>
<li><p><strong>简单使用</strong>: 可以通过包管理器直接创建配置，然后按照命令行的提示操作，即可创建开箱即用的模板项目。</p>
<ul>
<li>在这里选择 <code>vue</code> 技术栈进入，选择 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/awesome-starter/vue3-ts-vite-starter">vue3-ts-vite</a> 创建一个基于 Vite + Vue 3 + TypeScript 的项目启动模板。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create preset</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>全局安装</strong></p>
<ul>
<li><p>也可以像使用 <code>@vue/cli</code> 一样，全局安装到本地，通过 <code>preset init</code> 命令来创建项目。<strong>推荐全局安装它，用起来更方便</strong>，请先全局安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-preset</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以通过下面这个命令来检查安装是否成功，如果成功，将会得到一个版本号：</span></span><br><span class="line">preset -v</span><br><span class="line">0.13.1</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后可以通过 <code>--template</code> 选项直接指定一个模板创建项目，在这里使用 <code>vue3-ts-vite</code> 模板创建一个名为 <code>hello-vue3</code> 的项目：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preset init hello-vue3 --template vue3-ts-vite</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>常用的项目模板也可以绑定为本地配置，点击 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://preset.js.org/zh/">Create Preset 官方文档</a> 查看完整使用教程。</p>
</li>
</ul>
<h3 id="管理项目配置"><a href="#管理项目配置" class="headerlink" title="管理项目配置"></a>管理项目配置</h3><p>不论使用上方哪种方式创建项目，在项目的根目录下都会有一个名为 <code>vite.config.js</code> 或 <code>vite.config.ts</code> 的项目配置文件（其扩展名由项目使用 JavaScript 还是 TypeScript 决定）。</p>
<p>里面会有一些预设好的配置，可以在 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://cn.vitejs.dev/config/">Vite 官网的配置文档</a> 查阅更多的可配置选项。</p>
<h2 id="使用-vue-cli-创建项目"><a href="#使用-vue-cli-创建项目" class="headerlink" title="使用 @vue&#x2F;cli 创建项目"></a>使用 @vue&#x2F;cli 创建项目</h2><p>如果不习惯 Vite ，依然可以使用 Vue CLI 作为开发脚手架,Vue CLI 使用的构建工具是基于 Webpack 。</p>
<h3 id="更新-CLI-脚手架"><a href="#更新-CLI-脚手架" class="headerlink" title="更新 CLI 脚手架"></a>更新 CLI 脚手架</h3><p>请先全局安装，把脚手架更新到最新版本（最低版本要求在 <code>4.5.6</code> 以上才能支持 Vue 3 项目的创建）。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure>

<h3 id="使用-CLI-创建-3-x-项目"><a href="#使用-CLI-创建-3-x-项目" class="headerlink" title="使用 CLI 创建 3.x 项目"></a>使用 CLI 创建 3.x 项目</h3><p>Vue CLI 全局安装后，可以在命令行输入 <code>vue</code> 进行操作，创建项目使用的是 <code>create</code> 命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create hello-vue3</span><br></pre></td></tr></table></figure>

<p>由于要使用 TypeScript ，所以需要选择最后一个选项来进行自定义搭配，通过键盘的上下箭头进行切换选择：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue CLI v5.0.4</span><br><span class="line">? Please pick a preset:</span><br><span class="line">  Default ([Vue 3] babel, eslint)</span><br><span class="line">  Default ([Vue 2] babel, eslint)</span><br><span class="line">&gt; Manually <span class="keyword">select</span> features</span><br></pre></td></tr></table></figure>

<p>多选菜单可以按空格选中需要的依赖，总共选择了下面这些选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue CLI v5.0.4</span><br><span class="line">? Please pick a preset: Manually <span class="keyword">select</span> features</span><br><span class="line">? Check the features needed <span class="keyword">for</span> your project: (Press &lt;space&gt; to <span class="keyword">select</span>,</span><br><span class="line">&lt;a&gt; to toggle all, &lt;i&gt; to invert selection, and &lt;enter&gt; to proceed)</span><br><span class="line"> (*) Babel</span><br><span class="line"> (*) TypeScript</span><br><span class="line"> ( ) Progressive Web App (PWA) Support</span><br><span class="line"> (*) Router</span><br><span class="line"> (*) Vuex</span><br><span class="line"> (*) CSS Pre-processors</span><br><span class="line">&gt;(*) Linter / Formatter</span><br><span class="line"> ( ) Unit Testing</span><br><span class="line"> ( ) E2E Testing</span><br></pre></td></tr></table></figure>

<p>选择 Vue 版本，要用 Vue 3 所以需要选择 3.x ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">? Choose a version of Vue.js that you want to start the project with</span><br><span class="line">  (Use arrow keys)</span><br><span class="line">&gt; 3.x</span><br><span class="line">  2.x</span><br></pre></td></tr></table></figure>

<p>是否选择 Class 语法的模板，在 Vue 2 版本为了更好的支持 TypeScript ，通常需要使用 Class 语法，由于 Vue 3 有了对 TypeScript 支持度更高的 Composition API ，因此选择 <code>n</code> ，也就是 “否” ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? Use class-style component syntax? (y/N) n</span><br></pre></td></tr></table></figure>

<p>Babel 可以把新版本的 JavaScript 语句转换为兼容性更好的低版本 Polyfill 写法，所以选 <code>y</code> 确认使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? Use Babel alongside TypeScript</span><br><span class="line">  (required <span class="keyword">for</span> modern mode, auto-detected polyfills, transpiling JSX)?</span><br><span class="line">  (Y/n) y</span><br></pre></td></tr></table></figure>

<p>接下来是选择路由模式，选 <code>y</code> 启用 History 模式，选 <code>n</code> 使用 Hash 模式，可根据项目情况选择。建议先选 <code>y</code> 确认。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? Use <span class="built_in">history</span> mode <span class="keyword">for</span> router?</span><br><span class="line">  (Requires proper server setup <span class="keyword">for</span> index fallback <span class="keyword">in</span> production)</span><br><span class="line">  (Y/n) y</span><br></pre></td></tr></table></figure>

<p>选择一个 CSS 预处理器，可以根据自己的喜好选择，不过鉴于目前开源社区组件常用的都是 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/less/less.js">Less</a> ，所以也建议选择 Less 作为入门的预处理器工具。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported</span><br><span class="line"> by default):</span><br><span class="line">  Sass/SCSS (with dart-sass)</span><br><span class="line">&gt; Less</span><br><span class="line">  Stylus</span><br></pre></td></tr></table></figure>

<p>Lint 规则，用来代码检查，写 TypeScript 离不开 Lint ，可以根据自己喜好选择，也可以先选择默认，这里先默认第一个：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? Pick a linter / formatter config: (Use arrow keys)</span><br><span class="line">&gt; ESLint with error prevention only</span><br><span class="line">  ESLint + Airbnb config</span><br><span class="line">  ESLint + Standard config</span><br><span class="line">  ESLint + Prettier</span><br></pre></td></tr></table></figure>

<p>Lint 的校验时机，一个是在保存时校验，一个是在提交 commit 的时候才校验，这里也选默认：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">? Pick additional lint features: (Press &lt;space&gt; to <span class="keyword">select</span>,</span><br><span class="line"> &lt;a&gt; to toggle all, &lt;i&gt; to invert selection, and &lt;enter&gt; to proceed)</span><br><span class="line">&gt;(*) Lint on save</span><br><span class="line"> ( ) Lint and fix on commit</span><br></pre></td></tr></table></figure>

<p>项目配置文件，笔者更习惯保存为独立文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">? Where <span class="keyword">do</span> you prefer placing config <span class="keyword">for</span> Babel, ESLint, etc.?</span><br><span class="line">  (Use arrow keys)</span><br><span class="line">&gt; In dedicated config files</span><br><span class="line">  In package.json</span><br></pre></td></tr></table></figure>

<p>是否保存为未来的项目配置，存起来方便以后快速创建：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? Save this as a preset <span class="keyword">for</span> future projects? Yes</span><br><span class="line">? Save preset as: vue-3-ts-config</span><br></pre></td></tr></table></figure>

<p>至此，项目创建完成！可以通过 <code>npm run serve</code> 开启热更进行开发调试，通过 <code>npm run build</code> 构建打包上线。</p>
<h3 id="管理项目配置-1"><a href="#管理项目配置-1" class="headerlink" title="管理项目配置"></a>管理项目配置</h3><p>Vue CLI 的配置文件是 <code>vue.config.js</code> ，可以参考官网的说明文档调整各个选项配置：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://cli.vuejs.org/zh/config/">配置参考 - Vue CLI</a> 。</p>
<h2 id="Hello-Vue3"><a href="#Hello-Vue3" class="headerlink" title="Hello Vue3"></a>Hello Vue3</h2><p>如果想早点开始 Vue 3 的世界，可以通过以下命令直接创建一个启动项目：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 `vue3-ts-vite` 模板创建一个名为 `hello-vue3` 的项目</span></span><br><span class="line">preset init hello-vue3 --template vue3-ts-vite</span><br><span class="line"></span><br><span class="line">npm install </span><br></pre></td></tr></table></figure>

<p>至此，通过脚手架已经搭好了一个可直接运行的基础项目，已经可以正常的 <code>npm run dev</code> 和 <code>npm run build</code> 了，项目配置和编辑器也都弄好了，是不是可以开始写代码了呢？</p>
<p>请不要着急，还需要了解一点东西，就是如何初始化一个 Vue 3 项目。</p>
<p>因为在实际开发过程中，还会用到各种 npm 包，像很多 UI 框架、功能插件的引入都是需要在 Vue 初始化阶段处理。</p>
<p>甚至有时候还要脱离脚手架，采用 CDN 引入的方式来开发，所以开始写组件之前，还需要了解一下在 Vue 3 项目中，初始化阶段对比 Vue 2 的一些变化。</p>
<h3 id="回顾-Vue-2-vue-2"><a href="#回顾-Vue-2-vue-2" class="headerlink" title="回顾 Vue 2-vue-2"></a>回顾 Vue 2-vue-2</h3><p>Vue 2 在导入各种依赖之后，通过 <code>new Vue()</code> 执行 Vue 的初始化，相关的 Vue 生态和插件，有的是使用 <code>Vue.use()</code> 来进行初始化，有的是作为 <code>new Vue()</code> 的入参：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> pluginA <span class="keyword">from</span> <span class="string">&#x27;pluginA&#x27;</span></span><br><span class="line"><span class="keyword">import</span> pluginB <span class="keyword">from</span> <span class="string">&#x27;pluginB&#x27;</span></span><br><span class="line"><span class="keyword">import</span> pluginC <span class="keyword">from</span> <span class="string">&#x27;pluginC&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用了 `use` 方法激活</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(pluginA)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(pluginB)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(pluginC)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为 `new Vue()` 的入参激活</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">render</span>: <span class="function">(<span class="params">h</span>) =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><p>项目的初始化都是在入口文件集中处理，Vue 3 的目录结构对比 Vue 2 没有变化，入口文件依然还是 main.ts 这个文件。但是 Vue 3 在初始化的时候，做了不少的调整，代码写法和 Vue 2 完全不同。因为统一了相关生态的启用方式，不再像 Vue 2 时期那样多方式共存，显得比较杂乱。</p>
<p>在 Vue 3 ，使用 <code>createApp</code> 执行 Vue 的初始化，另外不管是 Vue 生态里的东西，还是外部插件、 UI 框架，统一都是由 <code>use()</code> 进行激活，非常统一和简洁：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> pluginA <span class="keyword">from</span> <span class="string">&#x27;pluginA&#x27;</span></span><br><span class="line"><span class="keyword">import</span> pluginB <span class="keyword">from</span> <span class="string">&#x27;pluginB&#x27;</span></span><br><span class="line"><span class="keyword">import</span> pluginC <span class="keyword">from</span> <span class="string">&#x27;pluginC&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">  .<span class="title function_">use</span>(store)</span><br><span class="line">  .<span class="title function_">use</span>(router)</span><br><span class="line">  .<span class="title function_">use</span>(pluginA)</span><br><span class="line">  .<span class="title function_">use</span>(pluginB)</span><br><span class="line">  .<span class="title function_">use</span>(pluginC)</span><br><span class="line">  .<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="全新的-setup-函数"><a href="#全新的-setup-函数" class="headerlink" title="全新的 setup 函数"></a>全新的 setup 函数</h2><p>在开始编写 Vue 组件之前，需要了解两个全新的前置知识点：</p>
<ul>
<li>全新的 <code>setup</code> 函数，关系到组件的生命周期和渲染等问题</li>
<li>写 TypeScript 组件离不开的 <code>defineComponent</code> API</li>
</ul>
<h3 id="setup-的含义"><a href="#setup-的含义" class="headerlink" title="setup 的含义"></a>setup 的含义</h3><p>Vue 3 的 Composition API 系列里，推出了一个全新的 <code>setup</code> 函数，它是一个组件选项，在创建组件之前执行，一旦 props 被解析，便作为组合式 API 的入口点。</p>
<blockquote>
<p>说的通俗一点，就是在使用 Vue 3 生命周期的情况下，整个组件相关的业务代码，都可以放在 <code>setup</code> 里执行。因为在 <code>setup</code> 之后，其他的生命周期才会被启用。</p>
</blockquote>
<p>基本语法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个基于 TypeScript 的 Vue 组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">    <span class="comment">// 在这里声明数据，或者编写函数并在这里执行它</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 需要给 `&lt;template /&gt;` 用的数据或函数，在这里 `return` 出去</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以发现在这段代码里还导入了一个 <code>defineComponent</code> API ，也是 Vue 3 带来的新功能，下文的 defineComponent 的作用将介绍其用法。</p>
<p><strong>在使用 <code>setup</code> 的情况下，请牢记一点：不能再用 <code>this</code> 来获取 Vue 实例，也就是无法和 Vue 2 一样，通过 <code>this.foo</code> 、 <code>this.bar()</code> 这样来获取实例上的数据，或者执行实例上的方法。</strong></p>
<h3 id="setup-的参数使用"><a href="#setup-的参数使用" class="headerlink" title="setup 的参数使用"></a>setup 的参数使用</h3><p><code>setup</code> 函数包含了两个入参：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">类型</th>
<th align="left">含义</th>
<th align="left">是否必传</th>
</tr>
</thead>
<tbody><tr>
<td align="left">props</td>
<td align="left">object</td>
<td align="left">由父组件传递下来的数据</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">context</td>
<td align="left">object</td>
<td align="left">组件的执行上下文</td>
<td align="left">否</td>
</tr>
</tbody></table>
<ul>
<li><strong>第一个参数 <code>props</code> ：</strong><ul>
<li>它是响应式的，当父组件传入新的数据时，它将被更新。</li>
</ul>
</li>
</ul>
<blockquote>
<p>请不要解构它，这样会让数据失去响应性，一旦父组件发生数据变化，解构后的变量将无法同步更新为最新的值。</p>
<p>可以使用 Vue 3 全新的响应式 API <code>toRef / toRefs</code>进行响应式数据转换，下文将会介绍全新的响应式 API 的用法。</p>
</blockquote>
<ul>
<li><p><strong>第二个参数 <code>context</code> ：</strong></p>
<ul>
<li><p><code>context</code> 只是一个普通的对象，它暴露三个组件的 Property ：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">类型</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">attrs</td>
<td align="left">非响应式对象</td>
<td align="left">未在 Props 里定义的属性都将变成 Attrs</td>
</tr>
<tr>
<td align="left">slots</td>
<td align="left">非响应式对象</td>
<td align="left">组件插槽，用于接收父组件传递进来的模板内容</td>
</tr>
<tr>
<td align="left">emit</td>
<td align="left">方法</td>
<td align="left">触发父组件绑定下来的事件</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>因为 <code>context</code> 只是一个普通对象，所以可以直接使用 ES6 解构。</p>
<ul>
<li>平时使用可以通过直接传入 <code>&#123; emit &#125;</code> ，即可用 <code>emit(&#39;xxx&#39;)</code> 来代替使用 <code>context.emit(&#39;xxx&#39;)</code>，另外两个功能也是如此。</li>
<li>但是 <code>attrs</code> 和 <code>slots</code> 请保持 <code>attrs.xxx</code>、<code>slots.xxx</code> 的方式来使用其数据，不要进行解构，虽然这两个属性不是响应式对象，但对应的数据会随组件本身的更新而更新。</li>
</ul>
</li>
</ul>
<h3 id="defineComponent-的作用"><a href="#defineComponent-的作用" class="headerlink" title="defineComponent 的作用"></a>defineComponent 的作用</h3><p><code>defineComponent</code> 是 Vue 3 推出的一个全新 API ，可用于对 TypeScript 代码的类型推导，帮助开发者简化掉很多编码过程中的类型声明。</p>
<p>比如，原本需要这样才可以使用 <code>setup</code> 函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Slots</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 `props` 和 `return` 的数据类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">unknown</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 `context` 的类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SetupContext</span> &#123;</span><br><span class="line">  <span class="attr">attrs</span>: <span class="title class_">Data</span></span><br><span class="line">  <span class="attr">slots</span>: <span class="title class_">Slots</span></span><br><span class="line">  <span class="attr">emit</span>: <span class="function">(<span class="params"><span class="attr">event</span>: <span class="built_in">string</span>, ...<span class="attr">args</span>: <span class="built_in">unknown</span>[]</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用的时候入参要加上声明， `return` 也要加上声明</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="attr">props</span>: <span class="title class_">Data</span>, <span class="attr">context</span>: <span class="title class_">SetupContext</span>): <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>每个组件都这样进行类型声明，会非常繁琐，如果使用了 <code>defineComponent</code> ，就可以省略这些类型声明：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 `defineComponent` 包裹组件的内部逻辑</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>代码量瞬间大幅度减少，只要是 Vue 本身的 API ， <code>defineComponent</code> 都可以自动推导其类型，这样开发者在编写组件的过程中，只需要维护自己定义的数据类型就可以了，可专注于业务。</p>
<h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>在了解了 Vue 3 组件的两个前置知识点后，不着急写组件，还需要先了解组件的生命周期，这个知识点非常重要，只有理解并记住组件的生命周期，才能够灵活地把控好每一处代码的执行，使程序的运行结果可以达到预期。</p>
<h3 id="升级变化"><a href="#升级变化" class="headerlink" title="升级变化"></a>升级变化</h3><p>从 Vue 2 升级到 Vue 3 ，在保留对 Vue 2 的生命周期支持的同时，Vue 3 也带来了一定的调整。</p>
<p>Vue 2 的生命周期写法名称是 Options API （选项式 API ）， Vue 3 新的生命周期写法名称是 Composition API （组合式 API ）。</p>
<p>Vue 3 组件默认支持 Options API ，而 Vue 2 可以通过 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.npmjs.com/package/@vue/composition-api">@vue&#x2F;composition-api</a> 插件获得 Composition API 的功能支持（其中 Vue 2.7 版本内置了该插件， 2.6 及以下的版本需要单独安装）。</p>
<p>为了减少理解成本，笔者将从读者的使用习惯上，使用 “ Vue 2 的生命周期” 代指 Options API 写法，用 “ Vue 3 的生命周期” 代指 Composition API 写法。</p>
<p>关于 Vue 生命周期的变化，可以从下表直观地了解：</p>
<table>
<thead>
<tr>
<th align="center">Vue 2 生命周期</th>
<th align="center">Vue 3 生命周期</th>
<th align="center">执行时间说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">beforeCreate</td>
<td align="center">setup</td>
<td align="center">组件创建前执行</td>
</tr>
<tr>
<td align="center">created</td>
<td align="center">setup</td>
<td align="center">组件创建后执行</td>
</tr>
<tr>
<td align="center">beforeMount</td>
<td align="center">onBeforeMount</td>
<td align="center">组件挂载到节点上之前执行</td>
</tr>
<tr>
<td align="center">mounted</td>
<td align="center">onMounted</td>
<td align="center">组件挂载完成后执行</td>
</tr>
<tr>
<td align="center">beforeUpdate</td>
<td align="center">onBeforeUpdate</td>
<td align="center">组件更新之前执行</td>
</tr>
<tr>
<td align="center">updated</td>
<td align="center">onUpdated</td>
<td align="center">组件更新完成之后执行</td>
</tr>
<tr>
<td align="center">beforeDestroy</td>
<td align="center">onBeforeUnmount</td>
<td align="center">组件卸载之前执行</td>
</tr>
<tr>
<td align="center">destroyed</td>
<td align="center">onUnmounted</td>
<td align="center">组件卸载完成后执行</td>
</tr>
<tr>
<td align="center">errorCaptured</td>
<td align="center">onErrorCaptured</td>
<td align="center">当捕获一个来自子孙组件的异常时激活钩子函数</td>
</tr>
</tbody></table>
<p>可以看到 Vue 2 生命周期里的 <code>beforeCreate</code> 和 <code>created</code> ，在 Vue 3 里已被 <code>setup</code> 替代。</p>
<p>熟悉 Vue 2 的开发者应该都知道 Vue 有一个全局组件 <code>&lt;KeepAlive /&gt;</code> ，用于在多个组件间动态切换时缓存被移除的组件实例，当组件被包含在 <code>&lt;KeepAlive /&gt;</code> 组件里时，会多出两个生命周期钩子函数：</p>
<table>
<thead>
<tr>
<th align="center">Vue 2 生命周期</th>
<th align="center">Vue 3 生命周期</th>
<th align="center">执行时间说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">activated</td>
<td align="center">onActivated</td>
<td align="center">被激活时执行</td>
</tr>
<tr>
<td align="center">deactivated</td>
<td align="center">onDeactivated</td>
<td align="center">切换组件后，原组件消失前执行</td>
</tr>
</tbody></table>
<blockquote>
<p>虽然 Vue 3 依然支持 Vue 2 的生命周期，但是不建议混搭使用，前期可以继续使用 Vue 2 的生命周期作为过渡阶段慢慢适应，但还是建议尽快熟悉并完全使用 Vue 3 的生命周期编写组件。</p>
</blockquote>
<h3 id="使用-3-x-的生命周期"><a href="#使用-3-x-的生命周期" class="headerlink" title="使用 3.x 的生命周期"></a>使用 3.x 的生命周期</h3><p>在 Vue 3 的 Composition API 写法里，<strong>每个生命周期函数都要先导入才可以使用</strong>，并且所有生命周期函数统一放在 <code>setup</code> 里运行。</p>
<p>如果需要达到 Vue 2 的 <code>beforeCreate</code> 和 <code>created</code> 生命周期的执行时机，直接在 <code>setup</code> 里执行函数即可。</p>
<p>以下是几个生命周期的执行顺序对比：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, onBeforeMount, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onBeforeMount</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最终将按照生命周期的顺序输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">// 4</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure>

<h2 id="组件的基本写法"><a href="#组件的基本写法" class="headerlink" title="组件的基本写法"></a>组件的基本写法</h2><p>如果想在 Vue 2 里使用 TypeScript 编写组件，需要通过 Options API 的 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://v2.cn.vuejs.org/v2/api/#Vue-extend">Vue.extend</a> 语法，或者是另外一种风格 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://class-component.vuejs.org/">Class Component</a> 的语法声明组件，其中为了更好地进行类型推导， Class Component 语法更受开发者欢迎。</p>
<p>但是 Class Component 语法和默认的组件语法相差较大，带来了一定的学习成本，对于平时编写 JavaScript 代码很少使用 Class 的开发者，适应时间应该也会比较长。</p>
<p>因此 Vue 3 在保留对 Class Component 支持的同时，推出了全新的 Function-based Component ，更贴合 JavaScript 的函数式编程风格，这也是接下来要讲解并贯穿全文使用的 Composition API 新写法。</p>
<p>Composition API 虽然也是一个步伐迈得比较大的改动，但其组件结构并没有特别大的变化，区别比较大的地方在于组件生命周期和响应式 API 的使用，只要掌握了这些核心功能，上手 Vue 3 非常容易！</p>
<h3 id="回顾-Vue-2"><a href="#回顾-Vue-2" class="headerlink" title="回顾 Vue 2"></a>回顾 Vue 2</h3><p>在 Vue 2 ，常用以下三种写法声明 TypeScript 组件：可在 Vue 2 官网的 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://v2.cn.vuejs.org/v2/guide/typescript.html">TypeScript 支持</a> 一章了解更多配置说明。</p>
<table>
<thead>
<tr>
<th align="center">适用版本</th>
<th align="center">基本写法</th>
<th align="center">视图写法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Vue 2</td>
<td align="center">Vue.extend</td>
<td align="center">Template</td>
</tr>
<tr>
<td align="center">Vue 2</td>
<td align="center">Class Component</td>
<td align="center">Template</td>
</tr>
<tr>
<td align="center">Vue 2</td>
<td align="center">Class Component</td>
<td align="center">TSX</td>
</tr>
</tbody></table>
<blockquote>
<p>使用 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://v2.cn.vuejs.org/v2/api/#Vue-extend">Vue.extend</a> API 声明组件：</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一段摘选自 Vue 2 官网的代码演示</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐使用 Vue.extend 声明组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Component</span> = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(&#123;</span><br><span class="line">  <span class="comment">// 类型推断已启用</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐这种方式声明</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Component</span> = &#123;</span><br><span class="line">  <span class="comment">// 这里不会有类型推断，</span></span><br><span class="line">  <span class="comment">// 因为 TypeScript 不能确认这是 Vue 组件的选项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为了更好地获得 TypeScript 类型推导支持， 使用 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://class-component.vuejs.org/">Class Component</a> 的写法，这是 Vue 官方推出的一个装饰器插件（需要单独安装）：</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一段摘选自 Vue 2 官网的代码演示</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Component</span> <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @Component 修饰符注明了此类为一个 Vue 组件</span></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="comment">// 所有的组件选项都可以放在这里</span></span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;button @click=&quot;onClick&quot;&gt;Click!&lt;/button&gt;&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Class 声明一个组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  <span class="comment">// 初始数据可以直接声明为实例的 property</span></span><br><span class="line">  <span class="attr">message</span>: <span class="built_in">string</span> = <span class="string">&#x27;Hello!&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件方法也可以直接声明为实例的方法</span></span><br><span class="line">  <span class="title function_">onClick</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">message</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="了解-Vue-3"><a href="#了解-Vue-3" class="headerlink" title="了解 Vue 3"></a>了解 Vue 3</h3><p>Vue 3 从设计初期就考虑了 TypeScript 的支持，其中 <code>defineComponent</code> 这个 API 就是为了解决 Vue 2 对 TypeScript 类型推导不完善等问题而推出的。</p>
<p>在 Vue 3 ，至少有以下六种写法可以声明 TypeScript 组件：</p>
<table>
<thead>
<tr>
<th align="center">适用版本</th>
<th align="center">基本写法</th>
<th align="center">视图写法</th>
<th align="center">生命周期版本</th>
<th align="center">官方是否推荐</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Vue 3</td>
<td align="center">Class Component</td>
<td align="center">Template</td>
<td align="center">Vue 2</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">Vue 3</td>
<td align="center">defineComponent</td>
<td align="center">Template</td>
<td align="center">Vue 2</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">Vue 3</td>
<td align="center">defineComponent</td>
<td align="center">Template</td>
<td align="center">Vue 3</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">Vue 3</td>
<td align="center">Class Component</td>
<td align="center">TSX</td>
<td align="center">Vue 2</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">Vue 3</td>
<td align="center">defineComponent</td>
<td align="center">TSX</td>
<td align="center">Vue 2</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">Vue 3</td>
<td align="center">defineComponent</td>
<td align="center">TSX</td>
<td align="center">Vue 3</td>
<td align="center">√</td>
</tr>
</tbody></table>
<blockquote>
<p>其中 <code>defineComponent + Composition API + Template</code> 的组合是 Vue 官方最为推荐的组件声明方式，接下来的内容都会以这种写法作为示范案例，也推荐开发者在学习的过程中，使用该组合进行入门。</p>
</blockquote>
<h3 id="编写Hello-World-组件"><a href="#编写Hello-World-组件" class="headerlink" title="编写Hello World 组件"></a>编写Hello World 组件</h3><p>使用 Composition API 编写一个最简单的 Hello World 组件：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- <span class="title class_">Template</span> 代码和 <span class="title class_">Vue</span> <span class="number">2</span> 一样 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;msg&quot;</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="title class_">Script</span> 代码需要使用 <span class="title class_">Vue</span> <span class="number">3</span> 的新写法--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// Vue 3 的 API 需要导入才能使用</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 使用 `defineComponent` 包裹组件代码</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 即可获得完善的 TypeScript 类型推导支持</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 在 `setup` 方法里声明变量</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> msg = <span class="string">&#x27;Hello World!&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 将需要在 `&lt;template /&gt;` 里使用的变量 `return` 出去</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      msg,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="variable constant_">CSS</span> 代码和 <span class="title class_">Vue</span> <span class="number">2</span> 一样 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.msg</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到 Vue 3 的组件也是 <code>&lt;template /&gt;</code> + <code>&lt;script /&gt;</code> + <code>&lt;style /&gt;</code> 的三段式组合，上手非常简单。</p>
<p>其中 Template 沿用了 Vue 2 时期类似 HTML 风格的模板写法， Style 则是使用原生 CSS 语法或者 Less 等 CSS 预处理器编写。</p>
<p>但需要注意的是，在 Vue 3 的 Composition API 写法里，数据或函数如果需要在 <code>&lt;template /&gt;</code> 中使用，就必须在 <code>setup</code> 里将其 <code>return</code> 出去，而仅在 <code>&lt;script /&gt;</code> 里被调用的函数或变量，不需要渲染到模板则无需 <code>return</code> 。</p>
<h2 id="响应式数据的变化"><a href="#响应式数据的变化" class="headerlink" title="响应式数据的变化"></a>响应式数据的变化</h2><p>响应式数据是 MVVM 数据驱动编程的特色， Vue 的设计也是受 MVVM 模型的启发，相信大部分开发者选择 MVVM 框架都是因为数据驱动编程比传统的事件驱动编程要来得方便，而选择 Vue ，则是方便中的方便。作为最重要的一个亮点， Vue 3 的响应式数据在设计上和 Vue 2 有着很大的不同。</p>
<h3 id="回顾-Vue-2-1"><a href="#回顾-Vue-2-1" class="headerlink" title="回顾 Vue 2"></a>回顾 Vue 2</h3><p>Vue 2 是使用了 <code>Object.defineProperty</code> API 的 <code>getter/setter</code> 来实现数据的响应性，这个方法的具体用法可以参考 MDN 的文档： <a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty - MDN</a> 。</p>
<p>下面使用 <code>Object.defineProperty</code> 实现一个简单的双向绑定 demo ，亲自敲代码试一下可以有更多的理解：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>DefineProperty Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 输入框和按钮 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;vm.text = &#x27;Hello World&#x27;&quot;</span>&gt;</span>设置为 Hello World<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 输入框和按钮 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 文本展示 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;output&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 文本展示 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 声明一个响应式数据</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> vm = &#123;&#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(vm, <span class="string">&#x27;text&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">set</span>(<span class="params">value</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#input&#x27;</span>).<span class="property">value</span> = value</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#output&#x27;</span>).<span class="property">innerText</span> = value</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 处理输入行为</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#input&#x27;</span>).<span class="property">oninput</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        vm.<span class="property">text</span> = e.<span class="property">target</span>.<span class="property">value</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个小 demo 实现了这两个功能：</p>
<ol>
<li>输入框的输入行为只修改 <code>vm.text</code> 的数据，但会同时更新 output 标签的文本内容</li>
<li>点击按钮修改 <code>vm.text</code> 的数据，也会触发输入框和 output 文本的更新</li>
</ol>
<p>当然 Vue 做了非常多的工作，而非只是简单的调用了 <code>Object.defineProperty</code> ，可以在官网 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://v2.cn.vuejs.org/v2/guide/reactivity.html">深入 Vue 2 的响应式原理</a> 一章了解更多 Vue 2 的响应式原理。</p>
<h3 id="了解-Vue-3-1"><a href="#了解-Vue-3-1" class="headerlink" title="了解 Vue 3"></a>了解 Vue 3</h3><p>Vue 3 是使用了 <code>Proxy</code> API 的 <code>getter/setter</code> 来实现数据的响应性，这个方法的具体用法可以参考 MDN 的文档： <a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy - MDN</a> 。</p>
<p>同样的，也来实现一个简单的双向绑定 demo ，这次使用 <code>Proxy</code> 来实现：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Proxy Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 输入框和按钮 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;vm.text = &#x27;Hello World&#x27;&quot;</span>&gt;</span>设置为 Hello World<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 输入框和按钮 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 文本展示 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;output&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 文本展示 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 声明一个响应式数据</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span></span><br><span class="line"><span class="language-javascript">        &#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">set</span>(<span class="params">obj, key, value</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#input&#x27;</span>).<span class="property">value</span> = value</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#output&#x27;</span>).<span class="property">innerText</span> = value</span></span><br><span class="line"><span class="language-javascript">          &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      )</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 处理输入行为</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#input&#x27;</span>).<span class="property">oninput</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        vm.<span class="property">text</span> = e.<span class="property">target</span>.<span class="property">value</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个 demo 实现的功能和使用 <code>Object.defineProperty</code> 的 demo 是完全一样的，也都是基于 <code>setter</code> 的行为完成数据更新的实现，那么为什么 Vue 3 要舍弃 <code>Object.defineProperty</code> ，换成 <code>Proxy</code> 呢？</p>
<p>主要原因在于 <code>Object.defineProperty</code> 有以下的不足：</p>
<ol>
<li>无法侦听数组下标的变化，对例如 <code>arr[i] = newValue</code> 这样的操作无法实时响应</li>
<li>无法侦听数组长度的变化，例如通过 <code>arr.length = 10</code> 去修改数组长度，无法响应</li>
<li>只能侦听对象的属性，对于整个对象则需要遍历，针对多级对象更是要通过嵌套来深度侦听</li>
<li>使用 <code>Object.assign()</code> 等方法给对象添加新属性时，也不会触发更新</li>
<li>更多细节上的问题 …</li>
</ol>
<p>这也是为什么 Vue 2 要提供一个 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://v2.cn.vuejs.org/v2/api/#Vue-set">Vue.set API</a> 的原因，可以在官网 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://v2.cn.vuejs.org/v2/guide/reactivity.html#%E6%A3%80%E6%B5%8B%E5%8F%98%E5%8C%96%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">Vue 2 中检测变化的注意事项</a> 一章了解更多说明。</p>
<p>而这些问题在 <code>Proxy</code> 都可以得到解决，可以在官网 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://cn.vuejs.org/guide/extras/reactivity-in-depth.html">深入 Vue 3 的响应式原理</a> 一章了解更多这部分的内容。</p>
<h3 id="用法上的变化"><a href="#用法上的变化" class="headerlink" title="用法上的变化"></a>用法上的变化</h3><p>相对于 Vue 2 在 <code>data</code> 里声明后即可通过 <code>this.xxx</code> 调用响应式数据，在 Vue 3 的生命周期里没有了 Vue 实例的 <code>this</code> 指向，需要导入 <code>ref</code> 、<code>reactive</code> 等响应式 API 才能声明并使用响应式数据。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里导入的 `ref` 是一个响应式 API</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 通过响应式 API 创建的变量具备了响应性</span></span><br><span class="line">    <span class="keyword">const</span> msg = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="响应式-API-之-ref"><a href="#响应式-API-之-ref" class="headerlink" title="响应式 API 之 ref"></a>响应式 API 之 ref</h2><h3 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h3><p><code>ref</code> 是最常用的一个响应式 API，它可以用来<strong>定义所有类型的数据，包括 Node 节点和组件</strong>。</p>
<p>没错，在 Vue 2 常用的以 <code>this.$refs.xxx</code> 取代 <code>document.querySelector(&#39;.xxx&#39;)</code> 来获取 Node 节点的方式，也是使用了这个 API 。</p>
<h4 id="API-本身的类型"><a href="#API-本身的类型" class="headerlink" title="API 本身的类型"></a>API 本身的类型</h4><p>先看 API 本身， <code>ref</code> API 是一个函数，通过接受一个泛型入参，返回一个响应式对象，所有的值都通过 <code>.value</code> 属性获取，这是 API 本身的 TS 类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `ref` API 的 TS 类型</span></span><br><span class="line"><span class="keyword">function</span> ref&lt;T&gt;(<span class="attr">value</span>: T): <span class="title class_">Ref</span>&lt;<span class="title class_">UnwrapRef</span>&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `ref` API 的返回值的 TS 类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Ref</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此在声明变量时，是使用尖括号 <code>&lt;&gt;</code> 包裹其 TS 类型，紧跟在 <code>ref</code> API 之后：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式指定 `msg.value` 是 `string` 类型</span></span><br><span class="line"><span class="keyword">const</span> msg = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>再回看该 API 本身的类型，其中使用了 <code>T</code> 泛型，这表示在传入函数的入参时，可以不需要手动指定其 TS 类型， TypeScript 会根据这个 API 所返回的响应式对象的 <code>.value</code> 属性的类型，确定当前变量的类型。</p>
<p>因此也可以<strong>省略显式的类型指定，像下面这样声明变量，其类型交给 TypeScript 去自动推导</strong>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeScript 会推导 `msg.value` 是 `string` 类型</span></span><br><span class="line"><span class="keyword">const</span> msg = <span class="title function_">ref</span>(<span class="string">&#x27;Hello World&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>对于声明时会赋予初始值，并且在使用过程中不会改变其类型的变量，是可以省略类型的显式指定的。</p>
<p>而如果有显式的指定的类型，那么在一些特殊情况下，初始化时可以不必赋值，这样 TypeScript 会自动添加 <code>undefined</code> 类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> msg = ref&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(msg.<span class="property">value</span>) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">msg.<span class="property">value</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(msg.<span class="property">value</span>) <span class="comment">// Hello World!</span></span><br></pre></td></tr></table></figure>

<p>因为入参留空时，虽然指定了 <code>string</code> 类型，但实际上此时的值是 <code>undefined</code> ，所以实际上这个时候的 <code>msg.value</code> 是一个 <code>string | undefined</code> 的联合类型。</p>
<p>对于声明时不知道是什么值，在某种条件下才进行初始化的情况，就可以省略其初始值，但是切记在调用该变量的时候对 <code>.value</code> 值进行有效性判断。</p>
<p>而如果既不显式指定类型，也不赋予初始值，那么会被默认为 <code>any</code> 类型，除非真的无法确认类型，否则不建议这么做。</p>
<h4 id="API-返回值的类型"><a href="#API-返回值的类型" class="headerlink" title="API 返回值的类型"></a>API 返回值的类型</h4><p>细心的开发者还会留意到 <code>ref</code> API 类型里面还标注了一个返回值的 TS 类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Ref</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它是代表整个 Ref 变量的完整类型：</p>
<ul>
<li>上文声明 Ref 变量时，提到的 <code>string</code> 类型都是指 <code>msg.value</code> 这个 <code>.value</code> 属性的类型</li>
<li>而 <code>msg</code> 这个响应式变量，其本身是 <code>Ref&lt;string&gt;</code> 类型</li>
</ul>
<p>如果在开发过程中需要在函数里返回一个 Ref 变量，那么其 TypeScript 类型就可以这样写（请留意 <code>Calculator</code> 里的 <code>num</code> 变量的类型）：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 `ref` API 函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 导入 `ref` API 的返回值类型</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">Ref</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 `useCalculator` 函数的返回值类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">  <span class="comment">// 这里包含了一个 Ref 变量</span></span><br><span class="line">  <span class="attr">num</span>: <span class="title class_">Ref</span>&lt;<span class="built_in">number</span>&gt;</span><br><span class="line">  <span class="attr">add</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个 “使用计算器” 的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useCalculator</span>(<span class="params"></span>): <span class="title class_">Calculator</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> num = ref&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">    num.<span class="property">value</span>++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    num,</span><br><span class="line">    add,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在执行使用计算器函数时，可以获取到一个 Ref 变量和其他方法</span></span><br><span class="line"><span class="keyword">const</span> &#123; num, add &#125; = <span class="title function_">useCalculator</span>()</span><br><span class="line"><span class="title function_">add</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="property">value</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面这个简单的例子演示了如何手动指定 Ref 变量的类型，对于逻辑复用时的函数代码抽离、插件开发等场景非常有用！当然大部分情况下可以交给 TypeScript 自动推导，但掌握其用法，在必要的时候就派得上用场了！</p>
<h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><p>在了解了如何对 Ref 变量进行类型声明之后，面对不同的数据类型，相信都得心应手了！但不同类型的值之间还是有少许差异和注意事项，例如上文提及该 API 可以用来定义所有类型的数据，包括 Node 节点和组件，具体可以参考下文的示例。</p>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>对字符串、布尔值等基本类型的定义方式，比较简单：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">const</span> msg = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数值</span></span><br><span class="line"><span class="keyword">const</span> count = ref&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔值</span></span><br><span class="line"><span class="keyword">const</span> isVip = ref&lt;<span class="built_in">boolean</span>&gt;(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>对于对象、数组等引用类型也适用，比如要定义一个对象：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先声明对象的格式</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在定义对象时指定该类型</span></span><br><span class="line"><span class="keyword">const</span> userInfo = ref&lt;<span class="title class_">Member</span>&gt;(&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>定义一个普通数组：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值数组</span></span><br><span class="line"><span class="keyword">const</span> uids = ref&lt;<span class="built_in">number</span>[]&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串数组</span></span><br><span class="line"><span class="keyword">const</span> names = ref&lt;<span class="built_in">string</span>[]&gt;([<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Petter&#x27;</span>, <span class="string">&#x27;Andy&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>定义一个对象数组：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明对象的格式</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个对象数组</span></span><br><span class="line"><span class="keyword">const</span> memberList = ref&lt;<span class="title class_">Member</span>[]&gt;([</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Petter&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h3 id="DOM-元素与子组件"><a href="#DOM-元素与子组件" class="headerlink" title="DOM 元素与子组件"></a>DOM 元素与子组件</h3><p>除了可以定义数据，<code>ref</code> 也有熟悉的用途，就是用来挂载节点，也可以挂在子组件上，对应在 Vue 2 时常用的 <code>this.$refs.xxx</code> ，起到获取 DOM 元素信息的作用。</p>
<p>模板部分依然是熟悉的用法，在要引用的 DOM 上添加一个 <code>ref</code> 属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 给 DOM 元素添加 `ref` 属性 --&gt;</span><br><span class="line">  &lt;p ref=&quot;msg&quot;&gt;请留意该节点，有一个 ref 属性&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 子组件也用同样的方式添加 --&gt;</span><br><span class="line">  &lt;Child ref=&quot;child&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>在 <code>&lt;script /&gt;</code> 部分有三个最基本的注意事项：</p>
<ol>
<li>在 <code>&lt;template /&gt;</code> 代码里添加的 <code>ref</code> 属性的值，对应 <code>&lt;script /&gt;</code> 里使用 <code>ref</code> API 声明的变量的名称；</li>
<li>请保证视图渲染完毕后再执行 DOM 或组件的相关操作（需要放到生命周期的 <code>onMounted</code> 或者 <code>nextTick</code> 函数里，这一点在 Vue 2 也是一样）；</li>
<li>该 Ref 变量必须 <code>return</code> 出去才可以给到 <code>&lt;template /&gt;</code> 使用，这一点是 Vue 3 生命周期的硬性要求，子组件的数据和方法如果要给父组件操作，也要 <code>return</code> 出来才可以。</li>
</ol>
<p>配合上面的 <code>&lt;template /&gt;</code> ，来看看 <code>&lt;script /&gt;</code> 部分的具体例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, onMounted, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;@cp/Child.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="title class_">Child</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 定义挂载节点，声明的类型详见下方附表</span></span><br><span class="line">    <span class="keyword">const</span> msg = ref&lt;<span class="title class_">HTMLElement</span>&gt;()</span><br><span class="line">    <span class="keyword">const</span> child = ref&lt;<span class="title class_">InstanceType</span>&lt;<span class="keyword">typeof</span> <span class="title class_">Child</span>&gt;&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请保证视图渲染完毕后再执行节点操作 e.g. `onMounted` / `nextTick`</span></span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 比如获取 DOM 的文本</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(msg.<span class="property">value</span>.<span class="property">innerText</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 或者操作子组件里的数据</span></span><br><span class="line">      child.<span class="property">value</span>.<span class="property">isShowDialog</span> = <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须 `return` 出去才可以给到 `&lt;template /&gt;` 使用</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg,</span><br><span class="line">      child,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>关于 DOM 和子组件的 TS 类型声明，可参考以下规则：</p>
<table>
<thead>
<tr>
<th align="left">节点类型</th>
<th align="left">声明类型</th>
<th align="left">参考文档</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DOM 元素</td>
<td align="left">使用 HTML 元素接口</td>
<td align="left"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model#html_%E5%85%83%E7%B4%A0%E6%8E%A5%E5%8F%A3">HTML 元素接口</a></td>
</tr>
<tr>
<td align="left">子组件</td>
<td align="left">使用 <code>InstanceType</code> 配合 <code>typeof</code> 获取子组件的类型</td>
<td align="left"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/311150643">typeof 操作符</a></td>
</tr>
</tbody></table>
<blockquote>
<p>单纯使用 <code>typeof Child</code> 虽然可以获得 Child.vue 组件的 Props 和方法等提示，但目前在 VSCode 的类型推导还不够智能，缺乏更有效的代码补全支持。</p>
<p>上文使用的 <code>InstanceType&lt;T&gt;</code> 是 TypeScript 提供的一个工具类型，可以获取构造函数类型的实例类型，因此将组件的类型声明为 <code>InstanceType&lt;typeof Child&gt;</code> ，不仅可以得到更完善的类型提示，在编程过程中还可以让编辑器提供更完善的代码补全功能。</p>
</blockquote>
<h3 id="变量的读取与赋值"><a href="#变量的读取与赋值" class="headerlink" title="变量的读取与赋值"></a>变量的读取与赋值</h3><p>前面在介绍 API 类型的时候已经了解，通过 <code>ref</code> 声明的变量会全部变成对象，不管定义的是什么类型的值，都会转化为一个 Ref 对象，其中 Ref 对象具有指向内部值的单个 Property <code>.value</code>。</p>
<p>也就是说，任何 Ref 对象的值都必须通过 <code>xxx.value</code> 才可以正确获取。</p>
<p>请牢记上面这句话，初用 Vue 3 的开发者很多 BUG 都是由这个问题引起的（包括笔者刚开始使用 Vue 3 的那段时间，嘿嘿）。</p>
<h4 id="读取变量"><a href="#读取变量" class="headerlink" title="读取变量"></a>读取变量</h4><p>平时对于普通变量的值，读取的时候都是直接调用其变量名即可：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取一个字符串</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">msg</span>: <span class="built_in">string</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取一个数组</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">uids</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uids[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>而 Ref 对象的值的读取，切记！必须通过 <code>.value</code> ！</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取一个字符串</span></span><br><span class="line"><span class="keyword">const</span> msg = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(msg.<span class="property">value</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取一个数组</span></span><br><span class="line"><span class="keyword">const</span> uids = ref&lt;<span class="built_in">number</span>[]&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uids.<span class="property">value</span>[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h4 id="为变量赋值"><a href="#为变量赋值" class="headerlink" title="为变量赋值"></a>为变量赋值</h4><p>普通变量需要使用 <code>let</code> 声明才可以修改其值，由于 Ref 对象是个引用类型，所以可以使用 <code>const</code> 声明，直接通过 <code>.value</code> 修改。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个字符串变量</span></span><br><span class="line"><span class="keyword">const</span> msg = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;Hi!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待 1s 后修改它的值</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  msg.<span class="property">value</span> = <span class="string">&#x27;Hello!&#x27;</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>因此日常业务中，像在对接服务端 API 的接口数据时，可以自由地使用 <code>forEach</code>、<code>map</code>、<code>filter</code> 等方法操作 Ref 数组，或者直接重置它，而不必担心数据失去响应性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = ref&lt;<span class="built_in">string</span>[]&gt;([])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取接口的数据</span></span><br><span class="line">data.<span class="property">value</span> = api.<span class="property">data</span>.<span class="title function_">map</span>(<span class="function">(<span class="params"><span class="attr">item</span>: <span class="built_in">any</span></span>) =&gt;</span> item.<span class="property">text</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置数组</span></span><br><span class="line">data.<span class="property">value</span> = []</span><br></pre></td></tr></table></figure>

<p>为什么突然要说这个呢？因为涉及到下一部分的知识，关于 <code>reactive</code> API 在使用上的注意事项。</p>
<h2 id="响应式-API-之-reactive"><a href="#响应式-API-之-reactive" class="headerlink" title="响应式 API 之 reactive"></a>响应式 API 之 reactive</h2><p><code>reactive</code> 是继 <code>ref</code> 之后最常用的一个响应式 API 了，相对于 <code>ref</code> ，它的局限性在于只适合对象、数组。</p>
<p>使用 <code>reactive</code> 的好处就是写法跟平时的对象、数组几乎一模一样，但它也带来了一些特殊注意点，请留意赋值部分的特殊说明。</p>
<h3 id="类型声明与定义"><a href="#类型声明与定义" class="headerlink" title="类型声明与定义"></a>类型声明与定义</h3><p><code>reactive</code> 变量的声明方式没有 <code>ref</code> 的变化那么大，基本上和普通变量一样，它的 TS 类型如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> reactive&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(<span class="attr">target</span>: T): <span class="title class_">UnwrapNestedRefs</span>&lt;T&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到其用法还是比较简单的，下面是一个 Reactive 对象的声明方式：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明对象的类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">userInfo</span>: <span class="title class_">Member</span> = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>下面是 Reactive 数组的声明方式：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">uids</span>: <span class="built_in">number</span>[] = <span class="title function_">reactive</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p>还可以声明一个 Reactive 对象数组：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象数组也是先声明其中的对象类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再定义一个为对象数组</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">userList</span>: <span class="title class_">Member</span>[] = <span class="title function_">reactive</span>([</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Petter&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Andy&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h3 id="变量的读取与赋值-1"><a href="#变量的读取与赋值-1" class="headerlink" title="变量的读取与赋值"></a>变量的读取与赋值</h3><p>虽然 <code>reactive</code> API 在使用上没有像 <code>ref</code> API 一样有 <code>.value</code> 的心智负担，但也有一些注意事项要留意。</p>
<h4 id="处理对象"><a href="#处理对象" class="headerlink" title="处理对象"></a>处理对象</h4><p>Reactive 对象在读取或者修改字段的值时，与普通对象是一样的，这部分没有太多问题。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明对象的类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">userInfo</span>: <span class="title class_">Member</span> = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取用户名</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInfo.<span class="property">name</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改用户名</span></span><br><span class="line">userInfo.<span class="property">name</span> = <span class="string">&#x27;Petter&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="处理数组"><a href="#处理数组" class="headerlink" title="处理数组"></a>处理数组</h4><p>但是 Reactive 数组和普通数组会有一些区别。</p>
<p>普通数组在 “重置” 或者 “修改值” 时都可以直接操作：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个普通数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">uids</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从另外一个对象数组里提取数据过来</span></span><br><span class="line">uids = api.<span class="property">data</span>.<span class="title function_">map</span>(<span class="function">(<span class="params"><span class="attr">item</span>: <span class="built_in">any</span></span>) =&gt;</span> item.<span class="property">id</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并另外一个数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">newUids</span>: <span class="built_in">number</span>[] = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">uids = [...uids, ...newUids]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置数组</span></span><br><span class="line">uids = []</span><br></pre></td></tr></table></figure>

<p>但在 Vue 3 ，如果使用 <code>reactive</code> 定义数组，则不能这么处理，必须只使用那些不会改变引用地址的操作。比如要从服务端 API 接口获取翻页数据时，通常要先重置数组，再异步添加数据，如果使用常规的重置，会导致这个变量失去响应性：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">uids</span>: <span class="built_in">number</span>[] = <span class="title function_">reactive</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不推荐使用这种方式，会丢失响应性</span></span><br><span class="line"><span class="comment"> * 异步添加数据后，模板不会响应更新</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">uids = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步获取数据后，模板依然是空数组</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  uids.<span class="title function_">push</span>(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>要让数据依然保持响应性，则必须在关键操作时，不破坏响应性 API ，以下是推荐的操作方式，通过重置数组的 <code>length</code> 长度来实现数据的重置：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">uids</span>: <span class="built_in">number</span>[] = <span class="title function_">reactive</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 推荐使用这种方式，不会破坏响应性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">uids.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步获取数据后，模板可以正确的展示</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  uids.<span class="title function_">push</span>(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<h3 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h3><p>不要对 Reactive 数据进行 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">ES6 的解构</a> 操作，因为解构后得到的变量会失去响应性。</p>
<p>比如这些情况，在 2s 后都得不到新的 name 信息：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 定义一个带有响应性的对象</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">userInfo</span>: <span class="title class_">Member</span> = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;Petter&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 2s 后更新 `userInfo`</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      userInfo.<span class="property">name</span> = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个变量在 2s 后不会同步更新</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">newUserInfo</span>: <span class="title class_">Member</span> = &#123; ...userInfo &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个变量在 2s 后不会再同步更新</span></span><br><span class="line">    <span class="keyword">const</span> &#123; name &#125; = userInfo</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这样 `return` 出去给模板用，在 2s 后也不会同步更新</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...userInfo,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="响应式-API-之-toRef-与-toRefs"><a href="#响应式-API-之-toRef-与-toRefs" class="headerlink" title="响应式 API 之 toRef 与 toRefs"></a>响应式 API 之 toRef 与 toRefs</h2><p>相信各位开发者看到这里时，应该已经对 <code>ref</code> 和 <code>reactive</code> API 都有所了解了，为了方便开发者使用， Vue 3 还推出了两个与之相关的 API ： <code>toRef</code> 和 <code>toRefs</code> ，都是用于 <code>reactive</code> 向 <code>ref</code> 转换。</p>
<h3 id="各自的作用"><a href="#各自的作用" class="headerlink" title="各自的作用"></a>各自的作用</h3><p>这两个 API 在拼写上非常接近，顾名思义，一个是只转换一个字段，一个是转换所有字段，转换后将得到新的变量，并且新变量和原来的变量可以保持同步更新。</p>
<table>
<thead>
<tr>
<th align="left">API</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">toRef</td>
<td align="left">创建一个新的 Ref 变量，转换 Reactive 对象的某个字段为 Ref 变量</td>
</tr>
<tr>
<td align="left">toRefs</td>
<td align="left">创建一个新的对象，它的每个字段都是 Reactive 对象各个字段的 Ref 变量</td>
</tr>
</tbody></table>
<p>光看概念可能不容易理解，来看下面的例子，先声明一个 <code>reactive</code> 变量：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">userInfo</span>: <span class="title class_">Member</span> = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Petter&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后分别看看这两个 API 应该怎么使用。</p>
<h3 id="使用-toRef"><a href="#使用-toRef" class="headerlink" title="使用 toRef"></a>使用 toRef</h3><p>先看这个转换单个字段的 <code>toRef</code> API ，了解了它的用法之后，再去看 <code>toRefs</code> 就很容易理解了。</p>
<h4 id="API-类型和基本用法"><a href="#API-类型和基本用法" class="headerlink" title="API 类型和基本用法"></a>API 类型和基本用法</h4><p><code>toRef</code> API 的 TS 类型如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `toRef` API 的 TS 类型</span></span><br><span class="line"><span class="keyword">function</span> toRef&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>, K <span class="keyword">extends</span> keyof T&gt;(</span><br><span class="line">  <span class="attr">object</span>: T,</span><br><span class="line">  <span class="attr">key</span>: K,</span><br><span class="line">  <span class="attr">defaultValue</span>?: T[K]</span><br><span class="line">): <span class="title class_">ToRef</span>&lt;T[K]&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `toRef` API 的返回值的 TS 类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ToRef</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="title class_">Ref</span> ? T : <span class="title class_">Ref</span>&lt;T&gt;</span><br></pre></td></tr></table></figure>

<p>通过接收两个必传的参数（第一个是 <code>reactive</code> 对象, 第二个是要转换的 <code>key</code> ），返回一个 Ref 变量，在适当的时候也可以传递第三个参数，为该变量设置默认值。</p>
<p>以上文声明好的 <code>userInfo</code> 为例，如果想转换 <code>name</code> 这个字段为 Ref 变量，只需要这样操作：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="title function_">toRef</span>(userInfo, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">value</span>) <span class="comment">// Petter</span></span><br></pre></td></tr></table></figure>

<p>等号左侧的 <code>name</code> 变量此时是一个 Ref 变量，这里因为 TypeScript 可以对其自动推导，因此声明时可以省略 TS 类型的显式指定，实际上该变量的类型是 <code>Ref&lt;string&gt;</code> 。</p>
<p>所以之后在读取和赋值时，就需要使用 <code>name.value</code> 来操作，在重新赋值时会同时更新 <code>name</code> 和 <code>userInfo.name</code> 的值：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改前先查看初始值</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="title function_">toRef</span>(userInfo, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">value</span>) <span class="comment">// Petter</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInfo.<span class="property">name</span>) <span class="comment">// Petter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 Ref 变量的值，两者同步更新</span></span><br><span class="line">name.<span class="property">value</span> = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">value</span>) <span class="comment">// Tom</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInfo.<span class="property">name</span>) <span class="comment">// Tom</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 Reactive 对象上该属性的值，两者也是同步更新</span></span><br><span class="line">userInfo.<span class="property">name</span> = <span class="string">&#x27;Jerry&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">value</span>) <span class="comment">// Jerry</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInfo.<span class="property">name</span>) <span class="comment">// Jerry</span></span><br></pre></td></tr></table></figure>

<p>这个 API 也可以接收一个 Reactive 数组，此时第二个参数应该传入数组的下标：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这一次声明的是数组</span></span><br><span class="line"><span class="keyword">const</span> words = <span class="title function_">reactive</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过下标 `0` 转换第一个 item</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">toRef</span>(words, <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">value</span>) <span class="comment">// a</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(words[<span class="number">0</span>]) <span class="comment">// a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过下标 `2` 转换第三个 item</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="title function_">toRef</span>(words, <span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">value</span>) <span class="comment">// c</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(words[<span class="number">2</span>]) <span class="comment">// c</span></span><br></pre></td></tr></table></figure>

<h4 id="设置默认值"><a href="#设置默认值" class="headerlink" title="设置默认值"></a>设置默认值</h4><p>如果 Reactive 对象上有一个属性本身没有初始值，也可以传递第三个参数进行设置（默认值仅对 Ref 变量有效）：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="comment">// 类型上新增一个属性，因为是可选的，因此默认值会是 `undefined`</span></span><br><span class="line">  <span class="attr">age</span>?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明变量时省略 `age` 属性</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">userInfo</span>: <span class="title class_">Member</span> = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Petter&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时为了避免程序运行错误，可以指定一个初始值</span></span><br><span class="line"><span class="comment">// 但初始值仅对 Ref 变量有效，不会影响 Reactive 字段的值</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="title function_">toRef</span>(userInfo, <span class="string">&#x27;age&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age.<span class="property">value</span>)  <span class="comment">// 18</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInfo.<span class="property">age</span>) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 除非重新赋值，才会使两者同时更新</span></span><br><span class="line">age.<span class="property">value</span> = <span class="number">25</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age.<span class="property">value</span>)  <span class="comment">// 25</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInfo.<span class="property">age</span>) <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>

<p>数组也是同理，对于可能不存在的下标，可以传入默认值避免项目的逻辑代码出现问题：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> words = <span class="title function_">reactive</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当下标对应的值不存在时，也是返回 `undefined`</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="title function_">toRef</span>(words, <span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d.<span class="property">value</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(words[<span class="number">3</span>]) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置了默认值之后，就会对 Ref 变量使用默认值， Reactive 数组此时不影响</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="title function_">toRef</span>(words, <span class="number">4</span>, <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">value</span>) <span class="comment">// e</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(words[<span class="number">4</span>]) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h4><p>这个 API 还有一个特殊用法，但不建议在 TypeScript 里使用。</p>
<p>在 <code>toRef</code> 的过程中，如果使用了原对象上面不存在的 <code>key</code> ，那么定义出来的 Ref 变量的 <code>.value</code> 值将会是 <code>undefined</code> 。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 众所周知， Petter 是没有女朋友的</span></span><br><span class="line"><span class="keyword">const</span> girlfriend = <span class="title function_">toRef</span>(userInfo, <span class="string">&#x27;girlfriend&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(girlfriend.<span class="property">value</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInfo.<span class="property">girlfriend</span>) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时 Reactive 对象上只有两个 Key</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(userInfo)) <span class="comment">// [&#x27;id&#x27;, &#x27;name&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>如果对这个不存在的 <code>key</code> 的 Ref 变量进行赋值，那么原来的 Reactive 对象也会同步增加这个 <code>key</code>，其值也会同步更新。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值后，不仅 Ref 变量得到了 `Marry` ， Reactive 对象也得到了 `Marry`</span></span><br><span class="line">girlfriend.<span class="property">value</span> = <span class="string">&#x27;Marry&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(girlfriend.<span class="property">value</span>) <span class="comment">// &#x27;Marry&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInfo.<span class="property">girlfriend</span>) <span class="comment">// &#x27;Marry&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时 Reactive 对象上有了三个 Key</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(userInfo)) <span class="comment">// [&#x27;id&#x27;, &#x27;name&#x27;, &#x27;girlfriend&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>为什么强调不要在 TypeScript 里使用呢？因为在编译时，无法通过 TypeScript 的类型检查：</p>
<p>如果不得不使用这种情况，可以考虑使用 any 类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将该类型直接指定为 `any`</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Member</span> = <span class="built_in">any</span></span><br><span class="line"><span class="comment">// 当然一般都是 `const userInfo: any`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者保持接口类型的情况下，允许任意键值</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 `Record` 也是同理</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Member</span> = <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="使用-toRefs"><a href="#使用-toRefs" class="headerlink" title="使用 toRefs"></a>使用 toRefs</h3><p>在了解了 <code>toRef</code> API 之后，来看看 <code>toRefs</code> 的用法。</p>
<h4 id="API-类型和基本用法-1"><a href="#API-类型和基本用法-1" class="headerlink" title="API 类型和基本用法"></a>API 类型和基本用法</h4><p>先看看它的 TS 类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> toRefs&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(</span><br><span class="line">  <span class="attr">object</span>: T</span><br><span class="line">): &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: <span class="title class_">ToRef</span>&lt;T[K]&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ToRef</span> = T <span class="keyword">extends</span> <span class="title class_">Ref</span> ? T : <span class="title class_">Ref</span>&lt;T&gt;</span><br></pre></td></tr></table></figure>

<p>与 <code>toRef</code> 不同， <code>toRefs</code> 只接收了一个参数，是一个 <code>reactive</code> 变量。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个 Reactive 变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">userInfo</span>: <span class="title class_">Member</span> = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Petter&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传给 `toRefs` 作为入参</span></span><br><span class="line"><span class="keyword">const</span> userInfoRefs = <span class="title function_">toRefs</span>(userInfo)</span><br></pre></td></tr></table></figure>

<p>此时这个新的 <code>userInfoRefs</code> 变量，它的 TS 类型就不再是 <code>Member</code> 了，而应该是：<code>ToRefs&lt;Member&gt;</code></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 `toRefs` API 的类型</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">ToRefs</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文代码省略...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将原来的类型传给 API 的类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">userInfoRefs</span>: <span class="title class_">ToRefs</span>&lt;<span class="title class_">Member</span>&gt; = <span class="title function_">toRefs</span>(userInfo)</span><br></pre></td></tr></table></figure>

<p>也可以重新编写一个新的类型来指定它，因为每个字段都是与原来关联的 Ref 变量，所以也可以这样声明：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 `ref` API 的类型</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">Ref</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文代码省略...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新声明的类型每个字段都是一个 Ref 变量的类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MemberRefs</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="title class_">Ref</span>&lt;<span class="built_in">number</span>&gt;</span><br><span class="line">  <span class="attr">name</span>: <span class="title class_">Ref</span>&lt;<span class="built_in">string</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用新的类型进行声明</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">userInfoRefs</span>: <span class="title class_">MemberRefs</span> = <span class="title function_">toRefs</span>(userInfo)</span><br></pre></td></tr></table></figure>

<p>当然实际上日常使用时并不需要手动指定其类型， TypeScript 会自动推导，可以节约非常多的开发工作量。</p>
<p>和 <code>toRef</code> API 一样，这个 API 也是可以对数组进行转换：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> words = <span class="title function_">reactive</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="keyword">const</span> wordsRefs = <span class="title function_">toRefs</span>(words)</span><br></pre></td></tr></table></figure>

<p>此时新数组的类型是 <code>Ref&lt;string&gt;[]</code> ，不再是原来的 <code>string[]</code> 类型。</p>
<h4 id="解构与赋值"><a href="#解构与赋值" class="headerlink" title="解构与赋值"></a>解构与赋值</h4><p>转换后的 Reactive 对象或数组支持 ES6 的解构，并且不会失去响应性，因为解构后的每一个变量都具备响应性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了提高开发效率，可以直接将 Ref 变量直接解构出来使用</span></span><br><span class="line"><span class="keyword">const</span> &#123; name &#125; = <span class="title function_">toRefs</span>(userInfo)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">value</span>) <span class="comment">// Petter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时对解构出来的变量重新赋值，原来的变量也可以同步更新</span></span><br><span class="line">name.<span class="property">value</span> = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">value</span>) <span class="comment">// Tom</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInfo.<span class="property">name</span>) <span class="comment">// Tom</span></span><br></pre></td></tr></table></figure>

<p>这一点和直接解构 Reactive 变量有非常大的不同，直接解构 Reactive 变量，得到的是一个普通的变量，不再具备响应性。</p>
<p>这个功能在使用 Hooks 函数非常好用（在 Vue 3 里也叫可组合函数， Composable Functions ），还是以一个计算器函数为例，这一次将其修改为内部有一个 Reactive 的数据状态中心，在函数返回时解构为多个 Ref 变量：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 `useCalculator` 数据状态类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CalculatorState</span> &#123;</span><br><span class="line">  <span class="comment">// 这是要用来计算操作的数据</span></span><br><span class="line">  <span class="attr">num</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="comment">// 这是每次计算时要增加的幅度</span></span><br><span class="line">  <span class="attr">step</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个 “使用计算器” 的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useCalculator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 通过数据状态中心的形式，集中管理内部变量</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">state</span>: <span class="title class_">CalculatorState</span> = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">num</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">step</span>: <span class="number">10</span>,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 功能函数也是通过数据中心变量去调用</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">    state.<span class="property">num</span> += state.<span class="property">step</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...<span class="title function_">toRefs</span>(state),</span><br><span class="line">    add,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在调用 <code>useCalculator</code> 函数时，可以通过解构直接获取到 Ref 变量，不需要再进行额外的转换工作。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解构出来的 `num` 和 `step` 都是 Ref 变量</span></span><br><span class="line"><span class="keyword">const</span> &#123; num, step, add &#125; = <span class="title function_">useCalculator</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="property">value</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(step.<span class="property">value</span>) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用计算器的方法，数据也是会得到响应式更新</span></span><br><span class="line"><span class="title function_">add</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="property">value</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h3 id="为什么要进行转换"><a href="#为什么要进行转换" class="headerlink" title="为什么要进行转换"></a>为什么要进行转换</h3><p>关于为什么要出这么两个 API ，官方文档没有特别说明，不过经过笔者在业务中的一些实际使用感受，以及在写上一节 <code>reactive</code> 的 特别注意，可能知道一些使用理由。</p>
<p>关于 <code>ref</code> 和 <code>reactive</code> 这两个 API 的好处就不重复了，但是在使用的过程中，各自都有不方便的地方：</p>
<p><code>ref</code> API 虽然在 <code>&lt;template /&gt;</code> 里使用起来方便，但是在 <code>&lt;script /&gt;</code> 里进行读取 &#x2F; 赋值的时候，要一直记得加上 <code>.value</code> ，否则 BUG 就来了。</p>
<p><code>reactive</code> API 虽然在使用的时候，因为知道它本身是一个对象，所以不会忘记通过 <code>foo.bar</code> 这样的格式去操作，但是在 <code>&lt;template /&gt;</code> 渲染的时候，又因此不得不每次都使用 <code>foo.bar</code> 的格式去渲染。</p>
<p>那么有没有办法，既可以在编写 <code>&lt;script /&gt;</code> 的时候不容易出错，在写 <code>&lt;template /&gt;</code> 的时候又比较简单呢？</p>
<p>于是， <code>toRef</code> 和 <code>toRefs</code> 因此诞生。</p>
<h3 id="什么场景下比较适合使用它们"><a href="#什么场景下比较适合使用它们" class="headerlink" title="什么场景下比较适合使用它们"></a>什么场景下比较适合使用它们</h3><p>从便利性和可维护性来说，最好只在功能单一、代码量少的组件里使用，比如一个表单组件，通常表单的数据都放在一个对象里。</p>
<p>当然也可以把所有的数据都定义到一个 <code>data</code> 里，再去 <code>data</code> 里面取值，但是没有必要为了转换而转换，否则不如使用 Options API 风格。</p>
<h3 id="在业务中的具体运用"><a href="#在业务中的具体运用" class="headerlink" title="在业务中的具体运用"></a>在业务中的具体运用</h3><p>继续使用上文一直在使用的 <code>userInfo</code> 来当案例，以一个用户信息表的小 demo 做个演示。</p>
<p>在 <code>&lt;script /&gt;</code> 部分：</p>
<ol>
<li><p>先用 <code>reactive</code> 定义一个源数据，所有的数据更新，都是修改这个对象对应的值，按照对象的写法维护数据</p>
</li>
<li><p>再通过 <code>toRefs</code> 定义一个给 <code>&lt;template /&gt;</code> 使用的对象，这样可以得到一个每个字段都是 Ref 变量的新对象</p>
</li>
<li><p>在 <code>return</code> 的时候，对步骤 2 里的 <code>toRefs</code> 对象进行解构，这样导出去就是各个字段对应的 Ref 变量，而不是一整个对象</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, reactive, toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">gender</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 定义一个 reactive 对象</span></span><br><span class="line">    <span class="keyword">const</span> userInfo = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;Petter&#x27;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">      <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个新的对象，它本身不具备响应性，但是它的字段全部是 Ref 变量</span></span><br><span class="line">    <span class="keyword">const</span> userInfoRefs = <span class="title function_">toRefs</span>(userInfo)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 2s 后更新 `userInfo`</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      userInfo.<span class="property">id</span> = <span class="number">2</span></span><br><span class="line">      userInfo.<span class="property">name</span> = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">      userInfo.<span class="property">age</span> = <span class="number">20</span></span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里解构 `toRefs` 对象才能继续保持响应性</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...userInfoRefs,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>&lt;template /&gt;</code> 部分：由于 <code>return</code> 出来的都是 Ref 变量，所以在模板里可以直接使用 <code>userInfo</code> 各个字段的 <code>key</code> ，不再需要写很长的 <code>userInfo.name</code> 了。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;user-info&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;key&quot;</span>&gt;</span>ID:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;value&quot;</span>&gt;</span>&#123;&#123; id &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;key&quot;</span>&gt;</span>name:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;value&quot;</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;key&quot;</span>&gt;</span>age:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;value&quot;</span>&gt;</span>&#123;&#123; age &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;key&quot;</span>&gt;</span>gender:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;value&quot;</span>&gt;</span>&#123;&#123; gender &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h3><p>请注意是否有相同命名的变量存在，比如上面在 <code>return</code> 给 <code>&lt;template /&gt;</code> 使用时，在解构 <code>userInfoRefs</code> 的时候已经包含了一个 <code>name</code> 字段，此时如果还有一个单独的变量也叫 <code>name</code> ，就会出现渲染上的数据显示问题。</p>
<p>此时它们在 <code>&lt;template /&gt;</code> 里哪个会生效，取决于谁排在后面，因为 <code>return</code> 出去的其实是一个对象，在对象里，如果存在相同的 <code>key</code> ，则后面的会覆盖前面的。</p>
<p>下面这种情况，会以单独的 <code>name</code> 为渲染数据：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  ...userInfoRefs,</span><br><span class="line">  name,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而下面这种情况，则是以 <code>userInfoRefs</code> 里的 <code>name</code> 为渲染数据：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  name,</span><br><span class="line">  ...userInfoRefs,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以当决定使用 <code>toRef</code> 和 <code>toRefs</code> API 的时候，请注意这个特殊情况！</p>
<h2 id="函数的声明和使用"><a href="#函数的声明和使用" class="headerlink" title="函数的声明和使用"></a>函数的声明和使用</h2><p>在了解了响应式数据如何使用之后，接下来就要开始了解函数了。</p>
<p>在 Vue 2 ，函数通常是作为当前组件实例上的方法在 <code>methods</code> 里声明，然后再在 <code>mounted</code> 等生命周期里调用，或者是在模板里通过 Click 等行为触发，由于组件内部经常需要使用 <code>this</code> 获取组件实例，因此不能使用箭头函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">num</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mounted</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">add</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 不可以使用 `add: () =&gt; this.num++`</span></span><br><span class="line">    <span class="attr">add</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">num</span>++</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Vue 3 则灵活了很多，可以使用普通函数、 Class 类、箭头函数、匿名函数等等进行声明，可以将其写在 <code>setup</code> 里直接使用，也可以抽离在独立的 <code>.js</code> &#x2F; <code>.ts</code> 文件里再导入使用。</p>
<p>需要在组件创建时自动执行的函数，其执行时机需要遵循 Vue 3 的生命周期，需要在模板里通过 <code>@click</code>、<code>@change</code> 等行为触发，和变量一样，需要把函数名在 <code>setup</code> 里进行 <code>return</code> 出去。</p>
<p>下面是一个简单的例子，方便开发者更直观地了解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 在这里点击执行 `return` 出来的方法 --&gt;</span><br><span class="line">  &lt;button @click=&quot;updateMsg&quot;&gt;修改MSG&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, onMounted, ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const msg = ref&lt;string&gt;(&#x27;Hello World!&#x27;)</span><br><span class="line"></span><br><span class="line">    // 这个要暴露给模板使用，必须 `return` 才可以使用</span><br><span class="line">    function updateMsg() &#123;</span><br><span class="line">      msg.value = &#x27;Hi World!&#x27;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 这个要在页面载入时执行，无需 `return` 出去</span><br><span class="line">    const init = () =&gt; &#123;</span><br><span class="line">      console.log(&#x27;init&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onMounted(() =&gt; &#123;</span><br><span class="line">      init()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      msg,</span><br><span class="line">      updateMsg,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="数据的侦听"><a href="#数据的侦听" class="headerlink" title="数据的侦听"></a>数据的侦听</h2><p>侦听数据变化也是组件里的一项重要工作，比如侦听路由变化、侦听参数变化等等。</p>
<p>Vue 3 在保留原来的 <code>watch</code> 功能之外，还新增了一个 <code>watchEffect</code> 帮助更简单地进行侦听。</p>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>在 Vue 3 ，新版的 <code>watch</code> 和 Vue 2 的旧版写法对比，在使用方式上变化非常大！</p>
<h4 id="回顾-Vue-2-2"><a href="#回顾-Vue-2-2" class="headerlink" title="回顾 Vue 2"></a>回顾 Vue 2</h4><p>在 Vue 2 是这样用的，和 <code>data</code> 、 <code>methods</code> 都在同级配置：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 注意这里，放在 `data` 、 `methods` 同个级别</span></span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且类型繁多，选项式 API 的类型如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123; [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="title class_">Function</span> | <span class="title class_">Object</span> | <span class="title class_">Array</span>&#125;</span><br></pre></td></tr></table></figure>

<p>联合类型过多，意味着用法复杂，下面是个很好的例子，虽然出自 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://cn.vuejs.org/api/options-state.html#watch">官网</a> 的用法介绍，但过于繁多的用法也反映出来对初学者不太友好，初次接触可能会觉得一头雾水：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">c</span>: &#123;</span><br><span class="line">        <span class="attr">d</span>: <span class="number">4</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">e</span>: <span class="number">5</span>,</span><br><span class="line">      <span class="attr">f</span>: <span class="number">6</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="comment">// 侦听顶级 Property</span></span><br><span class="line">    <span class="title function_">a</span>(<span class="params">val, oldVal</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`new: <span class="subst">$&#123;val&#125;</span>, old: <span class="subst">$&#123;oldVal&#125;</span>`</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 字符串方法名</span></span><br><span class="line">    <span class="attr">b</span>: <span class="string">&#x27;someMethod&#x27;</span>,</span><br><span class="line">    <span class="comment">// 该回调会在任何被侦听的对象的 Property 改变时被调用，不论其被嵌套多深</span></span><br><span class="line">    <span class="attr">c</span>: &#123;</span><br><span class="line">      <span class="title function_">handler</span>(<span class="params">val, oldVal</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;c changed&#x27;</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 侦听单个嵌套 Property</span></span><br><span class="line">    <span class="string">&#x27;c.d&#x27;</span>: <span class="keyword">function</span> (<span class="params">val, oldVal</span>) &#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 该回调将会在侦听开始之后被立即调用</span></span><br><span class="line">    <span class="attr">e</span>: &#123;</span><br><span class="line">      <span class="title function_">handler</span>(<span class="params">val, oldVal</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;e changed&#x27;</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 可以传入回调数组，它们会被逐一调用</span></span><br><span class="line">    <span class="attr">f</span>: [</span><br><span class="line">      <span class="string">&#x27;handle1&#x27;</span>,</span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">handle2</span>(<span class="params">val, oldVal</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;handle2 triggered&#x27;</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">handler</span>: <span class="keyword">function</span> <span class="title function_">handle3</span>(<span class="params">val, oldVal</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;handle3 triggered&#x27;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">someMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b changed&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">handle1</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;handle 1 triggered&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>另外需要注意的是，不能使用箭头函数来定义 Watcher 函数 (例如 <code>searchQuery: newValue =&gt; this.updateAutocomplete(newValue)</code> )。</p>
<p>因为箭头函数绑定了父级作用域的上下文，所以 <code>this</code> 将不会按照期望指向组件实例， <code>this.updateAutocomplete</code> 将是 <code>undefined</code> 。</p>
</blockquote>
<p>Vue 2 也可以通过 <code>this.$watch()</code> 这个 API 的用法来实现对某个数据的侦听，它接受三个参数： <code>source</code> 、 <code>callback</code> 和 <code>options</code> 。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 生命周期钩子</span></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.$watch(<span class="string">&#x27;a&#x27;</span>, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="了解-Vue-3-2"><a href="#了解-Vue-3-2" class="headerlink" title="了解 Vue 3"></a>了解 Vue 3</h4><p>在 Vue 3 的组合式 API 写法， <code>watch</code> 是一个可以接受 3 个参数的函数（保留了 Vue 2 的 <code>this.$watch</code> 这种用法），在使用层面上简单了很多。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个用法走天下</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  source, <span class="comment">// 必传，要侦听的数据源</span></span><br><span class="line">  callback <span class="comment">// 必传，侦听到变化后要执行的回调函数</span></span><br><span class="line">  <span class="comment">// options // 可选，一些侦听选项</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>下面的内容都基于 Vue 3 的组合式 API 用法展开讲解。</p>
<h4 id="API-的-TS-类型"><a href="#API-的-TS-类型" class="headerlink" title="API 的 TS 类型"></a>API 的 TS 类型</h4><p>在了解用法之前，先对它的 TS 类型声明做一个简单的了解， watch 作为组合式 API ，根据使用方式有两种类型声明：</p>
<ol>
<li><p>基础用法的 TS 类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watch 部分的 TS 类型</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">function</span> watch&lt;T, <span class="title class_">Immediate</span> <span class="keyword">extends</span> <span class="title class_">Readonly</span>&lt;<span class="built_in">boolean</span>&gt; = <span class="literal">false</span>&gt;(</span><br><span class="line">  <span class="attr">source</span>: <span class="title class_">WatchSource</span>&lt;T&gt;,</span><br><span class="line">  <span class="attr">cb</span>: <span class="title class_">WatchCallback</span>&lt;T, <span class="title class_">Immediate</span> <span class="keyword">extends</span> <span class="literal">true</span> ? T | <span class="literal">undefined</span> : T&gt;,</span><br><span class="line">  <span class="attr">options</span>?: <span class="title class_">WatchOptions</span>&lt;<span class="title class_">Immediate</span>&gt;</span><br><span class="line">): <span class="title class_">WatchStopHandle</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>批量侦听的 TS 类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watch 部分的 TS 类型</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">function</span> watch&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="title class_">MultiWatchSources</span>,</span><br><span class="line">  <span class="title class_">Immediate</span> <span class="keyword">extends</span> <span class="title class_">Readonly</span>&lt;<span class="built_in">boolean</span>&gt; = <span class="literal">false</span></span><br><span class="line">&gt;(</span><br><span class="line">  <span class="attr">sources</span>: [...T],</span><br><span class="line">  <span class="attr">cb</span>: <span class="title class_">WatchCallback</span>&lt;<span class="title class_">MapSources</span>&lt;T, <span class="literal">false</span>&gt;, <span class="title class_">MapSources</span>&lt;T, <span class="title class_">Immediate</span>&gt;&gt;,</span><br><span class="line">  <span class="attr">options</span>?: <span class="title class_">WatchOptions</span>&lt;<span class="title class_">Immediate</span>&gt;</span><br><span class="line">): <span class="title class_">WatchStopHandle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MultiWatchSources 是一个数组</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">MultiWatchSources</span> = (<span class="title class_">WatchSource</span>&lt;<span class="built_in">unknown</span>&gt; | <span class="built_in">object</span>)[]</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>但是不管是基础用法还是批量侦听，可以看到这个 API 都是接受三个入参, 并返回一个可以用来停止侦听的函数</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">是否可选</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">source</td>
<td align="center">必传</td>
<td align="left">数据源</td>
</tr>
<tr>
<td align="center">callback</td>
<td align="center">必传</td>
<td align="left">侦听到变化后要执行的回调函数</td>
</tr>
<tr>
<td align="center">options</td>
<td align="center">可选</td>
<td align="left">一些侦听选项</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="要侦听的数据源"><a href="#要侦听的数据源" class="headerlink" title="要侦听的数据源"></a>要侦听的数据源</h4><p>在上面API 的 TS 类型已经对 <code>watch</code> API 的组成有一定的了解了，这里先对数据源的类型和使用限制做下说明。如果不提前了解，在使用的过程中可能会遇到 “侦听了但没有反应” 的情况出现。</p>
<p><code>watch</code> API 的第 1 个参数 <code>source</code> 是要侦听的数据源，它的 TS 类型如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watch 第 1 个入参的 TS 类型</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">WatchSource</span>&lt;T = <span class="built_in">any</span>&gt; = <span class="title class_">Ref</span>&lt;T&gt; | <span class="title class_">ComputedRef</span>&lt;T&gt; | (<span class="function">() =&gt;</span> T)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>可以看到能够用于侦听的数据，是通过响应式 API定义的变量（ <code>Ref&lt;T&gt;</code> ），或者是一个 计算数据（ <code>ComputedRef&lt;T&gt;</code> ），或者是一个 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get">getter 函数</a> （ <code>() =&gt; T</code> ）。</p>
<p>所以要想定义的 watch 能够做出预期的行为，数据源必须具备响应性或者是一个 getter ，如果只是通过 <code>let</code> 定义一个普通变量，然后去改变这个变量的值，这样是无法侦听的。</p>
<blockquote>
<p>如果要侦听响应式对象里面的某个值（这种情况下对象本身是响应式，但它的 property 不是），需要写成 getter 函数，简单的说就是需要写成有返回值的函数，这个函数 return 要侦听的数据， e.g. <code>() =&gt; foo.bar</code>。</p>
</blockquote>
<h4 id="侦听后的回调函数"><a href="#侦听后的回调函数" class="headerlink" title="侦听后的回调函数"></a>侦听后的回调函数</h4><p>在上面 API 的 TS 类型 介绍了 watch API 的组成，和数据源一样，先了解一下回调函数的定义。</p>
<p>watch API 的第 2 个参数 <code>callback</code> 是侦听到数据变化时要做出的行为，它的 TS 类型如下</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watch 第 2 个入参的 TS 类型</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">WatchCallback</span>&lt;V = <span class="built_in">any</span>, <span class="variable constant_">OV</span> = <span class="built_in">any</span>&gt; = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">value</span>: V,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">oldValue</span>: OV,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">onCleanup</span>: <span class="title class_">OnCleanup</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="built_in">any</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>乍一看它有三个参数，但实际上这些参数不是自己定义的，而是 watch API 传递的，所以不管用或者不用，它们都在那里：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">value</td>
<td align="left">变化后的新值，类型和数据源保持一致</td>
</tr>
<tr>
<td align="left">oldValue</td>
<td align="left">变化前的旧值，类型和数据源保持一致</td>
</tr>
<tr>
<td align="left">onCleanup</td>
<td align="left">注册一个清理函数</td>
</tr>
</tbody></table>
<p>注意：第一个参数是新值，第二个才是原来的旧值！</p>
<p>如同其他 JS 函数，在使用 watch 的回调函数时，可以对这三个参数任意命名，比如把 <code>value</code> 命名为觉得更容易理解的 <code>newValue</code> 。</p>
<p>另外，默认情况下，<code>watch</code> 是惰性的，也就是只有当被侦听的数据源发生变化时才执行回调。</p>
<h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><p>来到这里，对 2 个必传的参数都有一定的了解了，先看看基础的用法，也就是日常最常编写的方案，只需要先关注前 2 个必传的参数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要忘了导入要用的 API</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent, reactive, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 定义一个响应式数据</span></span><br><span class="line">    <span class="keyword">const</span> userInfo = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;Petter&#x27;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2s后改变数据</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      userInfo.<span class="property">name</span> = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以直接侦听这个响应式对象</span></span><br><span class="line"><span class="comment">     * callback 的参数如果不用可以不写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">watch</span>(userInfo, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;侦听整个 userInfo &#x27;</span>, userInfo.<span class="property">name</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 也可以侦听对象里面的某个值</span></span><br><span class="line"><span class="comment">     * 此时数据源需要写成 getter 函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">watch</span>(</span><br><span class="line">      <span class="comment">// 数据源，getter 形式</span></span><br><span class="line">      <span class="function">() =&gt;</span> userInfo.<span class="property">name</span>,</span><br><span class="line">      <span class="comment">// 回调函数 callback</span></span><br><span class="line">      <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;只侦听 name 的变化 &#x27;</span>, userInfo.<span class="property">name</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;打印变化前后的值&#x27;</span>, &#123; oldValue, newValue &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>如果有多个数据源要侦听，并且侦听到变化后要执行的行为一样，那么可以使用 批量侦听 。特殊的情况下，可以搭配 侦听的选项 做一些特殊的用法，详见下面部分的内容。</p>
<h4 id="批量侦听"><a href="#批量侦听" class="headerlink" title="批量侦听"></a>批量侦听</h4><p>如果有多个数据源要侦听，并且侦听到变化后要执行的行为一样，第一反应可能是这样来写：</p>
<ol>
<li>抽离相同的处理行为为公共函数</li>
<li>然后定义多个侦听操作，传入这个公共函数</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> message = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> index = ref&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2s后改变数据</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 来到这里才会触发 watch 的回调</span></span><br><span class="line">      message.<span class="property">value</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">      index.<span class="property">value</span>++</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽离相同的处理行为为公共函数</span></span><br><span class="line">    <span class="keyword">const</span> handleWatch = (</span><br><span class="line">      <span class="attr">newValue</span>: <span class="built_in">string</span> | <span class="built_in">number</span>,</span><br><span class="line">      <span class="attr">oldValue</span>: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">    ): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(&#123; newValue, oldValue &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后定义多个侦听操作，传入这个公共函数</span></span><br><span class="line">    <span class="title function_">watch</span>(message, handleWatch)</span><br><span class="line">    <span class="title function_">watch</span>(index, handleWatch)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样写其实没什么问题，不过除了抽离公共代码的写法之外， watch API 还提供了一个批量侦听的用法，<strong>和基础用法的区别在于，数据源和回调参数都变成了数组的形式</strong>。</p>
<ul>
<li><p>数据源：以数组的形式传入，里面每一项都是一个响应式数据。</p>
</li>
<li><p>回调数：原来的 <code>value</code> 和 <code>newValue</code> 也都变成了数组，每个数组里面的顺序和数据源数组排序一致。</p>
</li>
</ul>
<p>可以看下面的这个例子更为直观：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 定义多个数据源</span></span><br><span class="line">    <span class="keyword">const</span> message = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> index = ref&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2s后改变数据</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      message.<span class="property">value</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">      index.<span class="property">value</span>++</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">watch</span>(</span><br><span class="line">      <span class="comment">// 数据源改成了数组</span></span><br><span class="line">      [message, index],</span><br><span class="line">      <span class="comment">// 回调的入参也变成了数组，每个数组里面的顺序和数据源数组排序一致</span></span><br><span class="line">      <span class="function">(<span class="params">[newMessage, newIndex], [oldMessage, oldIndex]</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;message 的变化&#x27;</span>, &#123; newMessage, oldMessage &#125;)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;index 的变化&#x27;</span>, &#123; newIndex, oldIndex &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="watch侦听的选项"><a href="#watch侦听的选项" class="headerlink" title="watch侦听的选项"></a>watch侦听的选项</h3><p>在 API 的 TS 类型 里提到， watch API 还接受第 3 个参数 options ，可选的一些侦听选项。</p>
<p>它的 TS 类型如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watch 第 3 个入参的 TS 类型</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">interface</span> <span class="title class_">WatchOptions</span>&lt;<span class="title class_">Immediate</span> = <span class="built_in">boolean</span>&gt;</span><br><span class="line">  <span class="keyword">extends</span> <span class="title class_">WatchOptionsBase</span> &#123;</span><br><span class="line">  <span class="attr">immediate</span>?: <span class="title class_">Immediate</span></span><br><span class="line">  <span class="attr">deep</span>?: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承的 base 类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">interface</span> <span class="title class_">WatchOptionsBase</span> <span class="keyword">extends</span> <span class="title class_">DebuggerOptions</span> &#123;</span><br><span class="line">  <span class="attr">flush</span>?: <span class="string">&#x27;pre&#x27;</span> | <span class="string">&#x27;post&#x27;</span> | <span class="string">&#x27;sync&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承的 debugger 选项类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">interface</span> <span class="title class_">DebuggerOptions</span> &#123;</span><br><span class="line">  <span class="attr">onTrack</span>?: <span class="function">(<span class="params"><span class="attr">event</span>: <span class="title class_">DebuggerEvent</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  <span class="attr">onTrigger</span>?: <span class="function">(<span class="params"><span class="attr">event</span>: <span class="title class_">DebuggerEvent</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p><code>options</code> 是一个对象的形式传入，有以下几个选项：</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">类型</th>
<th align="center">默认值</th>
<th align="center">可选值</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">deep</td>
<td align="center">boolean</td>
<td align="center">false</td>
<td align="center">true | false</td>
<td align="left">是否进行深度侦听</td>
</tr>
<tr>
<td align="center">immediate</td>
<td align="center">boolean</td>
<td align="center">false</td>
<td align="center">true | false</td>
<td align="left">是否立即执行侦听回调</td>
</tr>
<tr>
<td align="center">flush</td>
<td align="center">string</td>
<td align="center">‘pre’</td>
<td align="center">‘pre’ | ‘post’ | ‘sync’</td>
<td align="left">控制侦听回调的调用时机</td>
</tr>
<tr>
<td align="center">onTrack</td>
<td align="center">(e) &#x3D;&gt; void</td>
<td align="center"></td>
<td align="center"></td>
<td align="left">在数据源被追踪时调用</td>
</tr>
<tr>
<td align="center">onTrigger</td>
<td align="center">(e) &#x3D;&gt; void</td>
<td align="center"></td>
<td align="center"></td>
<td align="left">在侦听回调被触发时调用</td>
</tr>
</tbody></table>
<p>其中 <code>onTrack</code> 和 <code>onTrigger</code> 的 <code>e</code> 是 debugger 事件，建议在回调内放置一个 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/debugger">debugger 语句</a> 以调试依赖，这两个选项仅在开发模式下生效。</p>
<p>deep 默认是 <code>false</code> ，但是在侦听 reactive 对象或数组时，会默认为 <code>true</code> 。</p>
<h4 id="侦听选项之-deep"><a href="#侦听选项之-deep" class="headerlink" title="侦听选项之 deep"></a>侦听选项之 deep</h4><p><code>deep</code> 选项接受一个布尔值，可以设置为 <code>true</code> 开启深度侦听，或者是 <code>false</code> 关闭深度侦听，默认情况下这个选项是 <code>false</code> 关闭深度侦听的，但也存在特例。</p>
<p>设置为 <code>false</code> 的情况下，如果直接侦听一个响应式的 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%AF%B9%E8%B1%A1">引用类型</a> 数据（e.g. <code>Object</code> 、 <code>Array</code> … ），虽然它的属性的值有变化，但对其本身来说是不变的，所以不会触发 watch 的 callback 。</p>
<p>下面是一个关闭了深度侦听的例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 定义一个响应式数据，注意用的是 ref 来定义</span></span><br><span class="line">    <span class="keyword">const</span> nums = ref&lt;<span class="built_in">number</span>[]&gt;([])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2s后给这个数组添加项目</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      nums.<span class="property">value</span>.<span class="title function_">push</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 可以打印一下，确保数据确实变化了</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;修改后&#x27;</span>, nums.<span class="property">value</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但是这个 watch 不会按预期执行</span></span><br><span class="line">    <span class="title function_">watch</span>(</span><br><span class="line">      nums,</span><br><span class="line">      <span class="comment">// 这里的 callback 不会被触发</span></span><br><span class="line">      <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发侦听&#x27;</span>, nums.<span class="property">value</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 因为关闭了 deep</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">deep</span>: <span class="literal">false</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>类似这种情况，需要把 <code>deep</code> 设置为 <code>true</code> 才可以触发侦听。</p>
<p>可以看到上面的例子特地用了ref API，这是因为通过 reactive API义的对象无法将 <code>deep</code> 成功设置为 <code>false</code> （这一点在目前的官网文档未找到说明，最终是在 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/vuejs/core/blob/main/packages/runtime-core/src/apiWatch.ts#L212">watch API 的源码</a> 上找到了答案）。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isReactive</span>(source)) &#123;</span><br><span class="line">  getter = <span class="function">() =&gt;</span> source</span><br><span class="line">  deep = <span class="literal">true</span> <span class="comment">// 被强制开启了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>这个情况就是上面所说的 “特例” ，可以通过 <code>isReactive</code> API 来判断是否需要手动开启深度侦听。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 isReactive API</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent, isReactive, reactive, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 侦听这个数据时，会默认开启深度侦听</span></span><br><span class="line">    <span class="keyword">const</span> foo = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;Petter&#x27;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(foo)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 侦听这个数据时，不会默认开启深度侦听</span></span><br><span class="line">    <span class="keyword">const</span> bar = <span class="title function_">ref</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;Petter&#x27;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(bar)) <span class="comment">// false</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="侦听选项之-immediate"><a href="#侦听选项之-immediate" class="headerlink" title="侦听选项之 immediate"></a>侦听选项之 immediate</h4><p> watch 默认是惰性的，也就是只有当被侦听的数据源发生变化时才执行回调。</p>
<p>这句话是什么意思呢？来看一下这段代码，为了减少deep选项的干扰，换一个类型，换成 <code>string</code> 数据来演示，请留意注释：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 这个时候不会触发 watch 的回调</span></span><br><span class="line">    <span class="keyword">const</span> message = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2s后改变数据</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 来到这里才会触发 watch 的回调</span></span><br><span class="line">      message.<span class="property">value</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">watch</span>(message, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发侦听&#x27;</span>, message.<span class="property">value</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以看到，数据在初始化的时候并不会触发侦听回调，如果有需要的话，通过 <code>immediate</code> 选项来让它直接触发。</p>
<p><code>immediate</code> 选项接受一个布尔值，默认是 <code>false</code> ，<strong>可以设置为 <code>true</code> 让回调立即执行</strong>。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 这一次在这里可以会触发 watch 的回调了</span></span><br><span class="line">    <span class="keyword">const</span> message = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2s后改变数据</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 这一次，这里是第二次触发 watch 的回调，不再是第一次</span></span><br><span class="line">      message.<span class="property">value</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">watch</span>(</span><br><span class="line">      message,</span><br><span class="line">      <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发侦听&#x27;</span>, message.<span class="property">value</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 设置 immediate 选项</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意，在带有 immediate 选项时，不能在第一次回调时取消该数据源的侦听。</p>
<h4 id="侦听选项之-flush"><a href="#侦听选项之-flush" class="headerlink" title="侦听选项之 flush"></a>侦听选项之 flush</h4><p><code>flush</code> 选项是用来控制[侦听回调的调用时机，接受指定的字符串，可选值如下，默认是 <code>&#39;pre&#39;</code> 。</p>
<table>
<thead>
<tr>
<th align="center">可选值</th>
<th align="left">回调的调用时机</th>
<th align="left">使用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">‘pre’</td>
<td align="left">将在渲染前被调用</td>
<td align="left">允许回调在模板运行前更新了其他值</td>
</tr>
<tr>
<td align="center">‘sync’</td>
<td align="left">在渲染时被同步调用</td>
<td align="left">目前来说没什么好处，可以了解但不建议用…</td>
</tr>
<tr>
<td align="center">‘post’</td>
<td align="left">被推迟到渲染之后调用</td>
<td align="left">如果要通过 ref 操作 DOM 元素与子组件 ，需要使用这个值来启用该选项，以达到预期的执行效果</td>
</tr>
</tbody></table>
<p>对于 <code>&#39;pre&#39;</code> 和 <code>&#39;post&#39;</code> ，回调使用队列进行缓冲。回调只被添加到队列中一次。</p>
<p>即使观察值变化了多次，值的中间变化将被跳过，不会传递给回调，这样做不仅可以提高性能，还有助于保证数据的一致性。</p>
<p>更多关于 flush 的信息，请参阅 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://cn.vuejs.org/guide/essentials/watchers.html#callback-flush-timing">回调的触发时机</a> 。</p>
<h4 id="停止侦听"><a href="#停止侦听" class="headerlink" title="停止侦听"></a>停止侦听</h4><p>如果在 setup或者script-setup里使用 watch 的话， 组件被卸载的时候也会一起被停止，一般情况下不太需要关心如何停止侦听。</p>
<p>不过有时候可能想要手动取消， Vue 3 也提供了方法。</p>
<blockquote>
<p>随着组件被卸载一起停止的前提是，侦听器必须是 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Introducing#%E5%90%8C%E6%AD%A5javascript">同步语句</a> 创建的，这种情况下侦听器会绑定在当前组件上。</p>
<p>如果放在 <code>setTimeout</code> 等 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Introducing#%E5%BC%82%E6%AD%A5javascript">异步函数</a> 里面创建，则不会绑定到当前组件，因此组件卸载的时候不会一起停止该侦听器，这种时候就需要手动停止侦听。</p>
</blockquote>
<p>当在定义一个 watch 行为的时候，它会返回一个用来停止侦听的函数。这个函数的 TS 类型如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">WatchStopHandle</span> = <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br></pre></td></tr></table></figure>

<p>用法很简单，做一下简单了解即可：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个取消观察的变量，它是一个函数</span></span><br><span class="line"><span class="keyword">const</span> unwatch = <span class="title function_">watch</span>(message, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在合适的时期调用它，可以取消这个侦听</span></span><br><span class="line"><span class="title function_">unwatch</span>()</span><br></pre></td></tr></table></figure>

<p>但是也有一点需要注意的是，如果启用了immediate 选项，不能在第一次触发侦听回调时执行它。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：这是一段错误的代码，运行会报错</span></span><br><span class="line"><span class="keyword">const</span> unwatch = <span class="title function_">watch</span>(</span><br><span class="line">  message,</span><br><span class="line">  <span class="comment">// 侦听的回调</span></span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 在这里调用会有问题 ❌</span></span><br><span class="line">    <span class="title function_">unwatch</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 启用 immediate 选项</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>会收获一段报错，告诉 <code>unwatch</code> 这个变量在初始化前无法被访问：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught ReferenceError: Cannot access <span class="string">&#x27;unwatch&#x27;</span> before initialization</span><br></pre></td></tr></table></figure>

<p>目前有两种方案可以让实现这个操作：</p>
<p>方案一：使用 <code>var</code> 并判断变量类型，利用 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var#%E6%8F%8F%E8%BF%B0">var 的变量提升</a> 来实现目的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里改成 var ，不要用 const 或 let</span></span><br><span class="line"><span class="keyword">var</span> unwatch = <span class="title function_">watch</span>(</span><br><span class="line">  message,</span><br><span class="line">  <span class="comment">// 侦听回调</span></span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里加一个判断，是函数才执行它</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> unwatch === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">unwatch</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 侦听选项</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>不过 <code>var</code> 已经属于过时的语句了，建议用方案二的 <code>let</code> 。</p>
<p>方案二：使用 <code>let</code> 并判断变量类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果不想用 any ，可以导入 TS 类型</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">WatchStopHandle</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里改成 let ，但是要另起一行，先定义，再赋值</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">unwatch</span>: <span class="title class_">WatchStopHandle</span></span><br><span class="line">unwatch = <span class="title function_">watch</span>(</span><br><span class="line">  message,</span><br><span class="line">  <span class="comment">// 侦听回调</span></span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里加一个判断，是函数才执行它</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> unwatch === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">unwatch</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 侦听选项</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="侦听效果清理"><a href="#侦听效果清理" class="headerlink" title="侦听效果清理"></a>侦听效果清理</h4><p>在 侦听后的回调函数部分提及到一个参数 <code>onCleanup</code> ，它可以帮注册一个清理函数。</p>
<p>有时 watch 的回调会执行异步操作，当 watch 到数据变更的时候，需要取消这些操作，这个函数的作用就用于此，会在以下情况调用这个清理函数：</p>
<ul>
<li>watcher 即将重新运行的时候</li>
<li>watcher 被停止（组件被卸载或者被手动停止侦听）</li>
</ul>
<p>TS 类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">OnCleanup</span> = <span class="function">(<span class="params"><span class="attr">cleanupFn</span>: () =&gt; <span class="built_in">void</span></span>) =&gt;</span> <span class="built_in">void</span></span><br></pre></td></tr></table></figure>

<p>用法方面比较简单，传入一个回调函数运行即可，不过需要注意的是，需要在停止侦听之前注册好清理行为，否则不会生效。</p>
<p>在停止侦听里的最后一个 immediate 例子的基础上继续添加代码，请注意注册的时机：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let unwatch: WatchStopHandle</span><br><span class="line">unwatch = watch(</span><br><span class="line">  message,</span><br><span class="line">  (newValue, oldValue, onCleanup) =&gt; &#123;</span><br><span class="line">    // 需要在停止侦听之前注册好清理行为</span><br><span class="line">    onCleanup(() =&gt; &#123;</span><br><span class="line">      console.log(&#x27;侦听清理ing&#x27;)</span><br><span class="line">      // 根据实际的业务情况定义一些清理操作 ...</span><br><span class="line">    &#125;)</span><br><span class="line">    // 然后再停止侦听</span><br><span class="line">    if (typeof unwatch === &#x27;function&#x27;) &#123;</span><br><span class="line">      unwatch()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    immediate: true,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><p>如果一个函数里包含了多个需要侦听的数据，一个一个数据去侦听太麻烦了，在 Vue 3 ，可以直接使用 watchEffect API 来简化的操作。</p>
<h4 id="API-的-TS-类型-1"><a href="#API-的-TS-类型-1" class="headerlink" title="API 的 TS 类型"></a>API 的 TS 类型</h4><p>这个 API 的类型如下，使用的时候需要传入一个副作用函数（相当于 watch 的 侦听后的回调函数），也可以根据的实际情况传入一些可选的侦听选项 。</p>
<p>和 watch API 一样，它也会返回一个用于停止侦听 的函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watchEffect 部分的 TS 类型</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">WatchEffect</span> = <span class="function">(<span class="params"><span class="attr">onCleanup</span>: <span class="title class_">OnCleanup</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">watchEffect</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">effect</span>: <span class="title class_">WatchEffect</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">options</span>?: <span class="title class_">WatchOptionsBase</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">WatchStopHandle</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>副作用函数也会传入一个清理回调作为参数，和 watch 的 侦听效果清理一样的用法。可以理解为它是一个简化版的 watch ，具体简化在哪里呢？请看下面的用法示例。</p>
<h4 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h4><p>它立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref, watchEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 单独定义两个数据，后面用来分开改变数值</span></span><br><span class="line">    <span class="keyword">const</span> name = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;Petter&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> age = ref&lt;<span class="built_in">number</span>&gt;(<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个调用这两个数据的函数</span></span><br><span class="line">    <span class="keyword">const</span> getUserInfo = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: name.<span class="property">value</span>,</span><br><span class="line">        <span class="attr">age</span>: age.<span class="property">value</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2s后改变第一个数据</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      name.<span class="property">value</span> = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4s后改变第二个数据</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      age.<span class="property">value</span> = <span class="number">20</span></span><br><span class="line">    &#125;, <span class="number">4000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接侦听调用函数，在每个数据产生变化的时候，它都会自动执行</span></span><br><span class="line">    <span class="title function_">watchEffect</span>(getUserInfo)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="和-watch-的区别"><a href="#和-watch-的区别" class="headerlink" title="和 watch 的区别"></a>和 watch 的区别</h4><p>虽然理论上 <code>watchEffect</code> 是 <code>watch</code> 的一个简化操作，可以用来代替 批量侦听 ，但它们也有一定的区别：</p>
<ol>
<li><code>watch</code> 可以访问侦听状态变化前后的值，而 <code>watchEffect</code> 没有。</li>
<li><code>watch</code> 是在属性改变的时候才执行，而 <code>watchEffect</code> 则默认会执行一次，然后在属性改变的时候也会执行。</li>
</ol>
<p>第二点的意思，看下面这段代码可以有更直观的理解：</p>
<p>使用 watch ：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> foo = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      foo.<span class="property">value</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">value</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 watch 需要先手动执行一次</span></span><br><span class="line">    <span class="title function_">bar</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后当 foo 有变动时，才会通过 watch 来执行 bar()</span></span><br><span class="line">    <span class="title function_">watch</span>(foo, bar)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用 watchEffect ：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> foo = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      foo.<span class="property">value</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">value</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以通过 watchEffect 实现 bar() + watch(foo, bar) 的效果</span></span><br><span class="line">    <span class="title function_">watchEffect</span>(bar)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="可用的侦听选项"><a href="#可用的侦听选项" class="headerlink" title="可用的侦听选项"></a>可用的侦听选项</h4><p>虽然用法和 watch 类似，但也简化了一些选项，它的侦听选项 TS 类型如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只支持 base 类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">interface</span> <span class="title class_">WatchOptionsBase</span> <span class="keyword">extends</span> <span class="title class_">DebuggerOptions</span> &#123;</span><br><span class="line">  <span class="attr">flush</span>?: <span class="string">&#x27;pre&#x27;</span> | <span class="string">&#x27;post&#x27;</span> | <span class="string">&#x27;sync&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承的 debugger 选项类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">interface</span> <span class="title class_">DebuggerOptions</span> &#123;</span><br><span class="line">  <span class="attr">onTrack</span>?: <span class="function">(<span class="params"><span class="attr">event</span>: <span class="title class_">DebuggerEvent</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  <span class="attr">onTrigger</span>?: <span class="function">(<span class="params"><span class="attr">event</span>: <span class="title class_">DebuggerEvent</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>对比 watch API ，它不支持deep和 immediate，请记住这一点，其他的用法是一样的。</p>
<h3 id="watchPostEffect"><a href="#watchPostEffect" class="headerlink" title="watchPostEffect"></a>watchPostEffect</h3><p>watchEffec API 使用 <code>flush: &#39;post&#39;</code> 选项时的别名</p>
<blockquote>
<p>TIP Vue v3.2.0 及以上版本才支持该 API 。</p>
</blockquote>
<h3 id="watchSyncEffe"><a href="#watchSyncEffe" class="headerlink" title="watchSyncEffe"></a>watchSyncEffe</h3><p>watchEffect API 使用 <code>flush: &#39;sync&#39;</code> 选项时的别名。</p>
<blockquote>
<p>TIP  Vue v3.2.0 及以上版本才支持该 API 。</p>
</blockquote>
<h2 id="数据的计算"><a href="#数据的计算" class="headerlink" title="数据的计算"></a>数据的计算</h2><p>和 Vue 2.0 一样，数据的计算也是使用 <code>computed</code> API ，它可以通过现有的响应式数据，去通过计算得到新的响应式变量，用过 Vue 2.0 的开发者应该不会太陌生，但是在 Vue 3.0 ，在使用方式上也是变化非常大！</p>
<blockquote>
<p>TIP 这里的响应式数据，可以简单理解为通过 ref API 、 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://vue3.chengpeiquan.com/component.html#%E5%93%8D%E5%BA%94%E5%BC%8F-api-%E4%B9%8B-reactive-new">reactive</a> API 定义出来的数据，当然 Vuex 、Vue Router 等 Vue 数据也都具备响应式，可以在 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://vue3.chengpeiquan.com/component.html#%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E5%8C%96-new">响应式数据的变化</a> 了解。</p>
</blockquote>
<h3 id="用法变化"><a href="#用法变化" class="headerlink" title="用法变化"></a>用法变化</h3><p>先从一个简单的用例来看看在 Vue 新旧版本的用法区别：</p>
<p>假设定义了两个分开的数据 <code>firstName</code> 名字和 <code>lastName</code> 姓氏，但是在 template 展示时，需要展示完整的姓名，那么就可以通过 <code>computed</code> 来计算一个新的数据：</p>
<h4 id="回顾-Vue-2-3"><a href="#回顾-Vue-2-3" class="headerlink" title="回顾 Vue 2"></a>回顾 Vue 2</h4><p>在 Vue 2.0 ，<code>computed</code> 和 <code>data</code> 在同级配置，并且不可以和 <code>data</code> 里的数据同名重复定义：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Vue 2 的写法：</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">firstName</span>: <span class="string">&#x27;Bill&#x27;</span>,</span><br><span class="line">      <span class="attr">lastName</span>: <span class="string">&#x27;Gates&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 注意这里定义的变量，都要通过函数的形式来返回它的值</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">// 普通函数可以直接通过熟悉的 this 来拿到 data 里的数据</span></span><br><span class="line">    <span class="title function_">fullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.lastName&#125;</span>`</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 箭头函数则需要通过参数来拿到实例上的数据</span></span><br><span class="line">    <span class="attr">fullName2</span>: <span class="function">(<span class="params">vm</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;vm.firstName&#125;</span> <span class="subst">$&#123;vm.lastName&#125;</span>`</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在需要用到全名的地方，只需要通过 <code>this.fullName</code> 就可以得到 <code>Bill Gates</code> 。</p>
<h4 id="了解-Vue-3-3"><a href="#了解-Vue-3-3" class="headerlink" title="了解 Vue 3"></a>了解 Vue 3</h4><p>在 Vue 3.0 ，跟其他 API 的用法一样，需要先导入 <code>computed</code> 才能使用：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Vue 3 的写法：</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 定义基本的数据</span></span><br><span class="line">    <span class="keyword">const</span> firstName = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;Bill&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> lastName = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;Gates&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义需要计算拼接结果的数据</span></span><br><span class="line">    <span class="keyword">const</span> fullName = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> <span class="string">`<span class="subst">$&#123;firstName.value&#125;</span> <span class="subst">$&#123;lastName.value&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2s 后改变某个数据的值</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      firstName.<span class="property">value</span> = <span class="string">&#x27;Petter&#x27;</span></span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// template 那边在 2s 后也会显示为 Petter Gates</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      fullName,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以把这个用法简单的理解为，传入一个回调函数，并 <code>return</code> 一个值，对，它需要有明确的返回值。</p>
<blockquote>
<p>需要注意的是：</p>
<ol>
<li>定义出来的 <code>computed</code> 变量，和 Ref 变量的用法一样，也是需要通过 <code>.value</code> 才能拿到它的值</li>
<li>但是区别在于，默认情况下 <code>computed</code> 的 <code>value</code> 是只读的</li>
</ol>
</blockquote>
<h3 id="类型声明-1"><a href="#类型声明-1" class="headerlink" title="类型声明"></a>类型声明</h3><p>之前说过，在defineComponent里，会自动帮推导 Vue API 的类型，所以一般情况下，是不需要显式的去定义 <code>computed</code> 出来的变量类型的。</p>
<p>在确实需要手动指定的情况下，也可以导入它的类型然后定义：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">ComputedRef</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里添加了类型声明</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">fullName</span>: <span class="title class_">ComputedRef</span>&lt;<span class="built_in">string</span>&gt; = <span class="title function_">computed</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="string">`<span class="subst">$&#123;firstName.value&#125;</span> <span class="subst">$&#123;lastName.value&#125;</span>`</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>要返回一个字符串，就写 <code>ComputedRef&lt;string&gt;</code> ；返回布尔值，就写 <code>ComputedRef&lt;boolean&gt;</code> ；返回一些复杂对象信息，可以先定义好的类型，再诸如 <code>ComputedRef&lt;UserInfo&gt;</code> 去写。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是 ComputedRef 的类型声明：</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">interface</span> <span class="title class_">ComputedRef</span>&lt;T = <span class="built_in">any</span>&gt; <span class="keyword">extends</span> <span class="title class_">WritableComputedRef</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">value</span>: T</span><br><span class="line">  [<span class="title class_">ComoutedRefSymbol</span>]: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="优势对比和注意事项"><a href="#优势对比和注意事项" class="headerlink" title="优势对比和注意事项"></a>优势对比和注意事项</h3><p>在继续往下看之前，先来了解一下这个 API 的一些优势和注意事项（如果在 Vue 2 已经有接触过的话，可以跳过这一段，因为优势和需要注意的东西比较一致）。</p>
<h4 id="优势对比"><a href="#优势对比" class="headerlink" title="优势对比"></a>优势对比</h4><p>看到这里，相信刚接触的开发者可能会有疑问，既然 <code>computed</code> 也是通过一个函数来返回值，那么和普通的 <code>function</code> 有什么区别，或者说优势？</p>
<ol>
<li>性能优势<ul>
<li>这一点在 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://cn.vuejs.org/guide/essentials/computed.html#computed-caching-vs-methods">官网文档</a> 其实是有提到的：数据的计算是基于它们的响应依赖关系缓存的，<strong>只在相关响应式依赖发生改变时它们才会重新求值。</strong></li>
<li>也就是说，只要原始数据没有发生改变，多次访问 <code>computed</code> ，都是会立即返回之前的计算结果，而不是再次执行函数；而普通的 <code>function</code> 调用多少次就执行多少次，每调用一次就计算一次。</li>
<li>至于为何要如此设计，官网文档也给出了原因：为什么需要缓存？假设有一个性能开销比较大的计算数据 list，它需要遍历一个巨大的数组并做大量的计算。然后可能有其他的计算数据依赖于 list。如果没有缓存，将不可避免地多次执行 list 的 getter！如果不希望有缓存，请用function 来替代。</li>
</ul>
</li>
<li>书写统一<ul>
<li>假定 foo1 是 Ref 变量， foo2 是 <code>computed</code> 变量， foo3 是普通函数返回值</li>
<li>看到这里的开发者应该都已经清楚 Vue 3 的 Ref 变量是通过 <code>foo1.value</code> 来拿到值的，而 <code>computed</code> 也是通过 <code>foo2.value</code> ，并且在 template 里都可以省略 <code>.value</code> ，在读取方面，他们是有一致的风格和简洁性。</li>
<li>而 foo3 不管是在 script 还是 template ，都需要通过 <code>foo3()</code> 才能拿到结果，相对来说会有那么一丢丢别扭。</li>
</ul>
</li>
</ol>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>有优势当然也就有一定的 “劣势” ，当然这也是 Vue 框架的有意为之，所以在使用上也需要注意一些问题：</p>
<ol>
<li><p><strong>只会更新响应式数据的计算</strong></p>
<ul>
<li><p>假设要获取当前的时间信息，因为不是响应式数据，所以这种情况下就需要用普通的函数去获取返回值，才能拿到最新的时间。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nowTime = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nowTime.<span class="property">value</span>)</span><br><span class="line"><span class="comment">// 输出 Sun Nov 14 2021 21:07:00 GMT+0800 (GMT+08:00)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2s 后依然是跟上面一样的结果</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(nowTime.<span class="property">value</span>)</span><br><span class="line">  <span class="comment">// 还是输出 Sun Nov 14 2021 21:07:00 GMT+0800 (GMT+08:00)</span></span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>数据是只读的</strong></p>
<ul>
<li><p>通过 computed 定义的数据，它是只读的，这一点在类型声明已经有所了解。</p>
</li>
<li><p>如果直接赋值，不仅无法变更数据，而且会收获一个报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">TS2540</span>: <span class="title class_">Cannot</span> assign to <span class="string">&#x27;value&#x27;</span> because it is a read-only property.</span><br></pre></td></tr></table></figure>
</li>
<li><p>虽然无法直接赋值，但是在必要的情况下，依然可以通过 <code>computed</code> 的 <code>setter</code> 来更新数据。</p>
</li>
</ul>
</li>
</ol>
<h3 id="setter-的使用"><a href="#setter-的使用" class="headerlink" title="setter 的使用"></a>setter 的使用</h3><p>通过 computed 定义的变量默认都是只读的形式（只有一个 getter ），但是在必要的情况下，也可以使用其 setter 属性来更新数据。</p>
<h4 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h4><p>当需要用到 setter 的时候， <code>computed</code> 就不再是一个传入 callback 的形式了，而是传入一个带有 2 个方法的对象。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里computed接收的入参已经不再是函数</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="title function_">computed</span>(&#123;</span><br><span class="line">  <span class="comment">// 这里需要明确的返回一个值</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 这里接收一个参数，代表修改 foo 时，赋值下来的新值</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里的 <code>get</code> 就是 <code>computed</code> 的 getter ，跟原来传入 callback 的形式一样，用于 <code>foo.value</code> 的读取，所以这里必须有明确的返回值。</p>
<p>这里的 <code>set</code> 就是 <code>computed</code> 的 setter ，它会接收一个参数，代表新的值，当通过 <code>foo.value = xxx</code> 赋值的时候，赋入的这个值，就会通过这个入参传递进来，可以根据的业务需要，把这个值赋给相关的数据源。</p>
<blockquote>
<p>TIP 请注意，必须使用 <code>get</code> 和 <code>set</code> 这 2 个方法名，也只接受这 2 个方法。</p>
</blockquote>
<h4 id="使用示范"><a href="#使用示范" class="headerlink" title="使用示范"></a>使用示范</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 还是这2个数据源</span></span><br><span class="line"><span class="keyword">const</span> firstName = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;Bill&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> lastName = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;Gates&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里配合setter的需要，改成了另外一种写法</span></span><br><span class="line"><span class="keyword">const</span> fullName = <span class="title function_">computed</span>(&#123;</span><br><span class="line">  <span class="comment">// getter还是返回一个拼接起来的全名</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstName.value&#125;</span> <span class="subst">$&#123;lastName.value&#125;</span>`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// setter这里改成只更新firstName，注意参数也定义TS类型</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params"><span class="attr">newFirstName</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    firstName.<span class="property">value</span> = newFirstName</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fullName.<span class="property">value</span>) <span class="comment">// 输出 Bill Gates</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2s后更新一下数据</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 对fullName的赋值，其实更新的是firstName</span></span><br><span class="line">  fullName.<span class="property">value</span> = <span class="string">&#x27;Petter&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此时firstName已经得到了更新</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(firstName.<span class="property">value</span>) <span class="comment">// 会输出 Petter</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当然，由于firstName变化了，所以fullName的getter也会得到更新</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(fullName.<span class="property">value</span>) <span class="comment">// 会输出 Petter Gates</span></span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>

<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>计算 API 的作用，官网文档只举了一个非常简单的例子，那么在实际项目中，什么情况下用它会让更方便呢？</p>
<p>简单举几个比较常见的例子吧，加深一下对 <code>computed</code> 的理解。</p>
<h4 id="数据的拼接和计算"><a href="#数据的拼接和计算" class="headerlink" title="数据的拼接和计算"></a>数据的拼接和计算</h4><p>如上面的案例，与其每个用到的地方都要用到 <code>firstName + &#39; &#39; + lastName</code> 这样的多变量拼接，不如用一个 <code>fullName</code> 来的简单。</p>
<p>当然，不止是字符串拼接，数据的求和等操作更是合适，比如说做一个购物车，购物车里有商品列表，同时还要显示购物车内的商品总金额，这种情况就非常适合用计算数据。</p>
<h4 id="复用组件的动态数据"><a href="#复用组件的动态数据" class="headerlink" title="复用组件的动态数据"></a>复用组件的动态数据</h4><p>在一个项目里，很多时候组件会涉及到复用，比如说：“首页的文章列表 vs 列表页的文章列表 vs 作者详情页的文章列表” ，特别常见于新闻网站等内容资讯站点，这种情况下，往往并不需要每次都重新写 UI 、数据渲染等代码，仅仅是接口 URL 的区别。</p>
<p>这种情况就可以通过路由名称来动态获取要调用哪个列表接口：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个根据路由名称来获取接口URL的计算数据</span></span><br><span class="line"><span class="keyword">const</span> apiUrl = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (route.<span class="property">name</span>) &#123;</span><br><span class="line">    <span class="comment">// 首页</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;home&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;/api/list1&#x27;</span></span><br><span class="line">    <span class="comment">// 列表页</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;list&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;/api/list2&#x27;</span></span><br><span class="line">    <span class="comment">// 作者页</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;author&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;/api/list3&#x27;</span></span><br><span class="line">    <span class="comment">// 默认是随机列表</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;/api/random&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求列表</span></span><br><span class="line"><span class="keyword">const</span> getArticleList = <span class="title function_">async</span> (): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  articleList.<span class="property">value</span> = <span class="keyword">await</span> <span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: apiUrl.<span class="property">value</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这种情况也可以在父组件通过 <code>props</code> 传递接口 URL 。</p>
<h4 id="获取多级对象的值"><a href="#获取多级对象的值" class="headerlink" title="获取多级对象的值"></a>获取多级对象的值</h4><p>经常遇到这样的情况：要在 template 显示一些多级对象的字段，而某些字段不一定有，需要做一些判断。虽然有 <code>v-if</code> ，但是嵌套层级一多，模板代码会难以维护。</p>
<p>如果把这些工作量转移给计算数据，结合 <code>try / catch</code> ，就无需在 template 里处理很多判断了。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子比较极端，但在 Vuex 这种大型数据树上，也不是完全不可能存在</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 正常情况下返回需要的数据</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> store.<span class="property">state</span>.<span class="property">foo3</span>.<span class="property">foo2</span>.<span class="property">foo1</span>.<span class="property">foo</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 处理失败则返回一个默认值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样在 template 里要拿到 foo 的值，完全不需要关心中间一级又一级的字段是否存在，只需要区分是不是默认值。</p>
<h4 id="不同类型的数据转换"><a href="#不同类型的数据转换" class="headerlink" title="不同类型的数据转换"></a>不同类型的数据转换</h4><p>有时候会遇到一些需求，类似于：让用户在输入框里按一定的格式填写文本，比如用英文逗号 <code>,</code> 隔开每个词，然后保存时用数组的格式提交给接口。</p>
<p>这个时候 <code>computed</code> 的 setter 就发挥妙用了，只需要一个简单的 <code>computed</code> ，就可以代替 <code>input</code> 的 <code>change</code> 事件或者 <code>watch</code> 侦听，可以减少很多业务代码的编写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    type=&quot;text&quot;</span><br><span class="line">    v-model=&quot;tagsStr&quot;</span><br><span class="line">    placeholder=&quot;请输入标签，多个标签用英文逗号隔开&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, computed, ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    // 这个是最终要用到的数组</span><br><span class="line">    const tags = ref&lt;string[]&gt;([])</span><br><span class="line"></span><br><span class="line">    // 因为input必须绑定一个字符串</span><br><span class="line">    const tagsStr = computed(&#123;</span><br><span class="line">      // 所以通过getter来转成字符串</span><br><span class="line">      get() &#123;</span><br><span class="line">        return tags.value.join(&#x27;,&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">      // 然后在用户输入的时候，切割字符串转换回数组</span><br><span class="line">      set(newValue: string) &#123;</span><br><span class="line">        tags.value = newValue.split(&#x27;,&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      tagsStr,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>所以在实际业务开发中，开发者可以多考虑一下是否可以使用 <code>computed</code> 代替 <code>watch</code> ，避免过多的数组侦听带来项目性能的下降。</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令是 Vue 模板语法里的特殊标记，在使用上和 HTML 的 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/data-*">data-*</a> 属性十分相似，统一以 <code>v-</code> 开头（ e.g. <code>v-html</code> ）。</p>
<p>它以简单的方式实现了常用的 JavaScript 表达式功能，当表达式的值改变的时候，响应式地作用到 DOM 上。</p>
<h3 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a>内置指令</h3><p>Vue 提供了一些内置指令可以直接使用，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 渲染一段文本 --&gt;</span><br><span class="line">  &lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 渲染一段 HTML --&gt;</span><br><span class="line">  &lt;div v-html=&quot;html&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 循环创建一个列表 --&gt;</span><br><span class="line">  &lt;ul v-if=&quot;items.length&quot;&gt;</span><br><span class="line">    &lt;li v-for=&quot;(item, index) in items&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">      &lt;span&gt;&#123;&#123; item &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 一些事件（ `@` 等价于 `v-on` ） --&gt;</span><br><span class="line">  &lt;button @click=&quot;hello&quot;&gt;Hello&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const msg = ref&lt;string&gt;(&#x27;Hello World!&#x27;)</span><br><span class="line">    const html = ref&lt;string&gt;(&#x27;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;)</span><br><span class="line">    const items = ref&lt;string[]&gt;([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;])</span><br><span class="line"></span><br><span class="line">    function hello() &#123;</span><br><span class="line">      console.log(msg.value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      msg,</span><br><span class="line">      html,</span><br><span class="line">      items,</span><br><span class="line">      hello,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>内置指令在使用上都非常的简单，可以在官方文档的 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://cn.vuejs.org/api/built-in-directives.html">内置指令</a> 一章查询完整的指令列表和用法，在模板上使用时，请了解 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://cn.vuejs.org/guide/essentials/template-syntax.html#directives">指令的模板语法</a> 。</p>
<blockquote>
<p>TIP：有两个指令可以使用别名：</p>
<ul>
<li><code>v-on</code> 的别名是 <code>@</code> ，使用 <code>@click</code> 等价于 <code>v-on:click</code></li>
<li><code>v-bind</code> 的别名是 <code>:</code> ，使用 <code>:src</code> 等价于 <code>v-bind:src</code></li>
</ul>
</blockquote>
<h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>如果 Vue 的内置指令不能满足业务需求，还可以开发自定义指令。</p>
<h4 id="相关的-TS-类型"><a href="#相关的-TS-类型" class="headerlink" title="相关的 TS 类型"></a>相关的 TS 类型</h4><p>在开始编写代码之前，先了解一下自定义指令相关的 TypeScript 类型。</p>
<p>自定义指令有两种实现形式，一种是作为一个对象，其中的写法比较接近于 Vue 组件，除了 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://cn.vuejs.org/guide/scaling-up/ssr.html#custom-directives">getSSRProps</a> 和 deep 选项外，其他的每一个属性都是一个 钩子函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象式写法的 TS 类型</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">interface</span> <span class="title class_">ObjectDirective</span>&lt;T = <span class="built_in">any</span>, V = <span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  <span class="attr">created</span>?: <span class="title class_">DirectiveHook</span>&lt;T, <span class="literal">null</span>, V&gt;</span><br><span class="line">  <span class="attr">beforeMount</span>?: <span class="title class_">DirectiveHook</span>&lt;T, <span class="literal">null</span>, V&gt;</span><br><span class="line">  <span class="attr">mounted</span>?: <span class="title class_">DirectiveHook</span>&lt;T, <span class="literal">null</span>, V&gt;</span><br><span class="line">  <span class="attr">beforeUpdate</span>?: <span class="title class_">DirectiveHook</span>&lt;T, <span class="title class_">VNode</span>&lt;<span class="built_in">any</span>, T&gt;, V&gt;</span><br><span class="line">  <span class="attr">updated</span>?: <span class="title class_">DirectiveHook</span>&lt;T, <span class="title class_">VNode</span>&lt;<span class="built_in">any</span>, T&gt;, V&gt;</span><br><span class="line">  <span class="attr">beforeUnmount</span>?: <span class="title class_">DirectiveHook</span>&lt;T, <span class="literal">null</span>, V&gt;</span><br><span class="line">  <span class="attr">unmounted</span>?: <span class="title class_">DirectiveHook</span>&lt;T, <span class="literal">null</span>, V&gt;</span><br><span class="line">  <span class="attr">getSSRProps</span>?: <span class="title class_">SSRDirectiveHook</span></span><br><span class="line">  <span class="attr">deep</span>?: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>另外一种是函数式写法，只需要定义成一个函数，但这种写法只在 <code>mounted</code> 和 <code>updated</code> 这两个钩子生效，并且触发一样的行为。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数式写法的 TS 类型</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">FunctionDirective</span>&lt;T = <span class="built_in">any</span>, V = <span class="built_in">any</span>&gt; = <span class="title class_">DirectiveHook</span>&lt;</span><br><span class="line">  T,</span><br><span class="line">  <span class="built_in">any</span>,</span><br><span class="line">  V</span><br><span class="line">&gt;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>这是每个钩子函数对应的类型，它有 4 个入参：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 钩子函数的 TS 类型</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">DirectiveHook</span>&lt;</span><br><span class="line">  T = <span class="built_in">any</span>,</span><br><span class="line">  <span class="title class_">Prev</span> = <span class="title class_">VNode</span>&lt;<span class="built_in">any</span>, T&gt; | <span class="literal">null</span>,</span><br><span class="line">  V = <span class="built_in">any</span></span><br><span class="line">&gt; = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">el</span>: T,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">binding</span>: <span class="title class_">DirectiveBinding</span>&lt;V&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">vnode</span>: <span class="title class_">VNode</span>&lt;<span class="built_in">any</span>, T&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">prevVNode</span>: <span class="title class_">Prev</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>钩子函数第二个参数的类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 钩子函数第二个参数的 TS 类型</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">interface</span> <span class="title class_">DirectiveBinding</span>&lt;V = <span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  <span class="attr">instance</span>: <span class="title class_">ComponentPublicInstance</span> | <span class="literal">null</span></span><br><span class="line">  <span class="attr">value</span>: V</span><br><span class="line">  <span class="attr">oldValue</span>: V | <span class="literal">null</span></span><br><span class="line">  <span class="attr">arg</span>?: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">modifiers</span>: <span class="title class_">DirectiveModifiers</span></span><br><span class="line">  <span class="attr">dir</span>: <span class="title class_">ObjectDirective</span>&lt;<span class="built_in">any</span>, V&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>可以看到自定义指令最核心的就是 “钩子函数” 了，接下来来了解这部分的知识点。</p>
<h4 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h4><p>和 组件的生命周期 类似，自定义指令里的逻辑代码也有一些特殊的调用时机，在这里称之为钩子函数：</p>
<table>
<thead>
<tr>
<th align="center">钩子函数</th>
<th align="left">调用时机</th>
</tr>
</thead>
<tbody><tr>
<td align="center">created</td>
<td align="left">在绑定元素的 attribute 或事件侦听器被应用之前调用</td>
</tr>
<tr>
<td align="center">beforeMount</td>
<td align="left">当指令第一次绑定到元素并且在挂载父组件之前调用</td>
</tr>
<tr>
<td align="center">mounted</td>
<td align="left">在绑定元素的父组件被挂载后调用</td>
</tr>
<tr>
<td align="center">beforeUpdate</td>
<td align="left">在更新包含组件的 VNode 之前调用</td>
</tr>
<tr>
<td align="center">updated</td>
<td align="left">在包含组件的 VNode 及其子组件的 VNode 更新后调用</td>
</tr>
<tr>
<td align="center">beforeUnmount</td>
<td align="left">在卸载绑定元素的父组件之前调用</td>
</tr>
<tr>
<td align="center">unmounted</td>
<td align="left">当指令与元素解除绑定且父组件已卸载时，只调用一次</td>
</tr>
</tbody></table>
<blockquote>
<p>因为自定义指令的默认写法是一个对象，所以在代码风格上遵循 Options API 的生命周期命名，而非 Vue 3 的 Composition API 风格。</p>
</blockquote>
<p>钩子函数在用法上就是这样子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myDirective = &#123;</span><br><span class="line">  <span class="title function_">created</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 其他钩子...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在相关的 TS 类型]已了解，每个钩子函数都有 4 个入参：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">el</td>
<td align="left">指令绑定的 DOM 元素，可以直接操作它</td>
</tr>
<tr>
<td align="center">binding</td>
<td align="left">一个对象数据，见下方的单独说明</td>
</tr>
<tr>
<td align="center">vnode</td>
<td align="left">el 对应在 Vue 里的虚拟节点信息</td>
</tr>
<tr>
<td align="center">prevVNode</td>
<td align="left">Update 时的上一个虚拟节点信息，仅在 <code>beforeUpdate</code> 和 <code>updated</code> 可用</td>
</tr>
</tbody></table>
<p>其中用的最多是 <code>el</code> 和 <code>binding</code> 。</p>
<ul>
<li><code>el</code> 的值就是通过 <code>document.querySelector</code> 拿到的那个 DOM 元素。</li>
<li><code>binding</code> 是一个对象，里面包含了以下属性：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">value</td>
<td align="left">传递给指令的值，例如 <code>v-foo=&quot;bar&quot;</code> 里的 <code>bar</code> ，支持任意有效的 JS 表达式</td>
</tr>
<tr>
<td align="center">oldValue</td>
<td align="left">指令的上一个值，仅对 <code>beforeUpdate</code> 和 <code>updated</code> 可用</td>
</tr>
<tr>
<td align="center">arg</td>
<td align="left">传给指令的参数，例如 <code>v-foo:bar</code> 里的 <code>bar</code></td>
</tr>
<tr>
<td align="center">modifiers</td>
<td align="left">传给指令的修饰符，例如 <code>v-foo.bar</code> 里的 <code>bar</code></td>
</tr>
<tr>
<td align="center">instance</td>
<td align="left">使用指令的组件实例</td>
</tr>
<tr>
<td align="center">dir</td>
<td align="left">指令定义的对象（就是上面的 <code>const myDirective = &#123; /* ... */ &#125;</code> 这个对象）</td>
</tr>
</tbody></table>
<p>在了解了指令的写法和参数作用之后，来看看如何注册一个自定义指令。</p>
<h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><p>自定义指令可以在单个组件内定义并使用，通过和 setup 函数]同级别的 <code>directives</code> 选项进行定义，可以参考下面的例子和注释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 这个使用默认值 `unset` --&gt;</span><br><span class="line">  &lt;div v-highlight&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 这个使用传进去的黄色 --&gt;</span><br><span class="line">  &lt;div v-highlight=&quot;`yellow`&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  // 自定义指令在这里编写，和 `setup` 同级别</span><br><span class="line">  directives: &#123;</span><br><span class="line">    // `directives` 下的每个字段名就是指令名称</span><br><span class="line">    highlight: &#123;</span><br><span class="line">      // 钩子函数</span><br><span class="line">      mounted(el, binding) &#123;</span><br><span class="line">        el.style.backgroundColor =</span><br><span class="line">          typeof binding.value === &#x27;string&#x27; ? binding.value : &#x27;unset&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const msg = ref&lt;string&gt;(&#x27;Hello World!&#x27;)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      msg,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>上面是对象式的写法，也可以写成函数式：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="attr">directives</span>: &#123;</span><br><span class="line">    <span class="title function_">highlight</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">      el.<span class="property">style</span>.<span class="property">backgroundColor</span> =</span><br><span class="line">        <span class="keyword">typeof</span> binding.<span class="property">value</span> === <span class="string">&#x27;string&#x27;</span> ? binding.<span class="property">value</span> : <span class="string">&#x27;unset&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TIP 局部注册的自定义指令，默认在子组件内生效，子组件内无需重新注册即可使用父组件的自定义指令。</p>
</blockquote>
<h4 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h4><p>自定义指令也可以注册成全局，这样就无需在每个组件里定义了，只要在入口文件 <code>main.ts</code> 里启用它，任意组件里都可以使用自定义指令。</p>
<h4 id="deep-选项"><a href="#deep-选项" class="headerlink" title="deep 选项"></a>deep 选项</h4><p>除了钩子函数，在相关的 TS 类型里还可以看到有一个 deep 选项，它是一个布尔值，作用是：</p>
<p>如果自定义指令用于一个有嵌套属性的对象，并且需要在嵌套属性更新的时候触发 <code>beforeUpdate</code> 和 <code>updated</code> 钩子，那么需要将这个选项设置为 <code>true</code> 才能够生效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div v-foo=&quot;foo&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, reactive &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  directives: &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">      beforeUpdate(el, binding) &#123;</span><br><span class="line">        console.log(&#x27;beforeUpdate&#x27;, binding)</span><br><span class="line">      &#125;,</span><br><span class="line">      updated(el, binding) &#123;</span><br><span class="line">        console.log(&#x27;updated&#x27;, binding)</span><br><span class="line">      &#125;,</span><br><span class="line">      mounted(el, binding) &#123;</span><br><span class="line">        console.log(&#x27;mounted&#x27;, binding)</span><br><span class="line">      &#125;,</span><br><span class="line">      // 需要设置为 `true` ，如果是 `false` 则不会触发</span><br><span class="line">      deep: true,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    // 定义一个有嵌套属性的对象</span><br><span class="line">    const foo = reactive(&#123;</span><br><span class="line">      bar: &#123;</span><br><span class="line">        baz: 1,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    // 2s 后修改其中一个值，会触发 `beforeUpdate` 和 `updated`</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      foo.bar.baz = 2</span><br><span class="line">      console.log(foo)</span><br><span class="line">    &#125;, 2000)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      foo,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>





<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><p>Vue 在使用子组件的时候，子组件在 template 里类似一个 HTML 标签，可以在这个子组件标签里传入任意模板代码以及 HTML 代码，这个功能就叫做 “插槽” 。</p>
<h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><p>默认情况下，子组件使用 <code>&lt;slot /&gt;</code> 标签即可渲染父组件传下来的插槽内容，例如：</p>
<p>在父组件这边：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Child&gt;</span><br><span class="line">    &lt;!-- 注意这里，子组件标签里面传入了 HTML 代码 --&gt;</span><br><span class="line">    &lt;p&gt;这是插槽内容&lt;/p&gt;</span><br><span class="line">  &lt;/Child&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent &#125; from &#x27;vue&#x27;</span><br><span class="line">import Child from &#x27;@cp/Child.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在子组件这边：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;slot /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>默认插槽非常简单，一个 <code>&lt;slot /&gt;</code> 就可以了。</p>
<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>有时候可能需要指定多个插槽，例如一个子组件里有 “标题” 、 “作者”、 “内容” 等预留区域可以显示对应的内容，这时候就需要用到具名插槽来指定不同的插槽位。</p>
<p>子组件通过 <code>name</code> 属性来指定插槽名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 显示标题的插槽内容 --&gt;</span><br><span class="line">  &lt;div class=&quot;title&quot;&gt;</span><br><span class="line">    &lt;slot name=&quot;title&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 显示作者的插槽内容 --&gt;</span><br><span class="line">  &lt;div class=&quot;author&quot;&gt;</span><br><span class="line">    &lt;slot name=&quot;author&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 其他插槽内容放到这里 --&gt;</span><br><span class="line">  &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">    &lt;slot /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>父组件通过 <code>template</code> 标签绑定 <code>v-slot:name</code> 格式的属性，来指定传入哪个插槽里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Child&gt;</span><br><span class="line">    &lt;!-- 传给标题插槽 --&gt;</span><br><span class="line">    &lt;template v-slot:title&gt;</span><br><span class="line">      &lt;h1&gt;这是标题&lt;/h1&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 传给作者插槽 --&gt;</span><br><span class="line">    &lt;template v-slot:author&gt;</span><br><span class="line">      &lt;h1&gt;这是作者信息&lt;/h1&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 传给默认插槽 --&gt;</span><br><span class="line">    &lt;p&gt;这是插槽内容&lt;/p&gt;</span><br><span class="line">  &lt;/Child&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p><code>v-slot:name</code> 有一个别名 <code>#name</code> 语法，上面父组件的代码也相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Child&gt;</span><br><span class="line">    &lt;!-- 传给标题插槽 --&gt;</span><br><span class="line">    &lt;template #title&gt;</span><br><span class="line">      &lt;h1&gt;这是标题&lt;/h1&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 传给作者插槽 --&gt;</span><br><span class="line">    &lt;template #author&gt;</span><br><span class="line">      &lt;h1&gt;这是作者信息&lt;/h1&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 传给默认插槽 --&gt;</span><br><span class="line">    &lt;p&gt;这是插槽内容&lt;/p&gt;</span><br><span class="line">  &lt;/Child&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TIP  在使用具名插槽的时候，子组件如果不指定默认插槽，那么在具名插槽之外的内容将不会被渲染。</p>
</blockquote>
<h3 id="默认内容"><a href="#默认内容" class="headerlink" title="默认内容"></a>默认内容</h3><p>可以给 <code>slot</code> 标签添加内容，例如 <code>&lt;slot&gt;默认内容&lt;/slot&gt;</code> ，当父组件没有传入插槽内容时，会使用默认内容来显示，默认插槽和具名插槽均支持该功能。</p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>有一条规则需要记住：</p>
<ul>
<li>父组件里的所有内容都是在父级作用域中编译的</li>
<li>子组件里的所有内容都是在子作用域中编译的</li>
</ul>
<h2 id="CSS-样式与预处理器"><a href="#CSS-样式与预处理器" class="headerlink" title="CSS 样式与预处理器"></a>CSS 样式与预处理器</h2><p>Vue 组件的 CSS 样式部分，Vue 3 保留着和 Vue 2 完全一样的写法。</p>
<h3 id="编写组件样式表"><a href="#编写组件样式表" class="headerlink" title="编写组件样式表"></a>编写组件样式表</h3><p>最基础的写法，就是在 <code>.vue</code> 文件里添加一个 <code>&lt;style /&gt;</code> 标签，即可在里面写 CSS 代码了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- HTML 代码 --&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">  // TypeScript 代码</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">/* CSS 代码 */</span><br><span class="line">.msg &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.msg p &#123;</span><br><span class="line">  color: #333;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="动态绑定-CSS"><a href="#动态绑定-CSS" class="headerlink" title="动态绑定 CSS"></a>动态绑定 CSS</h3><p>动态绑定 CSS ，在 Vue 2 就已经存在了，在此之前常用的是 <code>:class</code> 和 <code>:style</code> ，现在在 Vue 3 ，还可以通过 <code>v-bind</code> 来动态修改了。</p>
<h4 id="使用-class-动态修改样式名"><a href="#使用-class-动态修改样式名" class="headerlink" title="使用 :class 动态修改样式名"></a>使用 :class 动态修改样式名</h4><p>它是绑定在 DOM 元素上面的一个属性，跟 <code>class=&quot;class-name&quot;</code> 这样的属性同级别，它非常灵活！</p>
<blockquote>
<p>TIP 使用 <code>:class</code> 是用来动态修改样式名，也就意味着必须提前把样式名对应的样式表先写好！</p>
</blockquote>
<p>假设已经提前定义好了这几个变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const activeClass = &#x27;active-class&#x27;</span><br><span class="line">    const activeClass1 = &#x27;active-class1&#x27;</span><br><span class="line">    const activeClass2 = &#x27;active-class2&#x27;</span><br><span class="line">    const isActive = true</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      activeClass,</span><br><span class="line">      activeClass1,</span><br><span class="line">      activeClass2,</span><br><span class="line">      isActive,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>如果只想绑定一个单独的动态样式，可以传入一个字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p :class=&quot;activeClass&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>如果有多个动态样式，也可以传入一个数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p :class=&quot;[activeClass1, activeClass2]&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>还可以对动态样式做一些判断，这个时候传入一个对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p :class=&quot;&#123; &#x27;active-class&#x27;: isActive &#125;&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>多个判断的情况下，记得也用数组套起来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p :class=&quot;[&#123; activeClass1: isActive &#125;, &#123; activeClass2: !isActive &#125;]&quot;&gt;</span><br><span class="line">    Hello World!</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>那么什么情况下会用到 <code>:class</code> 呢？</p>
<p>最常见的场景，应该就是导航、选项卡了，比如要给一个当前选中的选项卡做一个突出高亮的状态，那么就可以使用 <code>:class</code> 来动态绑定一个样式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul class=&quot;list&quot;&gt;</span><br><span class="line">    &lt;li</span><br><span class="line">      class=&quot;item&quot;</span><br><span class="line">      :class=&quot;&#123; cur: index === curIndex &#125;&quot;</span><br><span class="line">      v-for=&quot;(item, index) in 5&quot;</span><br><span class="line">      :key=&quot;index&quot;</span><br><span class="line">      @click=&quot;curIndex = index&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;&#123; item &#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const curIndex = ref&lt;number&gt;(0)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      curIndex,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.cur &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>这样就简单实现了一个点击切换选项卡高亮的功能。</p>
<h4 id="使用-style-动态修改内联样式"><a href="#使用-style-动态修改内联样式" class="headerlink" title="使用 :style 动态修改内联样式"></a>使用 :style 动态修改内联样式</h4><p>如果觉得使用 <code>:class</code> 需要提前先写样式，再去绑定样式名有点繁琐，有时候只想简简单单的修改几个样式，那么可以通过 <code>:style</code> 来处理。</p>
<p>默认的情况下，都是传入一个对象去绑定：</p>
<ul>
<li><code>key</code> 是符合 CSS 属性名的 “小驼峰式” 写法，或者套上引号的短横线分隔写法（原写法），例如在 CSS 里，定义字号是 <code>font-size</code> ，那么需要写成 <code>fontSize</code> 或者 <code>&#39;font-size&#39;</code> 作为它的键。</li>
<li><code>value</code> 是 CSS 属性对应的 “合法值”，比如要修改字号大小，可以传入 <code>13px</code> 、<code>0.4rem</code> 这种带合法单位字符串值，但不可以是 <code>13</code> 这样的缺少单位的值，无效的 CSS 值会被过滤不渲染。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p</span><br><span class="line">    :style=&quot;&#123;</span><br><span class="line">      fontSize: &#x27;13px&#x27;,</span><br><span class="line">      &#x27;line-height&#x27;: 2,</span><br><span class="line">      color: &#x27;#ff0000&#x27;,</span><br><span class="line">      textAlign: &#x27;center&#x27;,</span><br><span class="line">    &#125;&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    Hello World!</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>如果有些特殊场景需要绑定多套 <code>style</code>，需要在 <code>script</code> 先定义好各自的样式变量（也是符合上面说到的那几个要求的对象），然后通过数组来传入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p :style=&quot;[style1, style2]&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const style1 = &#123;</span><br><span class="line">      fontSize: &#x27;13px&#x27;,</span><br><span class="line">      &#x27;line-height&#x27;: 2,</span><br><span class="line">    &#125;</span><br><span class="line">    const style2 = &#123;</span><br><span class="line">      color: &#x27;#ff0000&#x27;,</span><br><span class="line">      textAlign: &#x27;center&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      style1,</span><br><span class="line">      style2,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="使用-v-bind-动态修改-style"><a href="#使用-v-bind-动态修改-style" class="headerlink" title="使用 v-bind 动态修改 style"></a>使用 v-bind 动态修改 style</h4><p>当然，以上两种形式都是关于 <code>&lt;script /&gt;</code> 和 <code>&lt;template /&gt;</code> 部分的操作，如果觉得会给模板带来一定的维护成本的话，不妨考虑这个新方案，将变量绑定到 <code>&lt;style /&gt;</code> 部分去。</p>
<blockquote>
<p>TIP 请注意这是一个在 <code>3.2.0</code> 版本之后才被归入正式队列的新功能！如果需要使用它，请确保的 <code>vue</code> 的版本号在 <code>3.2.0</code> 以上，最好是保持最新版本。</p>
</blockquote>
<p>先来看看基本的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p class=&quot;msg&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const fontColor = ref&lt;string&gt;(&#x27;#ff0000&#x27;)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      fontColor,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.msg &#123;</span><br><span class="line">  color: v-bind(fontColor);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>如上面的代码，将渲染出一句红色文本的 <code>Hello World!</code></p>
<p>这其实是利用了现代浏览器支持的 CSS 变量来实现的一个功能（所以如果打算用它的话，需要提前注意一下兼容性噢，点击查看：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://caniuse.com/css-variables">CSS Variables 兼容情况</a> ）。</p>
<p>它渲染到 DOM 上，其实也是通过绑定 <code>style</code> 来实现，可以看到渲染出来的样式是：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;msg&quot;</span> <span class="attr">data-v-7eb2bc79</span>=<span class="string">&quot;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--7eb2bc79-fontColor:#ff0000;&quot;</span>&gt;</span></span><br><span class="line">  Hello World!</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对应的 CSS 变成了：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.msg</span><span class="selector-attr">[data-v-7eb2bc79]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--<span class="number">7</span>eb2bc79-fontColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理论上 <code>v-bind</code> 函数可以在 Vue 内部支持任意的 JavaScript 表达式，但由于可能包含在 CSS 标识符中无效的字符，因此官方是建议在大多数情况下，用引号括起来，如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="built_in">v-bind</span>(<span class="string">&#x27;theme.font.size&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 CSS 变量的特性，因此对 CSS 响应式属性的更改不会触发模板的重新渲染（这也是和 <code>:class</code> 与 <code>:style</code> 的最大不同）。</p>
<blockquote>
<p>TIP 不管有没有开启 style-scoped ，使用 <code>v-bind</code> 渲染出来的 CSS 变量，都会带上 <code>scoped</code> 的随机 hash 前缀，避免样式污染（永远不会意外泄漏到子组件中），所以请放心使用！</p>
</blockquote>
<p>如果对 CSS 变量的使用还不是很了解的话，可以先阅读一下相关的基础知识点。</p>
<p>相关阅读：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties">使用 CSS 自定义属性（变量） - MDN</a></p>
<h3 id="样式表的组件作用域"><a href="#样式表的组件作用域" class="headerlink" title="样式表的组件作用域"></a>样式表的组件作用域</h3><p>CSS 不像 JS ，是没有作用域的概念的，一旦写了某个样式，直接就是全局污染。所以 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.bemcss.com/">BEM 命名法</a> 等规范才应运而生。</p>
<p>但在 Vue 组件里，有两种方案可以避免出现这种污染问题：一个是 Vue 2 就有的 <code>&lt;style scoped&gt;</code> ，一个是 Vue 3 新推出的 <code>&lt;style module&gt;</code> 。</p>
<h4 id="Style-Scoped"><a href="#Style-Scoped" class="headerlink" title="Style Scoped"></a>Style Scoped</h4><p>Vue 组件在设计的时候，就想到了一个很优秀的解决方案，通过 <code>scoped</code> 来支持创建一个 CSS 作用域，使这部分代码只运行在这个组件渲染出来的虚拟 DOM 上。</p>
<p>使用方式很简单，只需要在 <code>&lt;style /&gt;</code> 上添加 <code>scoped</code> 属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注意这里多了一个 `scoped` --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.msg &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.msg p &#123;</span><br><span class="line">  color: #333;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>编译后，虚拟 DOM 都会带有一个 <code>data-v-xxxxx</code> 这样的属性，其中 <code>xxxxx</code> 是一个随机生成的 Hash ，同一个组件的 Hash 是相同并且唯一的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;msg&quot;</span> <span class="attr">data-v-7eb2bc79</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">data-v-7eb2bc79</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而 CSS 则也会带上与 HTML 相同的属性，从而达到样式作用域的目的。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.msg</span><span class="selector-attr">[data-v-7eb2bc79]</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.msg</span> <span class="selector-tag">p</span><span class="selector-attr">[data-v-7eb2bc79]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>scoped</code> 可以有效的避免全局样式污染，可以在不同的组件里面都使用相同的 className，而不必担心会相互覆盖，不必再定义很长很长的样式名来防止冲突了。</p>
<blockquote>
<p>TIP 添加 <code>scoped</code> 生成的样式，只作用于当前组件中的元素，并且权重高于全局 CSS ，可以覆盖全局样式</p>
</blockquote>
<h4 id="Style-Module"><a href="#Style-Module" class="headerlink" title="Style Module"></a>Style Module</h4><p>这是在 Vue 3 才推出的一个新方案，和 <code>&lt;style scoped&gt;</code> 不同，scoped 是通过给 DOM 元素添加自定义属性的方式来避免冲突，而 <code>&lt;style module&gt;</code> 则更为激进，将会编译成 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/css-modules/css-modules">CSS Modules</a> 。</p>
<p>对于 CSS Modules 的处理方式，也可以通过一个小例子来更直观的了解它：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 案例来自阮一峰老师的博文《CSS Modules 用法教程》 */</span></span><br><span class="line"><span class="comment">/* https://www.ruanyifeng.com/blog/2016/06/css_modules.html */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 编译前 */</span></span><br><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 编译后 */</span></span><br><span class="line">._3zyde4l1yATCOkgn-DBWEL &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，是通过比较 “暴力” 的方式，把编写的 “好看的” 样式名，直接改写成一个随机 Hash 样式名，来避免样式互相污染。</p>
<p>所以回到 Vue 这边，看看 <code>&lt;style module&gt;</code> 是怎么操作的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p :class=&quot;$style.msg&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style module&gt;</span><br><span class="line">.msg &#123;</span><br><span class="line">  color: #ff0000;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>于是，将渲染出一句红色文本的 <code>Hello World!</code> 。</p>
<blockquote>
<p>TIP</p>
<ol>
<li>使用这个方案，需要了解如何 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://vue3.chengpeiquan.com/component.html#%E4%BD%BF%E7%94%A8-class-%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%A0%B7%E5%BC%8F%E5%90%8D">使用 :class 动态修改样式名</a></li>
<li>如果单纯只使用 <code>&lt;style module&gt;</code> ，那么在绑定样式的时候，是默认使用 <code>$style</code> 对象来操作的</li>
<li>必须显示的指定绑定到某个样式，比如 <code>$style.msg</code> ，才能生效</li>
<li>如果单纯的绑定 <code>$style</code> ，并不能得到 “把全部样式名直接绑定” 的期望结果</li>
<li>如果指定的 className 是短横杆命名，比如 <code>.user-name</code> ，那么需要通过 <code>$style[&#39;user-name&#39;]</code> 去绑定</li>
</ol>
</blockquote>
<p>也可以给 <code>module</code> 进行命名，然后就可以通过命名的 “变量名” 来操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p :class=&quot;classes.msg&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style module=&quot;classes&quot;&gt;</span><br><span class="line">.msg &#123;</span><br><span class="line">  color: #ff0000;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TIP 需要注意的一点是，一旦开启 <code>&lt;style module&gt;</code> ，那么在 <code>&lt;style module&gt;</code> 里所编写的样式都必须手动绑定才能生效，没有被绑定的样式虽然也会被编译，但不会主动生效到 DOM 上。</p>
</blockquote>
<p>原因是编译出来的样式名已经变化，而原来的 DOM 未指定对应的样式名，或者指定的是编译前的命名，所以并不能匹配到正确的样式。</p>
<h4 id="useCssModule"><a href="#useCssModule" class="headerlink" title="useCssModule"></a>useCssModule</h4><p>这是一个全新的 API ，面向在 script 部分操作 CSS Modules 。</p>
<p>在上面的CSS Modules部分可以知道，可以在 <code>style</code> 定义好样式，然后在 <code>template</code> 部分通过变量名来绑定样式。</p>
<p>那么如果有一天有个需求，需要通过 <code>v-html</code> 来渲染 HTML 代码，那这里的样式岂不是凉凉了？当然不会！</p>
<p>Vue 3 提供了一个 Composition API <code>useCssModule</code> 来帮助在 <code>setup</code> 函数里操作的 CSS Modules （对，只能在 setup或者 script setup 里使用）。</p>
<p><strong>基本用法：</strong></p>
<p>多绑定几个样式，再来操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p :class=&quot;$style.msg&quot;&gt;</span><br><span class="line">    &lt;span :class=&quot;$style.text&quot;&gt;Hello World!&lt;/span&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, useCssModule &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const style = useCssModule()</span><br><span class="line">    console.log(style)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style module&gt;</span><br><span class="line">.msg &#123;</span><br><span class="line">  color: #ff0000;</span><br><span class="line">&#125;</span><br><span class="line">.text &#123;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到打印出来的 <code>style</code> 是一个对象：</p>
<ul>
<li><code>key</code> 是在 <code>&lt;style modules&gt;</code> 里定义的原始样式名</li>
<li><code>value</code> 则是编译后的新样式名</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&#x27;home_msg_37Xmr&#x27;</span>,</span><br><span class="line">  <span class="attr">text</span>: <span class="string">&#x27;home_text_2woQJ&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以来配合 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals">模板字符串</a> 的使用，看看刚刚说的，要通过 <code>v-html</code> 渲染出来的内容应该如何绑定样式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div v-html=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, useCssModule &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    // 获取样式</span><br><span class="line">    const style = useCssModule()</span><br><span class="line"></span><br><span class="line">    // 编写模板内容</span><br><span class="line">    const content = `&lt;p class=&quot;$&#123;style.msg&#125;&quot;&gt;</span><br><span class="line">      &lt;span class=&quot;$&#123;style.text&#125;&quot;&gt;Hello World! —— from v-html&lt;/span&gt;</span><br><span class="line">    &lt;/p&gt;`</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      content,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style module&gt;</span><br><span class="line">.msg &#123;</span><br><span class="line">  color: #ff0000;</span><br><span class="line">&#125;</span><br><span class="line">.text &#123;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>是不是也非常简单？可能刚开始不太习惯，但写多几次其实这个功能也蛮好玩的！</p>
<p><strong>另外，需要注意的是，如果指定了 modules 的名称，那么必须传入对应的名称作为入参才可以正确拿到这些样式：</strong></p>
<p>比如指定了一个 classes 作为名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style module=&quot;classes&quot;&gt;</span><br><span class="line">/* ... */</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>那么需要通过传入 classes 这个名称才能拿到样式，否则会是一个空对象：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> style = <span class="title function_">useCssModule</span>(<span class="string">&#x27;classes&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TIP  在 <code>const style = useCssModule()</code> 的时候，命名是随意的，跟在 <code>&lt;style module=&quot;classes&quot;&gt;</code> 这里指定的命名没有关系。</p>
</blockquote>
<h3 id="深度操作符"><a href="#深度操作符" class="headerlink" title="深度操作符"></a>深度操作符</h3><p>使用 scoped 后，父组件的样式将不会渗透到子组件中，也不能直接修改子组件的样式。</p>
<p>如果确实需要修改子组件的样式，必须通过 <code>::v-deep</code>（完整写法） 或者 <code>:deep</code>（快捷写法） 操作符来实现。</p>
<blockquote>
<p>TIP</p>
<ol>
<li>旧版的深度操作符是 <code>&gt;&gt;&gt;</code> 、 <code>/deep/</code> 和 <code>::v-deep</code>，现在 <code>&gt;&gt;&gt;</code> 和 <code>/deep/</code> 已进入弃用阶段（虽然暂时还没完全移除）</li>
<li>同时需要注意的是，旧版 <code>::v-deep</code> 的写法是作为组合器的方式，写在样式或者元素前面，如：<code>::v-deep .class-name &#123; /* ... */ &#125;</code>，现在这种写法也废弃了。</li>
</ol>
</blockquote>
<p>现在不论是 <code>::v-deep</code> 还是 <code>:deep</code> ，使用方法非常统一，来假设 .b 是子组件的样式名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">.a :deep(.b) &#123;</span><br><span class="line">  /* ... */</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>编译后：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span><span class="selector-attr">[data-v-f3f3eg9]</span> <span class="selector-class">.b</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TIP 可以看到，新的 deep 写法是作为一个类似 JS “函数” 那样去使用，需要深度操作的样式或者元素名，作为 “入参” 去传入。</p>
<p>同理，如果使用 Less 或者 Stylus 这种支持嵌套写法的预处理器，也是可以这样去深度操作的：</p>
</blockquote>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">  :<span class="selector-tag">deep</span>(.b) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，除了操作子组件的样式，那些通过 <code>v-html</code> 创建的 DOM 内容，也不受作用域内的样式影响，也可以通过深度操作符来实现样式修改。</p>
<h3 id="使用-CSS-预处理器"><a href="#使用-CSS-预处理器" class="headerlink" title="使用 CSS 预处理器"></a>使用 CSS 预处理器</h3><p>在工程化的现在，可以说前端都几乎不写 CSS 了，都是通过 <code>sass</code>、<code>less</code>、<code>stylus</code> 等 CSS 预处理器来完成样式的编写。</p>
<p>为什么要用 CSS 预处理器？放一篇关于三大预处理器的点评，新开发者可以做个简单了解，具体的用法在对应的官网上有非常详细的说明。</p>
<p>可以查看了解：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/23382462">浅谈 CSS 预处理器，Sass、Less 和 Stylus</a></p>
<p>在 Vue 组件里使用预处理器非常简单，像 Vite 已内置了对预处理器文件的支持（可处理 <code>.less</code> 、 <code>.scss</code> 之类的预处理器扩展名文件），因此只需要安装对应的依赖到项目里。</p>
<p>这里以 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/less/less.js">Less</a> 为例，先安装该预处理器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为是在开发阶段使用，所以添加到 `devDependencies`</span></span><br><span class="line">npm i -D less</span><br></pre></td></tr></table></figure>

<p>接下来在 Vue 组件里，只需要在 <code>&lt;style /&gt;</code> 标签上，通过 <code>lang=&quot;less&quot;</code> 属性指定使用哪个预处理器，即可直接编写对应的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">// 定义颜色变量</span><br><span class="line">@color-black: #333;</span><br><span class="line">@color-red: #ff0000;</span><br><span class="line"></span><br><span class="line">// 父级标签</span><br><span class="line">.msg &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  // 其子标签可以使用嵌套写法</span><br><span class="line">  p &#123;</span><br><span class="line">    color: @color-black;</span><br><span class="line">    font-size: 14px;</span><br><span class="line">    // 支持多级嵌套</span><br><span class="line">    span &#123;</span><br><span class="line">      color: @color-red;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>编译后的 css 代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.msg</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.msg</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333333</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.msg</span> <span class="selector-tag">p</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预处理器也支持 <code>scoped</code>。</p>
<h2 id="Vue-Devtools"><a href="#Vue-Devtools" class="headerlink" title="Vue Devtools"></a>Vue Devtools</h2><p>Vue Devtools 是一个浏览器扩展，支持 Chrome 、 Firefox 等浏览器，需要先安装才能使用。</p>
<p>点击安装：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://devtools.vuejs.org/guide/installation.html">Vue Devtools 的浏览器扩展</a></p>
<p>当在 Vue 项目通过 <code>npm run dev</code> 等命令启动开发环境服务后，访问本地页面（如： <code>http://localhost:3000/</code> ），在页面上按 F12 唤起浏览器的控制台，会发现多了一个名为 <code>vue</code> 的面板。</p>
<p>面板的顶部有一个菜单可以切换不同的选项卡，菜单数量会根据不同项目有所不同，例如没有安装 Pinia 则不会出现 Pinia 选项卡，这里以其中一部分选项卡作为举例。</p>
<h3 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h3><p>Components 是以结构化的方式显示组件的调试信息，可以查看组件的父子关系，并检查组件的各种内部状态：</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/e930893f/3e26be0a15dc6863e534e51432026f49.jpg" alt="Vue Devtools 的 Components 界面"></p>
<h3 id="Routes"><a href="#Routes" class="headerlink" title="Routes"></a>Routes</h3><p>Routes 可以查看当前所在路由的配置信息：</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/e930893f/58952f0abc9fbad3903a3dc5e81c7b14.jpg" alt="Vue Devtools 的 Routes 界面"></p>
<h3 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h3><p>Timeline 是以时间线的方式追踪不同类型的数据，例如事件：</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/e930893f/2043dfa393db23fc46d5ee34215c48f8.jpg" alt="Vue Devtools 的 Timeline 界面"></p>
<h3 id="Pinia"><a href="#Pinia" class="headerlink" title="Pinia"></a>Pinia</h3><p>Pinia 是可以查看当前组件引入的全局状态情况：</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/e930893f/7980bce40ff75223abd18dfe09771b73.jpg" alt="Vue Devtools 的 Pinia 界面"></p>
<script>var description="Vue3入门"</script></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://fulsun.github.io">凉月</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://fulsun.github.io/p/e930893f">https://fulsun.github.io/p/e930893f</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://fulsun.github.io" target="_blank">凉月の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Vue3/">Vue3</a></div><div class="post-share"><div class="social-share" data-image="/medias/featureimages/010.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/p/9f7edc20" title="VScode环境配置"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/001.webp" onerror="onerror=null;src='/medias/detail/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">VScode环境配置</div></div><div class="info-2"><div class="info-item-1">Visual Studio Code（简称 VS Code）是一款由微软开发的免费、开源且跨平台的代码编辑器，深受开发者喜爱。</div></div></div></a><a class="pagination-related" href="/p/8448ab29" title="路由的使用"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/003.webp" onerror="onerror=null;src='/medias/detail/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">路由的使用</div></div><div class="info-2"><div class="info-item-1">在传统Web前端框架（如Vue、Vite等）中使用路由时，如果遇到页面刷新变为404或部分路由显示为白色的问题，通常是由于以下原因：</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/p/8448ab29" title="路由的使用"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/003.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-20</div><div class="info-item-2">路由的使用</div></div><div class="info-2"><div class="info-item-1">在传统Web前端框架（如Vue、Vite等）中使用路由时，如果遇到页面刷新变为404或部分路由显示为白色的问题，通常是由于以下原因：</div></div></div></a><a class="pagination-related" href="/p/28806695" title="Vue3项目实战"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/013.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-21</div><div class="info-item-2">Vue3项目实战</div></div><div class="info-2"><div class="info-item-1">通过这篇文章的学习，可以掌握如何高效地配置Vite项目，简化代码管理，并利用插件工具提升开发效率。每一步都需要实际操作以加深理解，并结合个人项目需求进行应用。</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/avatar.jpg" onerror="this.onerror=null;this.src='/medias/detail/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">凉月</div><div class="author-info-description">记录生活,分享知识。</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/fulsun"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/fulsun" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:fl_6145@163.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">感谢访问本站，若喜欢请收藏 ^_^</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E6%96%B0%E7%9A%84-Vue-%E7%89%88%E6%9C%AC"><span class="toc-text">全新的 Vue 版本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3"><span class="toc-text">官方文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Vue-2"><span class="toc-text">使用 Vue 2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Vite-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-text">使用 Vite 创建项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Create-Vite"><span class="toc-text">Create Vite</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Create-Vue"><span class="toc-text">Create Vue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Create-Preset"><span class="toc-text">Create Preset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE"><span class="toc-text">管理项目配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-vue-cli-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-text">使用 @vue&#x2F;cli 创建项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0-CLI-%E8%84%9A%E6%89%8B%E6%9E%B6"><span class="toc-text">更新 CLI 脚手架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-CLI-%E5%88%9B%E5%BB%BA-3-x-%E9%A1%B9%E7%9B%AE"><span class="toc-text">使用 CLI 创建 3.x 项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE-1"><span class="toc-text">管理项目配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hello-Vue3"><span class="toc-text">Hello Vue3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE-Vue-2-vue-2"><span class="toc-text">回顾 Vue 2-vue-2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6"><span class="toc-text">入口文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E6%96%B0%E7%9A%84-setup-%E5%87%BD%E6%95%B0"><span class="toc-text">全新的 setup 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setup-%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-text">setup 的含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setup-%E7%9A%84%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8"><span class="toc-text">setup 的参数使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defineComponent-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">defineComponent 的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">组件的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%87%E7%BA%A7%E5%8F%98%E5%8C%96"><span class="toc-text">升级变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-3-x-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">使用 3.x 的生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%86%99%E6%B3%95"><span class="toc-text">组件的基本写法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE-Vue-2"><span class="toc-text">回顾 Vue 2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3-Vue-3"><span class="toc-text">了解 Vue 3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99Hello-World-%E7%BB%84%E4%BB%B6"><span class="toc-text">编写Hello World 组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-text">响应式数据的变化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE-Vue-2-1"><span class="toc-text">回顾 Vue 2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3-Vue-3-1"><span class="toc-text">了解 Vue 3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95%E4%B8%8A%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-text">用法上的变化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F-API-%E4%B9%8B-ref"><span class="toc-text">响应式 API 之 ref</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-text">类型声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API-%E6%9C%AC%E8%BA%AB%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">API 本身的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#API-%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">API 返回值的类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">变量的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">引用类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E5%85%83%E7%B4%A0%E4%B8%8E%E5%AD%90%E7%BB%84%E4%BB%B6"><span class="toc-text">DOM 元素与子组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E8%AF%BB%E5%8F%96%E4%B8%8E%E8%B5%8B%E5%80%BC"><span class="toc-text">变量的读取与赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%8F%98%E9%87%8F"><span class="toc-text">读取变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC"><span class="toc-text">为变量赋值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F-API-%E4%B9%8B-reactive"><span class="toc-text">响应式 API 之 reactive</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89"><span class="toc-text">类型声明与定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E8%AF%BB%E5%8F%96%E4%B8%8E%E8%B5%8B%E5%80%BC-1"><span class="toc-text">变量的读取与赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%AF%B9%E8%B1%A1"><span class="toc-text">处理对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84"><span class="toc-text">处理数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F"><span class="toc-text">特别注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F-API-%E4%B9%8B-toRef-%E4%B8%8E-toRefs"><span class="toc-text">响应式 API 之 toRef 与 toRefs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E8%87%AA%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">各自的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-toRef"><span class="toc-text">使用 toRef</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API-%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">API 类型和基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-text">设置默认值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%94%A8%E6%B3%95"><span class="toc-text">其他用法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-toRefs"><span class="toc-text">使用 toRefs</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API-%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-1"><span class="toc-text">API 类型和基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E4%B8%8E%E8%B5%8B%E5%80%BC"><span class="toc-text">解构与赋值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E8%BD%AC%E6%8D%A2"><span class="toc-text">为什么要进行转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E6%AF%94%E8%BE%83%E9%80%82%E5%90%88%E4%BD%BF%E7%94%A8%E5%AE%83%E4%BB%AC"><span class="toc-text">什么场景下比较适合使用它们</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%85%B7%E4%BD%93%E8%BF%90%E7%94%A8"><span class="toc-text">在业务中的具体运用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">需要注意的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">函数的声明和使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BE%A6%E5%90%AC"><span class="toc-text">数据的侦听</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#watch"><span class="toc-text">watch</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE-Vue-2-2"><span class="toc-text">回顾 Vue 2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3-Vue-3-2"><span class="toc-text">了解 Vue 3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#API-%E7%9A%84-TS-%E7%B1%BB%E5%9E%8B"><span class="toc-text">API 的 TS 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E4%BE%A6%E5%90%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-text">要侦听的数据源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%A6%E5%90%AC%E5%90%8E%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-text">侦听后的回调函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95"><span class="toc-text">基础用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E4%BE%A6%E5%90%AC"><span class="toc-text">批量侦听</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#watch%E4%BE%A6%E5%90%AC%E7%9A%84%E9%80%89%E9%A1%B9"><span class="toc-text">watch侦听的选项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%A6%E5%90%AC%E9%80%89%E9%A1%B9%E4%B9%8B-deep"><span class="toc-text">侦听选项之 deep</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%A6%E5%90%AC%E9%80%89%E9%A1%B9%E4%B9%8B-immediate"><span class="toc-text">侦听选项之 immediate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%A6%E5%90%AC%E9%80%89%E9%A1%B9%E4%B9%8B-flush"><span class="toc-text">侦听选项之 flush</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E4%BE%A6%E5%90%AC"><span class="toc-text">停止侦听</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%A6%E5%90%AC%E6%95%88%E6%9E%9C%E6%B8%85%E7%90%86"><span class="toc-text">侦听效果清理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#watchEffect"><span class="toc-text">watchEffect</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API-%E7%9A%84-TS-%E7%B1%BB%E5%9E%8B-1"><span class="toc-text">API 的 TS 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-text">用法示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8C-watch-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">和 watch 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E7%94%A8%E7%9A%84%E4%BE%A6%E5%90%AC%E9%80%89%E9%A1%B9"><span class="toc-text">可用的侦听选项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#watchPostEffect"><span class="toc-text">watchPostEffect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#watchSyncEffe"><span class="toc-text">watchSyncEffe</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-text">数据的计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95%E5%8F%98%E5%8C%96"><span class="toc-text">用法变化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE-Vue-2-3"><span class="toc-text">回顾 Vue 2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3-Vue-3-3"><span class="toc-text">了解 Vue 3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E-1"><span class="toc-text">类型声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF%E5%AF%B9%E6%AF%94%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">优势对比和注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF%E5%AF%B9%E6%AF%94"><span class="toc-text">优势对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setter-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">setter 的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F"><span class="toc-text">基本格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E8%8C%83"><span class="toc-text">使用示范</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8B%BC%E6%8E%A5%E5%92%8C%E8%AE%A1%E7%AE%97"><span class="toc-text">数据的拼接和计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E7%94%A8%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE"><span class="toc-text">复用组件的动态数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%A4%9A%E7%BA%A7%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%80%BC"><span class="toc-text">获取多级对象的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2"><span class="toc-text">不同类型的数据转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4"><span class="toc-text">指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4"><span class="toc-text">内置指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-text">自定义指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%9A%84-TS-%E7%B1%BB%E5%9E%8B"><span class="toc-text">相关的 TS 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><span class="toc-text">钩子函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%B3%A8%E5%86%8C"><span class="toc-text">局部注册</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C"><span class="toc-text">全局注册</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deep-%E9%80%89%E9%A1%B9"><span class="toc-text">deep 选项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E6%A7%BD"><span class="toc-text">插槽</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%8F%92%E6%A7%BD"><span class="toc-text">默认插槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD"><span class="toc-text">具名插槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%86%85%E5%AE%B9"><span class="toc-text">默认内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS-%E6%A0%B7%E5%BC%8F%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">CSS 样式与预处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%E8%A1%A8"><span class="toc-text">编写组件样式表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A-CSS"><span class="toc-text">动态绑定 CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-class-%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%A0%B7%E5%BC%8F%E5%90%8D"><span class="toc-text">使用 :class 动态修改样式名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-style-%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F"><span class="toc-text">使用 :style 动态修改内联样式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-v-bind-%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9-style"><span class="toc-text">使用 v-bind 动态修改 style</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E5%BC%8F%E8%A1%A8%E7%9A%84%E7%BB%84%E4%BB%B6%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">样式表的组件作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Style-Scoped"><span class="toc-text">Style Scoped</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Style-Module"><span class="toc-text">Style Module</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#useCssModule"><span class="toc-text">useCssModule</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">深度操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-CSS-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">使用 CSS 预处理器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-Devtools"><span class="toc-text">Vue Devtools</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Components"><span class="toc-text">Components</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Routes"><span class="toc-text">Routes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Timeline"><span class="toc-text">Timeline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pinia"><span class="toc-text">Pinia</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/p/b3bc049e" title="Java中的SPI服务发现机制"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/003.webp" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Java中的SPI服务发现机制"/></a><div class="content"><a class="title" href="/p/b3bc049e" title="Java中的SPI服务发现机制">Java中的SPI服务发现机制</a><time datetime="2025-02-16T05:36:57.339Z" title="发表于 2025-02-16 05:36:57">2025-02-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/3ca9bef3" title="SpringBoot预览PDF文件"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/001.webp" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="SpringBoot预览PDF文件"/></a><div class="content"><a class="title" href="/p/3ca9bef3" title="SpringBoot预览PDF文件">SpringBoot预览PDF文件</a><time datetime="2025-02-07T10:19:00.000Z" title="发表于 2025-02-07 10:19:00">2025-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/9b5fc26a" title="Debain12配置"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/013.webp" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Debain12配置"/></a><div class="content"><a class="title" href="/p/9b5fc26a" title="Debain12配置">Debain12配置</a><time datetime="2025-02-06T16:07:00.000Z" title="发表于 2025-02-06 16:07:00">2025-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/42bd8820" title="Docker安装脚本与换源"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/009.webp" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Docker安装脚本与换源"/></a><div class="content"><a class="title" href="/p/42bd8820" title="Docker安装脚本与换源">Docker安装脚本与换源</a><time datetime="2025-02-05T16:00:00.000Z" title="发表于 2025-02-05 16:00:00">2025-02-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/c3561f90" title="Nvm包管理器"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/007.webp" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Nvm包管理器"/></a><div class="content"><a class="title" href="/p/c3561f90" title="Nvm包管理器">Nvm包管理器</a><time datetime="2025-01-22T16:00:55.000Z" title="发表于 2025-01-22 16:00:55">2025-01-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 凉月</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.3.2"></script><script src="/js/main.js?v=5.3.2"></script><script src="https://unpkg.com/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://waline-fulsun.netlify.app/.netlify/functions/comment',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://unpkg.com/@waline/client@3.4.3/dist/waline.css')
        .then(() => import('https://unpkg.com/@waline/client@3.4.3/dist/waline.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://unpkg.com/butterfly-extsrc@1.1.4/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>